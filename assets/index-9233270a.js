function LI(n, e) {
  for (var t = 0; t < e.length; t++) {
    const i = e[t];
    if (typeof i != "string" && !Array.isArray(i)) {
      for (const r in i)
        if (r !== "default" && !(r in n)) {
          const s = Object.getOwnPropertyDescriptor(i, r);
          s &&
            Object.defineProperty(
              n,
              r,
              s.get ? s : { enumerable: !0, get: () => i[r] }
            );
        }
    }
  }
  return Object.freeze(
    Object.defineProperty(n, Symbol.toStringTag, { value: "Module" })
  );
}
(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r);
  new MutationObserver((r) => {
    for (const s of r)
      if (s.type === "childList")
        for (const o of s.addedNodes)
          o.tagName === "LINK" && o.rel === "modulepreload" && i(o);
  }).observe(document, { childList: !0, subtree: !0 });
  function t(r) {
    const s = {};
    return (
      r.integrity && (s.integrity = r.integrity),
      r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy),
      r.crossOrigin === "use-credentials"
        ? (s.credentials = "include")
        : r.crossOrigin === "anonymous"
          ? (s.credentials = "omit")
          : (s.credentials = "same-origin"),
      s
    );
  }
  function i(r) {
    if (r.ep) return;
    r.ep = !0;
    const s = t(r);
    fetch(r.href, s);
  }
})();
function Cb(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default")
    ? n.default
    : n;
}
function II(n) {
  if (n.__esModule) return n;
  var e = n.default;
  if (typeof e == "function") {
    var t = function i() {
      if (this instanceof i) {
        var r = [null];
        r.push.apply(r, arguments);
        var s = Function.bind.apply(e, r);
        return new s();
      }
      return e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else t = {};
  return (
    Object.defineProperty(t, "__esModule", { value: !0 }),
    Object.keys(n).forEach(function (i) {
      var r = Object.getOwnPropertyDescriptor(n, i);
      Object.defineProperty(
        t,
        i,
        r.get
          ? r
          : {
              enumerable: !0,
              get: function () {
                return n[i];
              },
            }
      );
    }),
    t
  );
}
var If = {},
  DI = {
    get exports() {
      return If;
    },
    set exports(n) {
      If = n;
    },
  },
  hg = {},
  H = {},
  FI = {
    get exports() {
      return H;
    },
    set exports(n) {
      H = n;
    },
  },
  Ct = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var gh = Symbol.for("react.element"),
  NI = Symbol.for("react.portal"),
  kI = Symbol.for("react.fragment"),
  OI = Symbol.for("react.strict_mode"),
  UI = Symbol.for("react.profiler"),
  zI = Symbol.for("react.provider"),
  GI = Symbol.for("react.context"),
  HI = Symbol.for("react.forward_ref"),
  VI = Symbol.for("react.suspense"),
  WI = Symbol.for("react.memo"),
  jI = Symbol.for("react.lazy"),
  XS = Symbol.iterator;
function JI(n) {
  return n === null || typeof n != "object"
    ? null
    : ((n = (XS && n[XS]) || n["@@iterator"]),
      typeof n == "function" ? n : null);
}
var Tb = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {},
  },
  bb = Object.assign,
  Pb = {};
function eu(n, e, t) {
  ((this.props = n),
    (this.context = e),
    (this.refs = Pb),
    (this.updater = t || Tb));
}
eu.prototype.isReactComponent = {};
eu.prototype.setState = function (n, e) {
  if (typeof n != "object" && typeof n != "function" && n != null)
    throw Error(
      "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
    );
  this.updater.enqueueSetState(this, n, e, "setState");
};
eu.prototype.forceUpdate = function (n) {
  this.updater.enqueueForceUpdate(this, n, "forceUpdate");
};
function Bb() {}
Bb.prototype = eu.prototype;
function K_(n, e, t) {
  ((this.props = n),
    (this.context = e),
    (this.refs = Pb),
    (this.updater = t || Tb));
}
var Y_ = (K_.prototype = new Bb());
Y_.constructor = K_;
bb(Y_, eu.prototype);
Y_.isPureReactComponent = !0;
var KS = Array.isArray,
  Rb = Object.prototype.hasOwnProperty,
  Q_ = { current: null },
  Lb = { key: !0, ref: !0, __self: !0, __source: !0 };
function Ib(n, e, t) {
  var i,
    r = {},
    s = null,
    o = null;
  if (e != null)
    for (i in (e.ref !== void 0 && (o = e.ref),
    e.key !== void 0 && (s = "" + e.key),
    e))
      Rb.call(e, i) && !Lb.hasOwnProperty(i) && (r[i] = e[i]);
  var a = arguments.length - 2;
  if (a === 1) r.children = t;
  else if (1 < a) {
    for (var l = Array(a), u = 0; u < a; u++) l[u] = arguments[u + 2];
    r.children = l;
  }
  if (n && n.defaultProps)
    for (i in ((a = n.defaultProps), a)) r[i] === void 0 && (r[i] = a[i]);
  return {
    $$typeof: gh,
    type: n,
    key: s,
    ref: o,
    props: r,
    _owner: Q_.current,
  };
}
function XI(n, e) {
  return {
    $$typeof: gh,
    type: n.type,
    key: e,
    ref: n.ref,
    props: n.props,
    _owner: n._owner,
  };
}
function Z_(n) {
  return typeof n == "object" && n !== null && n.$$typeof === gh;
}
function KI(n) {
  var e = { "=": "=0", ":": "=2" };
  return (
    "$" +
    n.replace(/[=:]/g, function (t) {
      return e[t];
    })
  );
}
var YS = /\/+/g;
function uv(n, e) {
  return typeof n == "object" && n !== null && n.key != null
    ? KI("" + n.key)
    : e.toString(36);
}
function im(n, e, t, i, r) {
  var s = typeof n;
  (s === "undefined" || s === "boolean") && (n = null);
  var o = !1;
  if (n === null) o = !0;
  else
    switch (s) {
      case "string":
      case "number":
        o = !0;
        break;
      case "object":
        switch (n.$$typeof) {
          case gh:
          case NI:
            o = !0;
        }
    }
  if (o)
    return (
      (o = n),
      (r = r(o)),
      (n = i === "" ? "." + uv(o, 0) : i),
      KS(r)
        ? ((t = ""),
          n != null && (t = n.replace(YS, "$&/") + "/"),
          im(r, e, t, "", function (u) {
            return u;
          }))
        : r != null &&
          (Z_(r) &&
            (r = XI(
              r,
              t +
                (!r.key || (o && o.key === r.key)
                  ? ""
                  : ("" + r.key).replace(YS, "$&/") + "/") +
                n
            )),
          e.push(r)),
      1
    );
  if (((o = 0), (i = i === "" ? "." : i + ":"), KS(n)))
    for (var a = 0; a < n.length; a++) {
      s = n[a];
      var l = i + uv(s, a);
      o += im(s, e, t, l, r);
    }
  else if (((l = JI(n)), typeof l == "function"))
    for (n = l.call(n), a = 0; !(s = n.next()).done; )
      ((s = s.value), (l = i + uv(s, a++)), (o += im(s, e, t, l, r)));
  else if (s === "object")
    throw (
      (e = String(n)),
      Error(
        "Objects are not valid as a React child (found: " +
          (e === "[object Object]"
            ? "object with keys {" + Object.keys(n).join(", ") + "}"
            : e) +
          "). If you meant to render a collection of children, use an array instead."
      )
    );
  return o;
}
function Wd(n, e, t) {
  if (n == null) return n;
  var i = [],
    r = 0;
  return (
    im(n, i, "", "", function (s) {
      return e.call(t, s, r++);
    }),
    i
  );
}
function YI(n) {
  if (n._status === -1) {
    var e = n._result;
    ((e = e()),
      e.then(
        function (t) {
          (n._status === 0 || n._status === -1) &&
            ((n._status = 1), (n._result = t));
        },
        function (t) {
          (n._status === 0 || n._status === -1) &&
            ((n._status = 2), (n._result = t));
        }
      ),
      n._status === -1 && ((n._status = 0), (n._result = e)));
  }
  if (n._status === 1) return n._result.default;
  throw n._result;
}
var yi = { current: null },
  rm = { transition: null },
  QI = {
    ReactCurrentDispatcher: yi,
    ReactCurrentBatchConfig: rm,
    ReactCurrentOwner: Q_,
  };
Ct.Children = {
  map: Wd,
  forEach: function (n, e, t) {
    Wd(
      n,
      function () {
        e.apply(this, arguments);
      },
      t
    );
  },
  count: function (n) {
    var e = 0;
    return (
      Wd(n, function () {
        e++;
      }),
      e
    );
  },
  toArray: function (n) {
    return (
      Wd(n, function (e) {
        return e;
      }) || []
    );
  },
  only: function (n) {
    if (!Z_(n))
      throw Error(
        "React.Children.only expected to receive a single React element child."
      );
    return n;
  },
};
Ct.Component = eu;
Ct.Fragment = kI;
Ct.Profiler = UI;
Ct.PureComponent = K_;
Ct.StrictMode = OI;
Ct.Suspense = VI;
Ct.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = QI;
Ct.cloneElement = function (n, e, t) {
  if (n == null)
    throw Error(
      "React.cloneElement(...): The argument must be a React element, but you passed " +
        n +
        "."
    );
  var i = bb({}, n.props),
    r = n.key,
    s = n.ref,
    o = n._owner;
  if (e != null) {
    if (
      (e.ref !== void 0 && ((s = e.ref), (o = Q_.current)),
      e.key !== void 0 && (r = "" + e.key),
      n.type && n.type.defaultProps)
    )
      var a = n.type.defaultProps;
    for (l in e)
      Rb.call(e, l) &&
        !Lb.hasOwnProperty(l) &&
        (i[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l]);
  }
  var l = arguments.length - 2;
  if (l === 1) i.children = t;
  else if (1 < l) {
    a = Array(l);
    for (var u = 0; u < l; u++) a[u] = arguments[u + 2];
    i.children = a;
  }
  return { $$typeof: gh, type: n.type, key: r, ref: s, props: i, _owner: o };
};
Ct.createContext = function (n) {
  return (
    (n = {
      $$typeof: GI,
      _currentValue: n,
      _currentValue2: n,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null,
    }),
    (n.Provider = { $$typeof: zI, _context: n }),
    (n.Consumer = n)
  );
};
Ct.createElement = Ib;
Ct.createFactory = function (n) {
  var e = Ib.bind(null, n);
  return ((e.type = n), e);
};
Ct.createRef = function () {
  return { current: null };
};
Ct.forwardRef = function (n) {
  return { $$typeof: HI, render: n };
};
Ct.isValidElement = Z_;
Ct.lazy = function (n) {
  return { $$typeof: jI, _payload: { _status: -1, _result: n }, _init: YI };
};
Ct.memo = function (n, e) {
  return { $$typeof: WI, type: n, compare: e === void 0 ? null : e };
};
Ct.startTransition = function (n) {
  var e = rm.transition;
  rm.transition = {};
  try {
    n();
  } finally {
    rm.transition = e;
  }
};
Ct.unstable_act = function () {
  throw Error("act(...) is not supported in production builds of React.");
};
Ct.useCallback = function (n, e) {
  return yi.current.useCallback(n, e);
};
Ct.useContext = function (n) {
  return yi.current.useContext(n);
};
Ct.useDebugValue = function () {};
Ct.useDeferredValue = function (n) {
  return yi.current.useDeferredValue(n);
};
Ct.useEffect = function (n, e) {
  return yi.current.useEffect(n, e);
};
Ct.useId = function () {
  return yi.current.useId();
};
Ct.useImperativeHandle = function (n, e, t) {
  return yi.current.useImperativeHandle(n, e, t);
};
Ct.useInsertionEffect = function (n, e) {
  return yi.current.useInsertionEffect(n, e);
};
Ct.useLayoutEffect = function (n, e) {
  return yi.current.useLayoutEffect(n, e);
};
Ct.useMemo = function (n, e) {
  return yi.current.useMemo(n, e);
};
Ct.useReducer = function (n, e, t) {
  return yi.current.useReducer(n, e, t);
};
Ct.useRef = function (n) {
  return yi.current.useRef(n);
};
Ct.useState = function (n) {
  return yi.current.useState(n);
};
Ct.useSyncExternalStore = function (n, e, t) {
  return yi.current.useSyncExternalStore(n, e, t);
};
Ct.useTransition = function () {
  return yi.current.useTransition();
};
Ct.version = "18.2.0";
(function (n) {
  n.exports = Ct;
})(FI);
const vh = Cb(H),
  Uy = LI({ __proto__: null, default: vh }, [H]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var ZI = H,
  qI = Symbol.for("react.element"),
  $I = Symbol.for("react.fragment"),
  eD = Object.prototype.hasOwnProperty,
  tD = ZI.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  nD = { key: !0, ref: !0, __self: !0, __source: !0 };
function Db(n, e, t) {
  var i,
    r = {},
    s = null,
    o = null;
  (t !== void 0 && (s = "" + t),
    e.key !== void 0 && (s = "" + e.key),
    e.ref !== void 0 && (o = e.ref));
  for (i in e) eD.call(e, i) && !nD.hasOwnProperty(i) && (r[i] = e[i]);
  if (n && n.defaultProps)
    for (i in ((e = n.defaultProps), e)) r[i] === void 0 && (r[i] = e[i]);
  return {
    $$typeof: qI,
    type: n,
    key: s,
    ref: o,
    props: r,
    _owner: tD.current,
  };
}
hg.Fragment = $I;
hg.jsx = Db;
hg.jsxs = Db;
(function (n) {
  n.exports = hg;
})(DI);
const dg = If.Fragment,
  ce = If.jsx,
  rt = If.jsxs;
var zy = {},
  Gy = {},
  iD = {
    get exports() {
      return Gy;
    },
    set exports(n) {
      Gy = n;
    },
  },
  qi = {},
  Hy = {},
  rD = {
    get exports() {
      return Hy;
    },
    set exports(n) {
      Hy = n;
    },
  },
  Fb = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (n) {
  function e(I, G) {
    var z = I.length;
    I.push(G);
    e: for (; 0 < z; ) {
      var q = (z - 1) >>> 1,
        Q = I[q];
      if (0 < r(Q, G)) ((I[q] = G), (I[z] = Q), (z = q));
      else break e;
    }
  }
  function t(I) {
    return I.length === 0 ? null : I[0];
  }
  function i(I) {
    if (I.length === 0) return null;
    var G = I[0],
      z = I.pop();
    if (z !== G) {
      I[0] = z;
      e: for (var q = 0, Q = I.length, ee = Q >>> 1; q < ee; ) {
        var ne = 2 * (q + 1) - 1,
          Ee = I[ne],
          Ae = ne + 1,
          $ = I[Ae];
        if (0 > r(Ee, z))
          Ae < Q && 0 > r($, Ee)
            ? ((I[q] = $), (I[Ae] = z), (q = Ae))
            : ((I[q] = Ee), (I[ne] = z), (q = ne));
        else if (Ae < Q && 0 > r($, z)) ((I[q] = $), (I[Ae] = z), (q = Ae));
        else break e;
      }
    }
    return G;
  }
  function r(I, G) {
    var z = I.sortIndex - G.sortIndex;
    return z !== 0 ? z : I.id - G.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    n.unstable_now = function () {
      return s.now();
    };
  } else {
    var o = Date,
      a = o.now();
    n.unstable_now = function () {
      return o.now() - a;
    };
  }
  var l = [],
    u = [],
    h = 1,
    d = null,
    p = 3,
    g = !1,
    y = !1,
    A = !1,
    _ = typeof setTimeout == "function" ? setTimeout : null,
    m = typeof clearTimeout == "function" ? clearTimeout : null,
    x = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function S(I) {
    for (var G = t(u); G !== null; ) {
      if (G.callback === null) i(u);
      else if (G.startTime <= I)
        (i(u), (G.sortIndex = G.expirationTime), e(l, G));
      else break;
      G = t(u);
    }
  }
  function w(I) {
    if (((A = !1), S(I), !y))
      if (t(l) !== null) ((y = !0), oe(C));
      else {
        var G = t(u);
        G !== null && ae(w, G.startTime - I);
      }
  }
  function C(I, G) {
    ((y = !1), A && ((A = !1), m(B), (B = -1)), (g = !0));
    var z = p;
    try {
      for (
        S(G), d = t(l);
        d !== null && (!(d.expirationTime > G) || (I && !U()));

      ) {
        var q = d.callback;
        if (typeof q == "function") {
          ((d.callback = null), (p = d.priorityLevel));
          var Q = q(d.expirationTime <= G);
          ((G = n.unstable_now()),
            typeof Q == "function" ? (d.callback = Q) : d === t(l) && i(l),
            S(G));
        } else i(l);
        d = t(l);
      }
      if (d !== null) var ee = !0;
      else {
        var ne = t(u);
        (ne !== null && ae(w, ne.startTime - G), (ee = !1));
      }
      return ee;
    } finally {
      ((d = null), (p = z), (g = !1));
    }
  }
  var P = !1,
    R = null,
    B = -1,
    b = 5,
    L = -1;
  function U() {
    return !(n.unstable_now() - L < b);
  }
  function J() {
    if (R !== null) {
      var I = n.unstable_now();
      L = I;
      var G = !0;
      try {
        G = R(!0, I);
      } finally {
        G ? V() : ((P = !1), (R = null));
      }
    } else P = !1;
  }
  var V;
  if (typeof x == "function")
    V = function () {
      x(J);
    };
  else if (typeof MessageChannel < "u") {
    var j = new MessageChannel(),
      X = j.port2;
    ((j.port1.onmessage = J),
      (V = function () {
        X.postMessage(null);
      }));
  } else
    V = function () {
      _(J, 0);
    };
  function oe(I) {
    ((R = I), P || ((P = !0), V()));
  }
  function ae(I, G) {
    B = _(function () {
      I(n.unstable_now());
    }, G);
  }
  ((n.unstable_IdlePriority = 5),
    (n.unstable_ImmediatePriority = 1),
    (n.unstable_LowPriority = 4),
    (n.unstable_NormalPriority = 3),
    (n.unstable_Profiling = null),
    (n.unstable_UserBlockingPriority = 2),
    (n.unstable_cancelCallback = function (I) {
      I.callback = null;
    }),
    (n.unstable_continueExecution = function () {
      y || g || ((y = !0), oe(C));
    }),
    (n.unstable_forceFrameRate = function (I) {
      0 > I || 125 < I
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (b = 0 < I ? Math.floor(1e3 / I) : 5);
    }),
    (n.unstable_getCurrentPriorityLevel = function () {
      return p;
    }),
    (n.unstable_getFirstCallbackNode = function () {
      return t(l);
    }),
    (n.unstable_next = function (I) {
      switch (p) {
        case 1:
        case 2:
        case 3:
          var G = 3;
          break;
        default:
          G = p;
      }
      var z = p;
      p = G;
      try {
        return I();
      } finally {
        p = z;
      }
    }),
    (n.unstable_pauseExecution = function () {}),
    (n.unstable_requestPaint = function () {}),
    (n.unstable_runWithPriority = function (I, G) {
      switch (I) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          I = 3;
      }
      var z = p;
      p = I;
      try {
        return G();
      } finally {
        p = z;
      }
    }),
    (n.unstable_scheduleCallback = function (I, G, z) {
      var q = n.unstable_now();
      switch (
        (typeof z == "object" && z !== null
          ? ((z = z.delay), (z = typeof z == "number" && 0 < z ? q + z : q))
          : (z = q),
        I)
      ) {
        case 1:
          var Q = -1;
          break;
        case 2:
          Q = 250;
          break;
        case 5:
          Q = 1073741823;
          break;
        case 4:
          Q = 1e4;
          break;
        default:
          Q = 5e3;
      }
      return (
        (Q = z + Q),
        (I = {
          id: h++,
          callback: G,
          priorityLevel: I,
          startTime: z,
          expirationTime: Q,
          sortIndex: -1,
        }),
        z > q
          ? ((I.sortIndex = z),
            e(u, I),
            t(l) === null &&
              I === t(u) &&
              (A ? (m(B), (B = -1)) : (A = !0), ae(w, z - q)))
          : ((I.sortIndex = Q), e(l, I), y || g || ((y = !0), oe(C))),
        I
      );
    }),
    (n.unstable_shouldYield = U),
    (n.unstable_wrapCallback = function (I) {
      var G = p;
      return function () {
        var z = p;
        p = G;
        try {
          return I.apply(this, arguments);
        } finally {
          p = z;
        }
      };
    }));
})(Fb);
(function (n) {
  n.exports = Fb;
})(rD);
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Nb = H,
  Yi = Hy;
function be(n) {
  for (
    var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + n, t = 1;
    t < arguments.length;
    t++
  )
    e += "&args[]=" + encodeURIComponent(arguments[t]);
  return (
    "Minified React error #" +
    n +
    "; visit " +
    e +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
var kb = new Set(),
  Df = {};
function ul(n, e) {
  (Fc(n, e), Fc(n + "Capture", e));
}
function Fc(n, e) {
  for (Df[n] = e, n = 0; n < e.length; n++) kb.add(e[n]);
}
var js = !(
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
  ),
  Vy = Object.prototype.hasOwnProperty,
  sD =
    /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  QS = {},
  ZS = {};
function oD(n) {
  return Vy.call(ZS, n)
    ? !0
    : Vy.call(QS, n)
      ? !1
      : sD.test(n)
        ? (ZS[n] = !0)
        : ((QS[n] = !0), !1);
}
function aD(n, e, t, i) {
  if (t !== null && t.type === 0) return !1;
  switch (typeof e) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return i
        ? !1
        : t !== null
          ? !t.acceptsBooleans
          : ((n = n.toLowerCase().slice(0, 5)), n !== "data-" && n !== "aria-");
    default:
      return !1;
  }
}
function lD(n, e, t, i) {
  if (e === null || typeof e > "u" || aD(n, e, t, i)) return !0;
  if (i) return !1;
  if (t !== null)
    switch (t.type) {
      case 3:
        return !e;
      case 4:
        return e === !1;
      case 5:
        return isNaN(e);
      case 6:
        return isNaN(e) || 1 > e;
    }
  return !1;
}
function xi(n, e, t, i, r, s, o) {
  ((this.acceptsBooleans = e === 2 || e === 3 || e === 4),
    (this.attributeName = i),
    (this.attributeNamespace = r),
    (this.mustUseProperty = t),
    (this.propertyName = n),
    (this.type = e),
    (this.sanitizeURL = s),
    (this.removeEmptyString = o));
}
var Yn = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
  .split(" ")
  .forEach(function (n) {
    Yn[n] = new xi(n, 0, !1, n, null, !1, !1);
  });
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"],
].forEach(function (n) {
  var e = n[0];
  Yn[e] = new xi(e, 1, !1, n[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (n) {
  Yn[n] = new xi(n, 2, !1, n.toLowerCase(), null, !1, !1);
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha",
].forEach(function (n) {
  Yn[n] = new xi(n, 2, !1, n, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
  .split(" ")
  .forEach(function (n) {
    Yn[n] = new xi(n, 3, !1, n.toLowerCase(), null, !1, !1);
  });
["checked", "multiple", "muted", "selected"].forEach(function (n) {
  Yn[n] = new xi(n, 3, !0, n, null, !1, !1);
});
["capture", "download"].forEach(function (n) {
  Yn[n] = new xi(n, 4, !1, n, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (n) {
  Yn[n] = new xi(n, 6, !1, n, null, !1, !1);
});
["rowSpan", "start"].forEach(function (n) {
  Yn[n] = new xi(n, 5, !1, n.toLowerCase(), null, !1, !1);
});
var q_ = /[\-:]([a-z])/g;
function $_(n) {
  return n[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
  .split(" ")
  .forEach(function (n) {
    var e = n.replace(q_, $_);
    Yn[e] = new xi(e, 1, !1, n, null, !1, !1);
  });
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
  .split(" ")
  .forEach(function (n) {
    var e = n.replace(q_, $_);
    Yn[e] = new xi(e, 1, !1, n, "http://www.w3.org/1999/xlink", !1, !1);
  });
["xml:base", "xml:lang", "xml:space"].forEach(function (n) {
  var e = n.replace(q_, $_);
  Yn[e] = new xi(e, 1, !1, n, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function (n) {
  Yn[n] = new xi(n, 1, !1, n.toLowerCase(), null, !1, !1);
});
Yn.xlinkHref = new xi(
  "xlinkHref",
  1,
  !1,
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  !1
);
["src", "href", "action", "formAction"].forEach(function (n) {
  Yn[n] = new xi(n, 1, !1, n.toLowerCase(), null, !0, !0);
});
function e1(n, e, t, i) {
  var r = Yn.hasOwnProperty(e) ? Yn[e] : null;
  (r !== null
    ? r.type !== 0
    : i ||
      !(2 < e.length) ||
      (e[0] !== "o" && e[0] !== "O") ||
      (e[1] !== "n" && e[1] !== "N")) &&
    (lD(e, t, r, i) && (t = null),
    i || r === null
      ? oD(e) && (t === null ? n.removeAttribute(e) : n.setAttribute(e, "" + t))
      : r.mustUseProperty
        ? (n[r.propertyName] = t === null ? (r.type === 3 ? !1 : "") : t)
        : ((e = r.attributeName),
          (i = r.attributeNamespace),
          t === null
            ? n.removeAttribute(e)
            : ((r = r.type),
              (t = r === 3 || (r === 4 && t === !0) ? "" : "" + t),
              i ? n.setAttributeNS(i, e, t) : n.setAttribute(e, t))));
}
var $s = Nb.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  jd = Symbol.for("react.element"),
  sc = Symbol.for("react.portal"),
  oc = Symbol.for("react.fragment"),
  t1 = Symbol.for("react.strict_mode"),
  Wy = Symbol.for("react.profiler"),
  Ob = Symbol.for("react.provider"),
  Ub = Symbol.for("react.context"),
  n1 = Symbol.for("react.forward_ref"),
  jy = Symbol.for("react.suspense"),
  Jy = Symbol.for("react.suspense_list"),
  i1 = Symbol.for("react.memo"),
  So = Symbol.for("react.lazy"),
  zb = Symbol.for("react.offscreen"),
  qS = Symbol.iterator;
function Du(n) {
  return n === null || typeof n != "object"
    ? null
    : ((n = (qS && n[qS]) || n["@@iterator"]),
      typeof n == "function" ? n : null);
}
var cn = Object.assign,
  fv;
function af(n) {
  if (fv === void 0)
    try {
      throw Error();
    } catch (t) {
      var e = t.stack.trim().match(/\n( *(at )?)/);
      fv = (e && e[1]) || "";
    }
  return (
    `
` +
    fv +
    n
  );
}
var hv = !1;
function dv(n, e) {
  if (!n || hv) return "";
  hv = !0;
  var t = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (e)
      if (
        ((e = function () {
          throw Error();
        }),
        Object.defineProperty(e.prototype, "props", {
          set: function () {
            throw Error();
          },
        }),
        typeof Reflect == "object" && Reflect.construct)
      ) {
        try {
          Reflect.construct(e, []);
        } catch (u) {
          var i = u;
        }
        Reflect.construct(n, [], e);
      } else {
        try {
          e.call();
        } catch (u) {
          i = u;
        }
        n.call(e.prototype);
      }
    else {
      try {
        throw Error();
      } catch (u) {
        i = u;
      }
      n();
    }
  } catch (u) {
    if (u && i && typeof u.stack == "string") {
      for (
        var r = u.stack.split(`
`),
          s = i.stack.split(`
`),
          o = r.length - 1,
          a = s.length - 1;
        1 <= o && 0 <= a && r[o] !== s[a];

      )
        a--;
      for (; 1 <= o && 0 <= a; o--, a--)
        if (r[o] !== s[a]) {
          if (o !== 1 || a !== 1)
            do
              if ((o--, a--, 0 > a || r[o] !== s[a])) {
                var l =
                  `
` + r[o].replace(" at new ", " at ");
                return (
                  n.displayName &&
                    l.includes("<anonymous>") &&
                    (l = l.replace("<anonymous>", n.displayName)),
                  l
                );
              }
            while (1 <= o && 0 <= a);
          break;
        }
    }
  } finally {
    ((hv = !1), (Error.prepareStackTrace = t));
  }
  return (n = n ? n.displayName || n.name : "") ? af(n) : "";
}
function cD(n) {
  switch (n.tag) {
    case 5:
      return af(n.type);
    case 16:
      return af("Lazy");
    case 13:
      return af("Suspense");
    case 19:
      return af("SuspenseList");
    case 0:
    case 2:
    case 15:
      return ((n = dv(n.type, !1)), n);
    case 11:
      return ((n = dv(n.type.render, !1)), n);
    case 1:
      return ((n = dv(n.type, !0)), n);
    default:
      return "";
  }
}
function Xy(n) {
  if (n == null) return null;
  if (typeof n == "function") return n.displayName || n.name || null;
  if (typeof n == "string") return n;
  switch (n) {
    case oc:
      return "Fragment";
    case sc:
      return "Portal";
    case Wy:
      return "Profiler";
    case t1:
      return "StrictMode";
    case jy:
      return "Suspense";
    case Jy:
      return "SuspenseList";
  }
  if (typeof n == "object")
    switch (n.$$typeof) {
      case Ub:
        return (n.displayName || "Context") + ".Consumer";
      case Ob:
        return (n._context.displayName || "Context") + ".Provider";
      case n1:
        var e = n.render;
        return (
          (n = n.displayName),
          n ||
            ((n = e.displayName || e.name || ""),
            (n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef")),
          n
        );
      case i1:
        return (
          (e = n.displayName || null),
          e !== null ? e : Xy(n.type) || "Memo"
        );
      case So:
        ((e = n._payload), (n = n._init));
        try {
          return Xy(n(e));
        } catch {}
    }
  return null;
}
function uD(n) {
  var e = n.type;
  switch (n.tag) {
    case 24:
      return "Cache";
    case 9:
      return (e.displayName || "Context") + ".Consumer";
    case 10:
      return (e._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return (
        (n = e.render),
        (n = n.displayName || n.name || ""),
        e.displayName || (n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef")
      );
    case 7:
      return "Fragment";
    case 5:
      return e;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Xy(e);
    case 8:
      return e === t1 ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof e == "function") return e.displayName || e.name || null;
      if (typeof e == "string") return e;
  }
  return null;
}
function jo(n) {
  switch (typeof n) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return n;
    case "object":
      return n;
    default:
      return "";
  }
}
function Gb(n) {
  var e = n.type;
  return (
    (n = n.nodeName) &&
    n.toLowerCase() === "input" &&
    (e === "checkbox" || e === "radio")
  );
}
function fD(n) {
  var e = Gb(n) ? "checked" : "value",
    t = Object.getOwnPropertyDescriptor(n.constructor.prototype, e),
    i = "" + n[e];
  if (
    !n.hasOwnProperty(e) &&
    typeof t < "u" &&
    typeof t.get == "function" &&
    typeof t.set == "function"
  ) {
    var r = t.get,
      s = t.set;
    return (
      Object.defineProperty(n, e, {
        configurable: !0,
        get: function () {
          return r.call(this);
        },
        set: function (o) {
          ((i = "" + o), s.call(this, o));
        },
      }),
      Object.defineProperty(n, e, { enumerable: t.enumerable }),
      {
        getValue: function () {
          return i;
        },
        setValue: function (o) {
          i = "" + o;
        },
        stopTracking: function () {
          ((n._valueTracker = null), delete n[e]);
        },
      }
    );
  }
}
function Jd(n) {
  n._valueTracker || (n._valueTracker = fD(n));
}
function Hb(n) {
  if (!n) return !1;
  var e = n._valueTracker;
  if (!e) return !0;
  var t = e.getValue(),
    i = "";
  return (
    n && (i = Gb(n) ? (n.checked ? "true" : "false") : n.value),
    (n = i),
    n !== t ? (e.setValue(n), !0) : !1
  );
}
function wm(n) {
  if (((n = n || (typeof document < "u" ? document : void 0)), typeof n > "u"))
    return null;
  try {
    return n.activeElement || n.body;
  } catch {
    return n.body;
  }
}
function Ky(n, e) {
  var t = e.checked;
  return cn({}, e, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: t ?? n._wrapperState.initialChecked,
  });
}
function $S(n, e) {
  var t = e.defaultValue == null ? "" : e.defaultValue,
    i = e.checked != null ? e.checked : e.defaultChecked;
  ((t = jo(e.value != null ? e.value : t)),
    (n._wrapperState = {
      initialChecked: i,
      initialValue: t,
      controlled:
        e.type === "checkbox" || e.type === "radio"
          ? e.checked != null
          : e.value != null,
    }));
}
function Vb(n, e) {
  ((e = e.checked), e != null && e1(n, "checked", e, !1));
}
function Yy(n, e) {
  Vb(n, e);
  var t = jo(e.value),
    i = e.type;
  if (t != null)
    i === "number"
      ? ((t === 0 && n.value === "") || n.value != t) && (n.value = "" + t)
      : n.value !== "" + t && (n.value = "" + t);
  else if (i === "submit" || i === "reset") {
    n.removeAttribute("value");
    return;
  }
  (e.hasOwnProperty("value")
    ? Qy(n, e.type, t)
    : e.hasOwnProperty("defaultValue") && Qy(n, e.type, jo(e.defaultValue)),
    e.checked == null &&
      e.defaultChecked != null &&
      (n.defaultChecked = !!e.defaultChecked));
}
function ew(n, e, t) {
  if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
    var i = e.type;
    if (
      !(
        (i !== "submit" && i !== "reset") ||
        (e.value !== void 0 && e.value !== null)
      )
    )
      return;
    ((e = "" + n._wrapperState.initialValue),
      t || e === n.value || (n.value = e),
      (n.defaultValue = e));
  }
  ((t = n.name),
    t !== "" && (n.name = ""),
    (n.defaultChecked = !!n._wrapperState.initialChecked),
    t !== "" && (n.name = t));
}
function Qy(n, e, t) {
  (e !== "number" || wm(n.ownerDocument) !== n) &&
    (t == null
      ? (n.defaultValue = "" + n._wrapperState.initialValue)
      : n.defaultValue !== "" + t && (n.defaultValue = "" + t));
}
var lf = Array.isArray;
function wc(n, e, t, i) {
  if (((n = n.options), e)) {
    e = {};
    for (var r = 0; r < t.length; r++) e["$" + t[r]] = !0;
    for (t = 0; t < n.length; t++)
      ((r = e.hasOwnProperty("$" + n[t].value)),
        n[t].selected !== r && (n[t].selected = r),
        r && i && (n[t].defaultSelected = !0));
  } else {
    for (t = "" + jo(t), e = null, r = 0; r < n.length; r++) {
      if (n[r].value === t) {
        ((n[r].selected = !0), i && (n[r].defaultSelected = !0));
        return;
      }
      e !== null || n[r].disabled || (e = n[r]);
    }
    e !== null && (e.selected = !0);
  }
}
function Zy(n, e) {
  if (e.dangerouslySetInnerHTML != null) throw Error(be(91));
  return cn({}, e, {
    value: void 0,
    defaultValue: void 0,
    children: "" + n._wrapperState.initialValue,
  });
}
function tw(n, e) {
  var t = e.value;
  if (t == null) {
    if (((t = e.children), (e = e.defaultValue), t != null)) {
      if (e != null) throw Error(be(92));
      if (lf(t)) {
        if (1 < t.length) throw Error(be(93));
        t = t[0];
      }
      e = t;
    }
    (e == null && (e = ""), (t = e));
  }
  n._wrapperState = { initialValue: jo(t) };
}
function Wb(n, e) {
  var t = jo(e.value),
    i = jo(e.defaultValue);
  (t != null &&
    ((t = "" + t),
    t !== n.value && (n.value = t),
    e.defaultValue == null && n.defaultValue !== t && (n.defaultValue = t)),
    i != null && (n.defaultValue = "" + i));
}
function nw(n) {
  var e = n.textContent;
  e === n._wrapperState.initialValue && e !== "" && e !== null && (n.value = e);
}
function jb(n) {
  switch (n) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function qy(n, e) {
  return n == null || n === "http://www.w3.org/1999/xhtml"
    ? jb(e)
    : n === "http://www.w3.org/2000/svg" && e === "foreignObject"
      ? "http://www.w3.org/1999/xhtml"
      : n;
}
var Xd,
  Jb = (function (n) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
      ? function (e, t, i, r) {
          MSApp.execUnsafeLocalFunction(function () {
            return n(e, t, i, r);
          });
        }
      : n;
  })(function (n, e) {
    if (n.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in n)
      n.innerHTML = e;
    else {
      for (
        Xd = Xd || document.createElement("div"),
          Xd.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
          e = Xd.firstChild;
        n.firstChild;

      )
        n.removeChild(n.firstChild);
      for (; e.firstChild; ) n.appendChild(e.firstChild);
    }
  });
function Ff(n, e) {
  if (e) {
    var t = n.firstChild;
    if (t && t === n.lastChild && t.nodeType === 3) {
      t.nodeValue = e;
      return;
    }
  }
  n.textContent = e;
}
var pf = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  },
  hD = ["Webkit", "ms", "Moz", "O"];
Object.keys(pf).forEach(function (n) {
  hD.forEach(function (e) {
    ((e = e + n.charAt(0).toUpperCase() + n.substring(1)), (pf[e] = pf[n]));
  });
});
function Xb(n, e, t) {
  return e == null || typeof e == "boolean" || e === ""
    ? ""
    : t || typeof e != "number" || e === 0 || (pf.hasOwnProperty(n) && pf[n])
      ? ("" + e).trim()
      : e + "px";
}
function Kb(n, e) {
  n = n.style;
  for (var t in e)
    if (e.hasOwnProperty(t)) {
      var i = t.indexOf("--") === 0,
        r = Xb(t, e[t], i);
      (t === "float" && (t = "cssFloat"), i ? n.setProperty(t, r) : (n[t] = r));
    }
}
var dD = cn(
  { menuitem: !0 },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
  }
);
function $y(n, e) {
  if (e) {
    if (dD[n] && (e.children != null || e.dangerouslySetInnerHTML != null))
      throw Error(be(137, n));
    if (e.dangerouslySetInnerHTML != null) {
      if (e.children != null) throw Error(be(60));
      if (
        typeof e.dangerouslySetInnerHTML != "object" ||
        !("__html" in e.dangerouslySetInnerHTML)
      )
        throw Error(be(61));
    }
    if (e.style != null && typeof e.style != "object") throw Error(be(62));
  }
}
function ex(n, e) {
  if (n.indexOf("-") === -1) return typeof e.is == "string";
  switch (n) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var tx = null;
function r1(n) {
  return (
    (n = n.target || n.srcElement || window),
    n.correspondingUseElement && (n = n.correspondingUseElement),
    n.nodeType === 3 ? n.parentNode : n
  );
}
var nx = null,
  Ec = null,
  Cc = null;
function iw(n) {
  if ((n = _h(n))) {
    if (typeof nx != "function") throw Error(be(280));
    var e = n.stateNode;
    e && ((e = yg(e)), nx(n.stateNode, n.type, e));
  }
}
function Yb(n) {
  Ec ? (Cc ? Cc.push(n) : (Cc = [n])) : (Ec = n);
}
function Qb() {
  if (Ec) {
    var n = Ec,
      e = Cc;
    if (((Cc = Ec = null), iw(n), e)) for (n = 0; n < e.length; n++) iw(e[n]);
  }
}
function Zb(n, e) {
  return n(e);
}
function qb() {}
var pv = !1;
function $b(n, e, t) {
  if (pv) return n(e, t);
  pv = !0;
  try {
    return Zb(n, e, t);
  } finally {
    ((pv = !1), (Ec !== null || Cc !== null) && (qb(), Qb()));
  }
}
function Nf(n, e) {
  var t = n.stateNode;
  if (t === null) return null;
  var i = yg(t);
  if (i === null) return null;
  t = i[e];
  e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      ((i = !i.disabled) ||
        ((n = n.type),
        (i = !(
          n === "button" ||
          n === "input" ||
          n === "select" ||
          n === "textarea"
        ))),
        (n = !i));
      break e;
    default:
      n = !1;
  }
  if (n) return null;
  if (t && typeof t != "function") throw Error(be(231, e, typeof t));
  return t;
}
var ix = !1;
if (js)
  try {
    var Fu = {};
    (Object.defineProperty(Fu, "passive", {
      get: function () {
        ix = !0;
      },
    }),
      window.addEventListener("test", Fu, Fu),
      window.removeEventListener("test", Fu, Fu));
  } catch {
    ix = !1;
  }
function pD(n, e, t, i, r, s, o, a, l) {
  var u = Array.prototype.slice.call(arguments, 3);
  try {
    e.apply(t, u);
  } catch (h) {
    this.onError(h);
  }
}
var mf = !1,
  Em = null,
  Cm = !1,
  rx = null,
  mD = {
    onError: function (n) {
      ((mf = !0), (Em = n));
    },
  };
function gD(n, e, t, i, r, s, o, a, l) {
  ((mf = !1), (Em = null), pD.apply(mD, arguments));
}
function vD(n, e, t, i, r, s, o, a, l) {
  if ((gD.apply(this, arguments), mf)) {
    if (mf) {
      var u = Em;
      ((mf = !1), (Em = null));
    } else throw Error(be(198));
    Cm || ((Cm = !0), (rx = u));
  }
}
function fl(n) {
  var e = n,
    t = n;
  if (n.alternate) for (; e.return; ) e = e.return;
  else {
    n = e;
    do ((e = n), e.flags & 4098 && (t = e.return), (n = e.return));
    while (n);
  }
  return e.tag === 3 ? t : null;
}
function eP(n) {
  if (n.tag === 13) {
    var e = n.memoizedState;
    if (
      (e === null && ((n = n.alternate), n !== null && (e = n.memoizedState)),
      e !== null)
    )
      return e.dehydrated;
  }
  return null;
}
function rw(n) {
  if (fl(n) !== n) throw Error(be(188));
}
function yD(n) {
  var e = n.alternate;
  if (!e) {
    if (((e = fl(n)), e === null)) throw Error(be(188));
    return e !== n ? null : n;
  }
  for (var t = n, i = e; ; ) {
    var r = t.return;
    if (r === null) break;
    var s = r.alternate;
    if (s === null) {
      if (((i = r.return), i !== null)) {
        t = i;
        continue;
      }
      break;
    }
    if (r.child === s.child) {
      for (s = r.child; s; ) {
        if (s === t) return (rw(r), n);
        if (s === i) return (rw(r), e);
        s = s.sibling;
      }
      throw Error(be(188));
    }
    if (t.return !== i.return) ((t = r), (i = s));
    else {
      for (var o = !1, a = r.child; a; ) {
        if (a === t) {
          ((o = !0), (t = r), (i = s));
          break;
        }
        if (a === i) {
          ((o = !0), (i = r), (t = s));
          break;
        }
        a = a.sibling;
      }
      if (!o) {
        for (a = s.child; a; ) {
          if (a === t) {
            ((o = !0), (t = s), (i = r));
            break;
          }
          if (a === i) {
            ((o = !0), (i = s), (t = r));
            break;
          }
          a = a.sibling;
        }
        if (!o) throw Error(be(189));
      }
    }
    if (t.alternate !== i) throw Error(be(190));
  }
  if (t.tag !== 3) throw Error(be(188));
  return t.stateNode.current === t ? n : e;
}
function tP(n) {
  return ((n = yD(n)), n !== null ? nP(n) : null);
}
function nP(n) {
  if (n.tag === 5 || n.tag === 6) return n;
  for (n = n.child; n !== null; ) {
    var e = nP(n);
    if (e !== null) return e;
    n = n.sibling;
  }
  return null;
}
var iP = Yi.unstable_scheduleCallback,
  sw = Yi.unstable_cancelCallback,
  xD = Yi.unstable_shouldYield,
  _D = Yi.unstable_requestPaint,
  vn = Yi.unstable_now,
  AD = Yi.unstable_getCurrentPriorityLevel,
  s1 = Yi.unstable_ImmediatePriority,
  rP = Yi.unstable_UserBlockingPriority,
  Tm = Yi.unstable_NormalPriority,
  MD = Yi.unstable_LowPriority,
  sP = Yi.unstable_IdlePriority,
  pg = null,
  os = null;
function SD(n) {
  if (os && typeof os.onCommitFiberRoot == "function")
    try {
      os.onCommitFiberRoot(pg, n, void 0, (n.current.flags & 128) === 128);
    } catch {}
}
var kr = Math.clz32 ? Math.clz32 : CD,
  wD = Math.log,
  ED = Math.LN2;
function CD(n) {
  return ((n >>>= 0), n === 0 ? 32 : (31 - ((wD(n) / ED) | 0)) | 0);
}
var Kd = 64,
  Yd = 4194304;
function cf(n) {
  switch (n & -n) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return n & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return n & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return n;
  }
}
function bm(n, e) {
  var t = n.pendingLanes;
  if (t === 0) return 0;
  var i = 0,
    r = n.suspendedLanes,
    s = n.pingedLanes,
    o = t & 268435455;
  if (o !== 0) {
    var a = o & ~r;
    a !== 0 ? (i = cf(a)) : ((s &= o), s !== 0 && (i = cf(s)));
  } else ((o = t & ~r), o !== 0 ? (i = cf(o)) : s !== 0 && (i = cf(s)));
  if (i === 0) return 0;
  if (
    e !== 0 &&
    e !== i &&
    !(e & r) &&
    ((r = i & -i), (s = e & -e), r >= s || (r === 16 && (s & 4194240) !== 0))
  )
    return e;
  if ((i & 4 && (i |= t & 16), (e = n.entangledLanes), e !== 0))
    for (n = n.entanglements, e &= i; 0 < e; )
      ((t = 31 - kr(e)), (r = 1 << t), (i |= n[t]), (e &= ~r));
  return i;
}
function TD(n, e) {
  switch (n) {
    case 1:
    case 2:
    case 4:
      return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function bD(n, e) {
  for (
    var t = n.suspendedLanes,
      i = n.pingedLanes,
      r = n.expirationTimes,
      s = n.pendingLanes;
    0 < s;

  ) {
    var o = 31 - kr(s),
      a = 1 << o,
      l = r[o];
    (l === -1
      ? (!(a & t) || a & i) && (r[o] = TD(a, e))
      : l <= e && (n.expiredLanes |= a),
      (s &= ~a));
  }
}
function sx(n) {
  return (
    (n = n.pendingLanes & -1073741825),
    n !== 0 ? n : n & 1073741824 ? 1073741824 : 0
  );
}
function oP() {
  var n = Kd;
  return ((Kd <<= 1), !(Kd & 4194240) && (Kd = 64), n);
}
function mv(n) {
  for (var e = [], t = 0; 31 > t; t++) e.push(n);
  return e;
}
function yh(n, e, t) {
  ((n.pendingLanes |= e),
    e !== 536870912 && ((n.suspendedLanes = 0), (n.pingedLanes = 0)),
    (n = n.eventTimes),
    (e = 31 - kr(e)),
    (n[e] = t));
}
function PD(n, e) {
  var t = n.pendingLanes & ~e;
  ((n.pendingLanes = e),
    (n.suspendedLanes = 0),
    (n.pingedLanes = 0),
    (n.expiredLanes &= e),
    (n.mutableReadLanes &= e),
    (n.entangledLanes &= e),
    (e = n.entanglements));
  var i = n.eventTimes;
  for (n = n.expirationTimes; 0 < t; ) {
    var r = 31 - kr(t),
      s = 1 << r;
    ((e[r] = 0), (i[r] = -1), (n[r] = -1), (t &= ~s));
  }
}
function o1(n, e) {
  var t = (n.entangledLanes |= e);
  for (n = n.entanglements; t; ) {
    var i = 31 - kr(t),
      r = 1 << i;
    ((r & e) | (n[i] & e) && (n[i] |= e), (t &= ~r));
  }
}
var Ot = 0;
function aP(n) {
  return (
    (n &= -n),
    1 < n ? (4 < n ? (n & 268435455 ? 16 : 536870912) : 4) : 1
  );
}
var lP,
  a1,
  cP,
  uP,
  fP,
  ox = !1,
  Qd = [],
  Io = null,
  Do = null,
  Fo = null,
  kf = new Map(),
  Of = new Map(),
  To = [],
  BD =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
      " "
    );
function ow(n, e) {
  switch (n) {
    case "focusin":
    case "focusout":
      Io = null;
      break;
    case "dragenter":
    case "dragleave":
      Do = null;
      break;
    case "mouseover":
    case "mouseout":
      Fo = null;
      break;
    case "pointerover":
    case "pointerout":
      kf.delete(e.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Of.delete(e.pointerId);
  }
}
function Nu(n, e, t, i, r, s) {
  return n === null || n.nativeEvent !== s
    ? ((n = {
        blockedOn: e,
        domEventName: t,
        eventSystemFlags: i,
        nativeEvent: s,
        targetContainers: [r],
      }),
      e !== null && ((e = _h(e)), e !== null && a1(e)),
      n)
    : ((n.eventSystemFlags |= i),
      (e = n.targetContainers),
      r !== null && e.indexOf(r) === -1 && e.push(r),
      n);
}
function RD(n, e, t, i, r) {
  switch (e) {
    case "focusin":
      return ((Io = Nu(Io, n, e, t, i, r)), !0);
    case "dragenter":
      return ((Do = Nu(Do, n, e, t, i, r)), !0);
    case "mouseover":
      return ((Fo = Nu(Fo, n, e, t, i, r)), !0);
    case "pointerover":
      var s = r.pointerId;
      return (kf.set(s, Nu(kf.get(s) || null, n, e, t, i, r)), !0);
    case "gotpointercapture":
      return (
        (s = r.pointerId),
        Of.set(s, Nu(Of.get(s) || null, n, e, t, i, r)),
        !0
      );
  }
  return !1;
}
function hP(n) {
  var e = Na(n.target);
  if (e !== null) {
    var t = fl(e);
    if (t !== null) {
      if (((e = t.tag), e === 13)) {
        if (((e = eP(t)), e !== null)) {
          ((n.blockedOn = e),
            fP(n.priority, function () {
              cP(t);
            }));
          return;
        }
      } else if (e === 3 && t.stateNode.current.memoizedState.isDehydrated) {
        n.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null;
        return;
      }
    }
  }
  n.blockedOn = null;
}
function sm(n) {
  if (n.blockedOn !== null) return !1;
  for (var e = n.targetContainers; 0 < e.length; ) {
    var t = ax(n.domEventName, n.eventSystemFlags, e[0], n.nativeEvent);
    if (t === null) {
      t = n.nativeEvent;
      var i = new t.constructor(t.type, t);
      ((tx = i), t.target.dispatchEvent(i), (tx = null));
    } else return ((e = _h(t)), e !== null && a1(e), (n.blockedOn = t), !1);
    e.shift();
  }
  return !0;
}
function aw(n, e, t) {
  sm(n) && t.delete(e);
}
function LD() {
  ((ox = !1),
    Io !== null && sm(Io) && (Io = null),
    Do !== null && sm(Do) && (Do = null),
    Fo !== null && sm(Fo) && (Fo = null),
    kf.forEach(aw),
    Of.forEach(aw));
}
function ku(n, e) {
  n.blockedOn === e &&
    ((n.blockedOn = null),
    ox ||
      ((ox = !0),
      Yi.unstable_scheduleCallback(Yi.unstable_NormalPriority, LD)));
}
function Uf(n) {
  function e(r) {
    return ku(r, n);
  }
  if (0 < Qd.length) {
    ku(Qd[0], n);
    for (var t = 1; t < Qd.length; t++) {
      var i = Qd[t];
      i.blockedOn === n && (i.blockedOn = null);
    }
  }
  for (
    Io !== null && ku(Io, n),
      Do !== null && ku(Do, n),
      Fo !== null && ku(Fo, n),
      kf.forEach(e),
      Of.forEach(e),
      t = 0;
    t < To.length;
    t++
  )
    ((i = To[t]), i.blockedOn === n && (i.blockedOn = null));
  for (; 0 < To.length && ((t = To[0]), t.blockedOn === null); )
    (hP(t), t.blockedOn === null && To.shift());
}
var Tc = $s.ReactCurrentBatchConfig,
  Pm = !0;
function ID(n, e, t, i) {
  var r = Ot,
    s = Tc.transition;
  Tc.transition = null;
  try {
    ((Ot = 1), l1(n, e, t, i));
  } finally {
    ((Ot = r), (Tc.transition = s));
  }
}
function DD(n, e, t, i) {
  var r = Ot,
    s = Tc.transition;
  Tc.transition = null;
  try {
    ((Ot = 4), l1(n, e, t, i));
  } finally {
    ((Ot = r), (Tc.transition = s));
  }
}
function l1(n, e, t, i) {
  if (Pm) {
    var r = ax(n, e, t, i);
    if (r === null) (Ev(n, e, i, Bm, t), ow(n, i));
    else if (RD(r, n, e, t, i)) i.stopPropagation();
    else if ((ow(n, i), e & 4 && -1 < BD.indexOf(n))) {
      for (; r !== null; ) {
        var s = _h(r);
        if (
          (s !== null && lP(s),
          (s = ax(n, e, t, i)),
          s === null && Ev(n, e, i, Bm, t),
          s === r)
        )
          break;
        r = s;
      }
      r !== null && i.stopPropagation();
    } else Ev(n, e, i, null, t);
  }
}
var Bm = null;
function ax(n, e, t, i) {
  if (((Bm = null), (n = r1(i)), (n = Na(n)), n !== null))
    if (((e = fl(n)), e === null)) n = null;
    else if (((t = e.tag), t === 13)) {
      if (((n = eP(e)), n !== null)) return n;
      n = null;
    } else if (t === 3) {
      if (e.stateNode.current.memoizedState.isDehydrated)
        return e.tag === 3 ? e.stateNode.containerInfo : null;
      n = null;
    } else e !== n && (n = null);
  return ((Bm = n), null);
}
function dP(n) {
  switch (n) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (AD()) {
        case s1:
          return 1;
        case rP:
          return 4;
        case Tm:
        case MD:
          return 16;
        case sP:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var Po = null,
  c1 = null,
  om = null;
function pP() {
  if (om) return om;
  var n,
    e = c1,
    t = e.length,
    i,
    r = "value" in Po ? Po.value : Po.textContent,
    s = r.length;
  for (n = 0; n < t && e[n] === r[n]; n++);
  var o = t - n;
  for (i = 1; i <= o && e[t - i] === r[s - i]; i++);
  return (om = r.slice(n, 1 < i ? 1 - i : void 0));
}
function am(n) {
  var e = n.keyCode;
  return (
    "charCode" in n
      ? ((n = n.charCode), n === 0 && e === 13 && (n = 13))
      : (n = e),
    n === 10 && (n = 13),
    32 <= n || n === 13 ? n : 0
  );
}
function Zd() {
  return !0;
}
function lw() {
  return !1;
}
function $i(n) {
  function e(t, i, r, s, o) {
    ((this._reactName = t),
      (this._targetInst = r),
      (this.type = i),
      (this.nativeEvent = s),
      (this.target = o),
      (this.currentTarget = null));
    for (var a in n)
      n.hasOwnProperty(a) && ((t = n[a]), (this[a] = t ? t(s) : s[a]));
    return (
      (this.isDefaultPrevented = (
        s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1
      )
        ? Zd
        : lw),
      (this.isPropagationStopped = lw),
      this
    );
  }
  return (
    cn(e.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0;
        var t = this.nativeEvent;
        t &&
          (t.preventDefault
            ? t.preventDefault()
            : typeof t.returnValue != "unknown" && (t.returnValue = !1),
          (this.isDefaultPrevented = Zd));
      },
      stopPropagation: function () {
        var t = this.nativeEvent;
        t &&
          (t.stopPropagation
            ? t.stopPropagation()
            : typeof t.cancelBubble != "unknown" && (t.cancelBubble = !0),
          (this.isPropagationStopped = Zd));
      },
      persist: function () {},
      isPersistent: Zd,
    }),
    e
  );
}
var tu = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (n) {
      return n.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0,
  },
  u1 = $i(tu),
  xh = cn({}, tu, { view: 0, detail: 0 }),
  FD = $i(xh),
  gv,
  vv,
  Ou,
  mg = cn({}, xh, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: f1,
    button: 0,
    buttons: 0,
    relatedTarget: function (n) {
      return n.relatedTarget === void 0
        ? n.fromElement === n.srcElement
          ? n.toElement
          : n.fromElement
        : n.relatedTarget;
    },
    movementX: function (n) {
      return "movementX" in n
        ? n.movementX
        : (n !== Ou &&
            (Ou && n.type === "mousemove"
              ? ((gv = n.screenX - Ou.screenX), (vv = n.screenY - Ou.screenY))
              : (vv = gv = 0),
            (Ou = n)),
          gv);
    },
    movementY: function (n) {
      return "movementY" in n ? n.movementY : vv;
    },
  }),
  cw = $i(mg),
  ND = cn({}, mg, { dataTransfer: 0 }),
  kD = $i(ND),
  OD = cn({}, xh, { relatedTarget: 0 }),
  yv = $i(OD),
  UD = cn({}, tu, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
  zD = $i(UD),
  GD = cn({}, tu, {
    clipboardData: function (n) {
      return "clipboardData" in n ? n.clipboardData : window.clipboardData;
    },
  }),
  HD = $i(GD),
  VD = cn({}, tu, { data: 0 }),
  uw = $i(VD),
  WD = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified",
  },
  jD = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta",
  },
  JD = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey",
  };
function XD(n) {
  var e = this.nativeEvent;
  return e.getModifierState ? e.getModifierState(n) : (n = JD[n]) ? !!e[n] : !1;
}
function f1() {
  return XD;
}
var KD = cn({}, xh, {
    key: function (n) {
      if (n.key) {
        var e = WD[n.key] || n.key;
        if (e !== "Unidentified") return e;
      }
      return n.type === "keypress"
        ? ((n = am(n)), n === 13 ? "Enter" : String.fromCharCode(n))
        : n.type === "keydown" || n.type === "keyup"
          ? jD[n.keyCode] || "Unidentified"
          : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: f1,
    charCode: function (n) {
      return n.type === "keypress" ? am(n) : 0;
    },
    keyCode: function (n) {
      return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
    },
    which: function (n) {
      return n.type === "keypress"
        ? am(n)
        : n.type === "keydown" || n.type === "keyup"
          ? n.keyCode
          : 0;
    },
  }),
  YD = $i(KD),
  QD = cn({}, mg, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0,
  }),
  fw = $i(QD),
  ZD = cn({}, xh, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: f1,
  }),
  qD = $i(ZD),
  $D = cn({}, tu, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
  eF = $i($D),
  tF = cn({}, mg, {
    deltaX: function (n) {
      return "deltaX" in n ? n.deltaX : "wheelDeltaX" in n ? -n.wheelDeltaX : 0;
    },
    deltaY: function (n) {
      return "deltaY" in n
        ? n.deltaY
        : "wheelDeltaY" in n
          ? -n.wheelDeltaY
          : "wheelDelta" in n
            ? -n.wheelDelta
            : 0;
    },
    deltaZ: 0,
    deltaMode: 0,
  }),
  nF = $i(tF),
  iF = [9, 13, 27, 32],
  h1 = js && "CompositionEvent" in window,
  gf = null;
js && "documentMode" in document && (gf = document.documentMode);
var rF = js && "TextEvent" in window && !gf,
  mP = js && (!h1 || (gf && 8 < gf && 11 >= gf)),
  hw = String.fromCharCode(32),
  dw = !1;
function gP(n, e) {
  switch (n) {
    case "keyup":
      return iF.indexOf(e.keyCode) !== -1;
    case "keydown":
      return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function vP(n) {
  return ((n = n.detail), typeof n == "object" && "data" in n ? n.data : null);
}
var ac = !1;
function sF(n, e) {
  switch (n) {
    case "compositionend":
      return vP(e);
    case "keypress":
      return e.which !== 32 ? null : ((dw = !0), hw);
    case "textInput":
      return ((n = e.data), n === hw && dw ? null : n);
    default:
      return null;
  }
}
function oF(n, e) {
  if (ac)
    return n === "compositionend" || (!h1 && gP(n, e))
      ? ((n = pP()), (om = c1 = Po = null), (ac = !1), n)
      : null;
  switch (n) {
    case "paste":
      return null;
    case "keypress":
      if (!(e.ctrlKey || e.altKey || e.metaKey) || (e.ctrlKey && e.altKey)) {
        if (e.char && 1 < e.char.length) return e.char;
        if (e.which) return String.fromCharCode(e.which);
      }
      return null;
    case "compositionend":
      return mP && e.locale !== "ko" ? null : e.data;
    default:
      return null;
  }
}
var aF = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0,
};
function pw(n) {
  var e = n && n.nodeName && n.nodeName.toLowerCase();
  return e === "input" ? !!aF[n.type] : e === "textarea";
}
function yP(n, e, t, i) {
  (Yb(i),
    (e = Rm(e, "onChange")),
    0 < e.length &&
      ((t = new u1("onChange", "change", null, t, i)),
      n.push({ event: t, listeners: e })));
}
var vf = null,
  zf = null;
function lF(n) {
  PP(n, 0);
}
function gg(n) {
  var e = uc(n);
  if (Hb(e)) return n;
}
function cF(n, e) {
  if (n === "change") return e;
}
var xP = !1;
if (js) {
  var xv;
  if (js) {
    var _v = "oninput" in document;
    if (!_v) {
      var mw = document.createElement("div");
      (mw.setAttribute("oninput", "return;"),
        (_v = typeof mw.oninput == "function"));
    }
    xv = _v;
  } else xv = !1;
  xP = xv && (!document.documentMode || 9 < document.documentMode);
}
function gw() {
  vf && (vf.detachEvent("onpropertychange", _P), (zf = vf = null));
}
function _P(n) {
  if (n.propertyName === "value" && gg(zf)) {
    var e = [];
    (yP(e, zf, n, r1(n)), $b(lF, e));
  }
}
function uF(n, e, t) {
  n === "focusin"
    ? (gw(), (vf = e), (zf = t), vf.attachEvent("onpropertychange", _P))
    : n === "focusout" && gw();
}
function fF(n) {
  if (n === "selectionchange" || n === "keyup" || n === "keydown")
    return gg(zf);
}
function hF(n, e) {
  if (n === "click") return gg(e);
}
function dF(n, e) {
  if (n === "input" || n === "change") return gg(e);
}
function pF(n, e) {
  return (n === e && (n !== 0 || 1 / n === 1 / e)) || (n !== n && e !== e);
}
var Gr = typeof Object.is == "function" ? Object.is : pF;
function Gf(n, e) {
  if (Gr(n, e)) return !0;
  if (typeof n != "object" || n === null || typeof e != "object" || e === null)
    return !1;
  var t = Object.keys(n),
    i = Object.keys(e);
  if (t.length !== i.length) return !1;
  for (i = 0; i < t.length; i++) {
    var r = t[i];
    if (!Vy.call(e, r) || !Gr(n[r], e[r])) return !1;
  }
  return !0;
}
function vw(n) {
  for (; n && n.firstChild; ) n = n.firstChild;
  return n;
}
function yw(n, e) {
  var t = vw(n);
  n = 0;
  for (var i; t; ) {
    if (t.nodeType === 3) {
      if (((i = n + t.textContent.length), n <= e && i >= e))
        return { node: t, offset: e - n };
      n = i;
    }
    e: {
      for (; t; ) {
        if (t.nextSibling) {
          t = t.nextSibling;
          break e;
        }
        t = t.parentNode;
      }
      t = void 0;
    }
    t = vw(t);
  }
}
function AP(n, e) {
  return n && e
    ? n === e
      ? !0
      : n && n.nodeType === 3
        ? !1
        : e && e.nodeType === 3
          ? AP(n, e.parentNode)
          : "contains" in n
            ? n.contains(e)
            : n.compareDocumentPosition
              ? !!(n.compareDocumentPosition(e) & 16)
              : !1
    : !1;
}
function MP() {
  for (var n = window, e = wm(); e instanceof n.HTMLIFrameElement; ) {
    try {
      var t = typeof e.contentWindow.location.href == "string";
    } catch {
      t = !1;
    }
    if (t) n = e.contentWindow;
    else break;
    e = wm(n.document);
  }
  return e;
}
function d1(n) {
  var e = n && n.nodeName && n.nodeName.toLowerCase();
  return (
    e &&
    ((e === "input" &&
      (n.type === "text" ||
        n.type === "search" ||
        n.type === "tel" ||
        n.type === "url" ||
        n.type === "password")) ||
      e === "textarea" ||
      n.contentEditable === "true")
  );
}
function mF(n) {
  var e = MP(),
    t = n.focusedElem,
    i = n.selectionRange;
  if (
    e !== t &&
    t &&
    t.ownerDocument &&
    AP(t.ownerDocument.documentElement, t)
  ) {
    if (i !== null && d1(t)) {
      if (
        ((e = i.start),
        (n = i.end),
        n === void 0 && (n = e),
        "selectionStart" in t)
      )
        ((t.selectionStart = e),
          (t.selectionEnd = Math.min(n, t.value.length)));
      else if (
        ((n = ((e = t.ownerDocument || document) && e.defaultView) || window),
        n.getSelection)
      ) {
        n = n.getSelection();
        var r = t.textContent.length,
          s = Math.min(i.start, r);
        ((i = i.end === void 0 ? s : Math.min(i.end, r)),
          !n.extend && s > i && ((r = i), (i = s), (s = r)),
          (r = yw(t, s)));
        var o = yw(t, i);
        r &&
          o &&
          (n.rangeCount !== 1 ||
            n.anchorNode !== r.node ||
            n.anchorOffset !== r.offset ||
            n.focusNode !== o.node ||
            n.focusOffset !== o.offset) &&
          ((e = e.createRange()),
          e.setStart(r.node, r.offset),
          n.removeAllRanges(),
          s > i
            ? (n.addRange(e), n.extend(o.node, o.offset))
            : (e.setEnd(o.node, o.offset), n.addRange(e)));
      }
    }
    for (e = [], n = t; (n = n.parentNode); )
      n.nodeType === 1 &&
        e.push({ element: n, left: n.scrollLeft, top: n.scrollTop });
    for (typeof t.focus == "function" && t.focus(), t = 0; t < e.length; t++)
      ((n = e[t]),
        (n.element.scrollLeft = n.left),
        (n.element.scrollTop = n.top));
  }
}
var gF = js && "documentMode" in document && 11 >= document.documentMode,
  lc = null,
  lx = null,
  yf = null,
  cx = !1;
function xw(n, e, t) {
  var i = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument;
  cx ||
    lc == null ||
    lc !== wm(i) ||
    ((i = lc),
    "selectionStart" in i && d1(i)
      ? (i = { start: i.selectionStart, end: i.selectionEnd })
      : ((i = (
          (i.ownerDocument && i.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (i = {
          anchorNode: i.anchorNode,
          anchorOffset: i.anchorOffset,
          focusNode: i.focusNode,
          focusOffset: i.focusOffset,
        })),
    (yf && Gf(yf, i)) ||
      ((yf = i),
      (i = Rm(lx, "onSelect")),
      0 < i.length &&
        ((e = new u1("onSelect", "select", null, e, t)),
        n.push({ event: e, listeners: i }),
        (e.target = lc))));
}
function qd(n, e) {
  var t = {};
  return (
    (t[n.toLowerCase()] = e.toLowerCase()),
    (t["Webkit" + n] = "webkit" + e),
    (t["Moz" + n] = "moz" + e),
    t
  );
}
var cc = {
    animationend: qd("Animation", "AnimationEnd"),
    animationiteration: qd("Animation", "AnimationIteration"),
    animationstart: qd("Animation", "AnimationStart"),
    transitionend: qd("Transition", "TransitionEnd"),
  },
  Av = {},
  SP = {};
js &&
  ((SP = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete cc.animationend.animation,
    delete cc.animationiteration.animation,
    delete cc.animationstart.animation),
  "TransitionEvent" in window || delete cc.transitionend.transition);
function vg(n) {
  if (Av[n]) return Av[n];
  if (!cc[n]) return n;
  var e = cc[n],
    t;
  for (t in e) if (e.hasOwnProperty(t) && t in SP) return (Av[n] = e[t]);
  return n;
}
var wP = vg("animationend"),
  EP = vg("animationiteration"),
  CP = vg("animationstart"),
  TP = vg("transitionend"),
  bP = new Map(),
  _w =
    "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
function $o(n, e) {
  (bP.set(n, e), ul(e, [n]));
}
for (var Mv = 0; Mv < _w.length; Mv++) {
  var Sv = _w[Mv],
    vF = Sv.toLowerCase(),
    yF = Sv[0].toUpperCase() + Sv.slice(1);
  $o(vF, "on" + yF);
}
$o(wP, "onAnimationEnd");
$o(EP, "onAnimationIteration");
$o(CP, "onAnimationStart");
$o("dblclick", "onDoubleClick");
$o("focusin", "onFocus");
$o("focusout", "onBlur");
$o(TP, "onTransitionEnd");
Fc("onMouseEnter", ["mouseout", "mouseover"]);
Fc("onMouseLeave", ["mouseout", "mouseover"]);
Fc("onPointerEnter", ["pointerout", "pointerover"]);
Fc("onPointerLeave", ["pointerout", "pointerover"]);
ul(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
);
ul(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
);
ul("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
ul(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
);
ul(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
);
ul(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
);
var uf =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
  xF = new Set("cancel close invalid load scroll toggle".split(" ").concat(uf));
function Aw(n, e, t) {
  var i = n.type || "unknown-event";
  ((n.currentTarget = t), vD(i, e, void 0, n), (n.currentTarget = null));
}
function PP(n, e) {
  e = (e & 4) !== 0;
  for (var t = 0; t < n.length; t++) {
    var i = n[t],
      r = i.event;
    i = i.listeners;
    e: {
      var s = void 0;
      if (e)
        for (var o = i.length - 1; 0 <= o; o--) {
          var a = i[o],
            l = a.instance,
            u = a.currentTarget;
          if (((a = a.listener), l !== s && r.isPropagationStopped())) break e;
          (Aw(r, a, u), (s = l));
        }
      else
        for (o = 0; o < i.length; o++) {
          if (
            ((a = i[o]),
            (l = a.instance),
            (u = a.currentTarget),
            (a = a.listener),
            l !== s && r.isPropagationStopped())
          )
            break e;
          (Aw(r, a, u), (s = l));
        }
    }
  }
  if (Cm) throw ((n = rx), (Cm = !1), (rx = null), n);
}
function Xt(n, e) {
  var t = e[px];
  t === void 0 && (t = e[px] = new Set());
  var i = n + "__bubble";
  t.has(i) || (BP(e, n, 2, !1), t.add(i));
}
function wv(n, e, t) {
  var i = 0;
  (e && (i |= 4), BP(t, n, i, e));
}
var $d = "_reactListening" + Math.random().toString(36).slice(2);
function Hf(n) {
  if (!n[$d]) {
    ((n[$d] = !0),
      kb.forEach(function (t) {
        t !== "selectionchange" && (xF.has(t) || wv(t, !1, n), wv(t, !0, n));
      }));
    var e = n.nodeType === 9 ? n : n.ownerDocument;
    e === null || e[$d] || ((e[$d] = !0), wv("selectionchange", !1, e));
  }
}
function BP(n, e, t, i) {
  switch (dP(e)) {
    case 1:
      var r = ID;
      break;
    case 4:
      r = DD;
      break;
    default:
      r = l1;
  }
  ((t = r.bind(null, e, t, n)),
    (r = void 0),
    !ix ||
      (e !== "touchstart" && e !== "touchmove" && e !== "wheel") ||
      (r = !0),
    i
      ? r !== void 0
        ? n.addEventListener(e, t, { capture: !0, passive: r })
        : n.addEventListener(e, t, !0)
      : r !== void 0
        ? n.addEventListener(e, t, { passive: r })
        : n.addEventListener(e, t, !1));
}
function Ev(n, e, t, i, r) {
  var s = i;
  if (!(e & 1) && !(e & 2) && i !== null)
    e: for (;;) {
      if (i === null) return;
      var o = i.tag;
      if (o === 3 || o === 4) {
        var a = i.stateNode.containerInfo;
        if (a === r || (a.nodeType === 8 && a.parentNode === r)) break;
        if (o === 4)
          for (o = i.return; o !== null; ) {
            var l = o.tag;
            if (
              (l === 3 || l === 4) &&
              ((l = o.stateNode.containerInfo),
              l === r || (l.nodeType === 8 && l.parentNode === r))
            )
              return;
            o = o.return;
          }
        for (; a !== null; ) {
          if (((o = Na(a)), o === null)) return;
          if (((l = o.tag), l === 5 || l === 6)) {
            i = s = o;
            continue e;
          }
          a = a.parentNode;
        }
      }
      i = i.return;
    }
  $b(function () {
    var u = s,
      h = r1(t),
      d = [];
    e: {
      var p = bP.get(n);
      if (p !== void 0) {
        var g = u1,
          y = n;
        switch (n) {
          case "keypress":
            if (am(t) === 0) break e;
          case "keydown":
          case "keyup":
            g = YD;
            break;
          case "focusin":
            ((y = "focus"), (g = yv));
            break;
          case "focusout":
            ((y = "blur"), (g = yv));
            break;
          case "beforeblur":
          case "afterblur":
            g = yv;
            break;
          case "click":
            if (t.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            g = cw;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            g = kD;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            g = qD;
            break;
          case wP:
          case EP:
          case CP:
            g = zD;
            break;
          case TP:
            g = eF;
            break;
          case "scroll":
            g = FD;
            break;
          case "wheel":
            g = nF;
            break;
          case "copy":
          case "cut":
          case "paste":
            g = HD;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            g = fw;
        }
        var A = (e & 4) !== 0,
          _ = !A && n === "scroll",
          m = A ? (p !== null ? p + "Capture" : null) : p;
        A = [];
        for (var x = u, S; x !== null; ) {
          S = x;
          var w = S.stateNode;
          if (
            (S.tag === 5 &&
              w !== null &&
              ((S = w),
              m !== null && ((w = Nf(x, m)), w != null && A.push(Vf(x, w, S)))),
            _)
          )
            break;
          x = x.return;
        }
        0 < A.length &&
          ((p = new g(p, y, null, t, h)), d.push({ event: p, listeners: A }));
      }
    }
    if (!(e & 7)) {
      e: {
        if (
          ((p = n === "mouseover" || n === "pointerover"),
          (g = n === "mouseout" || n === "pointerout"),
          p &&
            t !== tx &&
            (y = t.relatedTarget || t.fromElement) &&
            (Na(y) || y[Js]))
        )
          break e;
        if (
          (g || p) &&
          ((p =
            h.window === h
              ? h
              : (p = h.ownerDocument)
                ? p.defaultView || p.parentWindow
                : window),
          g
            ? ((y = t.relatedTarget || t.toElement),
              (g = u),
              (y = y ? Na(y) : null),
              y !== null &&
                ((_ = fl(y)), y !== _ || (y.tag !== 5 && y.tag !== 6)) &&
                (y = null))
            : ((g = null), (y = u)),
          g !== y)
        ) {
          if (
            ((A = cw),
            (w = "onMouseLeave"),
            (m = "onMouseEnter"),
            (x = "mouse"),
            (n === "pointerout" || n === "pointerover") &&
              ((A = fw),
              (w = "onPointerLeave"),
              (m = "onPointerEnter"),
              (x = "pointer")),
            (_ = g == null ? p : uc(g)),
            (S = y == null ? p : uc(y)),
            (p = new A(w, x + "leave", g, t, h)),
            (p.target = _),
            (p.relatedTarget = S),
            (w = null),
            Na(h) === u &&
              ((A = new A(m, x + "enter", y, t, h)),
              (A.target = S),
              (A.relatedTarget = _),
              (w = A)),
            (_ = w),
            g && y)
          )
            t: {
              for (A = g, m = y, x = 0, S = A; S; S = Il(S)) x++;
              for (S = 0, w = m; w; w = Il(w)) S++;
              for (; 0 < x - S; ) ((A = Il(A)), x--);
              for (; 0 < S - x; ) ((m = Il(m)), S--);
              for (; x--; ) {
                if (A === m || (m !== null && A === m.alternate)) break t;
                ((A = Il(A)), (m = Il(m)));
              }
              A = null;
            }
          else A = null;
          (g !== null && Mw(d, p, g, A, !1),
            y !== null && _ !== null && Mw(d, _, y, A, !0));
        }
      }
      e: {
        if (
          ((p = u ? uc(u) : window),
          (g = p.nodeName && p.nodeName.toLowerCase()),
          g === "select" || (g === "input" && p.type === "file"))
        )
          var C = cF;
        else if (pw(p))
          if (xP) C = dF;
          else {
            C = fF;
            var P = uF;
          }
        else
          (g = p.nodeName) &&
            g.toLowerCase() === "input" &&
            (p.type === "checkbox" || p.type === "radio") &&
            (C = hF);
        if (C && (C = C(n, u))) {
          yP(d, C, t, h);
          break e;
        }
        (P && P(n, p, u),
          n === "focusout" &&
            (P = p._wrapperState) &&
            P.controlled &&
            p.type === "number" &&
            Qy(p, "number", p.value));
      }
      switch (((P = u ? uc(u) : window), n)) {
        case "focusin":
          (pw(P) || P.contentEditable === "true") &&
            ((lc = P), (lx = u), (yf = null));
          break;
        case "focusout":
          yf = lx = lc = null;
          break;
        case "mousedown":
          cx = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          ((cx = !1), xw(d, t, h));
          break;
        case "selectionchange":
          if (gF) break;
        case "keydown":
        case "keyup":
          xw(d, t, h);
      }
      var R;
      if (h1)
        e: {
          switch (n) {
            case "compositionstart":
              var B = "onCompositionStart";
              break e;
            case "compositionend":
              B = "onCompositionEnd";
              break e;
            case "compositionupdate":
              B = "onCompositionUpdate";
              break e;
          }
          B = void 0;
        }
      else
        ac
          ? gP(n, t) && (B = "onCompositionEnd")
          : n === "keydown" && t.keyCode === 229 && (B = "onCompositionStart");
      (B &&
        (mP &&
          t.locale !== "ko" &&
          (ac || B !== "onCompositionStart"
            ? B === "onCompositionEnd" && ac && (R = pP())
            : ((Po = h),
              (c1 = "value" in Po ? Po.value : Po.textContent),
              (ac = !0))),
        (P = Rm(u, B)),
        0 < P.length &&
          ((B = new uw(B, n, null, t, h)),
          d.push({ event: B, listeners: P }),
          R ? (B.data = R) : ((R = vP(t)), R !== null && (B.data = R)))),
        (R = rF ? sF(n, t) : oF(n, t)) &&
          ((u = Rm(u, "onBeforeInput")),
          0 < u.length &&
            ((h = new uw("onBeforeInput", "beforeinput", null, t, h)),
            d.push({ event: h, listeners: u }),
            (h.data = R))));
    }
    PP(d, e);
  });
}
function Vf(n, e, t) {
  return { instance: n, listener: e, currentTarget: t };
}
function Rm(n, e) {
  for (var t = e + "Capture", i = []; n !== null; ) {
    var r = n,
      s = r.stateNode;
    (r.tag === 5 &&
      s !== null &&
      ((r = s),
      (s = Nf(n, t)),
      s != null && i.unshift(Vf(n, s, r)),
      (s = Nf(n, e)),
      s != null && i.push(Vf(n, s, r))),
      (n = n.return));
  }
  return i;
}
function Il(n) {
  if (n === null) return null;
  do n = n.return;
  while (n && n.tag !== 5);
  return n || null;
}
function Mw(n, e, t, i, r) {
  for (var s = e._reactName, o = []; t !== null && t !== i; ) {
    var a = t,
      l = a.alternate,
      u = a.stateNode;
    if (l !== null && l === i) break;
    (a.tag === 5 &&
      u !== null &&
      ((a = u),
      r
        ? ((l = Nf(t, s)), l != null && o.unshift(Vf(t, l, a)))
        : r || ((l = Nf(t, s)), l != null && o.push(Vf(t, l, a)))),
      (t = t.return));
  }
  o.length !== 0 && n.push({ event: e, listeners: o });
}
var _F = /\r\n?/g,
  AF = /\u0000|\uFFFD/g;
function Sw(n) {
  return (typeof n == "string" ? n : "" + n)
    .replace(
      _F,
      `
`
    )
    .replace(AF, "");
}
function ep(n, e, t) {
  if (((e = Sw(e)), Sw(n) !== e && t)) throw Error(be(425));
}
function Lm() {}
var ux = null,
  fx = null;
function hx(n, e) {
  return (
    n === "textarea" ||
    n === "noscript" ||
    typeof e.children == "string" ||
    typeof e.children == "number" ||
    (typeof e.dangerouslySetInnerHTML == "object" &&
      e.dangerouslySetInnerHTML !== null &&
      e.dangerouslySetInnerHTML.__html != null)
  );
}
var dx = typeof setTimeout == "function" ? setTimeout : void 0,
  MF = typeof clearTimeout == "function" ? clearTimeout : void 0,
  ww = typeof Promise == "function" ? Promise : void 0,
  SF =
    typeof queueMicrotask == "function"
      ? queueMicrotask
      : typeof ww < "u"
        ? function (n) {
            return ww.resolve(null).then(n).catch(wF);
          }
        : dx;
function wF(n) {
  setTimeout(function () {
    throw n;
  });
}
function Cv(n, e) {
  var t = e,
    i = 0;
  do {
    var r = t.nextSibling;
    if ((n.removeChild(t), r && r.nodeType === 8))
      if (((t = r.data), t === "/$")) {
        if (i === 0) {
          (n.removeChild(r), Uf(e));
          return;
        }
        i--;
      } else (t !== "$" && t !== "$?" && t !== "$!") || i++;
    t = r;
  } while (t);
  Uf(e);
}
function No(n) {
  for (; n != null; n = n.nextSibling) {
    var e = n.nodeType;
    if (e === 1 || e === 3) break;
    if (e === 8) {
      if (((e = n.data), e === "$" || e === "$!" || e === "$?")) break;
      if (e === "/$") return null;
    }
  }
  return n;
}
function Ew(n) {
  n = n.previousSibling;
  for (var e = 0; n; ) {
    if (n.nodeType === 8) {
      var t = n.data;
      if (t === "$" || t === "$!" || t === "$?") {
        if (e === 0) return n;
        e--;
      } else t === "/$" && e++;
    }
    n = n.previousSibling;
  }
  return null;
}
var nu = Math.random().toString(36).slice(2),
  ss = "__reactFiber$" + nu,
  Wf = "__reactProps$" + nu,
  Js = "__reactContainer$" + nu,
  px = "__reactEvents$" + nu,
  EF = "__reactListeners$" + nu,
  CF = "__reactHandles$" + nu;
function Na(n) {
  var e = n[ss];
  if (e) return e;
  for (var t = n.parentNode; t; ) {
    if ((e = t[Js] || t[ss])) {
      if (
        ((t = e.alternate),
        e.child !== null || (t !== null && t.child !== null))
      )
        for (n = Ew(n); n !== null; ) {
          if ((t = n[ss])) return t;
          n = Ew(n);
        }
      return e;
    }
    ((n = t), (t = n.parentNode));
  }
  return null;
}
function _h(n) {
  return (
    (n = n[ss] || n[Js]),
    !n || (n.tag !== 5 && n.tag !== 6 && n.tag !== 13 && n.tag !== 3) ? null : n
  );
}
function uc(n) {
  if (n.tag === 5 || n.tag === 6) return n.stateNode;
  throw Error(be(33));
}
function yg(n) {
  return n[Wf] || null;
}
var mx = [],
  fc = -1;
function ea(n) {
  return { current: n };
}
function Yt(n) {
  0 > fc || ((n.current = mx[fc]), (mx[fc] = null), fc--);
}
function Jt(n, e) {
  (fc++, (mx[fc] = n.current), (n.current = e));
}
var Jo = {},
  oi = ea(Jo),
  Ri = ea(!1),
  el = Jo;
function Nc(n, e) {
  var t = n.type.contextTypes;
  if (!t) return Jo;
  var i = n.stateNode;
  if (i && i.__reactInternalMemoizedUnmaskedChildContext === e)
    return i.__reactInternalMemoizedMaskedChildContext;
  var r = {},
    s;
  for (s in t) r[s] = e[s];
  return (
    i &&
      ((n = n.stateNode),
      (n.__reactInternalMemoizedUnmaskedChildContext = e),
      (n.__reactInternalMemoizedMaskedChildContext = r)),
    r
  );
}
function Li(n) {
  return ((n = n.childContextTypes), n != null);
}
function Im() {
  (Yt(Ri), Yt(oi));
}
function Cw(n, e, t) {
  if (oi.current !== Jo) throw Error(be(168));
  (Jt(oi, e), Jt(Ri, t));
}
function RP(n, e, t) {
  var i = n.stateNode;
  if (((e = e.childContextTypes), typeof i.getChildContext != "function"))
    return t;
  i = i.getChildContext();
  for (var r in i) if (!(r in e)) throw Error(be(108, uD(n) || "Unknown", r));
  return cn({}, t, i);
}
function Dm(n) {
  return (
    (n =
      ((n = n.stateNode) && n.__reactInternalMemoizedMergedChildContext) || Jo),
    (el = oi.current),
    Jt(oi, n),
    Jt(Ri, Ri.current),
    !0
  );
}
function Tw(n, e, t) {
  var i = n.stateNode;
  if (!i) throw Error(be(169));
  (t
    ? ((n = RP(n, e, el)),
      (i.__reactInternalMemoizedMergedChildContext = n),
      Yt(Ri),
      Yt(oi),
      Jt(oi, n))
    : Yt(Ri),
    Jt(Ri, t));
}
var Rs = null,
  xg = !1,
  Tv = !1;
function LP(n) {
  Rs === null ? (Rs = [n]) : Rs.push(n);
}
function TF(n) {
  ((xg = !0), LP(n));
}
function ta() {
  if (!Tv && Rs !== null) {
    Tv = !0;
    var n = 0,
      e = Ot;
    try {
      var t = Rs;
      for (Ot = 1; n < t.length; n++) {
        var i = t[n];
        do i = i(!0);
        while (i !== null);
      }
      ((Rs = null), (xg = !1));
    } catch (r) {
      throw (Rs !== null && (Rs = Rs.slice(n + 1)), iP(s1, ta), r);
    } finally {
      ((Ot = e), (Tv = !1));
    }
  }
  return null;
}
var hc = [],
  dc = 0,
  Fm = null,
  Nm = 0,
  dr = [],
  pr = 0,
  tl = null,
  Ns = 1,
  ks = "";
function Ca(n, e) {
  ((hc[dc++] = Nm), (hc[dc++] = Fm), (Fm = n), (Nm = e));
}
function IP(n, e, t) {
  ((dr[pr++] = Ns), (dr[pr++] = ks), (dr[pr++] = tl), (tl = n));
  var i = Ns;
  n = ks;
  var r = 32 - kr(i) - 1;
  ((i &= ~(1 << r)), (t += 1));
  var s = 32 - kr(e) + r;
  if (30 < s) {
    var o = r - (r % 5);
    ((s = (i & ((1 << o) - 1)).toString(32)),
      (i >>= o),
      (r -= o),
      (Ns = (1 << (32 - kr(e) + r)) | (t << r) | i),
      (ks = s + n));
  } else ((Ns = (1 << s) | (t << r) | i), (ks = n));
}
function p1(n) {
  n.return !== null && (Ca(n, 1), IP(n, 1, 0));
}
function m1(n) {
  for (; n === Fm; )
    ((Fm = hc[--dc]), (hc[dc] = null), (Nm = hc[--dc]), (hc[dc] = null));
  for (; n === tl; )
    ((tl = dr[--pr]),
      (dr[pr] = null),
      (ks = dr[--pr]),
      (dr[pr] = null),
      (Ns = dr[--pr]),
      (dr[pr] = null));
}
var Xi = null,
  Wi = null,
  $t = !1,
  Fr = null;
function DP(n, e) {
  var t = gr(5, null, null, 0);
  ((t.elementType = "DELETED"),
    (t.stateNode = e),
    (t.return = n),
    (e = n.deletions),
    e === null ? ((n.deletions = [t]), (n.flags |= 16)) : e.push(t));
}
function bw(n, e) {
  switch (n.tag) {
    case 5:
      var t = n.type;
      return (
        (e =
          e.nodeType !== 1 || t.toLowerCase() !== e.nodeName.toLowerCase()
            ? null
            : e),
        e !== null
          ? ((n.stateNode = e), (Xi = n), (Wi = No(e.firstChild)), !0)
          : !1
      );
    case 6:
      return (
        (e = n.pendingProps === "" || e.nodeType !== 3 ? null : e),
        e !== null ? ((n.stateNode = e), (Xi = n), (Wi = null), !0) : !1
      );
    case 13:
      return (
        (e = e.nodeType !== 8 ? null : e),
        e !== null
          ? ((t = tl !== null ? { id: Ns, overflow: ks } : null),
            (n.memoizedState = {
              dehydrated: e,
              treeContext: t,
              retryLane: 1073741824,
            }),
            (t = gr(18, null, null, 0)),
            (t.stateNode = e),
            (t.return = n),
            (n.child = t),
            (Xi = n),
            (Wi = null),
            !0)
          : !1
      );
    default:
      return !1;
  }
}
function gx(n) {
  return (n.mode & 1) !== 0 && (n.flags & 128) === 0;
}
function vx(n) {
  if ($t) {
    var e = Wi;
    if (e) {
      var t = e;
      if (!bw(n, e)) {
        if (gx(n)) throw Error(be(418));
        e = No(t.nextSibling);
        var i = Xi;
        e && bw(n, e)
          ? DP(i, t)
          : ((n.flags = (n.flags & -4097) | 2), ($t = !1), (Xi = n));
      }
    } else {
      if (gx(n)) throw Error(be(418));
      ((n.flags = (n.flags & -4097) | 2), ($t = !1), (Xi = n));
    }
  }
}
function Pw(n) {
  for (n = n.return; n !== null && n.tag !== 5 && n.tag !== 3 && n.tag !== 13; )
    n = n.return;
  Xi = n;
}
function tp(n) {
  if (n !== Xi) return !1;
  if (!$t) return (Pw(n), ($t = !0), !1);
  var e;
  if (
    ((e = n.tag !== 3) &&
      !(e = n.tag !== 5) &&
      ((e = n.type),
      (e = e !== "head" && e !== "body" && !hx(n.type, n.memoizedProps))),
    e && (e = Wi))
  ) {
    if (gx(n)) throw (FP(), Error(be(418)));
    for (; e; ) (DP(n, e), (e = No(e.nextSibling)));
  }
  if ((Pw(n), n.tag === 13)) {
    if (((n = n.memoizedState), (n = n !== null ? n.dehydrated : null), !n))
      throw Error(be(317));
    e: {
      for (n = n.nextSibling, e = 0; n; ) {
        if (n.nodeType === 8) {
          var t = n.data;
          if (t === "/$") {
            if (e === 0) {
              Wi = No(n.nextSibling);
              break e;
            }
            e--;
          } else (t !== "$" && t !== "$!" && t !== "$?") || e++;
        }
        n = n.nextSibling;
      }
      Wi = null;
    }
  } else Wi = Xi ? No(n.stateNode.nextSibling) : null;
  return !0;
}
function FP() {
  for (var n = Wi; n; ) n = No(n.nextSibling);
}
function kc() {
  ((Wi = Xi = null), ($t = !1));
}
function g1(n) {
  Fr === null ? (Fr = [n]) : Fr.push(n);
}
var bF = $s.ReactCurrentBatchConfig;
function Lr(n, e) {
  if (n && n.defaultProps) {
    ((e = cn({}, e)), (n = n.defaultProps));
    for (var t in n) e[t] === void 0 && (e[t] = n[t]);
    return e;
  }
  return e;
}
var km = ea(null),
  Om = null,
  pc = null,
  v1 = null;
function y1() {
  v1 = pc = Om = null;
}
function x1(n) {
  var e = km.current;
  (Yt(km), (n._currentValue = e));
}
function yx(n, e, t) {
  for (; n !== null; ) {
    var i = n.alternate;
    if (
      ((n.childLanes & e) !== e
        ? ((n.childLanes |= e), i !== null && (i.childLanes |= e))
        : i !== null && (i.childLanes & e) !== e && (i.childLanes |= e),
      n === t)
    )
      break;
    n = n.return;
  }
}
function bc(n, e) {
  ((Om = n),
    (v1 = pc = null),
    (n = n.dependencies),
    n !== null &&
      n.firstContext !== null &&
      (n.lanes & e && (Bi = !0), (n.firstContext = null)));
}
function yr(n) {
  var e = n._currentValue;
  if (v1 !== n)
    if (((n = { context: n, memoizedValue: e, next: null }), pc === null)) {
      if (Om === null) throw Error(be(308));
      ((pc = n), (Om.dependencies = { lanes: 0, firstContext: n }));
    } else pc = pc.next = n;
  return e;
}
var ka = null;
function _1(n) {
  ka === null ? (ka = [n]) : ka.push(n);
}
function NP(n, e, t, i) {
  var r = e.interleaved;
  return (
    r === null ? ((t.next = t), _1(e)) : ((t.next = r.next), (r.next = t)),
    (e.interleaved = t),
    Xs(n, i)
  );
}
function Xs(n, e) {
  n.lanes |= e;
  var t = n.alternate;
  for (t !== null && (t.lanes |= e), t = n, n = n.return; n !== null; )
    ((n.childLanes |= e),
      (t = n.alternate),
      t !== null && (t.childLanes |= e),
      (t = n),
      (n = n.return));
  return t.tag === 3 ? t.stateNode : null;
}
var wo = !1;
function A1(n) {
  n.updateQueue = {
    baseState: n.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, interleaved: null, lanes: 0 },
    effects: null,
  };
}
function kP(n, e) {
  ((n = n.updateQueue),
    e.updateQueue === n &&
      (e.updateQueue = {
        baseState: n.baseState,
        firstBaseUpdate: n.firstBaseUpdate,
        lastBaseUpdate: n.lastBaseUpdate,
        shared: n.shared,
        effects: n.effects,
      }));
}
function Gs(n, e) {
  return {
    eventTime: n,
    lane: e,
    tag: 0,
    payload: null,
    callback: null,
    next: null,
  };
}
function ko(n, e, t) {
  var i = n.updateQueue;
  if (i === null) return null;
  if (((i = i.shared), Bt & 2)) {
    var r = i.pending;
    return (
      r === null ? (e.next = e) : ((e.next = r.next), (r.next = e)),
      (i.pending = e),
      Xs(n, t)
    );
  }
  return (
    (r = i.interleaved),
    r === null ? ((e.next = e), _1(i)) : ((e.next = r.next), (r.next = e)),
    (i.interleaved = e),
    Xs(n, t)
  );
}
function lm(n, e, t) {
  if (
    ((e = e.updateQueue), e !== null && ((e = e.shared), (t & 4194240) !== 0))
  ) {
    var i = e.lanes;
    ((i &= n.pendingLanes), (t |= i), (e.lanes = t), o1(n, t));
  }
}
function Bw(n, e) {
  var t = n.updateQueue,
    i = n.alternate;
  if (i !== null && ((i = i.updateQueue), t === i)) {
    var r = null,
      s = null;
    if (((t = t.firstBaseUpdate), t !== null)) {
      do {
        var o = {
          eventTime: t.eventTime,
          lane: t.lane,
          tag: t.tag,
          payload: t.payload,
          callback: t.callback,
          next: null,
        };
        (s === null ? (r = s = o) : (s = s.next = o), (t = t.next));
      } while (t !== null);
      s === null ? (r = s = e) : (s = s.next = e);
    } else r = s = e;
    ((t = {
      baseState: i.baseState,
      firstBaseUpdate: r,
      lastBaseUpdate: s,
      shared: i.shared,
      effects: i.effects,
    }),
      (n.updateQueue = t));
    return;
  }
  ((n = t.lastBaseUpdate),
    n === null ? (t.firstBaseUpdate = e) : (n.next = e),
    (t.lastBaseUpdate = e));
}
function Um(n, e, t, i) {
  var r = n.updateQueue;
  wo = !1;
  var s = r.firstBaseUpdate,
    o = r.lastBaseUpdate,
    a = r.shared.pending;
  if (a !== null) {
    r.shared.pending = null;
    var l = a,
      u = l.next;
    ((l.next = null), o === null ? (s = u) : (o.next = u), (o = l));
    var h = n.alternate;
    h !== null &&
      ((h = h.updateQueue),
      (a = h.lastBaseUpdate),
      a !== o &&
        (a === null ? (h.firstBaseUpdate = u) : (a.next = u),
        (h.lastBaseUpdate = l)));
  }
  if (s !== null) {
    var d = r.baseState;
    ((o = 0), (h = u = l = null), (a = s));
    do {
      var p = a.lane,
        g = a.eventTime;
      if ((i & p) === p) {
        h !== null &&
          (h = h.next =
            {
              eventTime: g,
              lane: 0,
              tag: a.tag,
              payload: a.payload,
              callback: a.callback,
              next: null,
            });
        e: {
          var y = n,
            A = a;
          switch (((p = e), (g = t), A.tag)) {
            case 1:
              if (((y = A.payload), typeof y == "function")) {
                d = y.call(g, d, p);
                break e;
              }
              d = y;
              break e;
            case 3:
              y.flags = (y.flags & -65537) | 128;
            case 0:
              if (
                ((y = A.payload),
                (p = typeof y == "function" ? y.call(g, d, p) : y),
                p == null)
              )
                break e;
              d = cn({}, d, p);
              break e;
            case 2:
              wo = !0;
          }
        }
        a.callback !== null &&
          a.lane !== 0 &&
          ((n.flags |= 64),
          (p = r.effects),
          p === null ? (r.effects = [a]) : p.push(a));
      } else
        ((g = {
          eventTime: g,
          lane: p,
          tag: a.tag,
          payload: a.payload,
          callback: a.callback,
          next: null,
        }),
          h === null ? ((u = h = g), (l = d)) : (h = h.next = g),
          (o |= p));
      if (((a = a.next), a === null)) {
        if (((a = r.shared.pending), a === null)) break;
        ((p = a),
          (a = p.next),
          (p.next = null),
          (r.lastBaseUpdate = p),
          (r.shared.pending = null));
      }
    } while (1);
    if (
      (h === null && (l = d),
      (r.baseState = l),
      (r.firstBaseUpdate = u),
      (r.lastBaseUpdate = h),
      (e = r.shared.interleaved),
      e !== null)
    ) {
      r = e;
      do ((o |= r.lane), (r = r.next));
      while (r !== e);
    } else s === null && (r.shared.lanes = 0);
    ((il |= o), (n.lanes = o), (n.memoizedState = d));
  }
}
function Rw(n, e, t) {
  if (((n = e.effects), (e.effects = null), n !== null))
    for (e = 0; e < n.length; e++) {
      var i = n[e],
        r = i.callback;
      if (r !== null) {
        if (((i.callback = null), (i = t), typeof r != "function"))
          throw Error(be(191, r));
        r.call(i);
      }
    }
}
var OP = new Nb.Component().refs;
function xx(n, e, t, i) {
  ((e = n.memoizedState),
    (t = t(i, e)),
    (t = t == null ? e : cn({}, e, t)),
    (n.memoizedState = t),
    n.lanes === 0 && (n.updateQueue.baseState = t));
}
var _g = {
  isMounted: function (n) {
    return (n = n._reactInternals) ? fl(n) === n : !1;
  },
  enqueueSetState: function (n, e, t) {
    n = n._reactInternals;
    var i = gi(),
      r = Uo(n),
      s = Gs(i, r);
    ((s.payload = e),
      t != null && (s.callback = t),
      (e = ko(n, s, r)),
      e !== null && (Or(e, n, r, i), lm(e, n, r)));
  },
  enqueueReplaceState: function (n, e, t) {
    n = n._reactInternals;
    var i = gi(),
      r = Uo(n),
      s = Gs(i, r);
    ((s.tag = 1),
      (s.payload = e),
      t != null && (s.callback = t),
      (e = ko(n, s, r)),
      e !== null && (Or(e, n, r, i), lm(e, n, r)));
  },
  enqueueForceUpdate: function (n, e) {
    n = n._reactInternals;
    var t = gi(),
      i = Uo(n),
      r = Gs(t, i);
    ((r.tag = 2),
      e != null && (r.callback = e),
      (e = ko(n, r, i)),
      e !== null && (Or(e, n, i, t), lm(e, n, i)));
  },
};
function Lw(n, e, t, i, r, s, o) {
  return (
    (n = n.stateNode),
    typeof n.shouldComponentUpdate == "function"
      ? n.shouldComponentUpdate(i, s, o)
      : e.prototype && e.prototype.isPureReactComponent
        ? !Gf(t, i) || !Gf(r, s)
        : !0
  );
}
function UP(n, e, t) {
  var i = !1,
    r = Jo,
    s = e.contextType;
  return (
    typeof s == "object" && s !== null
      ? (s = yr(s))
      : ((r = Li(e) ? el : oi.current),
        (i = e.contextTypes),
        (s = (i = i != null) ? Nc(n, r) : Jo)),
    (e = new e(t, s)),
    (n.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null),
    (e.updater = _g),
    (n.stateNode = e),
    (e._reactInternals = n),
    i &&
      ((n = n.stateNode),
      (n.__reactInternalMemoizedUnmaskedChildContext = r),
      (n.__reactInternalMemoizedMaskedChildContext = s)),
    e
  );
}
function Iw(n, e, t, i) {
  ((n = e.state),
    typeof e.componentWillReceiveProps == "function" &&
      e.componentWillReceiveProps(t, i),
    typeof e.UNSAFE_componentWillReceiveProps == "function" &&
      e.UNSAFE_componentWillReceiveProps(t, i),
    e.state !== n && _g.enqueueReplaceState(e, e.state, null));
}
function _x(n, e, t, i) {
  var r = n.stateNode;
  ((r.props = t), (r.state = n.memoizedState), (r.refs = OP), A1(n));
  var s = e.contextType;
  (typeof s == "object" && s !== null
    ? (r.context = yr(s))
    : ((s = Li(e) ? el : oi.current), (r.context = Nc(n, s))),
    (r.state = n.memoizedState),
    (s = e.getDerivedStateFromProps),
    typeof s == "function" && (xx(n, e, s, t), (r.state = n.memoizedState)),
    typeof e.getDerivedStateFromProps == "function" ||
      typeof r.getSnapshotBeforeUpdate == "function" ||
      (typeof r.UNSAFE_componentWillMount != "function" &&
        typeof r.componentWillMount != "function") ||
      ((e = r.state),
      typeof r.componentWillMount == "function" && r.componentWillMount(),
      typeof r.UNSAFE_componentWillMount == "function" &&
        r.UNSAFE_componentWillMount(),
      e !== r.state && _g.enqueueReplaceState(r, r.state, null),
      Um(n, t, r, i),
      (r.state = n.memoizedState)),
    typeof r.componentDidMount == "function" && (n.flags |= 4194308));
}
function Uu(n, e, t) {
  if (
    ((n = t.ref), n !== null && typeof n != "function" && typeof n != "object")
  ) {
    if (t._owner) {
      if (((t = t._owner), t)) {
        if (t.tag !== 1) throw Error(be(309));
        var i = t.stateNode;
      }
      if (!i) throw Error(be(147, n));
      var r = i,
        s = "" + n;
      return e !== null &&
        e.ref !== null &&
        typeof e.ref == "function" &&
        e.ref._stringRef === s
        ? e.ref
        : ((e = function (o) {
            var a = r.refs;
            (a === OP && (a = r.refs = {}),
              o === null ? delete a[s] : (a[s] = o));
          }),
          (e._stringRef = s),
          e);
    }
    if (typeof n != "string") throw Error(be(284));
    if (!t._owner) throw Error(be(290, n));
  }
  return n;
}
function np(n, e) {
  throw (
    (n = Object.prototype.toString.call(e)),
    Error(
      be(
        31,
        n === "[object Object]"
          ? "object with keys {" + Object.keys(e).join(", ") + "}"
          : n
      )
    )
  );
}
function Dw(n) {
  var e = n._init;
  return e(n._payload);
}
function zP(n) {
  function e(m, x) {
    if (n) {
      var S = m.deletions;
      S === null ? ((m.deletions = [x]), (m.flags |= 16)) : S.push(x);
    }
  }
  function t(m, x) {
    if (!n) return null;
    for (; x !== null; ) (e(m, x), (x = x.sibling));
    return null;
  }
  function i(m, x) {
    for (m = new Map(); x !== null; )
      (x.key !== null ? m.set(x.key, x) : m.set(x.index, x), (x = x.sibling));
    return m;
  }
  function r(m, x) {
    return ((m = zo(m, x)), (m.index = 0), (m.sibling = null), m);
  }
  function s(m, x, S) {
    return (
      (m.index = S),
      n
        ? ((S = m.alternate),
          S !== null
            ? ((S = S.index), S < x ? ((m.flags |= 2), x) : S)
            : ((m.flags |= 2), x))
        : ((m.flags |= 1048576), x)
    );
  }
  function o(m) {
    return (n && m.alternate === null && (m.flags |= 2), m);
  }
  function a(m, x, S, w) {
    return x === null || x.tag !== 6
      ? ((x = Dv(S, m.mode, w)), (x.return = m), x)
      : ((x = r(x, S)), (x.return = m), x);
  }
  function l(m, x, S, w) {
    var C = S.type;
    return C === oc
      ? h(m, x, S.props.children, w, S.key)
      : x !== null &&
          (x.elementType === C ||
            (typeof C == "object" &&
              C !== null &&
              C.$$typeof === So &&
              Dw(C) === x.type))
        ? ((w = r(x, S.props)), (w.ref = Uu(m, x, S)), (w.return = m), w)
        : ((w = pm(S.type, S.key, S.props, null, m.mode, w)),
          (w.ref = Uu(m, x, S)),
          (w.return = m),
          w);
  }
  function u(m, x, S, w) {
    return x === null ||
      x.tag !== 4 ||
      x.stateNode.containerInfo !== S.containerInfo ||
      x.stateNode.implementation !== S.implementation
      ? ((x = Fv(S, m.mode, w)), (x.return = m), x)
      : ((x = r(x, S.children || [])), (x.return = m), x);
  }
  function h(m, x, S, w, C) {
    return x === null || x.tag !== 7
      ? ((x = Xa(S, m.mode, w, C)), (x.return = m), x)
      : ((x = r(x, S)), (x.return = m), x);
  }
  function d(m, x, S) {
    if ((typeof x == "string" && x !== "") || typeof x == "number")
      return ((x = Dv("" + x, m.mode, S)), (x.return = m), x);
    if (typeof x == "object" && x !== null) {
      switch (x.$$typeof) {
        case jd:
          return (
            (S = pm(x.type, x.key, x.props, null, m.mode, S)),
            (S.ref = Uu(m, null, x)),
            (S.return = m),
            S
          );
        case sc:
          return ((x = Fv(x, m.mode, S)), (x.return = m), x);
        case So:
          var w = x._init;
          return d(m, w(x._payload), S);
      }
      if (lf(x) || Du(x))
        return ((x = Xa(x, m.mode, S, null)), (x.return = m), x);
      np(m, x);
    }
    return null;
  }
  function p(m, x, S, w) {
    var C = x !== null ? x.key : null;
    if ((typeof S == "string" && S !== "") || typeof S == "number")
      return C !== null ? null : a(m, x, "" + S, w);
    if (typeof S == "object" && S !== null) {
      switch (S.$$typeof) {
        case jd:
          return S.key === C ? l(m, x, S, w) : null;
        case sc:
          return S.key === C ? u(m, x, S, w) : null;
        case So:
          return ((C = S._init), p(m, x, C(S._payload), w));
      }
      if (lf(S) || Du(S)) return C !== null ? null : h(m, x, S, w, null);
      np(m, S);
    }
    return null;
  }
  function g(m, x, S, w, C) {
    if ((typeof w == "string" && w !== "") || typeof w == "number")
      return ((m = m.get(S) || null), a(x, m, "" + w, C));
    if (typeof w == "object" && w !== null) {
      switch (w.$$typeof) {
        case jd:
          return (
            (m = m.get(w.key === null ? S : w.key) || null),
            l(x, m, w, C)
          );
        case sc:
          return (
            (m = m.get(w.key === null ? S : w.key) || null),
            u(x, m, w, C)
          );
        case So:
          var P = w._init;
          return g(m, x, S, P(w._payload), C);
      }
      if (lf(w) || Du(w)) return ((m = m.get(S) || null), h(x, m, w, C, null));
      np(x, w);
    }
    return null;
  }
  function y(m, x, S, w) {
    for (
      var C = null, P = null, R = x, B = (x = 0), b = null;
      R !== null && B < S.length;
      B++
    ) {
      R.index > B ? ((b = R), (R = null)) : (b = R.sibling);
      var L = p(m, R, S[B], w);
      if (L === null) {
        R === null && (R = b);
        break;
      }
      (n && R && L.alternate === null && e(m, R),
        (x = s(L, x, B)),
        P === null ? (C = L) : (P.sibling = L),
        (P = L),
        (R = b));
    }
    if (B === S.length) return (t(m, R), $t && Ca(m, B), C);
    if (R === null) {
      for (; B < S.length; B++)
        ((R = d(m, S[B], w)),
          R !== null &&
            ((x = s(R, x, B)),
            P === null ? (C = R) : (P.sibling = R),
            (P = R)));
      return ($t && Ca(m, B), C);
    }
    for (R = i(m, R); B < S.length; B++)
      ((b = g(R, m, B, S[B], w)),
        b !== null &&
          (n && b.alternate !== null && R.delete(b.key === null ? B : b.key),
          (x = s(b, x, B)),
          P === null ? (C = b) : (P.sibling = b),
          (P = b)));
    return (
      n &&
        R.forEach(function (U) {
          return e(m, U);
        }),
      $t && Ca(m, B),
      C
    );
  }
  function A(m, x, S, w) {
    var C = Du(S);
    if (typeof C != "function") throw Error(be(150));
    if (((S = C.call(S)), S == null)) throw Error(be(151));
    for (
      var P = (C = null), R = x, B = (x = 0), b = null, L = S.next();
      R !== null && !L.done;
      B++, L = S.next()
    ) {
      R.index > B ? ((b = R), (R = null)) : (b = R.sibling);
      var U = p(m, R, L.value, w);
      if (U === null) {
        R === null && (R = b);
        break;
      }
      (n && R && U.alternate === null && e(m, R),
        (x = s(U, x, B)),
        P === null ? (C = U) : (P.sibling = U),
        (P = U),
        (R = b));
    }
    if (L.done) return (t(m, R), $t && Ca(m, B), C);
    if (R === null) {
      for (; !L.done; B++, L = S.next())
        ((L = d(m, L.value, w)),
          L !== null &&
            ((x = s(L, x, B)),
            P === null ? (C = L) : (P.sibling = L),
            (P = L)));
      return ($t && Ca(m, B), C);
    }
    for (R = i(m, R); !L.done; B++, L = S.next())
      ((L = g(R, m, B, L.value, w)),
        L !== null &&
          (n && L.alternate !== null && R.delete(L.key === null ? B : L.key),
          (x = s(L, x, B)),
          P === null ? (C = L) : (P.sibling = L),
          (P = L)));
    return (
      n &&
        R.forEach(function (J) {
          return e(m, J);
        }),
      $t && Ca(m, B),
      C
    );
  }
  function _(m, x, S, w) {
    if (
      (typeof S == "object" &&
        S !== null &&
        S.type === oc &&
        S.key === null &&
        (S = S.props.children),
      typeof S == "object" && S !== null)
    ) {
      switch (S.$$typeof) {
        case jd:
          e: {
            for (var C = S.key, P = x; P !== null; ) {
              if (P.key === C) {
                if (((C = S.type), C === oc)) {
                  if (P.tag === 7) {
                    (t(m, P.sibling),
                      (x = r(P, S.props.children)),
                      (x.return = m),
                      (m = x));
                    break e;
                  }
                } else if (
                  P.elementType === C ||
                  (typeof C == "object" &&
                    C !== null &&
                    C.$$typeof === So &&
                    Dw(C) === P.type)
                ) {
                  (t(m, P.sibling),
                    (x = r(P, S.props)),
                    (x.ref = Uu(m, P, S)),
                    (x.return = m),
                    (m = x));
                  break e;
                }
                t(m, P);
                break;
              } else e(m, P);
              P = P.sibling;
            }
            S.type === oc
              ? ((x = Xa(S.props.children, m.mode, w, S.key)),
                (x.return = m),
                (m = x))
              : ((w = pm(S.type, S.key, S.props, null, m.mode, w)),
                (w.ref = Uu(m, x, S)),
                (w.return = m),
                (m = w));
          }
          return o(m);
        case sc:
          e: {
            for (P = S.key; x !== null; ) {
              if (x.key === P)
                if (
                  x.tag === 4 &&
                  x.stateNode.containerInfo === S.containerInfo &&
                  x.stateNode.implementation === S.implementation
                ) {
                  (t(m, x.sibling),
                    (x = r(x, S.children || [])),
                    (x.return = m),
                    (m = x));
                  break e;
                } else {
                  t(m, x);
                  break;
                }
              else e(m, x);
              x = x.sibling;
            }
            ((x = Fv(S, m.mode, w)), (x.return = m), (m = x));
          }
          return o(m);
        case So:
          return ((P = S._init), _(m, x, P(S._payload), w));
      }
      if (lf(S)) return y(m, x, S, w);
      if (Du(S)) return A(m, x, S, w);
      np(m, S);
    }
    return (typeof S == "string" && S !== "") || typeof S == "number"
      ? ((S = "" + S),
        x !== null && x.tag === 6
          ? (t(m, x.sibling), (x = r(x, S)), (x.return = m), (m = x))
          : (t(m, x), (x = Dv(S, m.mode, w)), (x.return = m), (m = x)),
        o(m))
      : t(m, x);
  }
  return _;
}
var Oc = zP(!0),
  GP = zP(!1),
  Ah = {},
  as = ea(Ah),
  jf = ea(Ah),
  Jf = ea(Ah);
function Oa(n) {
  if (n === Ah) throw Error(be(174));
  return n;
}
function M1(n, e) {
  switch ((Jt(Jf, e), Jt(jf, n), Jt(as, Ah), (n = e.nodeType), n)) {
    case 9:
    case 11:
      e = (e = e.documentElement) ? e.namespaceURI : qy(null, "");
      break;
    default:
      ((n = n === 8 ? e.parentNode : e),
        (e = n.namespaceURI || null),
        (n = n.tagName),
        (e = qy(e, n)));
  }
  (Yt(as), Jt(as, e));
}
function Uc() {
  (Yt(as), Yt(jf), Yt(Jf));
}
function HP(n) {
  Oa(Jf.current);
  var e = Oa(as.current),
    t = qy(e, n.type);
  e !== t && (Jt(jf, n), Jt(as, t));
}
function S1(n) {
  jf.current === n && (Yt(as), Yt(jf));
}
var nn = ea(0);
function zm(n) {
  for (var e = n; e !== null; ) {
    if (e.tag === 13) {
      var t = e.memoizedState;
      if (
        t !== null &&
        ((t = t.dehydrated), t === null || t.data === "$?" || t.data === "$!")
      )
        return e;
    } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
      if (e.flags & 128) return e;
    } else if (e.child !== null) {
      ((e.child.return = e), (e = e.child));
      continue;
    }
    if (e === n) break;
    for (; e.sibling === null; ) {
      if (e.return === null || e.return === n) return null;
      e = e.return;
    }
    ((e.sibling.return = e.return), (e = e.sibling));
  }
  return null;
}
var bv = [];
function w1() {
  for (var n = 0; n < bv.length; n++)
    bv[n]._workInProgressVersionPrimary = null;
  bv.length = 0;
}
var cm = $s.ReactCurrentDispatcher,
  Pv = $s.ReactCurrentBatchConfig,
  nl = 0,
  ln = null,
  Tn = null,
  On = null,
  Gm = !1,
  xf = !1,
  Xf = 0,
  PF = 0;
function ti() {
  throw Error(be(321));
}
function E1(n, e) {
  if (e === null) return !1;
  for (var t = 0; t < e.length && t < n.length; t++)
    if (!Gr(n[t], e[t])) return !1;
  return !0;
}
function C1(n, e, t, i, r, s) {
  if (
    ((nl = s),
    (ln = e),
    (e.memoizedState = null),
    (e.updateQueue = null),
    (e.lanes = 0),
    (cm.current = n === null || n.memoizedState === null ? IF : DF),
    (n = t(i, r)),
    xf)
  ) {
    s = 0;
    do {
      if (((xf = !1), (Xf = 0), 25 <= s)) throw Error(be(301));
      ((s += 1),
        (On = Tn = null),
        (e.updateQueue = null),
        (cm.current = FF),
        (n = t(i, r)));
    } while (xf);
  }
  if (
    ((cm.current = Hm),
    (e = Tn !== null && Tn.next !== null),
    (nl = 0),
    (On = Tn = ln = null),
    (Gm = !1),
    e)
  )
    throw Error(be(300));
  return n;
}
function T1() {
  var n = Xf !== 0;
  return ((Xf = 0), n);
}
function is() {
  var n = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  };
  return (On === null ? (ln.memoizedState = On = n) : (On = On.next = n), On);
}
function xr() {
  if (Tn === null) {
    var n = ln.alternate;
    n = n !== null ? n.memoizedState : null;
  } else n = Tn.next;
  var e = On === null ? ln.memoizedState : On.next;
  if (e !== null) ((On = e), (Tn = n));
  else {
    if (n === null) throw Error(be(310));
    ((Tn = n),
      (n = {
        memoizedState: Tn.memoizedState,
        baseState: Tn.baseState,
        baseQueue: Tn.baseQueue,
        queue: Tn.queue,
        next: null,
      }),
      On === null ? (ln.memoizedState = On = n) : (On = On.next = n));
  }
  return On;
}
function Kf(n, e) {
  return typeof e == "function" ? e(n) : e;
}
function Bv(n) {
  var e = xr(),
    t = e.queue;
  if (t === null) throw Error(be(311));
  t.lastRenderedReducer = n;
  var i = Tn,
    r = i.baseQueue,
    s = t.pending;
  if (s !== null) {
    if (r !== null) {
      var o = r.next;
      ((r.next = s.next), (s.next = o));
    }
    ((i.baseQueue = r = s), (t.pending = null));
  }
  if (r !== null) {
    ((s = r.next), (i = i.baseState));
    var a = (o = null),
      l = null,
      u = s;
    do {
      var h = u.lane;
      if ((nl & h) === h)
        (l !== null &&
          (l = l.next =
            {
              lane: 0,
              action: u.action,
              hasEagerState: u.hasEagerState,
              eagerState: u.eagerState,
              next: null,
            }),
          (i = u.hasEagerState ? u.eagerState : n(i, u.action)));
      else {
        var d = {
          lane: h,
          action: u.action,
          hasEagerState: u.hasEagerState,
          eagerState: u.eagerState,
          next: null,
        };
        (l === null ? ((a = l = d), (o = i)) : (l = l.next = d),
          (ln.lanes |= h),
          (il |= h));
      }
      u = u.next;
    } while (u !== null && u !== s);
    (l === null ? (o = i) : (l.next = a),
      Gr(i, e.memoizedState) || (Bi = !0),
      (e.memoizedState = i),
      (e.baseState = o),
      (e.baseQueue = l),
      (t.lastRenderedState = i));
  }
  if (((n = t.interleaved), n !== null)) {
    r = n;
    do ((s = r.lane), (ln.lanes |= s), (il |= s), (r = r.next));
    while (r !== n);
  } else r === null && (t.lanes = 0);
  return [e.memoizedState, t.dispatch];
}
function Rv(n) {
  var e = xr(),
    t = e.queue;
  if (t === null) throw Error(be(311));
  t.lastRenderedReducer = n;
  var i = t.dispatch,
    r = t.pending,
    s = e.memoizedState;
  if (r !== null) {
    t.pending = null;
    var o = (r = r.next);
    do ((s = n(s, o.action)), (o = o.next));
    while (o !== r);
    (Gr(s, e.memoizedState) || (Bi = !0),
      (e.memoizedState = s),
      e.baseQueue === null && (e.baseState = s),
      (t.lastRenderedState = s));
  }
  return [s, i];
}
function VP() {}
function WP(n, e) {
  var t = ln,
    i = xr(),
    r = e(),
    s = !Gr(i.memoizedState, r);
  if (
    (s && ((i.memoizedState = r), (Bi = !0)),
    (i = i.queue),
    b1(XP.bind(null, t, i, n), [n]),
    i.getSnapshot !== e || s || (On !== null && On.memoizedState.tag & 1))
  ) {
    if (
      ((t.flags |= 2048),
      Yf(9, JP.bind(null, t, i, r, e), void 0, null),
      zn === null)
    )
      throw Error(be(349));
    nl & 30 || jP(t, e, r);
  }
  return r;
}
function jP(n, e, t) {
  ((n.flags |= 16384),
    (n = { getSnapshot: e, value: t }),
    (e = ln.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (ln.updateQueue = e),
        (e.stores = [n]))
      : ((t = e.stores), t === null ? (e.stores = [n]) : t.push(n)));
}
function JP(n, e, t, i) {
  ((e.value = t), (e.getSnapshot = i), KP(e) && YP(n));
}
function XP(n, e, t) {
  return t(function () {
    KP(e) && YP(n);
  });
}
function KP(n) {
  var e = n.getSnapshot;
  n = n.value;
  try {
    var t = e();
    return !Gr(n, t);
  } catch {
    return !0;
  }
}
function YP(n) {
  var e = Xs(n, 1);
  e !== null && Or(e, n, 1, -1);
}
function Fw(n) {
  var e = is();
  return (
    typeof n == "function" && (n = n()),
    (e.memoizedState = e.baseState = n),
    (n = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Kf,
      lastRenderedState: n,
    }),
    (e.queue = n),
    (n = n.dispatch = LF.bind(null, ln, n)),
    [e.memoizedState, n]
  );
}
function Yf(n, e, t, i) {
  return (
    (n = { tag: n, create: e, destroy: t, deps: i, next: null }),
    (e = ln.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (ln.updateQueue = e),
        (e.lastEffect = n.next = n))
      : ((t = e.lastEffect),
        t === null
          ? (e.lastEffect = n.next = n)
          : ((i = t.next), (t.next = n), (n.next = i), (e.lastEffect = n))),
    n
  );
}
function QP() {
  return xr().memoizedState;
}
function um(n, e, t, i) {
  var r = is();
  ((ln.flags |= n),
    (r.memoizedState = Yf(1 | e, t, void 0, i === void 0 ? null : i)));
}
function Ag(n, e, t, i) {
  var r = xr();
  i = i === void 0 ? null : i;
  var s = void 0;
  if (Tn !== null) {
    var o = Tn.memoizedState;
    if (((s = o.destroy), i !== null && E1(i, o.deps))) {
      r.memoizedState = Yf(e, t, s, i);
      return;
    }
  }
  ((ln.flags |= n), (r.memoizedState = Yf(1 | e, t, s, i)));
}
function Nw(n, e) {
  return um(8390656, 8, n, e);
}
function b1(n, e) {
  return Ag(2048, 8, n, e);
}
function ZP(n, e) {
  return Ag(4, 2, n, e);
}
function qP(n, e) {
  return Ag(4, 4, n, e);
}
function $P(n, e) {
  if (typeof e == "function")
    return (
      (n = n()),
      e(n),
      function () {
        e(null);
      }
    );
  if (e != null)
    return (
      (n = n()),
      (e.current = n),
      function () {
        e.current = null;
      }
    );
}
function e2(n, e, t) {
  return (
    (t = t != null ? t.concat([n]) : null),
    Ag(4, 4, $P.bind(null, e, n), t)
  );
}
function P1() {}
function t2(n, e) {
  var t = xr();
  e = e === void 0 ? null : e;
  var i = t.memoizedState;
  return i !== null && e !== null && E1(e, i[1])
    ? i[0]
    : ((t.memoizedState = [n, e]), n);
}
function n2(n, e) {
  var t = xr();
  e = e === void 0 ? null : e;
  var i = t.memoizedState;
  return i !== null && e !== null && E1(e, i[1])
    ? i[0]
    : ((n = n()), (t.memoizedState = [n, e]), n);
}
function i2(n, e, t) {
  return nl & 21
    ? (Gr(t, e) || ((t = oP()), (ln.lanes |= t), (il |= t), (n.baseState = !0)),
      e)
    : (n.baseState && ((n.baseState = !1), (Bi = !0)), (n.memoizedState = t));
}
function BF(n, e) {
  var t = Ot;
  ((Ot = t !== 0 && 4 > t ? t : 4), n(!0));
  var i = Pv.transition;
  Pv.transition = {};
  try {
    (n(!1), e());
  } finally {
    ((Ot = t), (Pv.transition = i));
  }
}
function r2() {
  return xr().memoizedState;
}
function RF(n, e, t) {
  var i = Uo(n);
  if (
    ((t = {
      lane: i,
      action: t,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
    s2(n))
  )
    o2(e, t);
  else if (((t = NP(n, e, t, i)), t !== null)) {
    var r = gi();
    (Or(t, n, i, r), a2(t, e, i));
  }
}
function LF(n, e, t) {
  var i = Uo(n),
    r = { lane: i, action: t, hasEagerState: !1, eagerState: null, next: null };
  if (s2(n)) o2(e, r);
  else {
    var s = n.alternate;
    if (
      n.lanes === 0 &&
      (s === null || s.lanes === 0) &&
      ((s = e.lastRenderedReducer), s !== null)
    )
      try {
        var o = e.lastRenderedState,
          a = s(o, t);
        if (((r.hasEagerState = !0), (r.eagerState = a), Gr(a, o))) {
          var l = e.interleaved;
          (l === null
            ? ((r.next = r), _1(e))
            : ((r.next = l.next), (l.next = r)),
            (e.interleaved = r));
          return;
        }
      } catch {
      } finally {
      }
    ((t = NP(n, e, r, i)),
      t !== null && ((r = gi()), Or(t, n, i, r), a2(t, e, i)));
  }
}
function s2(n) {
  var e = n.alternate;
  return n === ln || (e !== null && e === ln);
}
function o2(n, e) {
  xf = Gm = !0;
  var t = n.pending;
  (t === null ? (e.next = e) : ((e.next = t.next), (t.next = e)),
    (n.pending = e));
}
function a2(n, e, t) {
  if (t & 4194240) {
    var i = e.lanes;
    ((i &= n.pendingLanes), (t |= i), (e.lanes = t), o1(n, t));
  }
}
var Hm = {
    readContext: yr,
    useCallback: ti,
    useContext: ti,
    useEffect: ti,
    useImperativeHandle: ti,
    useInsertionEffect: ti,
    useLayoutEffect: ti,
    useMemo: ti,
    useReducer: ti,
    useRef: ti,
    useState: ti,
    useDebugValue: ti,
    useDeferredValue: ti,
    useTransition: ti,
    useMutableSource: ti,
    useSyncExternalStore: ti,
    useId: ti,
    unstable_isNewReconciler: !1,
  },
  IF = {
    readContext: yr,
    useCallback: function (n, e) {
      return ((is().memoizedState = [n, e === void 0 ? null : e]), n);
    },
    useContext: yr,
    useEffect: Nw,
    useImperativeHandle: function (n, e, t) {
      return (
        (t = t != null ? t.concat([n]) : null),
        um(4194308, 4, $P.bind(null, e, n), t)
      );
    },
    useLayoutEffect: function (n, e) {
      return um(4194308, 4, n, e);
    },
    useInsertionEffect: function (n, e) {
      return um(4, 2, n, e);
    },
    useMemo: function (n, e) {
      var t = is();
      return (
        (e = e === void 0 ? null : e),
        (n = n()),
        (t.memoizedState = [n, e]),
        n
      );
    },
    useReducer: function (n, e, t) {
      var i = is();
      return (
        (e = t !== void 0 ? t(e) : e),
        (i.memoizedState = i.baseState = e),
        (n = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: n,
          lastRenderedState: e,
        }),
        (i.queue = n),
        (n = n.dispatch = RF.bind(null, ln, n)),
        [i.memoizedState, n]
      );
    },
    useRef: function (n) {
      var e = is();
      return ((n = { current: n }), (e.memoizedState = n));
    },
    useState: Fw,
    useDebugValue: P1,
    useDeferredValue: function (n) {
      return (is().memoizedState = n);
    },
    useTransition: function () {
      var n = Fw(!1),
        e = n[0];
      return ((n = BF.bind(null, n[1])), (is().memoizedState = n), [e, n]);
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (n, e, t) {
      var i = ln,
        r = is();
      if ($t) {
        if (t === void 0) throw Error(be(407));
        t = t();
      } else {
        if (((t = e()), zn === null)) throw Error(be(349));
        nl & 30 || jP(i, e, t);
      }
      r.memoizedState = t;
      var s = { value: t, getSnapshot: e };
      return (
        (r.queue = s),
        Nw(XP.bind(null, i, s, n), [n]),
        (i.flags |= 2048),
        Yf(9, JP.bind(null, i, s, t, e), void 0, null),
        t
      );
    },
    useId: function () {
      var n = is(),
        e = zn.identifierPrefix;
      if ($t) {
        var t = ks,
          i = Ns;
        ((t = (i & ~(1 << (32 - kr(i) - 1))).toString(32) + t),
          (e = ":" + e + "R" + t),
          (t = Xf++),
          0 < t && (e += "H" + t.toString(32)),
          (e += ":"));
      } else ((t = PF++), (e = ":" + e + "r" + t.toString(32) + ":"));
      return (n.memoizedState = e);
    },
    unstable_isNewReconciler: !1,
  },
  DF = {
    readContext: yr,
    useCallback: t2,
    useContext: yr,
    useEffect: b1,
    useImperativeHandle: e2,
    useInsertionEffect: ZP,
    useLayoutEffect: qP,
    useMemo: n2,
    useReducer: Bv,
    useRef: QP,
    useState: function () {
      return Bv(Kf);
    },
    useDebugValue: P1,
    useDeferredValue: function (n) {
      var e = xr();
      return i2(e, Tn.memoizedState, n);
    },
    useTransition: function () {
      var n = Bv(Kf)[0],
        e = xr().memoizedState;
      return [n, e];
    },
    useMutableSource: VP,
    useSyncExternalStore: WP,
    useId: r2,
    unstable_isNewReconciler: !1,
  },
  FF = {
    readContext: yr,
    useCallback: t2,
    useContext: yr,
    useEffect: b1,
    useImperativeHandle: e2,
    useInsertionEffect: ZP,
    useLayoutEffect: qP,
    useMemo: n2,
    useReducer: Rv,
    useRef: QP,
    useState: function () {
      return Rv(Kf);
    },
    useDebugValue: P1,
    useDeferredValue: function (n) {
      var e = xr();
      return Tn === null ? (e.memoizedState = n) : i2(e, Tn.memoizedState, n);
    },
    useTransition: function () {
      var n = Rv(Kf)[0],
        e = xr().memoizedState;
      return [n, e];
    },
    useMutableSource: VP,
    useSyncExternalStore: WP,
    useId: r2,
    unstable_isNewReconciler: !1,
  };
function zc(n, e) {
  try {
    var t = "",
      i = e;
    do ((t += cD(i)), (i = i.return));
    while (i);
    var r = t;
  } catch (s) {
    r =
      `
Error generating stack: ` +
      s.message +
      `
` +
      s.stack;
  }
  return { value: n, source: e, stack: r, digest: null };
}
function Lv(n, e, t) {
  return { value: n, source: null, stack: t ?? null, digest: e ?? null };
}
function Ax(n, e) {
  try {
    console.error(e.value);
  } catch (t) {
    setTimeout(function () {
      throw t;
    });
  }
}
var NF = typeof WeakMap == "function" ? WeakMap : Map;
function l2(n, e, t) {
  ((t = Gs(-1, t)), (t.tag = 3), (t.payload = { element: null }));
  var i = e.value;
  return (
    (t.callback = function () {
      (Wm || ((Wm = !0), (Rx = i)), Ax(n, e));
    }),
    t
  );
}
function c2(n, e, t) {
  ((t = Gs(-1, t)), (t.tag = 3));
  var i = n.type.getDerivedStateFromError;
  if (typeof i == "function") {
    var r = e.value;
    ((t.payload = function () {
      return i(r);
    }),
      (t.callback = function () {
        Ax(n, e);
      }));
  }
  var s = n.stateNode;
  return (
    s !== null &&
      typeof s.componentDidCatch == "function" &&
      (t.callback = function () {
        (Ax(n, e),
          typeof i != "function" &&
            (Oo === null ? (Oo = new Set([this])) : Oo.add(this)));
        var o = e.stack;
        this.componentDidCatch(e.value, {
          componentStack: o !== null ? o : "",
        });
      }),
    t
  );
}
function kw(n, e, t) {
  var i = n.pingCache;
  if (i === null) {
    i = n.pingCache = new NF();
    var r = new Set();
    i.set(e, r);
  } else ((r = i.get(e)), r === void 0 && ((r = new Set()), i.set(e, r)));
  r.has(t) || (r.add(t), (n = QF.bind(null, n, e, t)), e.then(n, n));
}
function Ow(n) {
  do {
    var e;
    if (
      ((e = n.tag === 13) &&
        ((e = n.memoizedState), (e = e !== null ? e.dehydrated !== null : !0)),
      e)
    )
      return n;
    n = n.return;
  } while (n !== null);
  return null;
}
function Uw(n, e, t, i, r) {
  return n.mode & 1
    ? ((n.flags |= 65536), (n.lanes = r), n)
    : (n === e
        ? (n.flags |= 65536)
        : ((n.flags |= 128),
          (t.flags |= 131072),
          (t.flags &= -52805),
          t.tag === 1 &&
            (t.alternate === null
              ? (t.tag = 17)
              : ((e = Gs(-1, 1)), (e.tag = 2), ko(t, e, 1))),
          (t.lanes |= 1)),
      n);
}
var kF = $s.ReactCurrentOwner,
  Bi = !1;
function mi(n, e, t, i) {
  e.child = n === null ? GP(e, null, t, i) : Oc(e, n.child, t, i);
}
function zw(n, e, t, i, r) {
  t = t.render;
  var s = e.ref;
  return (
    bc(e, r),
    (i = C1(n, e, t, i, s, r)),
    (t = T1()),
    n !== null && !Bi
      ? ((e.updateQueue = n.updateQueue),
        (e.flags &= -2053),
        (n.lanes &= ~r),
        Ks(n, e, r))
      : ($t && t && p1(e), (e.flags |= 1), mi(n, e, i, r), e.child)
  );
}
function Gw(n, e, t, i, r) {
  if (n === null) {
    var s = t.type;
    return typeof s == "function" &&
      !k1(s) &&
      s.defaultProps === void 0 &&
      t.compare === null &&
      t.defaultProps === void 0
      ? ((e.tag = 15), (e.type = s), u2(n, e, s, i, r))
      : ((n = pm(t.type, null, i, e, e.mode, r)),
        (n.ref = e.ref),
        (n.return = e),
        (e.child = n));
  }
  if (((s = n.child), !(n.lanes & r))) {
    var o = s.memoizedProps;
    if (
      ((t = t.compare), (t = t !== null ? t : Gf), t(o, i) && n.ref === e.ref)
    )
      return Ks(n, e, r);
  }
  return (
    (e.flags |= 1),
    (n = zo(s, i)),
    (n.ref = e.ref),
    (n.return = e),
    (e.child = n)
  );
}
function u2(n, e, t, i, r) {
  if (n !== null) {
    var s = n.memoizedProps;
    if (Gf(s, i) && n.ref === e.ref)
      if (((Bi = !1), (e.pendingProps = i = s), (n.lanes & r) !== 0))
        n.flags & 131072 && (Bi = !0);
      else return ((e.lanes = n.lanes), Ks(n, e, r));
  }
  return Mx(n, e, t, i, r);
}
function f2(n, e, t) {
  var i = e.pendingProps,
    r = i.children,
    s = n !== null ? n.memoizedState : null;
  if (i.mode === "hidden")
    if (!(e.mode & 1))
      ((e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        Jt(gc, Hi),
        (Hi |= t));
    else {
      if (!(t & 1073741824))
        return (
          (n = s !== null ? s.baseLanes | t : t),
          (e.lanes = e.childLanes = 1073741824),
          (e.memoizedState = {
            baseLanes: n,
            cachePool: null,
            transitions: null,
          }),
          (e.updateQueue = null),
          Jt(gc, Hi),
          (Hi |= n),
          null
        );
      ((e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        (i = s !== null ? s.baseLanes : t),
        Jt(gc, Hi),
        (Hi |= i));
    }
  else
    (s !== null ? ((i = s.baseLanes | t), (e.memoizedState = null)) : (i = t),
      Jt(gc, Hi),
      (Hi |= i));
  return (mi(n, e, r, t), e.child);
}
function h2(n, e) {
  var t = e.ref;
  ((n === null && t !== null) || (n !== null && n.ref !== t)) &&
    ((e.flags |= 512), (e.flags |= 2097152));
}
function Mx(n, e, t, i, r) {
  var s = Li(t) ? el : oi.current;
  return (
    (s = Nc(e, s)),
    bc(e, r),
    (t = C1(n, e, t, i, s, r)),
    (i = T1()),
    n !== null && !Bi
      ? ((e.updateQueue = n.updateQueue),
        (e.flags &= -2053),
        (n.lanes &= ~r),
        Ks(n, e, r))
      : ($t && i && p1(e), (e.flags |= 1), mi(n, e, t, r), e.child)
  );
}
function Hw(n, e, t, i, r) {
  if (Li(t)) {
    var s = !0;
    Dm(e);
  } else s = !1;
  if ((bc(e, r), e.stateNode === null))
    (fm(n, e), UP(e, t, i), _x(e, t, i, r), (i = !0));
  else if (n === null) {
    var o = e.stateNode,
      a = e.memoizedProps;
    o.props = a;
    var l = o.context,
      u = t.contextType;
    typeof u == "object" && u !== null
      ? (u = yr(u))
      : ((u = Li(t) ? el : oi.current), (u = Nc(e, u)));
    var h = t.getDerivedStateFromProps,
      d =
        typeof h == "function" ||
        typeof o.getSnapshotBeforeUpdate == "function";
    (d ||
      (typeof o.UNSAFE_componentWillReceiveProps != "function" &&
        typeof o.componentWillReceiveProps != "function") ||
      ((a !== i || l !== u) && Iw(e, o, i, u)),
      (wo = !1));
    var p = e.memoizedState;
    ((o.state = p),
      Um(e, i, o, r),
      (l = e.memoizedState),
      a !== i || p !== l || Ri.current || wo
        ? (typeof h == "function" && (xx(e, t, h, i), (l = e.memoizedState)),
          (a = wo || Lw(e, t, a, i, p, l, u))
            ? (d ||
                (typeof o.UNSAFE_componentWillMount != "function" &&
                  typeof o.componentWillMount != "function") ||
                (typeof o.componentWillMount == "function" &&
                  o.componentWillMount(),
                typeof o.UNSAFE_componentWillMount == "function" &&
                  o.UNSAFE_componentWillMount()),
              typeof o.componentDidMount == "function" && (e.flags |= 4194308))
            : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
              (e.memoizedProps = i),
              (e.memoizedState = l)),
          (o.props = i),
          (o.state = l),
          (o.context = u),
          (i = a))
        : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
          (i = !1)));
  } else {
    ((o = e.stateNode),
      kP(n, e),
      (a = e.memoizedProps),
      (u = e.type === e.elementType ? a : Lr(e.type, a)),
      (o.props = u),
      (d = e.pendingProps),
      (p = o.context),
      (l = t.contextType),
      typeof l == "object" && l !== null
        ? (l = yr(l))
        : ((l = Li(t) ? el : oi.current), (l = Nc(e, l))));
    var g = t.getDerivedStateFromProps;
    ((h =
      typeof g == "function" ||
      typeof o.getSnapshotBeforeUpdate == "function") ||
      (typeof o.UNSAFE_componentWillReceiveProps != "function" &&
        typeof o.componentWillReceiveProps != "function") ||
      ((a !== d || p !== l) && Iw(e, o, i, l)),
      (wo = !1),
      (p = e.memoizedState),
      (o.state = p),
      Um(e, i, o, r));
    var y = e.memoizedState;
    a !== d || p !== y || Ri.current || wo
      ? (typeof g == "function" && (xx(e, t, g, i), (y = e.memoizedState)),
        (u = wo || Lw(e, t, u, i, p, y, l) || !1)
          ? (h ||
              (typeof o.UNSAFE_componentWillUpdate != "function" &&
                typeof o.componentWillUpdate != "function") ||
              (typeof o.componentWillUpdate == "function" &&
                o.componentWillUpdate(i, y, l),
              typeof o.UNSAFE_componentWillUpdate == "function" &&
                o.UNSAFE_componentWillUpdate(i, y, l)),
            typeof o.componentDidUpdate == "function" && (e.flags |= 4),
            typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024))
          : (typeof o.componentDidUpdate != "function" ||
              (a === n.memoizedProps && p === n.memoizedState) ||
              (e.flags |= 4),
            typeof o.getSnapshotBeforeUpdate != "function" ||
              (a === n.memoizedProps && p === n.memoizedState) ||
              (e.flags |= 1024),
            (e.memoizedProps = i),
            (e.memoizedState = y)),
        (o.props = i),
        (o.state = y),
        (o.context = l),
        (i = u))
      : (typeof o.componentDidUpdate != "function" ||
          (a === n.memoizedProps && p === n.memoizedState) ||
          (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" ||
          (a === n.memoizedProps && p === n.memoizedState) ||
          (e.flags |= 1024),
        (i = !1));
  }
  return Sx(n, e, t, i, s, r);
}
function Sx(n, e, t, i, r, s) {
  h2(n, e);
  var o = (e.flags & 128) !== 0;
  if (!i && !o) return (r && Tw(e, t, !1), Ks(n, e, s));
  ((i = e.stateNode), (kF.current = e));
  var a =
    o && typeof t.getDerivedStateFromError != "function" ? null : i.render();
  return (
    (e.flags |= 1),
    n !== null && o
      ? ((e.child = Oc(e, n.child, null, s)), (e.child = Oc(e, null, a, s)))
      : mi(n, e, a, s),
    (e.memoizedState = i.state),
    r && Tw(e, t, !0),
    e.child
  );
}
function d2(n) {
  var e = n.stateNode;
  (e.pendingContext
    ? Cw(n, e.pendingContext, e.pendingContext !== e.context)
    : e.context && Cw(n, e.context, !1),
    M1(n, e.containerInfo));
}
function Vw(n, e, t, i, r) {
  return (kc(), g1(r), (e.flags |= 256), mi(n, e, t, i), e.child);
}
var wx = { dehydrated: null, treeContext: null, retryLane: 0 };
function Ex(n) {
  return { baseLanes: n, cachePool: null, transitions: null };
}
function p2(n, e, t) {
  var i = e.pendingProps,
    r = nn.current,
    s = !1,
    o = (e.flags & 128) !== 0,
    a;
  if (
    ((a = o) ||
      (a = n !== null && n.memoizedState === null ? !1 : (r & 2) !== 0),
    a
      ? ((s = !0), (e.flags &= -129))
      : (n === null || n.memoizedState !== null) && (r |= 1),
    Jt(nn, r & 1),
    n === null)
  )
    return (
      vx(e),
      (n = e.memoizedState),
      n !== null && ((n = n.dehydrated), n !== null)
        ? (e.mode & 1
            ? n.data === "$!"
              ? (e.lanes = 8)
              : (e.lanes = 1073741824)
            : (e.lanes = 1),
          null)
        : ((o = i.children),
          (n = i.fallback),
          s
            ? ((i = e.mode),
              (s = e.child),
              (o = { mode: "hidden", children: o }),
              !(i & 1) && s !== null
                ? ((s.childLanes = 0), (s.pendingProps = o))
                : (s = wg(o, i, 0, null)),
              (n = Xa(n, i, t, null)),
              (s.return = e),
              (n.return = e),
              (s.sibling = n),
              (e.child = s),
              (e.child.memoizedState = Ex(t)),
              (e.memoizedState = wx),
              n)
            : B1(e, o))
    );
  if (((r = n.memoizedState), r !== null && ((a = r.dehydrated), a !== null)))
    return OF(n, e, o, i, a, r, t);
  if (s) {
    ((s = i.fallback), (o = e.mode), (r = n.child), (a = r.sibling));
    var l = { mode: "hidden", children: i.children };
    return (
      !(o & 1) && e.child !== r
        ? ((i = e.child),
          (i.childLanes = 0),
          (i.pendingProps = l),
          (e.deletions = null))
        : ((i = zo(r, l)), (i.subtreeFlags = r.subtreeFlags & 14680064)),
      a !== null ? (s = zo(a, s)) : ((s = Xa(s, o, t, null)), (s.flags |= 2)),
      (s.return = e),
      (i.return = e),
      (i.sibling = s),
      (e.child = i),
      (i = s),
      (s = e.child),
      (o = n.child.memoizedState),
      (o =
        o === null
          ? Ex(t)
          : {
              baseLanes: o.baseLanes | t,
              cachePool: null,
              transitions: o.transitions,
            }),
      (s.memoizedState = o),
      (s.childLanes = n.childLanes & ~t),
      (e.memoizedState = wx),
      i
    );
  }
  return (
    (s = n.child),
    (n = s.sibling),
    (i = zo(s, { mode: "visible", children: i.children })),
    !(e.mode & 1) && (i.lanes = t),
    (i.return = e),
    (i.sibling = null),
    n !== null &&
      ((t = e.deletions),
      t === null ? ((e.deletions = [n]), (e.flags |= 16)) : t.push(n)),
    (e.child = i),
    (e.memoizedState = null),
    i
  );
}
function B1(n, e) {
  return (
    (e = wg({ mode: "visible", children: e }, n.mode, 0, null)),
    (e.return = n),
    (n.child = e)
  );
}
function ip(n, e, t, i) {
  return (
    i !== null && g1(i),
    Oc(e, n.child, null, t),
    (n = B1(e, e.pendingProps.children)),
    (n.flags |= 2),
    (e.memoizedState = null),
    n
  );
}
function OF(n, e, t, i, r, s, o) {
  if (t)
    return e.flags & 256
      ? ((e.flags &= -257), (i = Lv(Error(be(422)))), ip(n, e, o, i))
      : e.memoizedState !== null
        ? ((e.child = n.child), (e.flags |= 128), null)
        : ((s = i.fallback),
          (r = e.mode),
          (i = wg({ mode: "visible", children: i.children }, r, 0, null)),
          (s = Xa(s, r, o, null)),
          (s.flags |= 2),
          (i.return = e),
          (s.return = e),
          (i.sibling = s),
          (e.child = i),
          e.mode & 1 && Oc(e, n.child, null, o),
          (e.child.memoizedState = Ex(o)),
          (e.memoizedState = wx),
          s);
  if (!(e.mode & 1)) return ip(n, e, o, null);
  if (r.data === "$!") {
    if (((i = r.nextSibling && r.nextSibling.dataset), i)) var a = i.dgst;
    return (
      (i = a),
      (s = Error(be(419))),
      (i = Lv(s, i, void 0)),
      ip(n, e, o, i)
    );
  }
  if (((a = (o & n.childLanes) !== 0), Bi || a)) {
    if (((i = zn), i !== null)) {
      switch (o & -o) {
        case 4:
          r = 2;
          break;
        case 16:
          r = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          r = 32;
          break;
        case 536870912:
          r = 268435456;
          break;
        default:
          r = 0;
      }
      ((r = r & (i.suspendedLanes | o) ? 0 : r),
        r !== 0 &&
          r !== s.retryLane &&
          ((s.retryLane = r), Xs(n, r), Or(i, n, r, -1)));
    }
    return (N1(), (i = Lv(Error(be(421)))), ip(n, e, o, i));
  }
  return r.data === "$?"
    ? ((e.flags |= 128),
      (e.child = n.child),
      (e = ZF.bind(null, n)),
      (r._reactRetry = e),
      null)
    : ((n = s.treeContext),
      (Wi = No(r.nextSibling)),
      (Xi = e),
      ($t = !0),
      (Fr = null),
      n !== null &&
        ((dr[pr++] = Ns),
        (dr[pr++] = ks),
        (dr[pr++] = tl),
        (Ns = n.id),
        (ks = n.overflow),
        (tl = e)),
      (e = B1(e, i.children)),
      (e.flags |= 4096),
      e);
}
function Ww(n, e, t) {
  n.lanes |= e;
  var i = n.alternate;
  (i !== null && (i.lanes |= e), yx(n.return, e, t));
}
function Iv(n, e, t, i, r) {
  var s = n.memoizedState;
  s === null
    ? (n.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: i,
        tail: t,
        tailMode: r,
      })
    : ((s.isBackwards = e),
      (s.rendering = null),
      (s.renderingStartTime = 0),
      (s.last = i),
      (s.tail = t),
      (s.tailMode = r));
}
function m2(n, e, t) {
  var i = e.pendingProps,
    r = i.revealOrder,
    s = i.tail;
  if ((mi(n, e, i.children, t), (i = nn.current), i & 2))
    ((i = (i & 1) | 2), (e.flags |= 128));
  else {
    if (n !== null && n.flags & 128)
      e: for (n = e.child; n !== null; ) {
        if (n.tag === 13) n.memoizedState !== null && Ww(n, t, e);
        else if (n.tag === 19) Ww(n, t, e);
        else if (n.child !== null) {
          ((n.child.return = n), (n = n.child));
          continue;
        }
        if (n === e) break e;
        for (; n.sibling === null; ) {
          if (n.return === null || n.return === e) break e;
          n = n.return;
        }
        ((n.sibling.return = n.return), (n = n.sibling));
      }
    i &= 1;
  }
  if ((Jt(nn, i), !(e.mode & 1))) e.memoizedState = null;
  else
    switch (r) {
      case "forwards":
        for (t = e.child, r = null; t !== null; )
          ((n = t.alternate),
            n !== null && zm(n) === null && (r = t),
            (t = t.sibling));
        ((t = r),
          t === null
            ? ((r = e.child), (e.child = null))
            : ((r = t.sibling), (t.sibling = null)),
          Iv(e, !1, r, t, s));
        break;
      case "backwards":
        for (t = null, r = e.child, e.child = null; r !== null; ) {
          if (((n = r.alternate), n !== null && zm(n) === null)) {
            e.child = r;
            break;
          }
          ((n = r.sibling), (r.sibling = t), (t = r), (r = n));
        }
        Iv(e, !0, t, null, s);
        break;
      case "together":
        Iv(e, !1, null, null, void 0);
        break;
      default:
        e.memoizedState = null;
    }
  return e.child;
}
function fm(n, e) {
  !(e.mode & 1) &&
    n !== null &&
    ((n.alternate = null), (e.alternate = null), (e.flags |= 2));
}
function Ks(n, e, t) {
  if (
    (n !== null && (e.dependencies = n.dependencies),
    (il |= e.lanes),
    !(t & e.childLanes))
  )
    return null;
  if (n !== null && e.child !== n.child) throw Error(be(153));
  if (e.child !== null) {
    for (
      n = e.child, t = zo(n, n.pendingProps), e.child = t, t.return = e;
      n.sibling !== null;

    )
      ((n = n.sibling),
        (t = t.sibling = zo(n, n.pendingProps)),
        (t.return = e));
    t.sibling = null;
  }
  return e.child;
}
function UF(n, e, t) {
  switch (e.tag) {
    case 3:
      (d2(e), kc());
      break;
    case 5:
      HP(e);
      break;
    case 1:
      Li(e.type) && Dm(e);
      break;
    case 4:
      M1(e, e.stateNode.containerInfo);
      break;
    case 10:
      var i = e.type._context,
        r = e.memoizedProps.value;
      (Jt(km, i._currentValue), (i._currentValue = r));
      break;
    case 13:
      if (((i = e.memoizedState), i !== null))
        return i.dehydrated !== null
          ? (Jt(nn, nn.current & 1), (e.flags |= 128), null)
          : t & e.child.childLanes
            ? p2(n, e, t)
            : (Jt(nn, nn.current & 1),
              (n = Ks(n, e, t)),
              n !== null ? n.sibling : null);
      Jt(nn, nn.current & 1);
      break;
    case 19:
      if (((i = (t & e.childLanes) !== 0), n.flags & 128)) {
        if (i) return m2(n, e, t);
        e.flags |= 128;
      }
      if (
        ((r = e.memoizedState),
        r !== null &&
          ((r.rendering = null), (r.tail = null), (r.lastEffect = null)),
        Jt(nn, nn.current),
        i)
      )
        break;
      return null;
    case 22:
    case 23:
      return ((e.lanes = 0), f2(n, e, t));
  }
  return Ks(n, e, t);
}
var g2, Cx, v2, y2;
g2 = function (n, e) {
  for (var t = e.child; t !== null; ) {
    if (t.tag === 5 || t.tag === 6) n.appendChild(t.stateNode);
    else if (t.tag !== 4 && t.child !== null) {
      ((t.child.return = t), (t = t.child));
      continue;
    }
    if (t === e) break;
    for (; t.sibling === null; ) {
      if (t.return === null || t.return === e) return;
      t = t.return;
    }
    ((t.sibling.return = t.return), (t = t.sibling));
  }
};
Cx = function () {};
v2 = function (n, e, t, i) {
  var r = n.memoizedProps;
  if (r !== i) {
    ((n = e.stateNode), Oa(as.current));
    var s = null;
    switch (t) {
      case "input":
        ((r = Ky(n, r)), (i = Ky(n, i)), (s = []));
        break;
      case "select":
        ((r = cn({}, r, { value: void 0 })),
          (i = cn({}, i, { value: void 0 })),
          (s = []));
        break;
      case "textarea":
        ((r = Zy(n, r)), (i = Zy(n, i)), (s = []));
        break;
      default:
        typeof r.onClick != "function" &&
          typeof i.onClick == "function" &&
          (n.onclick = Lm);
    }
    $y(t, i);
    var o;
    t = null;
    for (u in r)
      if (!i.hasOwnProperty(u) && r.hasOwnProperty(u) && r[u] != null)
        if (u === "style") {
          var a = r[u];
          for (o in a) a.hasOwnProperty(o) && (t || (t = {}), (t[o] = ""));
        } else
          u !== "dangerouslySetInnerHTML" &&
            u !== "children" &&
            u !== "suppressContentEditableWarning" &&
            u !== "suppressHydrationWarning" &&
            u !== "autoFocus" &&
            (Df.hasOwnProperty(u)
              ? s || (s = [])
              : (s = s || []).push(u, null));
    for (u in i) {
      var l = i[u];
      if (
        ((a = r != null ? r[u] : void 0),
        i.hasOwnProperty(u) && l !== a && (l != null || a != null))
      )
        if (u === "style")
          if (a) {
            for (o in a)
              !a.hasOwnProperty(o) ||
                (l && l.hasOwnProperty(o)) ||
                (t || (t = {}), (t[o] = ""));
            for (o in l)
              l.hasOwnProperty(o) &&
                a[o] !== l[o] &&
                (t || (t = {}), (t[o] = l[o]));
          } else (t || (s || (s = []), s.push(u, t)), (t = l));
        else
          u === "dangerouslySetInnerHTML"
            ? ((l = l ? l.__html : void 0),
              (a = a ? a.__html : void 0),
              l != null && a !== l && (s = s || []).push(u, l))
            : u === "children"
              ? (typeof l != "string" && typeof l != "number") ||
                (s = s || []).push(u, "" + l)
              : u !== "suppressContentEditableWarning" &&
                u !== "suppressHydrationWarning" &&
                (Df.hasOwnProperty(u)
                  ? (l != null && u === "onScroll" && Xt("scroll", n),
                    s || a === l || (s = []))
                  : (s = s || []).push(u, l));
    }
    t && (s = s || []).push("style", t);
    var u = s;
    (e.updateQueue = u) && (e.flags |= 4);
  }
};
y2 = function (n, e, t, i) {
  t !== i && (e.flags |= 4);
};
function zu(n, e) {
  if (!$t)
    switch (n.tailMode) {
      case "hidden":
        e = n.tail;
        for (var t = null; e !== null; )
          (e.alternate !== null && (t = e), (e = e.sibling));
        t === null ? (n.tail = null) : (t.sibling = null);
        break;
      case "collapsed":
        t = n.tail;
        for (var i = null; t !== null; )
          (t.alternate !== null && (i = t), (t = t.sibling));
        i === null
          ? e || n.tail === null
            ? (n.tail = null)
            : (n.tail.sibling = null)
          : (i.sibling = null);
    }
}
function ni(n) {
  var e = n.alternate !== null && n.alternate.child === n.child,
    t = 0,
    i = 0;
  if (e)
    for (var r = n.child; r !== null; )
      ((t |= r.lanes | r.childLanes),
        (i |= r.subtreeFlags & 14680064),
        (i |= r.flags & 14680064),
        (r.return = n),
        (r = r.sibling));
  else
    for (r = n.child; r !== null; )
      ((t |= r.lanes | r.childLanes),
        (i |= r.subtreeFlags),
        (i |= r.flags),
        (r.return = n),
        (r = r.sibling));
  return ((n.subtreeFlags |= i), (n.childLanes = t), e);
}
function zF(n, e, t) {
  var i = e.pendingProps;
  switch ((m1(e), e.tag)) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return (ni(e), null);
    case 1:
      return (Li(e.type) && Im(), ni(e), null);
    case 3:
      return (
        (i = e.stateNode),
        Uc(),
        Yt(Ri),
        Yt(oi),
        w1(),
        i.pendingContext &&
          ((i.context = i.pendingContext), (i.pendingContext = null)),
        (n === null || n.child === null) &&
          (tp(e)
            ? (e.flags |= 4)
            : n === null ||
              (n.memoizedState.isDehydrated && !(e.flags & 256)) ||
              ((e.flags |= 1024), Fr !== null && (Dx(Fr), (Fr = null)))),
        Cx(n, e),
        ni(e),
        null
      );
    case 5:
      S1(e);
      var r = Oa(Jf.current);
      if (((t = e.type), n !== null && e.stateNode != null))
        (v2(n, e, t, i, r),
          n.ref !== e.ref && ((e.flags |= 512), (e.flags |= 2097152)));
      else {
        if (!i) {
          if (e.stateNode === null) throw Error(be(166));
          return (ni(e), null);
        }
        if (((n = Oa(as.current)), tp(e))) {
          ((i = e.stateNode), (t = e.type));
          var s = e.memoizedProps;
          switch (((i[ss] = e), (i[Wf] = s), (n = (e.mode & 1) !== 0), t)) {
            case "dialog":
              (Xt("cancel", i), Xt("close", i));
              break;
            case "iframe":
            case "object":
            case "embed":
              Xt("load", i);
              break;
            case "video":
            case "audio":
              for (r = 0; r < uf.length; r++) Xt(uf[r], i);
              break;
            case "source":
              Xt("error", i);
              break;
            case "img":
            case "image":
            case "link":
              (Xt("error", i), Xt("load", i));
              break;
            case "details":
              Xt("toggle", i);
              break;
            case "input":
              ($S(i, s), Xt("invalid", i));
              break;
            case "select":
              ((i._wrapperState = { wasMultiple: !!s.multiple }),
                Xt("invalid", i));
              break;
            case "textarea":
              (tw(i, s), Xt("invalid", i));
          }
          ($y(t, s), (r = null));
          for (var o in s)
            if (s.hasOwnProperty(o)) {
              var a = s[o];
              o === "children"
                ? typeof a == "string"
                  ? i.textContent !== a &&
                    (s.suppressHydrationWarning !== !0 &&
                      ep(i.textContent, a, n),
                    (r = ["children", a]))
                  : typeof a == "number" &&
                    i.textContent !== "" + a &&
                    (s.suppressHydrationWarning !== !0 &&
                      ep(i.textContent, a, n),
                    (r = ["children", "" + a]))
                : Df.hasOwnProperty(o) &&
                  a != null &&
                  o === "onScroll" &&
                  Xt("scroll", i);
            }
          switch (t) {
            case "input":
              (Jd(i), ew(i, s, !0));
              break;
            case "textarea":
              (Jd(i), nw(i));
              break;
            case "select":
            case "option":
              break;
            default:
              typeof s.onClick == "function" && (i.onclick = Lm);
          }
          ((i = r), (e.updateQueue = i), i !== null && (e.flags |= 4));
        } else {
          ((o = r.nodeType === 9 ? r : r.ownerDocument),
            n === "http://www.w3.org/1999/xhtml" && (n = jb(t)),
            n === "http://www.w3.org/1999/xhtml"
              ? t === "script"
                ? ((n = o.createElement("div")),
                  (n.innerHTML = "<script><\/script>"),
                  (n = n.removeChild(n.firstChild)))
                : typeof i.is == "string"
                  ? (n = o.createElement(t, { is: i.is }))
                  : ((n = o.createElement(t)),
                    t === "select" &&
                      ((o = n),
                      i.multiple
                        ? (o.multiple = !0)
                        : i.size && (o.size = i.size)))
              : (n = o.createElementNS(n, t)),
            (n[ss] = e),
            (n[Wf] = i),
            g2(n, e, !1, !1),
            (e.stateNode = n));
          e: {
            switch (((o = ex(t, i)), t)) {
              case "dialog":
                (Xt("cancel", n), Xt("close", n), (r = i));
                break;
              case "iframe":
              case "object":
              case "embed":
                (Xt("load", n), (r = i));
                break;
              case "video":
              case "audio":
                for (r = 0; r < uf.length; r++) Xt(uf[r], n);
                r = i;
                break;
              case "source":
                (Xt("error", n), (r = i));
                break;
              case "img":
              case "image":
              case "link":
                (Xt("error", n), Xt("load", n), (r = i));
                break;
              case "details":
                (Xt("toggle", n), (r = i));
                break;
              case "input":
                ($S(n, i), (r = Ky(n, i)), Xt("invalid", n));
                break;
              case "option":
                r = i;
                break;
              case "select":
                ((n._wrapperState = { wasMultiple: !!i.multiple }),
                  (r = cn({}, i, { value: void 0 })),
                  Xt("invalid", n));
                break;
              case "textarea":
                (tw(n, i), (r = Zy(n, i)), Xt("invalid", n));
                break;
              default:
                r = i;
            }
            ($y(t, r), (a = r));
            for (s in a)
              if (a.hasOwnProperty(s)) {
                var l = a[s];
                s === "style"
                  ? Kb(n, l)
                  : s === "dangerouslySetInnerHTML"
                    ? ((l = l ? l.__html : void 0), l != null && Jb(n, l))
                    : s === "children"
                      ? typeof l == "string"
                        ? (t !== "textarea" || l !== "") && Ff(n, l)
                        : typeof l == "number" && Ff(n, "" + l)
                      : s !== "suppressContentEditableWarning" &&
                        s !== "suppressHydrationWarning" &&
                        s !== "autoFocus" &&
                        (Df.hasOwnProperty(s)
                          ? l != null && s === "onScroll" && Xt("scroll", n)
                          : l != null && e1(n, s, l, o));
              }
            switch (t) {
              case "input":
                (Jd(n), ew(n, i, !1));
                break;
              case "textarea":
                (Jd(n), nw(n));
                break;
              case "option":
                i.value != null && n.setAttribute("value", "" + jo(i.value));
                break;
              case "select":
                ((n.multiple = !!i.multiple),
                  (s = i.value),
                  s != null
                    ? wc(n, !!i.multiple, s, !1)
                    : i.defaultValue != null &&
                      wc(n, !!i.multiple, i.defaultValue, !0));
                break;
              default:
                typeof r.onClick == "function" && (n.onclick = Lm);
            }
            switch (t) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                i = !!i.autoFocus;
                break e;
              case "img":
                i = !0;
                break e;
              default:
                i = !1;
            }
          }
          i && (e.flags |= 4);
        }
        e.ref !== null && ((e.flags |= 512), (e.flags |= 2097152));
      }
      return (ni(e), null);
    case 6:
      if (n && e.stateNode != null) y2(n, e, n.memoizedProps, i);
      else {
        if (typeof i != "string" && e.stateNode === null) throw Error(be(166));
        if (((t = Oa(Jf.current)), Oa(as.current), tp(e))) {
          if (
            ((i = e.stateNode),
            (t = e.memoizedProps),
            (i[ss] = e),
            (s = i.nodeValue !== t) && ((n = Xi), n !== null))
          )
            switch (n.tag) {
              case 3:
                ep(i.nodeValue, t, (n.mode & 1) !== 0);
                break;
              case 5:
                n.memoizedProps.suppressHydrationWarning !== !0 &&
                  ep(i.nodeValue, t, (n.mode & 1) !== 0);
            }
          s && (e.flags |= 4);
        } else
          ((i = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(i)),
            (i[ss] = e),
            (e.stateNode = i));
      }
      return (ni(e), null);
    case 13:
      if (
        (Yt(nn),
        (i = e.memoizedState),
        n === null ||
          (n.memoizedState !== null && n.memoizedState.dehydrated !== null))
      ) {
        if ($t && Wi !== null && e.mode & 1 && !(e.flags & 128))
          (FP(), kc(), (e.flags |= 98560), (s = !1));
        else if (((s = tp(e)), i !== null && i.dehydrated !== null)) {
          if (n === null) {
            if (!s) throw Error(be(318));
            if (
              ((s = e.memoizedState),
              (s = s !== null ? s.dehydrated : null),
              !s)
            )
              throw Error(be(317));
            s[ss] = e;
          } else
            (kc(),
              !(e.flags & 128) && (e.memoizedState = null),
              (e.flags |= 4));
          (ni(e), (s = !1));
        } else (Fr !== null && (Dx(Fr), (Fr = null)), (s = !0));
        if (!s) return e.flags & 65536 ? e : null;
      }
      return e.flags & 128
        ? ((e.lanes = t), e)
        : ((i = i !== null),
          i !== (n !== null && n.memoizedState !== null) &&
            i &&
            ((e.child.flags |= 8192),
            e.mode & 1 &&
              (n === null || nn.current & 1 ? Pn === 0 && (Pn = 3) : N1())),
          e.updateQueue !== null && (e.flags |= 4),
          ni(e),
          null);
    case 4:
      return (
        Uc(),
        Cx(n, e),
        n === null && Hf(e.stateNode.containerInfo),
        ni(e),
        null
      );
    case 10:
      return (x1(e.type._context), ni(e), null);
    case 17:
      return (Li(e.type) && Im(), ni(e), null);
    case 19:
      if ((Yt(nn), (s = e.memoizedState), s === null)) return (ni(e), null);
      if (((i = (e.flags & 128) !== 0), (o = s.rendering), o === null))
        if (i) zu(s, !1);
        else {
          if (Pn !== 0 || (n !== null && n.flags & 128))
            for (n = e.child; n !== null; ) {
              if (((o = zm(n)), o !== null)) {
                for (
                  e.flags |= 128,
                    zu(s, !1),
                    i = o.updateQueue,
                    i !== null && ((e.updateQueue = i), (e.flags |= 4)),
                    e.subtreeFlags = 0,
                    i = t,
                    t = e.child;
                  t !== null;

                )
                  ((s = t),
                    (n = i),
                    (s.flags &= 14680066),
                    (o = s.alternate),
                    o === null
                      ? ((s.childLanes = 0),
                        (s.lanes = n),
                        (s.child = null),
                        (s.subtreeFlags = 0),
                        (s.memoizedProps = null),
                        (s.memoizedState = null),
                        (s.updateQueue = null),
                        (s.dependencies = null),
                        (s.stateNode = null))
                      : ((s.childLanes = o.childLanes),
                        (s.lanes = o.lanes),
                        (s.child = o.child),
                        (s.subtreeFlags = 0),
                        (s.deletions = null),
                        (s.memoizedProps = o.memoizedProps),
                        (s.memoizedState = o.memoizedState),
                        (s.updateQueue = o.updateQueue),
                        (s.type = o.type),
                        (n = o.dependencies),
                        (s.dependencies =
                          n === null
                            ? null
                            : {
                                lanes: n.lanes,
                                firstContext: n.firstContext,
                              })),
                    (t = t.sibling));
                return (Jt(nn, (nn.current & 1) | 2), e.child);
              }
              n = n.sibling;
            }
          s.tail !== null &&
            vn() > Gc &&
            ((e.flags |= 128), (i = !0), zu(s, !1), (e.lanes = 4194304));
        }
      else {
        if (!i)
          if (((n = zm(o)), n !== null)) {
            if (
              ((e.flags |= 128),
              (i = !0),
              (t = n.updateQueue),
              t !== null && ((e.updateQueue = t), (e.flags |= 4)),
              zu(s, !0),
              s.tail === null && s.tailMode === "hidden" && !o.alternate && !$t)
            )
              return (ni(e), null);
          } else
            2 * vn() - s.renderingStartTime > Gc &&
              t !== 1073741824 &&
              ((e.flags |= 128), (i = !0), zu(s, !1), (e.lanes = 4194304));
        s.isBackwards
          ? ((o.sibling = e.child), (e.child = o))
          : ((t = s.last),
            t !== null ? (t.sibling = o) : (e.child = o),
            (s.last = o));
      }
      return s.tail !== null
        ? ((e = s.tail),
          (s.rendering = e),
          (s.tail = e.sibling),
          (s.renderingStartTime = vn()),
          (e.sibling = null),
          (t = nn.current),
          Jt(nn, i ? (t & 1) | 2 : t & 1),
          e)
        : (ni(e), null);
    case 22:
    case 23:
      return (
        F1(),
        (i = e.memoizedState !== null),
        n !== null && (n.memoizedState !== null) !== i && (e.flags |= 8192),
        i && e.mode & 1
          ? Hi & 1073741824 && (ni(e), e.subtreeFlags & 6 && (e.flags |= 8192))
          : ni(e),
        null
      );
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(be(156, e.tag));
}
function GF(n, e) {
  switch ((m1(e), e.tag)) {
    case 1:
      return (
        Li(e.type) && Im(),
        (n = e.flags),
        n & 65536 ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 3:
      return (
        Uc(),
        Yt(Ri),
        Yt(oi),
        w1(),
        (n = e.flags),
        n & 65536 && !(n & 128) ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 5:
      return (S1(e), null);
    case 13:
      if (
        (Yt(nn), (n = e.memoizedState), n !== null && n.dehydrated !== null)
      ) {
        if (e.alternate === null) throw Error(be(340));
        kc();
      }
      return (
        (n = e.flags),
        n & 65536 ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 19:
      return (Yt(nn), null);
    case 4:
      return (Uc(), null);
    case 10:
      return (x1(e.type._context), null);
    case 22:
    case 23:
      return (F1(), null);
    case 24:
      return null;
    default:
      return null;
  }
}
var rp = !1,
  si = !1,
  HF = typeof WeakSet == "function" ? WeakSet : Set,
  ze = null;
function mc(n, e) {
  var t = n.ref;
  if (t !== null)
    if (typeof t == "function")
      try {
        t(null);
      } catch (i) {
        hn(n, e, i);
      }
    else t.current = null;
}
function Tx(n, e, t) {
  try {
    t();
  } catch (i) {
    hn(n, e, i);
  }
}
var jw = !1;
function VF(n, e) {
  if (((ux = Pm), (n = MP()), d1(n))) {
    if ("selectionStart" in n)
      var t = { start: n.selectionStart, end: n.selectionEnd };
    else
      e: {
        t = ((t = n.ownerDocument) && t.defaultView) || window;
        var i = t.getSelection && t.getSelection();
        if (i && i.rangeCount !== 0) {
          t = i.anchorNode;
          var r = i.anchorOffset,
            s = i.focusNode;
          i = i.focusOffset;
          try {
            (t.nodeType, s.nodeType);
          } catch {
            t = null;
            break e;
          }
          var o = 0,
            a = -1,
            l = -1,
            u = 0,
            h = 0,
            d = n,
            p = null;
          t: for (;;) {
            for (
              var g;
              d !== t || (r !== 0 && d.nodeType !== 3) || (a = o + r),
                d !== s || (i !== 0 && d.nodeType !== 3) || (l = o + i),
                d.nodeType === 3 && (o += d.nodeValue.length),
                (g = d.firstChild) !== null;

            )
              ((p = d), (d = g));
            for (;;) {
              if (d === n) break t;
              if (
                (p === t && ++u === r && (a = o),
                p === s && ++h === i && (l = o),
                (g = d.nextSibling) !== null)
              )
                break;
              ((d = p), (p = d.parentNode));
            }
            d = g;
          }
          t = a === -1 || l === -1 ? null : { start: a, end: l };
        } else t = null;
      }
    t = t || { start: 0, end: 0 };
  } else t = null;
  for (
    fx = { focusedElem: n, selectionRange: t }, Pm = !1, ze = e;
    ze !== null;

  )
    if (((e = ze), (n = e.child), (e.subtreeFlags & 1028) !== 0 && n !== null))
      ((n.return = e), (ze = n));
    else
      for (; ze !== null; ) {
        e = ze;
        try {
          var y = e.alternate;
          if (e.flags & 1024)
            switch (e.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (y !== null) {
                  var A = y.memoizedProps,
                    _ = y.memoizedState,
                    m = e.stateNode,
                    x = m.getSnapshotBeforeUpdate(
                      e.elementType === e.type ? A : Lr(e.type, A),
                      _
                    );
                  m.__reactInternalSnapshotBeforeUpdate = x;
                }
                break;
              case 3:
                var S = e.stateNode.containerInfo;
                S.nodeType === 1
                  ? (S.textContent = "")
                  : S.nodeType === 9 &&
                    S.documentElement &&
                    S.removeChild(S.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(be(163));
            }
        } catch (w) {
          hn(e, e.return, w);
        }
        if (((n = e.sibling), n !== null)) {
          ((n.return = e.return), (ze = n));
          break;
        }
        ze = e.return;
      }
  return ((y = jw), (jw = !1), y);
}
function _f(n, e, t) {
  var i = e.updateQueue;
  if (((i = i !== null ? i.lastEffect : null), i !== null)) {
    var r = (i = i.next);
    do {
      if ((r.tag & n) === n) {
        var s = r.destroy;
        ((r.destroy = void 0), s !== void 0 && Tx(e, t, s));
      }
      r = r.next;
    } while (r !== i);
  }
}
function Mg(n, e) {
  if (
    ((e = e.updateQueue), (e = e !== null ? e.lastEffect : null), e !== null)
  ) {
    var t = (e = e.next);
    do {
      if ((t.tag & n) === n) {
        var i = t.create;
        t.destroy = i();
      }
      t = t.next;
    } while (t !== e);
  }
}
function bx(n) {
  var e = n.ref;
  if (e !== null) {
    var t = n.stateNode;
    switch (n.tag) {
      case 5:
        n = t;
        break;
      default:
        n = t;
    }
    typeof e == "function" ? e(n) : (e.current = n);
  }
}
function x2(n) {
  var e = n.alternate;
  (e !== null && ((n.alternate = null), x2(e)),
    (n.child = null),
    (n.deletions = null),
    (n.sibling = null),
    n.tag === 5 &&
      ((e = n.stateNode),
      e !== null &&
        (delete e[ss], delete e[Wf], delete e[px], delete e[EF], delete e[CF])),
    (n.stateNode = null),
    (n.return = null),
    (n.dependencies = null),
    (n.memoizedProps = null),
    (n.memoizedState = null),
    (n.pendingProps = null),
    (n.stateNode = null),
    (n.updateQueue = null));
}
function _2(n) {
  return n.tag === 5 || n.tag === 3 || n.tag === 4;
}
function Jw(n) {
  e: for (;;) {
    for (; n.sibling === null; ) {
      if (n.return === null || _2(n.return)) return null;
      n = n.return;
    }
    for (
      n.sibling.return = n.return, n = n.sibling;
      n.tag !== 5 && n.tag !== 6 && n.tag !== 18;

    ) {
      if (n.flags & 2 || n.child === null || n.tag === 4) continue e;
      ((n.child.return = n), (n = n.child));
    }
    if (!(n.flags & 2)) return n.stateNode;
  }
}
function Px(n, e, t) {
  var i = n.tag;
  if (i === 5 || i === 6)
    ((n = n.stateNode),
      e
        ? t.nodeType === 8
          ? t.parentNode.insertBefore(n, e)
          : t.insertBefore(n, e)
        : (t.nodeType === 8
            ? ((e = t.parentNode), e.insertBefore(n, t))
            : ((e = t), e.appendChild(n)),
          (t = t._reactRootContainer),
          t != null || e.onclick !== null || (e.onclick = Lm)));
  else if (i !== 4 && ((n = n.child), n !== null))
    for (Px(n, e, t), n = n.sibling; n !== null; )
      (Px(n, e, t), (n = n.sibling));
}
function Bx(n, e, t) {
  var i = n.tag;
  if (i === 5 || i === 6)
    ((n = n.stateNode), e ? t.insertBefore(n, e) : t.appendChild(n));
  else if (i !== 4 && ((n = n.child), n !== null))
    for (Bx(n, e, t), n = n.sibling; n !== null; )
      (Bx(n, e, t), (n = n.sibling));
}
var Wn = null,
  Ir = !1;
function ho(n, e, t) {
  for (t = t.child; t !== null; ) (A2(n, e, t), (t = t.sibling));
}
function A2(n, e, t) {
  if (os && typeof os.onCommitFiberUnmount == "function")
    try {
      os.onCommitFiberUnmount(pg, t);
    } catch {}
  switch (t.tag) {
    case 5:
      si || mc(t, e);
    case 6:
      var i = Wn,
        r = Ir;
      ((Wn = null),
        ho(n, e, t),
        (Wn = i),
        (Ir = r),
        Wn !== null &&
          (Ir
            ? ((n = Wn),
              (t = t.stateNode),
              n.nodeType === 8 ? n.parentNode.removeChild(t) : n.removeChild(t))
            : Wn.removeChild(t.stateNode)));
      break;
    case 18:
      Wn !== null &&
        (Ir
          ? ((n = Wn),
            (t = t.stateNode),
            n.nodeType === 8
              ? Cv(n.parentNode, t)
              : n.nodeType === 1 && Cv(n, t),
            Uf(n))
          : Cv(Wn, t.stateNode));
      break;
    case 4:
      ((i = Wn),
        (r = Ir),
        (Wn = t.stateNode.containerInfo),
        (Ir = !0),
        ho(n, e, t),
        (Wn = i),
        (Ir = r));
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (
        !si &&
        ((i = t.updateQueue), i !== null && ((i = i.lastEffect), i !== null))
      ) {
        r = i = i.next;
        do {
          var s = r,
            o = s.destroy;
          ((s = s.tag),
            o !== void 0 && (s & 2 || s & 4) && Tx(t, e, o),
            (r = r.next));
        } while (r !== i);
      }
      ho(n, e, t);
      break;
    case 1:
      if (
        !si &&
        (mc(t, e),
        (i = t.stateNode),
        typeof i.componentWillUnmount == "function")
      )
        try {
          ((i.props = t.memoizedProps),
            (i.state = t.memoizedState),
            i.componentWillUnmount());
        } catch (a) {
          hn(t, e, a);
        }
      ho(n, e, t);
      break;
    case 21:
      ho(n, e, t);
      break;
    case 22:
      t.mode & 1
        ? ((si = (i = si) || t.memoizedState !== null), ho(n, e, t), (si = i))
        : ho(n, e, t);
      break;
    default:
      ho(n, e, t);
  }
}
function Xw(n) {
  var e = n.updateQueue;
  if (e !== null) {
    n.updateQueue = null;
    var t = n.stateNode;
    (t === null && (t = n.stateNode = new HF()),
      e.forEach(function (i) {
        var r = qF.bind(null, n, i);
        t.has(i) || (t.add(i), i.then(r, r));
      }));
  }
}
function br(n, e) {
  var t = e.deletions;
  if (t !== null)
    for (var i = 0; i < t.length; i++) {
      var r = t[i];
      try {
        var s = n,
          o = e,
          a = o;
        e: for (; a !== null; ) {
          switch (a.tag) {
            case 5:
              ((Wn = a.stateNode), (Ir = !1));
              break e;
            case 3:
              ((Wn = a.stateNode.containerInfo), (Ir = !0));
              break e;
            case 4:
              ((Wn = a.stateNode.containerInfo), (Ir = !0));
              break e;
          }
          a = a.return;
        }
        if (Wn === null) throw Error(be(160));
        (A2(s, o, r), (Wn = null), (Ir = !1));
        var l = r.alternate;
        (l !== null && (l.return = null), (r.return = null));
      } catch (u) {
        hn(r, e, u);
      }
    }
  if (e.subtreeFlags & 12854)
    for (e = e.child; e !== null; ) (M2(e, n), (e = e.sibling));
}
function M2(n, e) {
  var t = n.alternate,
    i = n.flags;
  switch (n.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if ((br(e, n), ts(n), i & 4)) {
        try {
          (_f(3, n, n.return), Mg(3, n));
        } catch (A) {
          hn(n, n.return, A);
        }
        try {
          _f(5, n, n.return);
        } catch (A) {
          hn(n, n.return, A);
        }
      }
      break;
    case 1:
      (br(e, n), ts(n), i & 512 && t !== null && mc(t, t.return));
      break;
    case 5:
      if (
        (br(e, n),
        ts(n),
        i & 512 && t !== null && mc(t, t.return),
        n.flags & 32)
      ) {
        var r = n.stateNode;
        try {
          Ff(r, "");
        } catch (A) {
          hn(n, n.return, A);
        }
      }
      if (i & 4 && ((r = n.stateNode), r != null)) {
        var s = n.memoizedProps,
          o = t !== null ? t.memoizedProps : s,
          a = n.type,
          l = n.updateQueue;
        if (((n.updateQueue = null), l !== null))
          try {
            (a === "input" && s.type === "radio" && s.name != null && Vb(r, s),
              ex(a, o));
            var u = ex(a, s);
            for (o = 0; o < l.length; o += 2) {
              var h = l[o],
                d = l[o + 1];
              h === "style"
                ? Kb(r, d)
                : h === "dangerouslySetInnerHTML"
                  ? Jb(r, d)
                  : h === "children"
                    ? Ff(r, d)
                    : e1(r, h, d, u);
            }
            switch (a) {
              case "input":
                Yy(r, s);
                break;
              case "textarea":
                Wb(r, s);
                break;
              case "select":
                var p = r._wrapperState.wasMultiple;
                r._wrapperState.wasMultiple = !!s.multiple;
                var g = s.value;
                g != null
                  ? wc(r, !!s.multiple, g, !1)
                  : p !== !!s.multiple &&
                    (s.defaultValue != null
                      ? wc(r, !!s.multiple, s.defaultValue, !0)
                      : wc(r, !!s.multiple, s.multiple ? [] : "", !1));
            }
            r[Wf] = s;
          } catch (A) {
            hn(n, n.return, A);
          }
      }
      break;
    case 6:
      if ((br(e, n), ts(n), i & 4)) {
        if (n.stateNode === null) throw Error(be(162));
        ((r = n.stateNode), (s = n.memoizedProps));
        try {
          r.nodeValue = s;
        } catch (A) {
          hn(n, n.return, A);
        }
      }
      break;
    case 3:
      if (
        (br(e, n), ts(n), i & 4 && t !== null && t.memoizedState.isDehydrated)
      )
        try {
          Uf(e.containerInfo);
        } catch (A) {
          hn(n, n.return, A);
        }
      break;
    case 4:
      (br(e, n), ts(n));
      break;
    case 13:
      (br(e, n),
        ts(n),
        (r = n.child),
        r.flags & 8192 &&
          ((s = r.memoizedState !== null),
          (r.stateNode.isHidden = s),
          !s ||
            (r.alternate !== null && r.alternate.memoizedState !== null) ||
            (I1 = vn())),
        i & 4 && Xw(n));
      break;
    case 22:
      if (
        ((h = t !== null && t.memoizedState !== null),
        n.mode & 1 ? ((si = (u = si) || h), br(e, n), (si = u)) : br(e, n),
        ts(n),
        i & 8192)
      ) {
        if (
          ((u = n.memoizedState !== null),
          (n.stateNode.isHidden = u) && !h && n.mode & 1)
        )
          for (ze = n, h = n.child; h !== null; ) {
            for (d = ze = h; ze !== null; ) {
              switch (((p = ze), (g = p.child), p.tag)) {
                case 0:
                case 11:
                case 14:
                case 15:
                  _f(4, p, p.return);
                  break;
                case 1:
                  mc(p, p.return);
                  var y = p.stateNode;
                  if (typeof y.componentWillUnmount == "function") {
                    ((i = p), (t = p.return));
                    try {
                      ((e = i),
                        (y.props = e.memoizedProps),
                        (y.state = e.memoizedState),
                        y.componentWillUnmount());
                    } catch (A) {
                      hn(i, t, A);
                    }
                  }
                  break;
                case 5:
                  mc(p, p.return);
                  break;
                case 22:
                  if (p.memoizedState !== null) {
                    Yw(d);
                    continue;
                  }
              }
              g !== null ? ((g.return = p), (ze = g)) : Yw(d);
            }
            h = h.sibling;
          }
        e: for (h = null, d = n; ; ) {
          if (d.tag === 5) {
            if (h === null) {
              h = d;
              try {
                ((r = d.stateNode),
                  u
                    ? ((s = r.style),
                      typeof s.setProperty == "function"
                        ? s.setProperty("display", "none", "important")
                        : (s.display = "none"))
                    : ((a = d.stateNode),
                      (l = d.memoizedProps.style),
                      (o =
                        l != null && l.hasOwnProperty("display")
                          ? l.display
                          : null),
                      (a.style.display = Xb("display", o))));
              } catch (A) {
                hn(n, n.return, A);
              }
            }
          } else if (d.tag === 6) {
            if (h === null)
              try {
                d.stateNode.nodeValue = u ? "" : d.memoizedProps;
              } catch (A) {
                hn(n, n.return, A);
              }
          } else if (
            ((d.tag !== 22 && d.tag !== 23) ||
              d.memoizedState === null ||
              d === n) &&
            d.child !== null
          ) {
            ((d.child.return = d), (d = d.child));
            continue;
          }
          if (d === n) break e;
          for (; d.sibling === null; ) {
            if (d.return === null || d.return === n) break e;
            (h === d && (h = null), (d = d.return));
          }
          (h === d && (h = null),
            (d.sibling.return = d.return),
            (d = d.sibling));
        }
      }
      break;
    case 19:
      (br(e, n), ts(n), i & 4 && Xw(n));
      break;
    case 21:
      break;
    default:
      (br(e, n), ts(n));
  }
}
function ts(n) {
  var e = n.flags;
  if (e & 2) {
    try {
      e: {
        for (var t = n.return; t !== null; ) {
          if (_2(t)) {
            var i = t;
            break e;
          }
          t = t.return;
        }
        throw Error(be(160));
      }
      switch (i.tag) {
        case 5:
          var r = i.stateNode;
          i.flags & 32 && (Ff(r, ""), (i.flags &= -33));
          var s = Jw(n);
          Bx(n, s, r);
          break;
        case 3:
        case 4:
          var o = i.stateNode.containerInfo,
            a = Jw(n);
          Px(n, a, o);
          break;
        default:
          throw Error(be(161));
      }
    } catch (l) {
      hn(n, n.return, l);
    }
    n.flags &= -3;
  }
  e & 4096 && (n.flags &= -4097);
}
function WF(n, e, t) {
  ((ze = n), S2(n));
}
function S2(n, e, t) {
  for (var i = (n.mode & 1) !== 0; ze !== null; ) {
    var r = ze,
      s = r.child;
    if (r.tag === 22 && i) {
      var o = r.memoizedState !== null || rp;
      if (!o) {
        var a = r.alternate,
          l = (a !== null && a.memoizedState !== null) || si;
        a = rp;
        var u = si;
        if (((rp = o), (si = l) && !u))
          for (ze = r; ze !== null; )
            ((o = ze),
              (l = o.child),
              o.tag === 22 && o.memoizedState !== null
                ? Qw(r)
                : l !== null
                  ? ((l.return = o), (ze = l))
                  : Qw(r));
        for (; s !== null; ) ((ze = s), S2(s), (s = s.sibling));
        ((ze = r), (rp = a), (si = u));
      }
      Kw(n);
    } else
      r.subtreeFlags & 8772 && s !== null ? ((s.return = r), (ze = s)) : Kw(n);
  }
}
function Kw(n) {
  for (; ze !== null; ) {
    var e = ze;
    if (e.flags & 8772) {
      var t = e.alternate;
      try {
        if (e.flags & 8772)
          switch (e.tag) {
            case 0:
            case 11:
            case 15:
              si || Mg(5, e);
              break;
            case 1:
              var i = e.stateNode;
              if (e.flags & 4 && !si)
                if (t === null) i.componentDidMount();
                else {
                  var r =
                    e.elementType === e.type
                      ? t.memoizedProps
                      : Lr(e.type, t.memoizedProps);
                  i.componentDidUpdate(
                    r,
                    t.memoizedState,
                    i.__reactInternalSnapshotBeforeUpdate
                  );
                }
              var s = e.updateQueue;
              s !== null && Rw(e, s, i);
              break;
            case 3:
              var o = e.updateQueue;
              if (o !== null) {
                if (((t = null), e.child !== null))
                  switch (e.child.tag) {
                    case 5:
                      t = e.child.stateNode;
                      break;
                    case 1:
                      t = e.child.stateNode;
                  }
                Rw(e, o, t);
              }
              break;
            case 5:
              var a = e.stateNode;
              if (t === null && e.flags & 4) {
                t = a;
                var l = e.memoizedProps;
                switch (e.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    l.autoFocus && t.focus();
                    break;
                  case "img":
                    l.src && (t.src = l.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (e.memoizedState === null) {
                var u = e.alternate;
                if (u !== null) {
                  var h = u.memoizedState;
                  if (h !== null) {
                    var d = h.dehydrated;
                    d !== null && Uf(d);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(be(163));
          }
        si || (e.flags & 512 && bx(e));
      } catch (p) {
        hn(e, e.return, p);
      }
    }
    if (e === n) {
      ze = null;
      break;
    }
    if (((t = e.sibling), t !== null)) {
      ((t.return = e.return), (ze = t));
      break;
    }
    ze = e.return;
  }
}
function Yw(n) {
  for (; ze !== null; ) {
    var e = ze;
    if (e === n) {
      ze = null;
      break;
    }
    var t = e.sibling;
    if (t !== null) {
      ((t.return = e.return), (ze = t));
      break;
    }
    ze = e.return;
  }
}
function Qw(n) {
  for (; ze !== null; ) {
    var e = ze;
    try {
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          var t = e.return;
          try {
            Mg(4, e);
          } catch (l) {
            hn(e, t, l);
          }
          break;
        case 1:
          var i = e.stateNode;
          if (typeof i.componentDidMount == "function") {
            var r = e.return;
            try {
              i.componentDidMount();
            } catch (l) {
              hn(e, r, l);
            }
          }
          var s = e.return;
          try {
            bx(e);
          } catch (l) {
            hn(e, s, l);
          }
          break;
        case 5:
          var o = e.return;
          try {
            bx(e);
          } catch (l) {
            hn(e, o, l);
          }
      }
    } catch (l) {
      hn(e, e.return, l);
    }
    if (e === n) {
      ze = null;
      break;
    }
    var a = e.sibling;
    if (a !== null) {
      ((a.return = e.return), (ze = a));
      break;
    }
    ze = e.return;
  }
}
var jF = Math.ceil,
  Vm = $s.ReactCurrentDispatcher,
  R1 = $s.ReactCurrentOwner,
  vr = $s.ReactCurrentBatchConfig,
  Bt = 0,
  zn = null,
  wn = null,
  Xn = 0,
  Hi = 0,
  gc = ea(0),
  Pn = 0,
  Qf = null,
  il = 0,
  Sg = 0,
  L1 = 0,
  Af = null,
  Ti = null,
  I1 = 0,
  Gc = 1 / 0,
  Bs = null,
  Wm = !1,
  Rx = null,
  Oo = null,
  sp = !1,
  Bo = null,
  jm = 0,
  Mf = 0,
  Lx = null,
  hm = -1,
  dm = 0;
function gi() {
  return Bt & 6 ? vn() : hm !== -1 ? hm : (hm = vn());
}
function Uo(n) {
  return n.mode & 1
    ? Bt & 2 && Xn !== 0
      ? Xn & -Xn
      : bF.transition !== null
        ? (dm === 0 && (dm = oP()), dm)
        : ((n = Ot),
          n !== 0 || ((n = window.event), (n = n === void 0 ? 16 : dP(n.type))),
          n)
    : 1;
}
function Or(n, e, t, i) {
  if (50 < Mf) throw ((Mf = 0), (Lx = null), Error(be(185)));
  (yh(n, t, i),
    (!(Bt & 2) || n !== zn) &&
      (n === zn && (!(Bt & 2) && (Sg |= t), Pn === 4 && bo(n, Xn)),
      Ii(n, i),
      t === 1 && Bt === 0 && !(e.mode & 1) && ((Gc = vn() + 500), xg && ta())));
}
function Ii(n, e) {
  var t = n.callbackNode;
  bD(n, e);
  var i = bm(n, n === zn ? Xn : 0);
  if (i === 0)
    (t !== null && sw(t), (n.callbackNode = null), (n.callbackPriority = 0));
  else if (((e = i & -i), n.callbackPriority !== e)) {
    if ((t != null && sw(t), e === 1))
      (n.tag === 0 ? TF(Zw.bind(null, n)) : LP(Zw.bind(null, n)),
        SF(function () {
          !(Bt & 6) && ta();
        }),
        (t = null));
    else {
      switch (aP(i)) {
        case 1:
          t = s1;
          break;
        case 4:
          t = rP;
          break;
        case 16:
          t = Tm;
          break;
        case 536870912:
          t = sP;
          break;
        default:
          t = Tm;
      }
      t = R2(t, w2.bind(null, n));
    }
    ((n.callbackPriority = e), (n.callbackNode = t));
  }
}
function w2(n, e) {
  if (((hm = -1), (dm = 0), Bt & 6)) throw Error(be(327));
  var t = n.callbackNode;
  if (Pc() && n.callbackNode !== t) return null;
  var i = bm(n, n === zn ? Xn : 0);
  if (i === 0) return null;
  if (i & 30 || i & n.expiredLanes || e) e = Jm(n, i);
  else {
    e = i;
    var r = Bt;
    Bt |= 2;
    var s = C2();
    (zn !== n || Xn !== e) && ((Bs = null), (Gc = vn() + 500), Ja(n, e));
    do
      try {
        KF();
        break;
      } catch (a) {
        E2(n, a);
      }
    while (1);
    (y1(),
      (Vm.current = s),
      (Bt = r),
      wn !== null ? (e = 0) : ((zn = null), (Xn = 0), (e = Pn)));
  }
  if (e !== 0) {
    if (
      (e === 2 && ((r = sx(n)), r !== 0 && ((i = r), (e = Ix(n, r)))), e === 1)
    )
      throw ((t = Qf), Ja(n, 0), bo(n, i), Ii(n, vn()), t);
    if (e === 6) bo(n, i);
    else {
      if (
        ((r = n.current.alternate),
        !(i & 30) &&
          !JF(r) &&
          ((e = Jm(n, i)),
          e === 2 && ((s = sx(n)), s !== 0 && ((i = s), (e = Ix(n, s)))),
          e === 1))
      )
        throw ((t = Qf), Ja(n, 0), bo(n, i), Ii(n, vn()), t);
      switch (((n.finishedWork = r), (n.finishedLanes = i), e)) {
        case 0:
        case 1:
          throw Error(be(345));
        case 2:
          Ta(n, Ti, Bs);
          break;
        case 3:
          if (
            (bo(n, i), (i & 130023424) === i && ((e = I1 + 500 - vn()), 10 < e))
          ) {
            if (bm(n, 0) !== 0) break;
            if (((r = n.suspendedLanes), (r & i) !== i)) {
              (gi(), (n.pingedLanes |= n.suspendedLanes & r));
              break;
            }
            n.timeoutHandle = dx(Ta.bind(null, n, Ti, Bs), e);
            break;
          }
          Ta(n, Ti, Bs);
          break;
        case 4:
          if ((bo(n, i), (i & 4194240) === i)) break;
          for (e = n.eventTimes, r = -1; 0 < i; ) {
            var o = 31 - kr(i);
            ((s = 1 << o), (o = e[o]), o > r && (r = o), (i &= ~s));
          }
          if (
            ((i = r),
            (i = vn() - i),
            (i =
              (120 > i
                ? 120
                : 480 > i
                  ? 480
                  : 1080 > i
                    ? 1080
                    : 1920 > i
                      ? 1920
                      : 3e3 > i
                        ? 3e3
                        : 4320 > i
                          ? 4320
                          : 1960 * jF(i / 1960)) - i),
            10 < i)
          ) {
            n.timeoutHandle = dx(Ta.bind(null, n, Ti, Bs), i);
            break;
          }
          Ta(n, Ti, Bs);
          break;
        case 5:
          Ta(n, Ti, Bs);
          break;
        default:
          throw Error(be(329));
      }
    }
  }
  return (Ii(n, vn()), n.callbackNode === t ? w2.bind(null, n) : null);
}
function Ix(n, e) {
  var t = Af;
  return (
    n.current.memoizedState.isDehydrated && (Ja(n, e).flags |= 256),
    (n = Jm(n, e)),
    n !== 2 && ((e = Ti), (Ti = t), e !== null && Dx(e)),
    n
  );
}
function Dx(n) {
  Ti === null ? (Ti = n) : Ti.push.apply(Ti, n);
}
function JF(n) {
  for (var e = n; ; ) {
    if (e.flags & 16384) {
      var t = e.updateQueue;
      if (t !== null && ((t = t.stores), t !== null))
        for (var i = 0; i < t.length; i++) {
          var r = t[i],
            s = r.getSnapshot;
          r = r.value;
          try {
            if (!Gr(s(), r)) return !1;
          } catch {
            return !1;
          }
        }
    }
    if (((t = e.child), e.subtreeFlags & 16384 && t !== null))
      ((t.return = e), (e = t));
    else {
      if (e === n) break;
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === n) return !0;
        e = e.return;
      }
      ((e.sibling.return = e.return), (e = e.sibling));
    }
  }
  return !0;
}
function bo(n, e) {
  for (
    e &= ~L1,
      e &= ~Sg,
      n.suspendedLanes |= e,
      n.pingedLanes &= ~e,
      n = n.expirationTimes;
    0 < e;

  ) {
    var t = 31 - kr(e),
      i = 1 << t;
    ((n[t] = -1), (e &= ~i));
  }
}
function Zw(n) {
  if (Bt & 6) throw Error(be(327));
  Pc();
  var e = bm(n, 0);
  if (!(e & 1)) return (Ii(n, vn()), null);
  var t = Jm(n, e);
  if (n.tag !== 0 && t === 2) {
    var i = sx(n);
    i !== 0 && ((e = i), (t = Ix(n, i)));
  }
  if (t === 1) throw ((t = Qf), Ja(n, 0), bo(n, e), Ii(n, vn()), t);
  if (t === 6) throw Error(be(345));
  return (
    (n.finishedWork = n.current.alternate),
    (n.finishedLanes = e),
    Ta(n, Ti, Bs),
    Ii(n, vn()),
    null
  );
}
function D1(n, e) {
  var t = Bt;
  Bt |= 1;
  try {
    return n(e);
  } finally {
    ((Bt = t), Bt === 0 && ((Gc = vn() + 500), xg && ta()));
  }
}
function rl(n) {
  Bo !== null && Bo.tag === 0 && !(Bt & 6) && Pc();
  var e = Bt;
  Bt |= 1;
  var t = vr.transition,
    i = Ot;
  try {
    if (((vr.transition = null), (Ot = 1), n)) return n();
  } finally {
    ((Ot = i), (vr.transition = t), (Bt = e), !(Bt & 6) && ta());
  }
}
function F1() {
  ((Hi = gc.current), Yt(gc));
}
function Ja(n, e) {
  ((n.finishedWork = null), (n.finishedLanes = 0));
  var t = n.timeoutHandle;
  if ((t !== -1 && ((n.timeoutHandle = -1), MF(t)), wn !== null))
    for (t = wn.return; t !== null; ) {
      var i = t;
      switch ((m1(i), i.tag)) {
        case 1:
          ((i = i.type.childContextTypes), i != null && Im());
          break;
        case 3:
          (Uc(), Yt(Ri), Yt(oi), w1());
          break;
        case 5:
          S1(i);
          break;
        case 4:
          Uc();
          break;
        case 13:
          Yt(nn);
          break;
        case 19:
          Yt(nn);
          break;
        case 10:
          x1(i.type._context);
          break;
        case 22:
        case 23:
          F1();
      }
      t = t.return;
    }
  if (
    ((zn = n),
    (wn = n = zo(n.current, null)),
    (Xn = Hi = e),
    (Pn = 0),
    (Qf = null),
    (L1 = Sg = il = 0),
    (Ti = Af = null),
    ka !== null)
  ) {
    for (e = 0; e < ka.length; e++)
      if (((t = ka[e]), (i = t.interleaved), i !== null)) {
        t.interleaved = null;
        var r = i.next,
          s = t.pending;
        if (s !== null) {
          var o = s.next;
          ((s.next = r), (i.next = o));
        }
        t.pending = i;
      }
    ka = null;
  }
  return n;
}
function E2(n, e) {
  do {
    var t = wn;
    try {
      if ((y1(), (cm.current = Hm), Gm)) {
        for (var i = ln.memoizedState; i !== null; ) {
          var r = i.queue;
          (r !== null && (r.pending = null), (i = i.next));
        }
        Gm = !1;
      }
      if (
        ((nl = 0),
        (On = Tn = ln = null),
        (xf = !1),
        (Xf = 0),
        (R1.current = null),
        t === null || t.return === null)
      ) {
        ((Pn = 1), (Qf = e), (wn = null));
        break;
      }
      e: {
        var s = n,
          o = t.return,
          a = t,
          l = e;
        if (
          ((e = Xn),
          (a.flags |= 32768),
          l !== null && typeof l == "object" && typeof l.then == "function")
        ) {
          var u = l,
            h = a,
            d = h.tag;
          if (!(h.mode & 1) && (d === 0 || d === 11 || d === 15)) {
            var p = h.alternate;
            p
              ? ((h.updateQueue = p.updateQueue),
                (h.memoizedState = p.memoizedState),
                (h.lanes = p.lanes))
              : ((h.updateQueue = null), (h.memoizedState = null));
          }
          var g = Ow(o);
          if (g !== null) {
            ((g.flags &= -257),
              Uw(g, o, a, s, e),
              g.mode & 1 && kw(s, u, e),
              (e = g),
              (l = u));
            var y = e.updateQueue;
            if (y === null) {
              var A = new Set();
              (A.add(l), (e.updateQueue = A));
            } else y.add(l);
            break e;
          } else {
            if (!(e & 1)) {
              (kw(s, u, e), N1());
              break e;
            }
            l = Error(be(426));
          }
        } else if ($t && a.mode & 1) {
          var _ = Ow(o);
          if (_ !== null) {
            (!(_.flags & 65536) && (_.flags |= 256),
              Uw(_, o, a, s, e),
              g1(zc(l, a)));
            break e;
          }
        }
        ((s = l = zc(l, a)),
          Pn !== 4 && (Pn = 2),
          Af === null ? (Af = [s]) : Af.push(s),
          (s = o));
        do {
          switch (s.tag) {
            case 3:
              ((s.flags |= 65536), (e &= -e), (s.lanes |= e));
              var m = l2(s, l, e);
              Bw(s, m);
              break e;
            case 1:
              a = l;
              var x = s.type,
                S = s.stateNode;
              if (
                !(s.flags & 128) &&
                (typeof x.getDerivedStateFromError == "function" ||
                  (S !== null &&
                    typeof S.componentDidCatch == "function" &&
                    (Oo === null || !Oo.has(S))))
              ) {
                ((s.flags |= 65536), (e &= -e), (s.lanes |= e));
                var w = c2(s, a, e);
                Bw(s, w);
                break e;
              }
          }
          s = s.return;
        } while (s !== null);
      }
      b2(t);
    } catch (C) {
      ((e = C), wn === t && t !== null && (wn = t = t.return));
      continue;
    }
    break;
  } while (1);
}
function C2() {
  var n = Vm.current;
  return ((Vm.current = Hm), n === null ? Hm : n);
}
function N1() {
  ((Pn === 0 || Pn === 3 || Pn === 2) && (Pn = 4),
    zn === null || (!(il & 268435455) && !(Sg & 268435455)) || bo(zn, Xn));
}
function Jm(n, e) {
  var t = Bt;
  Bt |= 2;
  var i = C2();
  (zn !== n || Xn !== e) && ((Bs = null), Ja(n, e));
  do
    try {
      XF();
      break;
    } catch (r) {
      E2(n, r);
    }
  while (1);
  if ((y1(), (Bt = t), (Vm.current = i), wn !== null)) throw Error(be(261));
  return ((zn = null), (Xn = 0), Pn);
}
function XF() {
  for (; wn !== null; ) T2(wn);
}
function KF() {
  for (; wn !== null && !xD(); ) T2(wn);
}
function T2(n) {
  var e = B2(n.alternate, n, Hi);
  ((n.memoizedProps = n.pendingProps),
    e === null ? b2(n) : (wn = e),
    (R1.current = null));
}
function b2(n) {
  var e = n;
  do {
    var t = e.alternate;
    if (((n = e.return), e.flags & 32768)) {
      if (((t = GF(t, e)), t !== null)) {
        ((t.flags &= 32767), (wn = t));
        return;
      }
      if (n !== null)
        ((n.flags |= 32768), (n.subtreeFlags = 0), (n.deletions = null));
      else {
        ((Pn = 6), (wn = null));
        return;
      }
    } else if (((t = zF(t, e, Hi)), t !== null)) {
      wn = t;
      return;
    }
    if (((e = e.sibling), e !== null)) {
      wn = e;
      return;
    }
    wn = e = n;
  } while (e !== null);
  Pn === 0 && (Pn = 5);
}
function Ta(n, e, t) {
  var i = Ot,
    r = vr.transition;
  try {
    ((vr.transition = null), (Ot = 1), YF(n, e, t, i));
  } finally {
    ((vr.transition = r), (Ot = i));
  }
  return null;
}
function YF(n, e, t, i) {
  do Pc();
  while (Bo !== null);
  if (Bt & 6) throw Error(be(327));
  t = n.finishedWork;
  var r = n.finishedLanes;
  if (t === null) return null;
  if (((n.finishedWork = null), (n.finishedLanes = 0), t === n.current))
    throw Error(be(177));
  ((n.callbackNode = null), (n.callbackPriority = 0));
  var s = t.lanes | t.childLanes;
  if (
    (PD(n, s),
    n === zn && ((wn = zn = null), (Xn = 0)),
    (!(t.subtreeFlags & 2064) && !(t.flags & 2064)) ||
      sp ||
      ((sp = !0),
      R2(Tm, function () {
        return (Pc(), null);
      })),
    (s = (t.flags & 15990) !== 0),
    t.subtreeFlags & 15990 || s)
  ) {
    ((s = vr.transition), (vr.transition = null));
    var o = Ot;
    Ot = 1;
    var a = Bt;
    ((Bt |= 4),
      (R1.current = null),
      VF(n, t),
      M2(t, n),
      mF(fx),
      (Pm = !!ux),
      (fx = ux = null),
      (n.current = t),
      WF(t),
      _D(),
      (Bt = a),
      (Ot = o),
      (vr.transition = s));
  } else n.current = t;
  if (
    (sp && ((sp = !1), (Bo = n), (jm = r)),
    (s = n.pendingLanes),
    s === 0 && (Oo = null),
    SD(t.stateNode),
    Ii(n, vn()),
    e !== null)
  )
    for (i = n.onRecoverableError, t = 0; t < e.length; t++)
      ((r = e[t]), i(r.value, { componentStack: r.stack, digest: r.digest }));
  if (Wm) throw ((Wm = !1), (n = Rx), (Rx = null), n);
  return (
    jm & 1 && n.tag !== 0 && Pc(),
    (s = n.pendingLanes),
    s & 1 ? (n === Lx ? Mf++ : ((Mf = 0), (Lx = n))) : (Mf = 0),
    ta(),
    null
  );
}
function Pc() {
  if (Bo !== null) {
    var n = aP(jm),
      e = vr.transition,
      t = Ot;
    try {
      if (((vr.transition = null), (Ot = 16 > n ? 16 : n), Bo === null))
        var i = !1;
      else {
        if (((n = Bo), (Bo = null), (jm = 0), Bt & 6)) throw Error(be(331));
        var r = Bt;
        for (Bt |= 4, ze = n.current; ze !== null; ) {
          var s = ze,
            o = s.child;
          if (ze.flags & 16) {
            var a = s.deletions;
            if (a !== null) {
              for (var l = 0; l < a.length; l++) {
                var u = a[l];
                for (ze = u; ze !== null; ) {
                  var h = ze;
                  switch (h.tag) {
                    case 0:
                    case 11:
                    case 15:
                      _f(8, h, s);
                  }
                  var d = h.child;
                  if (d !== null) ((d.return = h), (ze = d));
                  else
                    for (; ze !== null; ) {
                      h = ze;
                      var p = h.sibling,
                        g = h.return;
                      if ((x2(h), h === u)) {
                        ze = null;
                        break;
                      }
                      if (p !== null) {
                        ((p.return = g), (ze = p));
                        break;
                      }
                      ze = g;
                    }
                }
              }
              var y = s.alternate;
              if (y !== null) {
                var A = y.child;
                if (A !== null) {
                  y.child = null;
                  do {
                    var _ = A.sibling;
                    ((A.sibling = null), (A = _));
                  } while (A !== null);
                }
              }
              ze = s;
            }
          }
          if (s.subtreeFlags & 2064 && o !== null) ((o.return = s), (ze = o));
          else
            e: for (; ze !== null; ) {
              if (((s = ze), s.flags & 2048))
                switch (s.tag) {
                  case 0:
                  case 11:
                  case 15:
                    _f(9, s, s.return);
                }
              var m = s.sibling;
              if (m !== null) {
                ((m.return = s.return), (ze = m));
                break e;
              }
              ze = s.return;
            }
        }
        var x = n.current;
        for (ze = x; ze !== null; ) {
          o = ze;
          var S = o.child;
          if (o.subtreeFlags & 2064 && S !== null) ((S.return = o), (ze = S));
          else
            e: for (o = x; ze !== null; ) {
              if (((a = ze), a.flags & 2048))
                try {
                  switch (a.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Mg(9, a);
                  }
                } catch (C) {
                  hn(a, a.return, C);
                }
              if (a === o) {
                ze = null;
                break e;
              }
              var w = a.sibling;
              if (w !== null) {
                ((w.return = a.return), (ze = w));
                break e;
              }
              ze = a.return;
            }
        }
        if (
          ((Bt = r), ta(), os && typeof os.onPostCommitFiberRoot == "function")
        )
          try {
            os.onPostCommitFiberRoot(pg, n);
          } catch {}
        i = !0;
      }
      return i;
    } finally {
      ((Ot = t), (vr.transition = e));
    }
  }
  return !1;
}
function qw(n, e, t) {
  ((e = zc(t, e)),
    (e = l2(n, e, 1)),
    (n = ko(n, e, 1)),
    (e = gi()),
    n !== null && (yh(n, 1, e), Ii(n, e)));
}
function hn(n, e, t) {
  if (n.tag === 3) qw(n, n, t);
  else
    for (; e !== null; ) {
      if (e.tag === 3) {
        qw(e, n, t);
        break;
      } else if (e.tag === 1) {
        var i = e.stateNode;
        if (
          typeof e.type.getDerivedStateFromError == "function" ||
          (typeof i.componentDidCatch == "function" &&
            (Oo === null || !Oo.has(i)))
        ) {
          ((n = zc(t, n)),
            (n = c2(e, n, 1)),
            (e = ko(e, n, 1)),
            (n = gi()),
            e !== null && (yh(e, 1, n), Ii(e, n)));
          break;
        }
      }
      e = e.return;
    }
}
function QF(n, e, t) {
  var i = n.pingCache;
  (i !== null && i.delete(e),
    (e = gi()),
    (n.pingedLanes |= n.suspendedLanes & t),
    zn === n &&
      (Xn & t) === t &&
      (Pn === 4 || (Pn === 3 && (Xn & 130023424) === Xn && 500 > vn() - I1)
        ? Ja(n, 0)
        : (L1 |= t)),
    Ii(n, e));
}
function P2(n, e) {
  e === 0 &&
    (n.mode & 1
      ? ((e = Yd), (Yd <<= 1), !(Yd & 130023424) && (Yd = 4194304))
      : (e = 1));
  var t = gi();
  ((n = Xs(n, e)), n !== null && (yh(n, e, t), Ii(n, t)));
}
function ZF(n) {
  var e = n.memoizedState,
    t = 0;
  (e !== null && (t = e.retryLane), P2(n, t));
}
function qF(n, e) {
  var t = 0;
  switch (n.tag) {
    case 13:
      var i = n.stateNode,
        r = n.memoizedState;
      r !== null && (t = r.retryLane);
      break;
    case 19:
      i = n.stateNode;
      break;
    default:
      throw Error(be(314));
  }
  (i !== null && i.delete(e), P2(n, t));
}
var B2;
B2 = function (n, e, t) {
  if (n !== null)
    if (n.memoizedProps !== e.pendingProps || Ri.current) Bi = !0;
    else {
      if (!(n.lanes & t) && !(e.flags & 128)) return ((Bi = !1), UF(n, e, t));
      Bi = !!(n.flags & 131072);
    }
  else ((Bi = !1), $t && e.flags & 1048576 && IP(e, Nm, e.index));
  switch (((e.lanes = 0), e.tag)) {
    case 2:
      var i = e.type;
      (fm(n, e), (n = e.pendingProps));
      var r = Nc(e, oi.current);
      (bc(e, t), (r = C1(null, e, i, n, r, t)));
      var s = T1();
      return (
        (e.flags |= 1),
        typeof r == "object" &&
        r !== null &&
        typeof r.render == "function" &&
        r.$$typeof === void 0
          ? ((e.tag = 1),
            (e.memoizedState = null),
            (e.updateQueue = null),
            Li(i) ? ((s = !0), Dm(e)) : (s = !1),
            (e.memoizedState =
              r.state !== null && r.state !== void 0 ? r.state : null),
            A1(e),
            (r.updater = _g),
            (e.stateNode = r),
            (r._reactInternals = e),
            _x(e, i, n, t),
            (e = Sx(null, e, i, !0, s, t)))
          : ((e.tag = 0), $t && s && p1(e), mi(null, e, r, t), (e = e.child)),
        e
      );
    case 16:
      i = e.elementType;
      e: {
        switch (
          (fm(n, e),
          (n = e.pendingProps),
          (r = i._init),
          (i = r(i._payload)),
          (e.type = i),
          (r = e.tag = eN(i)),
          (n = Lr(i, n)),
          r)
        ) {
          case 0:
            e = Mx(null, e, i, n, t);
            break e;
          case 1:
            e = Hw(null, e, i, n, t);
            break e;
          case 11:
            e = zw(null, e, i, n, t);
            break e;
          case 14:
            e = Gw(null, e, i, Lr(i.type, n), t);
            break e;
        }
        throw Error(be(306, i, ""));
      }
      return e;
    case 0:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : Lr(i, r)),
        Mx(n, e, i, r, t)
      );
    case 1:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : Lr(i, r)),
        Hw(n, e, i, r, t)
      );
    case 3:
      e: {
        if ((d2(e), n === null)) throw Error(be(387));
        ((i = e.pendingProps),
          (s = e.memoizedState),
          (r = s.element),
          kP(n, e),
          Um(e, i, null, t));
        var o = e.memoizedState;
        if (((i = o.element), s.isDehydrated))
          if (
            ((s = {
              element: i,
              isDehydrated: !1,
              cache: o.cache,
              pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
              transitions: o.transitions,
            }),
            (e.updateQueue.baseState = s),
            (e.memoizedState = s),
            e.flags & 256)
          ) {
            ((r = zc(Error(be(423)), e)), (e = Vw(n, e, i, t, r)));
            break e;
          } else if (i !== r) {
            ((r = zc(Error(be(424)), e)), (e = Vw(n, e, i, t, r)));
            break e;
          } else
            for (
              Wi = No(e.stateNode.containerInfo.firstChild),
                Xi = e,
                $t = !0,
                Fr = null,
                t = GP(e, null, i, t),
                e.child = t;
              t;

            )
              ((t.flags = (t.flags & -3) | 4096), (t = t.sibling));
        else {
          if ((kc(), i === r)) {
            e = Ks(n, e, t);
            break e;
          }
          mi(n, e, i, t);
        }
        e = e.child;
      }
      return e;
    case 5:
      return (
        HP(e),
        n === null && vx(e),
        (i = e.type),
        (r = e.pendingProps),
        (s = n !== null ? n.memoizedProps : null),
        (o = r.children),
        hx(i, r) ? (o = null) : s !== null && hx(i, s) && (e.flags |= 32),
        h2(n, e),
        mi(n, e, o, t),
        e.child
      );
    case 6:
      return (n === null && vx(e), null);
    case 13:
      return p2(n, e, t);
    case 4:
      return (
        M1(e, e.stateNode.containerInfo),
        (i = e.pendingProps),
        n === null ? (e.child = Oc(e, null, i, t)) : mi(n, e, i, t),
        e.child
      );
    case 11:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : Lr(i, r)),
        zw(n, e, i, r, t)
      );
    case 7:
      return (mi(n, e, e.pendingProps, t), e.child);
    case 8:
      return (mi(n, e, e.pendingProps.children, t), e.child);
    case 12:
      return (mi(n, e, e.pendingProps.children, t), e.child);
    case 10:
      e: {
        if (
          ((i = e.type._context),
          (r = e.pendingProps),
          (s = e.memoizedProps),
          (o = r.value),
          Jt(km, i._currentValue),
          (i._currentValue = o),
          s !== null)
        )
          if (Gr(s.value, o)) {
            if (s.children === r.children && !Ri.current) {
              e = Ks(n, e, t);
              break e;
            }
          } else
            for (s = e.child, s !== null && (s.return = e); s !== null; ) {
              var a = s.dependencies;
              if (a !== null) {
                o = s.child;
                for (var l = a.firstContext; l !== null; ) {
                  if (l.context === i) {
                    if (s.tag === 1) {
                      ((l = Gs(-1, t & -t)), (l.tag = 2));
                      var u = s.updateQueue;
                      if (u !== null) {
                        u = u.shared;
                        var h = u.pending;
                        (h === null
                          ? (l.next = l)
                          : ((l.next = h.next), (h.next = l)),
                          (u.pending = l));
                      }
                    }
                    ((s.lanes |= t),
                      (l = s.alternate),
                      l !== null && (l.lanes |= t),
                      yx(s.return, t, e),
                      (a.lanes |= t));
                    break;
                  }
                  l = l.next;
                }
              } else if (s.tag === 10) o = s.type === e.type ? null : s.child;
              else if (s.tag === 18) {
                if (((o = s.return), o === null)) throw Error(be(341));
                ((o.lanes |= t),
                  (a = o.alternate),
                  a !== null && (a.lanes |= t),
                  yx(o, t, e),
                  (o = s.sibling));
              } else o = s.child;
              if (o !== null) o.return = s;
              else
                for (o = s; o !== null; ) {
                  if (o === e) {
                    o = null;
                    break;
                  }
                  if (((s = o.sibling), s !== null)) {
                    ((s.return = o.return), (o = s));
                    break;
                  }
                  o = o.return;
                }
              s = o;
            }
        (mi(n, e, r.children, t), (e = e.child));
      }
      return e;
    case 9:
      return (
        (r = e.type),
        (i = e.pendingProps.children),
        bc(e, t),
        (r = yr(r)),
        (i = i(r)),
        (e.flags |= 1),
        mi(n, e, i, t),
        e.child
      );
    case 14:
      return (
        (i = e.type),
        (r = Lr(i, e.pendingProps)),
        (r = Lr(i.type, r)),
        Gw(n, e, i, r, t)
      );
    case 15:
      return u2(n, e, e.type, e.pendingProps, t);
    case 17:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : Lr(i, r)),
        fm(n, e),
        (e.tag = 1),
        Li(i) ? ((n = !0), Dm(e)) : (n = !1),
        bc(e, t),
        UP(e, i, r),
        _x(e, i, r, t),
        Sx(null, e, i, !0, n, t)
      );
    case 19:
      return m2(n, e, t);
    case 22:
      return f2(n, e, t);
  }
  throw Error(be(156, e.tag));
};
function R2(n, e) {
  return iP(n, e);
}
function $F(n, e, t, i) {
  ((this.tag = n),
    (this.key = t),
    (this.sibling =
      this.child =
      this.return =
      this.stateNode =
      this.type =
      this.elementType =
        null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = e),
    (this.dependencies =
      this.memoizedState =
      this.updateQueue =
      this.memoizedProps =
        null),
    (this.mode = i),
    (this.subtreeFlags = this.flags = 0),
    (this.deletions = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null));
}
function gr(n, e, t, i) {
  return new $F(n, e, t, i);
}
function k1(n) {
  return ((n = n.prototype), !(!n || !n.isReactComponent));
}
function eN(n) {
  if (typeof n == "function") return k1(n) ? 1 : 0;
  if (n != null) {
    if (((n = n.$$typeof), n === n1)) return 11;
    if (n === i1) return 14;
  }
  return 2;
}
function zo(n, e) {
  var t = n.alternate;
  return (
    t === null
      ? ((t = gr(n.tag, e, n.key, n.mode)),
        (t.elementType = n.elementType),
        (t.type = n.type),
        (t.stateNode = n.stateNode),
        (t.alternate = n),
        (n.alternate = t))
      : ((t.pendingProps = e),
        (t.type = n.type),
        (t.flags = 0),
        (t.subtreeFlags = 0),
        (t.deletions = null)),
    (t.flags = n.flags & 14680064),
    (t.childLanes = n.childLanes),
    (t.lanes = n.lanes),
    (t.child = n.child),
    (t.memoizedProps = n.memoizedProps),
    (t.memoizedState = n.memoizedState),
    (t.updateQueue = n.updateQueue),
    (e = n.dependencies),
    (t.dependencies =
      e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }),
    (t.sibling = n.sibling),
    (t.index = n.index),
    (t.ref = n.ref),
    t
  );
}
function pm(n, e, t, i, r, s) {
  var o = 2;
  if (((i = n), typeof n == "function")) k1(n) && (o = 1);
  else if (typeof n == "string") o = 5;
  else
    e: switch (n) {
      case oc:
        return Xa(t.children, r, s, e);
      case t1:
        ((o = 8), (r |= 8));
        break;
      case Wy:
        return (
          (n = gr(12, t, e, r | 2)),
          (n.elementType = Wy),
          (n.lanes = s),
          n
        );
      case jy:
        return ((n = gr(13, t, e, r)), (n.elementType = jy), (n.lanes = s), n);
      case Jy:
        return ((n = gr(19, t, e, r)), (n.elementType = Jy), (n.lanes = s), n);
      case zb:
        return wg(t, r, s, e);
      default:
        if (typeof n == "object" && n !== null)
          switch (n.$$typeof) {
            case Ob:
              o = 10;
              break e;
            case Ub:
              o = 9;
              break e;
            case n1:
              o = 11;
              break e;
            case i1:
              o = 14;
              break e;
            case So:
              ((o = 16), (i = null));
              break e;
          }
        throw Error(be(130, n == null ? n : typeof n, ""));
    }
  return (
    (e = gr(o, t, e, r)),
    (e.elementType = n),
    (e.type = i),
    (e.lanes = s),
    e
  );
}
function Xa(n, e, t, i) {
  return ((n = gr(7, n, i, e)), (n.lanes = t), n);
}
function wg(n, e, t, i) {
  return (
    (n = gr(22, n, i, e)),
    (n.elementType = zb),
    (n.lanes = t),
    (n.stateNode = { isHidden: !1 }),
    n
  );
}
function Dv(n, e, t) {
  return ((n = gr(6, n, null, e)), (n.lanes = t), n);
}
function Fv(n, e, t) {
  return (
    (e = gr(4, n.children !== null ? n.children : [], n.key, e)),
    (e.lanes = t),
    (e.stateNode = {
      containerInfo: n.containerInfo,
      pendingChildren: null,
      implementation: n.implementation,
    }),
    e
  );
}
function tN(n, e, t, i, r) {
  ((this.tag = e),
    (this.containerInfo = n),
    (this.finishedWork =
      this.pingCache =
      this.current =
      this.pendingChildren =
        null),
    (this.timeoutHandle = -1),
    (this.callbackNode = this.pendingContext = this.context = null),
    (this.callbackPriority = 0),
    (this.eventTimes = mv(0)),
    (this.expirationTimes = mv(-1)),
    (this.entangledLanes =
      this.finishedLanes =
      this.mutableReadLanes =
      this.expiredLanes =
      this.pingedLanes =
      this.suspendedLanes =
      this.pendingLanes =
        0),
    (this.entanglements = mv(0)),
    (this.identifierPrefix = i),
    (this.onRecoverableError = r),
    (this.mutableSourceEagerHydrationData = null));
}
function O1(n, e, t, i, r, s, o, a, l) {
  return (
    (n = new tN(n, e, t, a, l)),
    e === 1 ? ((e = 1), s === !0 && (e |= 8)) : (e = 0),
    (s = gr(3, null, null, e)),
    (n.current = s),
    (s.stateNode = n),
    (s.memoizedState = {
      element: i,
      isDehydrated: t,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null,
    }),
    A1(s),
    n
  );
}
function nN(n, e, t) {
  var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    $$typeof: sc,
    key: i == null ? null : "" + i,
    children: n,
    containerInfo: e,
    implementation: t,
  };
}
function L2(n) {
  if (!n) return Jo;
  n = n._reactInternals;
  e: {
    if (fl(n) !== n || n.tag !== 1) throw Error(be(170));
    var e = n;
    do {
      switch (e.tag) {
        case 3:
          e = e.stateNode.context;
          break e;
        case 1:
          if (Li(e.type)) {
            e = e.stateNode.__reactInternalMemoizedMergedChildContext;
            break e;
          }
      }
      e = e.return;
    } while (e !== null);
    throw Error(be(171));
  }
  if (n.tag === 1) {
    var t = n.type;
    if (Li(t)) return RP(n, t, e);
  }
  return e;
}
function I2(n, e, t, i, r, s, o, a, l) {
  return (
    (n = O1(t, i, !0, n, r, s, o, a, l)),
    (n.context = L2(null)),
    (t = n.current),
    (i = gi()),
    (r = Uo(t)),
    (s = Gs(i, r)),
    (s.callback = e ?? null),
    ko(t, s, r),
    (n.current.lanes = r),
    yh(n, r, i),
    Ii(n, i),
    n
  );
}
function Eg(n, e, t, i) {
  var r = e.current,
    s = gi(),
    o = Uo(r);
  return (
    (t = L2(t)),
    e.context === null ? (e.context = t) : (e.pendingContext = t),
    (e = Gs(s, o)),
    (e.payload = { element: n }),
    (i = i === void 0 ? null : i),
    i !== null && (e.callback = i),
    (n = ko(r, e, o)),
    n !== null && (Or(n, r, o, s), lm(n, r, o)),
    o
  );
}
function Xm(n) {
  if (((n = n.current), !n.child)) return null;
  switch (n.child.tag) {
    case 5:
      return n.child.stateNode;
    default:
      return n.child.stateNode;
  }
}
function $w(n, e) {
  if (((n = n.memoizedState), n !== null && n.dehydrated !== null)) {
    var t = n.retryLane;
    n.retryLane = t !== 0 && t < e ? t : e;
  }
}
function U1(n, e) {
  ($w(n, e), (n = n.alternate) && $w(n, e));
}
function iN() {
  return null;
}
var D2 =
  typeof reportError == "function"
    ? reportError
    : function (n) {
        console.error(n);
      };
function z1(n) {
  this._internalRoot = n;
}
Cg.prototype.render = z1.prototype.render = function (n) {
  var e = this._internalRoot;
  if (e === null) throw Error(be(409));
  Eg(n, e, null, null);
};
Cg.prototype.unmount = z1.prototype.unmount = function () {
  var n = this._internalRoot;
  if (n !== null) {
    this._internalRoot = null;
    var e = n.containerInfo;
    (rl(function () {
      Eg(null, n, null, null);
    }),
      (e[Js] = null));
  }
};
function Cg(n) {
  this._internalRoot = n;
}
Cg.prototype.unstable_scheduleHydration = function (n) {
  if (n) {
    var e = uP();
    n = { blockedOn: null, target: n, priority: e };
    for (var t = 0; t < To.length && e !== 0 && e < To[t].priority; t++);
    (To.splice(t, 0, n), t === 0 && hP(n));
  }
};
function G1(n) {
  return !(!n || (n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11));
}
function Tg(n) {
  return !(
    !n ||
    (n.nodeType !== 1 &&
      n.nodeType !== 9 &&
      n.nodeType !== 11 &&
      (n.nodeType !== 8 || n.nodeValue !== " react-mount-point-unstable "))
  );
}
function eE() {}
function rN(n, e, t, i, r) {
  if (r) {
    if (typeof i == "function") {
      var s = i;
      i = function () {
        var u = Xm(o);
        s.call(u);
      };
    }
    var o = I2(e, i, n, 0, null, !1, !1, "", eE);
    return (
      (n._reactRootContainer = o),
      (n[Js] = o.current),
      Hf(n.nodeType === 8 ? n.parentNode : n),
      rl(),
      o
    );
  }
  for (; (r = n.lastChild); ) n.removeChild(r);
  if (typeof i == "function") {
    var a = i;
    i = function () {
      var u = Xm(l);
      a.call(u);
    };
  }
  var l = O1(n, 0, !1, null, null, !1, !1, "", eE);
  return (
    (n._reactRootContainer = l),
    (n[Js] = l.current),
    Hf(n.nodeType === 8 ? n.parentNode : n),
    rl(function () {
      Eg(e, l, t, i);
    }),
    l
  );
}
function bg(n, e, t, i, r) {
  var s = t._reactRootContainer;
  if (s) {
    var o = s;
    if (typeof r == "function") {
      var a = r;
      r = function () {
        var l = Xm(o);
        a.call(l);
      };
    }
    Eg(e, o, n, r);
  } else o = rN(t, e, n, r, i);
  return Xm(o);
}
lP = function (n) {
  switch (n.tag) {
    case 3:
      var e = n.stateNode;
      if (e.current.memoizedState.isDehydrated) {
        var t = cf(e.pendingLanes);
        t !== 0 &&
          (o1(e, t | 1), Ii(e, vn()), !(Bt & 6) && ((Gc = vn() + 500), ta()));
      }
      break;
    case 13:
      (rl(function () {
        var i = Xs(n, 1);
        if (i !== null) {
          var r = gi();
          Or(i, n, 1, r);
        }
      }),
        U1(n, 1));
  }
};
a1 = function (n) {
  if (n.tag === 13) {
    var e = Xs(n, 134217728);
    if (e !== null) {
      var t = gi();
      Or(e, n, 134217728, t);
    }
    U1(n, 134217728);
  }
};
cP = function (n) {
  if (n.tag === 13) {
    var e = Uo(n),
      t = Xs(n, e);
    if (t !== null) {
      var i = gi();
      Or(t, n, e, i);
    }
    U1(n, e);
  }
};
uP = function () {
  return Ot;
};
fP = function (n, e) {
  var t = Ot;
  try {
    return ((Ot = n), e());
  } finally {
    Ot = t;
  }
};
nx = function (n, e, t) {
  switch (e) {
    case "input":
      if ((Yy(n, t), (e = t.name), t.type === "radio" && e != null)) {
        for (t = n; t.parentNode; ) t = t.parentNode;
        for (
          t = t.querySelectorAll(
            "input[name=" + JSON.stringify("" + e) + '][type="radio"]'
          ),
            e = 0;
          e < t.length;
          e++
        ) {
          var i = t[e];
          if (i !== n && i.form === n.form) {
            var r = yg(i);
            if (!r) throw Error(be(90));
            (Hb(i), Yy(i, r));
          }
        }
      }
      break;
    case "textarea":
      Wb(n, t);
      break;
    case "select":
      ((e = t.value), e != null && wc(n, !!t.multiple, e, !1));
  }
};
Zb = D1;
qb = rl;
var sN = { usingClientEntryPoint: !1, Events: [_h, uc, yg, Yb, Qb, D1] },
  Gu = {
    findFiberByHostInstance: Na,
    bundleType: 0,
    version: "18.2.0",
    rendererPackageName: "react-dom",
  },
  oN = {
    bundleType: Gu.bundleType,
    version: Gu.version,
    rendererPackageName: Gu.rendererPackageName,
    rendererConfig: Gu.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: $s.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (n) {
      return ((n = tP(n)), n === null ? null : n.stateNode);
    },
    findFiberByHostInstance: Gu.findFiberByHostInstance || iN,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.2.0-next-9e3b772b8-20220608",
  };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var op = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!op.isDisabled && op.supportsFiber)
    try {
      ((pg = op.inject(oN)), (os = op));
    } catch {}
}
qi.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sN;
qi.createPortal = function (n, e) {
  var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!G1(e)) throw Error(be(200));
  return nN(n, e, null, t);
};
qi.createRoot = function (n, e) {
  if (!G1(n)) throw Error(be(299));
  var t = !1,
    i = "",
    r = D2;
  return (
    e != null &&
      (e.unstable_strictMode === !0 && (t = !0),
      e.identifierPrefix !== void 0 && (i = e.identifierPrefix),
      e.onRecoverableError !== void 0 && (r = e.onRecoverableError)),
    (e = O1(n, 1, !1, null, null, t, !1, i, r)),
    (n[Js] = e.current),
    Hf(n.nodeType === 8 ? n.parentNode : n),
    new z1(e)
  );
};
qi.findDOMNode = function (n) {
  if (n == null) return null;
  if (n.nodeType === 1) return n;
  var e = n._reactInternals;
  if (e === void 0)
    throw typeof n.render == "function"
      ? Error(be(188))
      : ((n = Object.keys(n).join(",")), Error(be(268, n)));
  return ((n = tP(e)), (n = n === null ? null : n.stateNode), n);
};
qi.flushSync = function (n) {
  return rl(n);
};
qi.hydrate = function (n, e, t) {
  if (!Tg(e)) throw Error(be(200));
  return bg(null, n, e, !0, t);
};
qi.hydrateRoot = function (n, e, t) {
  if (!G1(n)) throw Error(be(405));
  var i = (t != null && t.hydratedSources) || null,
    r = !1,
    s = "",
    o = D2;
  if (
    (t != null &&
      (t.unstable_strictMode === !0 && (r = !0),
      t.identifierPrefix !== void 0 && (s = t.identifierPrefix),
      t.onRecoverableError !== void 0 && (o = t.onRecoverableError)),
    (e = I2(e, null, n, 1, t ?? null, r, !1, s, o)),
    (n[Js] = e.current),
    Hf(n),
    i)
  )
    for (n = 0; n < i.length; n++)
      ((t = i[n]),
        (r = t._getVersion),
        (r = r(t._source)),
        e.mutableSourceEagerHydrationData == null
          ? (e.mutableSourceEagerHydrationData = [t, r])
          : e.mutableSourceEagerHydrationData.push(t, r));
  return new Cg(e);
};
qi.render = function (n, e, t) {
  if (!Tg(e)) throw Error(be(200));
  return bg(null, n, e, !1, t);
};
qi.unmountComponentAtNode = function (n) {
  if (!Tg(n)) throw Error(be(40));
  return n._reactRootContainer
    ? (rl(function () {
        bg(null, null, n, !1, function () {
          ((n._reactRootContainer = null), (n[Js] = null));
        });
      }),
      !0)
    : !1;
};
qi.unstable_batchedUpdates = D1;
qi.unstable_renderSubtreeIntoContainer = function (n, e, t, i) {
  if (!Tg(t)) throw Error(be(200));
  if (n == null || n._reactInternals === void 0) throw Error(be(38));
  return bg(n, e, t, !1, i);
};
qi.version = "18.2.0-next-9e3b772b8-20220608";
(function (n) {
  function e() {
    if (
      !(
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
      )
    )
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  (e(), (n.exports = qi));
})(iD);
var F2,
  tE = Gy;
((F2 = zy.createRoot = tE.createRoot), (zy.hydrateRoot = tE.hydrateRoot));
/**
 * @remix-run/router v1.5.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function Zf() {
  return (
    (Zf = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
              Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
          }
          return n;
        }),
    Zf.apply(this, arguments)
  );
}
var Ua;
(function (n) {
  ((n.Pop = "POP"), (n.Push = "PUSH"), (n.Replace = "REPLACE"));
})(Ua || (Ua = {}));
const nE = "popstate";
function aN(n) {
  n === void 0 && (n = {});
  function e(i, r) {
    let { pathname: s, search: o, hash: a } = i.location;
    return Fx(
      "",
      { pathname: s, search: o, hash: a },
      (r.state && r.state.usr) || null,
      (r.state && r.state.key) || "default"
    );
  }
  function t(i, r) {
    return typeof r == "string" ? r : Km(r);
  }
  return cN(e, t, null, n);
}
function Go(n, e) {
  if (n === !1 || n === null || typeof n > "u") throw new Error(e);
}
function lN() {
  return Math.random().toString(36).substr(2, 8);
}
function iE(n, e) {
  return { usr: n.state, key: n.key, idx: e };
}
function Fx(n, e, t, i) {
  return (
    t === void 0 && (t = null),
    Zf(
      { pathname: typeof n == "string" ? n : n.pathname, search: "", hash: "" },
      typeof e == "string" ? Pg(e) : e,
      { state: t, key: (e && e.key) || i || lN() }
    )
  );
}
function Km(n) {
  let { pathname: e = "/", search: t = "", hash: i = "" } = n;
  return (
    t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t),
    i && i !== "#" && (e += i.charAt(0) === "#" ? i : "#" + i),
    e
  );
}
function Pg(n) {
  let e = {};
  if (n) {
    let t = n.indexOf("#");
    t >= 0 && ((e.hash = n.substr(t)), (n = n.substr(0, t)));
    let i = n.indexOf("?");
    (i >= 0 && ((e.search = n.substr(i)), (n = n.substr(0, i))),
      n && (e.pathname = n));
  }
  return e;
}
function cN(n, e, t, i) {
  i === void 0 && (i = {});
  let { window: r = document.defaultView, v5Compat: s = !1 } = i,
    o = r.history,
    a = Ua.Pop,
    l = null,
    u = h();
  u == null && ((u = 0), o.replaceState(Zf({}, o.state, { idx: u }), ""));
  function h() {
    return (o.state || { idx: null }).idx;
  }
  function d() {
    a = Ua.Pop;
    let _ = h(),
      m = _ == null ? null : _ - u;
    ((u = _), l && l({ action: a, location: A.location, delta: m }));
  }
  function p(_, m) {
    a = Ua.Push;
    let x = Fx(A.location, _, m);
    (t && t(x, _), (u = h() + 1));
    let S = iE(x, u),
      w = A.createHref(x);
    try {
      o.pushState(S, "", w);
    } catch {
      r.location.assign(w);
    }
    s && l && l({ action: a, location: A.location, delta: 1 });
  }
  function g(_, m) {
    a = Ua.Replace;
    let x = Fx(A.location, _, m);
    (t && t(x, _), (u = h()));
    let S = iE(x, u),
      w = A.createHref(x);
    (o.replaceState(S, "", w),
      s && l && l({ action: a, location: A.location, delta: 0 }));
  }
  function y(_) {
    let m = r.location.origin !== "null" ? r.location.origin : r.location.href,
      x = typeof _ == "string" ? _ : Km(_);
    return (
      Go(
        m,
        "No window.location.(origin|href) available to create URL for href: " +
          x
      ),
      new URL(x, m)
    );
  }
  let A = {
    get action() {
      return a;
    },
    get location() {
      return n(r, o);
    },
    listen(_) {
      if (l) throw new Error("A history only accepts one active listener");
      return (
        r.addEventListener(nE, d),
        (l = _),
        () => {
          (r.removeEventListener(nE, d), (l = null));
        }
      );
    },
    createHref(_) {
      return e(r, _);
    },
    createURL: y,
    encodeLocation(_) {
      let m = y(_);
      return { pathname: m.pathname, search: m.search, hash: m.hash };
    },
    push: p,
    replace: g,
    go(_) {
      return o.go(_);
    },
  };
  return A;
}
var rE;
(function (n) {
  ((n.data = "data"),
    (n.deferred = "deferred"),
    (n.redirect = "redirect"),
    (n.error = "error"));
})(rE || (rE = {}));
function N2(n, e) {
  if (e === "/") return n;
  if (!n.toLowerCase().startsWith(e.toLowerCase())) return null;
  let t = e.endsWith("/") ? e.length - 1 : e.length,
    i = n.charAt(t);
  return i && i !== "/" ? null : n.slice(t) || "/";
}
function uN(n, e) {
  e === void 0 && (e = "/");
  let {
    pathname: t,
    search: i = "",
    hash: r = "",
  } = typeof n == "string" ? Pg(n) : n;
  return {
    pathname: t ? (t.startsWith("/") ? t : fN(t, e)) : e,
    search: hN(i),
    hash: dN(r),
  };
}
function fN(n, e) {
  let t = e.replace(/\/+$/, "").split("/");
  return (
    n.split("/").forEach((r) => {
      r === ".." ? t.length > 1 && t.pop() : r !== "." && t.push(r);
    }),
    t.length > 1 ? t.join("/") : "/"
  );
}
function Nv(n, e, t, i) {
  return (
    "Cannot include a '" +
    n +
    "' character in a manually specified " +
    ("`to." +
      e +
      "` field [" +
      JSON.stringify(i) +
      "].  Please separate it out to the ") +
    ("`to." + t + "` field. Alternatively you may provide the full path as ") +
    'a string in <Link to="..."> and the router will parse it for you.'
  );
}
function k2(n) {
  return n.filter(
    (e, t) => t === 0 || (e.route.path && e.route.path.length > 0)
  );
}
function O2(n, e, t, i) {
  i === void 0 && (i = !1);
  let r;
  typeof n == "string"
    ? (r = Pg(n))
    : ((r = Zf({}, n)),
      Go(
        !r.pathname || !r.pathname.includes("?"),
        Nv("?", "pathname", "search", r)
      ),
      Go(
        !r.pathname || !r.pathname.includes("#"),
        Nv("#", "pathname", "hash", r)
      ),
      Go(!r.search || !r.search.includes("#"), Nv("#", "search", "hash", r)));
  let s = n === "" || r.pathname === "",
    o = s ? "/" : r.pathname,
    a;
  if (i || o == null) a = t;
  else {
    let d = e.length - 1;
    if (o.startsWith("..")) {
      let p = o.split("/");
      for (; p[0] === ".."; ) (p.shift(), (d -= 1));
      r.pathname = p.join("/");
    }
    a = d >= 0 ? e[d] : "/";
  }
  let l = uN(r, a),
    u = o && o !== "/" && o.endsWith("/"),
    h = (s || o === ".") && t.endsWith("/");
  return (!l.pathname.endsWith("/") && (u || h) && (l.pathname += "/"), l);
}
const U2 = (n) => n.join("/").replace(/\/\/+/g, "/"),
  hN = (n) => (!n || n === "?" ? "" : n.startsWith("?") ? n : "?" + n),
  dN = (n) => (!n || n === "#" ? "" : n.startsWith("#") ? n : "#" + n);
/**
 * React Router v6.10.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function pN(n, e) {
  return (n === e && (n !== 0 || 1 / n === 1 / e)) || (n !== n && e !== e);
}
const mN = typeof Object.is == "function" ? Object.is : pN,
  { useState: gN, useEffect: vN, useLayoutEffect: yN, useDebugValue: xN } = Uy;
function _N(n, e, t) {
  const i = e(),
    [{ inst: r }, s] = gN({ inst: { value: i, getSnapshot: e } });
  return (
    yN(() => {
      ((r.value = i), (r.getSnapshot = e), kv(r) && s({ inst: r }));
    }, [n, i, e]),
    vN(
      () => (
        kv(r) && s({ inst: r }),
        n(() => {
          kv(r) && s({ inst: r });
        })
      ),
      [n]
    ),
    xN(i),
    i
  );
}
function kv(n) {
  const e = n.getSnapshot,
    t = n.value;
  try {
    const i = e();
    return !mN(t, i);
  } catch {
    return !0;
  }
}
function AN(n, e, t) {
  return e();
}
const MN =
    typeof window < "u" &&
    typeof window.document < "u" &&
    typeof window.document.createElement < "u",
  SN = !MN,
  wN = SN ? AN : _N;
"useSyncExternalStore" in Uy && ((n) => n.useSyncExternalStore)(Uy);
const Bg = H.createContext(null),
  H1 = H.createContext(null),
  z2 = H.createContext({ outlet: null, matches: [] });
function EN(n, e) {
  let { relative: t } = e === void 0 ? {} : e;
  Rg() || Go(!1);
  let { basename: i, navigator: r } = H.useContext(Bg),
    { hash: s, pathname: o, search: a } = G2(n, { relative: t }),
    l = o;
  return (
    i !== "/" && (l = o === "/" ? i : U2([i, o])),
    r.createHref({ pathname: l, search: a, hash: s })
  );
}
function Rg() {
  return H.useContext(H1) != null;
}
function V1() {
  return (Rg() || Go(!1), H.useContext(H1).location);
}
function CN() {
  Rg() || Go(!1);
  let { basename: n, navigator: e } = H.useContext(Bg),
    { matches: t } = H.useContext(z2),
    { pathname: i } = V1(),
    r = JSON.stringify(k2(t).map((a) => a.pathnameBase)),
    s = H.useRef(!1);
  return (
    H.useEffect(() => {
      s.current = !0;
    }),
    H.useCallback(
      function (a, l) {
        if ((l === void 0 && (l = {}), !s.current)) return;
        if (typeof a == "number") {
          e.go(a);
          return;
        }
        let u = O2(a, JSON.parse(r), i, l.relative === "path");
        (n !== "/" &&
          (u.pathname = u.pathname === "/" ? n : U2([n, u.pathname])),
          (l.replace ? e.replace : e.push)(u, l.state, l));
      },
      [n, e, r, i]
    )
  );
}
function G2(n, e) {
  let { relative: t } = e === void 0 ? {} : e,
    { matches: i } = H.useContext(z2),
    { pathname: r } = V1(),
    s = JSON.stringify(k2(i).map((o) => o.pathnameBase));
  return H.useMemo(() => O2(n, JSON.parse(s), r, t === "path"), [n, s, r, t]);
}
var sE;
(function (n) {
  ((n.UseBlocker = "useBlocker"), (n.UseRevalidator = "useRevalidator"));
})(sE || (sE = {}));
var oE;
(function (n) {
  ((n.UseBlocker = "useBlocker"),
    (n.UseLoaderData = "useLoaderData"),
    (n.UseActionData = "useActionData"),
    (n.UseRouteError = "useRouteError"),
    (n.UseNavigation = "useNavigation"),
    (n.UseRouteLoaderData = "useRouteLoaderData"),
    (n.UseMatches = "useMatches"),
    (n.UseRevalidator = "useRevalidator"));
})(oE || (oE = {}));
function TN(n) {
  let {
    basename: e = "/",
    children: t = null,
    location: i,
    navigationType: r = Ua.Pop,
    navigator: s,
    static: o = !1,
  } = n;
  Rg() && Go(!1);
  let a = e.replace(/^\/*/, "/"),
    l = H.useMemo(() => ({ basename: a, navigator: s, static: o }), [a, s, o]);
  typeof i == "string" && (i = Pg(i));
  let {
      pathname: u = "/",
      search: h = "",
      hash: d = "",
      state: p = null,
      key: g = "default",
    } = i,
    y = H.useMemo(() => {
      let A = N2(u, a);
      return A == null
        ? null
        : {
            location: { pathname: A, search: h, hash: d, state: p, key: g },
            navigationType: r,
          };
    }, [a, u, h, d, p, g, r]);
  return y == null
    ? null
    : H.createElement(
        Bg.Provider,
        { value: l },
        H.createElement(H1.Provider, { children: t, value: y })
      );
}
var aE;
(function (n) {
  ((n[(n.pending = 0)] = "pending"),
    (n[(n.success = 1)] = "success"),
    (n[(n.error = 2)] = "error"));
})(aE || (aE = {}));
new Promise(() => {});
/**
 * React Router DOM v6.10.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function Nx() {
  return (
    (Nx = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
              Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
          }
          return n;
        }),
    Nx.apply(this, arguments)
  );
}
function bN(n, e) {
  if (n == null) return {};
  var t = {},
    i = Object.keys(n),
    r,
    s;
  for (s = 0; s < i.length; s++)
    ((r = i[s]), !(e.indexOf(r) >= 0) && (t[r] = n[r]));
  return t;
}
function PN(n) {
  return !!(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey);
}
function BN(n, e) {
  return n.button === 0 && (!e || e === "_self") && !PN(n);
}
const RN = [
  "onClick",
  "relative",
  "reloadDocument",
  "replace",
  "state",
  "target",
  "to",
  "preventScrollReset",
];
function LN(n) {
  let { basename: e, children: t, window: i } = n,
    r = H.useRef();
  r.current == null && (r.current = aN({ window: i, v5Compat: !0 }));
  let s = r.current,
    [o, a] = H.useState({ action: s.action, location: s.location });
  return (
    H.useLayoutEffect(() => s.listen(a), [s]),
    H.createElement(TN, {
      basename: e,
      children: t,
      location: o.location,
      navigationType: o.action,
      navigator: s,
    })
  );
}
const IN =
    typeof window < "u" &&
    typeof window.document < "u" &&
    typeof window.document.createElement < "u",
  DN = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
  FN = H.forwardRef(function (e, t) {
    let {
        onClick: i,
        relative: r,
        reloadDocument: s,
        replace: o,
        state: a,
        target: l,
        to: u,
        preventScrollReset: h,
      } = e,
      d = bN(e, RN),
      { basename: p } = H.useContext(Bg),
      g,
      y = !1;
    if (typeof u == "string" && DN.test(u) && ((g = u), IN)) {
      let x = new URL(window.location.href),
        S = u.startsWith("//") ? new URL(x.protocol + u) : new URL(u),
        w = N2(S.pathname, p);
      S.origin === x.origin && w != null
        ? (u = w + S.search + S.hash)
        : (y = !0);
    }
    let A = EN(u, { relative: r }),
      _ = NN(u, {
        replace: o,
        state: a,
        target: l,
        preventScrollReset: h,
        relative: r,
      });
    function m(x) {
      (i && i(x), x.defaultPrevented || _(x));
    }
    return H.createElement(
      "a",
      Nx({}, d, { href: g || A, onClick: y || s ? i : m, ref: t, target: l })
    );
  });
var lE;
(function (n) {
  ((n.UseScrollRestoration = "useScrollRestoration"),
    (n.UseSubmitImpl = "useSubmitImpl"),
    (n.UseFetcher = "useFetcher"));
})(lE || (lE = {}));
var cE;
(function (n) {
  ((n.UseFetchers = "useFetchers"),
    (n.UseScrollRestoration = "useScrollRestoration"));
})(cE || (cE = {}));
function NN(n, e) {
  let {
      target: t,
      replace: i,
      state: r,
      preventScrollReset: s,
      relative: o,
    } = e === void 0 ? {} : e,
    a = CN(),
    l = V1(),
    u = G2(n, { relative: o });
  return H.useCallback(
    (h) => {
      if (BN(h, t)) {
        h.preventDefault();
        let d = i !== void 0 ? i : Km(l) === Km(u);
        a(n, { replace: d, state: r, preventScrollReset: s, relative: o });
      }
    },
    [l, a, u, i, r, t, n, s, o]
  );
}
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const Lg = "151",
  ba = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  Pa = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  H2 = 0,
  kx = 1,
  V2 = 2,
  kN = 3,
  W2 = 0,
  Ig = 1,
  Sf = 2,
  za = 3,
  fs = 0,
  vi = 1,
  mr = 2,
  ON = 2,
  Hs = 0,
  Ka = 1,
  Ox = 2,
  Ux = 3,
  zx = 4,
  j2 = 5,
  Da = 100,
  J2 = 101,
  X2 = 102,
  Gx = 103,
  Hx = 104,
  K2 = 200,
  Y2 = 201,
  Q2 = 202,
  Z2 = 203,
  W1 = 204,
  j1 = 205,
  q2 = 206,
  $2 = 207,
  eB = 208,
  tB = 209,
  nB = 210,
  iB = 0,
  rB = 1,
  sB = 2,
  Ym = 3,
  oB = 4,
  aB = 5,
  lB = 6,
  cB = 7,
  Mh = 0,
  uB = 1,
  fB = 2,
  Ur = 0,
  hB = 1,
  dB = 2,
  pB = 3,
  J1 = 4,
  mB = 5,
  Dg = 300,
  Xo = 301,
  Ko = 302,
  qf = 303,
  $f = 304,
  iu = 306,
  Yo = 1e3,
  jn = 1001,
  Hc = 1002,
  dn = 1003,
  eh = 1004,
  UN = 1004,
  Bc = 1005,
  zN = 1005,
  rn = 1006,
  Fg = 1007,
  GN = 1007,
  hs = 1008,
  HN = 1008,
  Ys = 1009,
  gB = 1010,
  vB = 1011,
  X1 = 1012,
  yB = 1013,
  Ro = 1014,
  Os = 1015,
  Vc = 1016,
  xB = 1017,
  _B = 1018,
  Ya = 1020,
  AB = 1021,
  Pi = 1023,
  MB = 1024,
  SB = 1025,
  Ho = 1026,
  sl = 1027,
  wB = 1028,
  EB = 1029,
  CB = 1030,
  TB = 1031,
  bB = 1033,
  mm = 33776,
  gm = 33777,
  vm = 33778,
  ym = 33779,
  Vx = 35840,
  Wx = 35841,
  jx = 35842,
  Jx = 35843,
  PB = 36196,
  Xx = 37492,
  Kx = 37496,
  Yx = 37808,
  Qx = 37809,
  Zx = 37810,
  qx = 37811,
  $x = 37812,
  e_ = 37813,
  t_ = 37814,
  n_ = 37815,
  i_ = 37816,
  r_ = 37817,
  s_ = 37818,
  o_ = 37819,
  a_ = 37820,
  l_ = 37821,
  xm = 36492,
  BB = 36283,
  c_ = 36284,
  u_ = 36285,
  f_ = 36286,
  RB = 2200,
  LB = 2201,
  IB = 2202,
  Wc = 2300,
  ol = 2301,
  _m = 2302,
  Ga = 2400,
  Ha = 2401,
  th = 2402,
  Ng = 2500,
  K1 = 2501,
  VN = 0,
  DB = 1,
  Y1 = 2,
  Qs = 3e3,
  Tt = 3001,
  FB = 3200,
  NB = 3201,
  eo = 0,
  kB = 1,
  WN = "",
  Dr = "srgb",
  jc = "srgb-linear",
  Q1 = "display-p3",
  jN = 0,
  Am = 7680,
  JN = 7681,
  XN = 7682,
  KN = 7683,
  YN = 34055,
  QN = 34056,
  ZN = 5386,
  qN = 512,
  $N = 513,
  ek = 514,
  tk = 515,
  nk = 516,
  ik = 517,
  rk = 518,
  OB = 519,
  nh = 35044,
  Qa = 35048,
  sk = 35040,
  ok = 35045,
  ak = 35049,
  lk = 35041,
  ck = 35046,
  uk = 35050,
  fk = 35042,
  hk = "100",
  h_ = "300 es",
  Qm = 1035;
class ps {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    (i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t));
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const i = this._listeners;
    return i[e] !== void 0 && i[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e];
    if (r !== void 0) {
      const s = r.indexOf(t);
      s !== -1 && r.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const r = i.slice(0);
      for (let s = 0, o = r.length; s < o; s++) r[s].call(this, e);
      e.target = null;
    }
  }
}
const ii = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let uE = 1234567;
const Za = Math.PI / 180,
  Jc = 180 / Math.PI;
function Ki() {
  const n = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    i = (Math.random() * 4294967295) | 0;
  return (
    ii[n & 255] +
    ii[(n >> 8) & 255] +
    ii[(n >> 16) & 255] +
    ii[(n >> 24) & 255] +
    "-" +
    ii[e & 255] +
    ii[(e >> 8) & 255] +
    "-" +
    ii[((e >> 16) & 15) | 64] +
    ii[(e >> 24) & 255] +
    "-" +
    ii[(t & 63) | 128] +
    ii[(t >> 8) & 255] +
    "-" +
    ii[(t >> 16) & 255] +
    ii[(t >> 24) & 255] +
    ii[i & 255] +
    ii[(i >> 8) & 255] +
    ii[(i >> 16) & 255] +
    ii[(i >> 24) & 255]
  ).toLowerCase();
}
function pn(n, e, t) {
  return Math.max(e, Math.min(t, n));
}
function Z1(n, e) {
  return ((n % e) + e) % e;
}
function dk(n, e, t, i, r) {
  return i + ((n - e) * (r - i)) / (t - e);
}
function pk(n, e, t) {
  return n !== e ? (t - n) / (e - n) : 0;
}
function wf(n, e, t) {
  return (1 - t) * n + t * e;
}
function mk(n, e, t, i) {
  return wf(n, e, 1 - Math.exp(-t * i));
}
function gk(n, e = 1) {
  return e - Math.abs(Z1(n, e * 2) - e);
}
function vk(n, e, t) {
  return n <= e
    ? 0
    : n >= t
      ? 1
      : ((n = (n - e) / (t - e)), n * n * (3 - 2 * n));
}
function yk(n, e, t) {
  return n <= e
    ? 0
    : n >= t
      ? 1
      : ((n = (n - e) / (t - e)), n * n * n * (n * (n * 6 - 15) + 10));
}
function xk(n, e) {
  return n + Math.floor(Math.random() * (e - n + 1));
}
function _k(n, e) {
  return n + Math.random() * (e - n);
}
function Ak(n) {
  return n * (0.5 - Math.random());
}
function Mk(n) {
  n !== void 0 && (uE = n);
  let e = (uE += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function Sk(n) {
  return n * Za;
}
function wk(n) {
  return n * Jc;
}
function d_(n) {
  return (n & (n - 1)) === 0 && n !== 0;
}
function UB(n) {
  return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
}
function zB(n) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
}
function Ek(n, e, t, i, r) {
  const s = Math.cos,
    o = Math.sin,
    a = s(t / 2),
    l = o(t / 2),
    u = s((e + i) / 2),
    h = o((e + i) / 2),
    d = s((e - i) / 2),
    p = o((e - i) / 2),
    g = s((i - e) / 2),
    y = o((i - e) / 2);
  switch (r) {
    case "XYX":
      n.set(a * h, l * d, l * p, a * u);
      break;
    case "YZY":
      n.set(l * p, a * h, l * d, a * u);
      break;
    case "ZXZ":
      n.set(l * d, l * p, a * h, a * u);
      break;
    case "XZX":
      n.set(a * h, l * y, l * g, a * u);
      break;
    case "YXY":
      n.set(l * g, a * h, l * y, a * u);
      break;
    case "ZYZ":
      n.set(l * y, l * g, a * h, a * u);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          r
      );
  }
}
function ji(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint16Array:
      return n / 65535;
    case Uint8Array:
      return n / 255;
    case Int16Array:
      return Math.max(n / 32767, -1);
    case Int8Array:
      return Math.max(n / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function vt(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint16Array:
      return Math.round(n * 65535);
    case Uint8Array:
      return Math.round(n * 255);
    case Int16Array:
      return Math.round(n * 32767);
    case Int8Array:
      return Math.round(n * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const q1 = {
  DEG2RAD: Za,
  RAD2DEG: Jc,
  generateUUID: Ki,
  clamp: pn,
  euclideanModulo: Z1,
  mapLinear: dk,
  inverseLerp: pk,
  lerp: wf,
  damp: mk,
  pingpong: gk,
  smoothstep: vk,
  smootherstep: yk,
  randInt: xk,
  randFloat: _k,
  randFloatSpread: Ak,
  seededRandom: Mk,
  degToRad: Sk,
  radToDeg: wk,
  isPowerOfTwo: d_,
  ceilPowerOfTwo: UB,
  floorPowerOfTwo: zB,
  setQuaternionFromProperEuler: Ek,
  normalize: vt,
  denormalize: ji,
};
class ve {
  constructor(e = 0, t = 0) {
    ((ve.prototype.isVector2 = !0), (this.x = e), (this.y = t));
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return ((this.x = e), (this.y = t), this);
  }
  setScalar(e) {
    return ((this.x = e), (this.y = e), this);
  }
  setX(e) {
    return ((this.x = e), this);
  }
  setY(e) {
    return ((this.y = e), this);
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return ((this.x = e.x), (this.y = e.y), this);
  }
  add(e) {
    return ((this.x += e.x), (this.y += e.y), this);
  }
  addScalar(e) {
    return ((this.x += e), (this.y += e), this);
  }
  addVectors(e, t) {
    return ((this.x = e.x + t.x), (this.y = e.y + t.y), this);
  }
  addScaledVector(e, t) {
    return ((this.x += e.x * t), (this.y += e.y * t), this);
  }
  sub(e) {
    return ((this.x -= e.x), (this.y -= e.y), this);
  }
  subScalar(e) {
    return ((this.x -= e), (this.y -= e), this);
  }
  subVectors(e, t) {
    return ((this.x = e.x - t.x), (this.y = e.y - t.y), this);
  }
  multiply(e) {
    return ((this.x *= e.x), (this.y *= e.y), this);
  }
  multiplyScalar(e) {
    return ((this.x *= e), (this.y *= e), this);
  }
  divide(e) {
    return ((this.x /= e.x), (this.y /= e.y), this);
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      i = this.y,
      r = e.elements;
    return (
      (this.x = r[0] * t + r[3] * i + r[6]),
      (this.y = r[1] * t + r[4] * i + r[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(t, i))
    );
  }
  floor() {
    return ((this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this);
  }
  ceil() {
    return ((this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this);
  }
  round() {
    return ((this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this);
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      this
    );
  }
  negate() {
    return ((this.x = -this.x), (this.y = -this.y), this);
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(pn(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      i = this.y - e.y;
    return t * t + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      this
    );
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return ((this.x = e[t]), (this.y = e[t + 1]), this);
  }
  toArray(e = [], t = 0) {
    return ((e[t] = this.x), (e[t + 1] = this.y), e);
  }
  fromBufferAttribute(e, t) {
    return ((this.x = e.getX(t)), (this.y = e.getY(t)), this);
  }
  rotateAround(e, t) {
    const i = Math.cos(t),
      r = Math.sin(t),
      s = this.x - e.x,
      o = this.y - e.y;
    return (
      (this.x = s * i - o * r + e.x),
      (this.y = s * r + o * i + e.y),
      this
    );
  }
  random() {
    return ((this.x = Math.random()), (this.y = Math.random()), this);
  }
  *[Symbol.iterator]() {
    (yield this.x, yield this.y);
  }
}
class wt {
  constructor() {
    ((wt.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]));
  }
  set(e, t, i, r, s, o, a, l, u) {
    const h = this.elements;
    return (
      (h[0] = e),
      (h[1] = r),
      (h[2] = a),
      (h[3] = t),
      (h[4] = s),
      (h[5] = l),
      (h[6] = i),
      (h[7] = o),
      (h[8] = u),
      this
    );
  }
  identity() {
    return (this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this);
  }
  copy(e) {
    const t = this.elements,
      i = e.elements;
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      this
    );
  }
  extractBasis(e, t, i) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      i.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return (
      this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements,
      r = t.elements,
      s = this.elements,
      o = i[0],
      a = i[3],
      l = i[6],
      u = i[1],
      h = i[4],
      d = i[7],
      p = i[2],
      g = i[5],
      y = i[8],
      A = r[0],
      _ = r[3],
      m = r[6],
      x = r[1],
      S = r[4],
      w = r[7],
      C = r[2],
      P = r[5],
      R = r[8];
    return (
      (s[0] = o * A + a * x + l * C),
      (s[3] = o * _ + a * S + l * P),
      (s[6] = o * m + a * w + l * R),
      (s[1] = u * A + h * x + d * C),
      (s[4] = u * _ + h * S + d * P),
      (s[7] = u * m + h * w + d * R),
      (s[2] = p * A + g * x + y * C),
      (s[5] = p * _ + g * S + y * P),
      (s[8] = p * m + g * w + y * R),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      u = e[7],
      h = e[8];
    return (
      t * o * h - t * a * u - i * s * h + i * a * l + r * s * u - r * o * l
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      u = e[7],
      h = e[8],
      d = h * o - a * u,
      p = a * l - h * s,
      g = u * s - o * l,
      y = t * d + i * p + r * g;
    if (y === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const A = 1 / y;
    return (
      (e[0] = d * A),
      (e[1] = (r * u - h * i) * A),
      (e[2] = (a * i - r * o) * A),
      (e[3] = p * A),
      (e[4] = (h * t - r * l) * A),
      (e[5] = (r * s - a * t) * A),
      (e[6] = g * A),
      (e[7] = (i * l - u * t) * A),
      (e[8] = (o * t - i * s) * A),
      this
    );
  }
  transpose() {
    let e;
    const t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, i, r, s, o, a) {
    const l = Math.cos(s),
      u = Math.sin(s);
    return (
      this.set(
        i * l,
        i * u,
        -i * (l * o + u * a) + o + e,
        -r * u,
        r * l,
        -r * (-u * o + l * a) + a + t,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, t) {
    return (this.premultiply(Ov.makeScale(e, t)), this);
  }
  rotate(e) {
    return (this.premultiply(Ov.makeRotation(-e)), this);
  }
  translate(e, t) {
    return (this.premultiply(Ov.makeTranslation(e, t)), this);
  }
  makeTranslation(e, t) {
    return (this.set(1, 0, e, 0, 1, t, 0, 0, 1), this);
  }
  makeRotation(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return (this.set(t, -i, 0, i, t, 0, 0, 0, 1), this);
  }
  makeScale(e, t) {
    return (this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this);
  }
  equals(e) {
    const t = this.elements,
      i = e.elements;
    for (let r = 0; r < 9; r++) if (t[r] !== i[r]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return (
      (e[t] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const Ov = new wt();
function GB(n) {
  for (let e = n.length - 1; e >= 0; --e) if (n[e] >= 65535) return !0;
  return !1;
}
const Ck = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
};
function vc(n, e) {
  return new Ck[n](e);
}
function ih(n) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", n);
}
function Rc(n) {
  return n < 0.04045
    ? n * 0.0773993808
    : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
}
function Uv(n) {
  return n < 0.0031308 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
}
const Tk = new wt().fromArray([
    0.8224621, 0.0331941, 0.0170827, 0.177538, 0.9668058, 0.0723974, -1e-7,
    1e-7, 0.9105199,
  ]),
  bk = new wt().fromArray([
    1.2249401, -0.0420569, -0.0196376, -0.2249404, 1.0420571, -0.0786361, 1e-7,
    0, 1.0982735,
  ]);
function Pk(n) {
  return n.convertSRGBToLinear().applyMatrix3(bk);
}
function Bk(n) {
  return n.applyMatrix3(Tk).convertLinearToSRGB();
}
const Rk = { [jc]: (n) => n, [Dr]: (n) => n.convertSRGBToLinear(), [Q1]: Pk },
  Lk = { [jc]: (n) => n, [Dr]: (n) => n.convertLinearToSRGB(), [Q1]: Bk },
  Ei = {
    enabled: !1,
    get legacyMode() {
      return (
        console.warn(
          "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
        ),
        !this.enabled
      );
    },
    set legacyMode(n) {
      (console.warn(
        "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
      ),
        (this.enabled = !n));
    },
    get workingColorSpace() {
      return jc;
    },
    set workingColorSpace(n) {
      console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
    },
    convert: function (n, e, t) {
      if (this.enabled === !1 || e === t || !e || !t) return n;
      const i = Rk[e],
        r = Lk[t];
      if (i === void 0 || r === void 0)
        throw new Error(
          `Unsupported color space conversion, "${e}" to "${t}".`
        );
      return r(i(n));
    },
    fromWorkingColorSpace: function (n, e) {
      return this.convert(n, this.workingColorSpace, e);
    },
    toWorkingColorSpace: function (n, e) {
      return this.convert(n, e, this.workingColorSpace);
    },
  };
let Dl;
class $1 {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let t;
    if (e instanceof HTMLCanvasElement) t = e;
    else {
      (Dl === void 0 && (Dl = ih("canvas")),
        (Dl.width = e.width),
        (Dl.height = e.height));
      const i = Dl.getContext("2d");
      (e instanceof ImageData
        ? i.putImageData(e, 0, 0)
        : i.drawImage(e, 0, 0, e.width, e.height),
        (t = Dl));
    }
    return t.width > 2048 || t.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e
        ),
        t.toDataURL("image/jpeg", 0.6))
      : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const t = ih("canvas");
      ((t.width = e.width), (t.height = e.height));
      const i = t.getContext("2d");
      i.drawImage(e, 0, 0, e.width, e.height);
      const r = i.getImageData(0, 0, e.width, e.height),
        s = r.data;
      for (let o = 0; o < s.length; o++) s[o] = Rc(s[o] / 255) * 255;
      return (i.putImageData(r, 0, 0), t);
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let i = 0; i < t.length; i++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[i] = Math.floor(Rc(t[i] / 255) * 255))
          : (t[i] = Rc(t[i]));
      return { data: t, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      );
  }
}
class Va {
  constructor(e = null) {
    ((this.isSource = !0),
      (this.uuid = Ki()),
      (this.data = e),
      (this.version = 0));
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const i = { uuid: this.uuid, url: "" },
      r = this.data;
    if (r !== null) {
      let s;
      if (Array.isArray(r)) {
        s = [];
        for (let o = 0, a = r.length; o < a; o++)
          r[o].isDataTexture ? s.push(zv(r[o].image)) : s.push(zv(r[o]));
      } else s = zv(r);
      i.url = s;
    }
    return (t || (e.images[this.uuid] = i), i);
  }
}
function zv(n) {
  return (typeof HTMLImageElement < "u" && n instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && n instanceof ImageBitmap)
    ? $1.getDataURL(n)
    : n.data
      ? {
          data: Array.from(n.data),
          width: n.width,
          height: n.height,
          type: n.data.constructor.name,
        }
      : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let Ik = 0;
class en extends ps {
  constructor(
    e = en.DEFAULT_IMAGE,
    t = en.DEFAULT_MAPPING,
    i = jn,
    r = jn,
    s = rn,
    o = hs,
    a = Pi,
    l = Ys,
    u = en.DEFAULT_ANISOTROPY,
    h = Qs
  ) {
    (super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: Ik++ }),
      (this.uuid = Ki()),
      (this.name = ""),
      (this.source = new Va(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.channel = 0),
      (this.wrapS = i),
      (this.wrapT = r),
      (this.magFilter = s),
      (this.minFilter = o),
      (this.anisotropy = u),
      (this.format = a),
      (this.internalFormat = null),
      (this.type = l),
      (this.offset = new ve(0, 0)),
      (this.repeat = new ve(1, 1)),
      (this.center = new ve(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new wt()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.encoding = h),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.needsPMREMUpdate = !1));
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.encoding = e.encoding),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const i = {
      metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      t || (e.textures[this.uuid] = i),
      i
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== Dg) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case Yo:
          e.x = e.x - Math.floor(e.x);
          break;
        case jn:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Hc:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Yo:
          e.y = e.y - Math.floor(e.y);
          break;
        case jn:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Hc:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return (this.flipY && (e.y = 1 - e.y), e);
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
}
en.DEFAULT_IMAGE = null;
en.DEFAULT_MAPPING = Dg;
en.DEFAULT_ANISOTROPY = 1;
class kt {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    ((kt.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = t),
      (this.z = i),
      (this.w = r));
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, i, r) {
    return ((this.x = e), (this.y = t), (this.z = i), (this.w = r), this);
  }
  setScalar(e) {
    return ((this.x = e), (this.y = e), (this.z = e), (this.w = e), this);
  }
  setX(e) {
    return ((this.x = e), this);
  }
  setY(e) {
    return ((this.y = e), this);
  }
  setZ(e) {
    return ((this.z = e), this);
  }
  setW(e) {
    return ((this.w = e), this);
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x),
      (this.y += e.y),
      (this.z += e.z),
      (this.w += e.w),
      this
    );
  }
  addScalar(e) {
    return ((this.x += e), (this.y += e), (this.z += e), (this.w += e), this);
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x),
      (this.y -= e.y),
      (this.z -= e.z),
      (this.w -= e.w),
      this
    );
  }
  subScalar(e) {
    return ((this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this);
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x),
      (this.y *= e.y),
      (this.z *= e.z),
      (this.w *= e.w),
      this
    );
  }
  multiplyScalar(e) {
    return ((this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this);
  }
  applyMatrix4(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = this.w,
      o = e.elements;
    return (
      (this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * s),
      (this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * s),
      (this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * s),
      (this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * s),
      this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, i, r, s;
    const l = e.elements,
      u = l[0],
      h = l[4],
      d = l[8],
      p = l[1],
      g = l[5],
      y = l[9],
      A = l[2],
      _ = l[6],
      m = l[10];
    if (
      Math.abs(h - p) < 0.01 &&
      Math.abs(d - A) < 0.01 &&
      Math.abs(y - _) < 0.01
    ) {
      if (
        Math.abs(h + p) < 0.1 &&
        Math.abs(d + A) < 0.1 &&
        Math.abs(y + _) < 0.1 &&
        Math.abs(u + g + m - 3) < 0.1
      )
        return (this.set(1, 0, 0, 0), this);
      t = Math.PI;
      const S = (u + 1) / 2,
        w = (g + 1) / 2,
        C = (m + 1) / 2,
        P = (h + p) / 4,
        R = (d + A) / 4,
        B = (y + _) / 4;
      return (
        S > w && S > C
          ? S < 0.01
            ? ((i = 0), (r = 0.707106781), (s = 0.707106781))
            : ((i = Math.sqrt(S)), (r = P / i), (s = R / i))
          : w > C
            ? w < 0.01
              ? ((i = 0.707106781), (r = 0), (s = 0.707106781))
              : ((r = Math.sqrt(w)), (i = P / r), (s = B / r))
            : C < 0.01
              ? ((i = 0.707106781), (r = 0.707106781), (s = 0))
              : ((s = Math.sqrt(C)), (i = R / s), (r = B / s)),
        this.set(i, r, s, t),
        this
      );
    }
    let x = Math.sqrt(
      (_ - y) * (_ - y) + (d - A) * (d - A) + (p - h) * (p - h)
    );
    return (
      Math.abs(x) < 0.001 && (x = 1),
      (this.x = (_ - y) / x),
      (this.y = (d - A) / x),
      (this.z = (p - h) / x),
      (this.w = Math.acos((u + g + m - 1) / 2)),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      (this.w = Math.max(e.w, Math.min(t.w, this.w))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      (this.w = Math.max(e, Math.min(t, this.w))),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(t, i))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      (this.z = e.z + (t.z - e.z) * i),
      (this.w = e.w + (t.w - e.w) * i),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    (yield this.x, yield this.y, yield this.z, yield this.w);
  }
}
class Hr extends ps {
  constructor(e = 1, t = 1, i = {}) {
    (super(),
      (this.isWebGLRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = 1),
      (this.scissor = new kt(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new kt(0, 0, e, t)));
    const r = { width: e, height: t, depth: 1 };
    ((this.texture = new en(
      r,
      i.mapping,
      i.wrapS,
      i.wrapT,
      i.magFilter,
      i.minFilter,
      i.format,
      i.type,
      i.anisotropy,
      i.encoding
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.flipY = !1),
      (this.texture.generateMipmaps =
        i.generateMipmaps !== void 0 ? i.generateMipmaps : !1),
      (this.texture.internalFormat =
        i.internalFormat !== void 0 ? i.internalFormat : null),
      (this.texture.minFilter = i.minFilter !== void 0 ? i.minFilter : rn),
      (this.depthBuffer = i.depthBuffer !== void 0 ? i.depthBuffer : !0),
      (this.stencilBuffer = i.stencilBuffer !== void 0 ? i.stencilBuffer : !1),
      (this.depthTexture = i.depthTexture !== void 0 ? i.depthTexture : null),
      (this.samples = i.samples !== void 0 ? i.samples : 0));
  }
  setSize(e, t, i = 1) {
    ((this.width !== e || this.height !== t || this.depth !== i) &&
      ((this.width = e),
      (this.height = t),
      (this.depth = i),
      (this.texture.image.width = e),
      (this.texture.image.height = t),
      (this.texture.image.depth = i),
      this.dispose()),
      this.viewport.set(0, 0, e, t),
      this.scissor.set(0, 0, e, t));
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    ((this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.viewport.copy(e.viewport),
      (this.texture = e.texture.clone()),
      (this.texture.isRenderTargetTexture = !0));
    const t = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new Va(t)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class kg extends en {
  constructor(e = null, t = 1, i = 1, r = 1) {
    (super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: i, depth: r }),
      (this.magFilter = dn),
      (this.minFilter = dn),
      (this.wrapR = jn),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1));
  }
}
class Dk extends Hr {
  constructor(e = 1, t = 1, i = 1) {
    (super(e, t),
      (this.isWebGLArrayRenderTarget = !0),
      (this.depth = i),
      (this.texture = new kg(null, e, t, i)),
      (this.texture.isRenderTargetTexture = !0));
  }
}
class eA extends en {
  constructor(e = null, t = 1, i = 1, r = 1) {
    (super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: i, depth: r }),
      (this.magFilter = dn),
      (this.minFilter = dn),
      (this.wrapR = jn),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1));
  }
}
class Fk extends Hr {
  constructor(e = 1, t = 1, i = 1) {
    (super(e, t),
      (this.isWebGL3DRenderTarget = !0),
      (this.depth = i),
      (this.texture = new eA(null, e, t, i)),
      (this.texture.isRenderTargetTexture = !0));
  }
}
class Nk extends Hr {
  constructor(e = 1, t = 1, i = 1, r = {}) {
    (super(e, t, r), (this.isWebGLMultipleRenderTargets = !0));
    const s = this.texture;
    this.texture = [];
    for (let o = 0; o < i; o++)
      ((this.texture[o] = s.clone()),
        (this.texture[o].isRenderTargetTexture = !0));
  }
  setSize(e, t, i = 1) {
    if (this.width !== e || this.height !== t || this.depth !== i) {
      ((this.width = e), (this.height = t), (this.depth = i));
      for (let r = 0, s = this.texture.length; r < s; r++)
        ((this.texture[r].image.width = e),
          (this.texture[r].image.height = t),
          (this.texture[r].image.depth = i));
      this.dispose();
    }
    return (this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this);
  }
  copy(e) {
    (this.dispose(),
      (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.viewport.set(0, 0, this.width, this.height),
      this.scissor.set(0, 0, this.width, this.height),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.texture.length = 0));
    for (let t = 0, i = e.texture.length; t < i; t++)
      ((this.texture[t] = e.texture[t].clone()),
        (this.texture[t].isRenderTargetTexture = !0));
    return this;
  }
}
class Kn {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    ((this.isQuaternion = !0),
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._w = r));
  }
  static slerpFlat(e, t, i, r, s, o, a) {
    let l = i[r + 0],
      u = i[r + 1],
      h = i[r + 2],
      d = i[r + 3];
    const p = s[o + 0],
      g = s[o + 1],
      y = s[o + 2],
      A = s[o + 3];
    if (a === 0) {
      ((e[t + 0] = l), (e[t + 1] = u), (e[t + 2] = h), (e[t + 3] = d));
      return;
    }
    if (a === 1) {
      ((e[t + 0] = p), (e[t + 1] = g), (e[t + 2] = y), (e[t + 3] = A));
      return;
    }
    if (d !== A || l !== p || u !== g || h !== y) {
      let _ = 1 - a;
      const m = l * p + u * g + h * y + d * A,
        x = m >= 0 ? 1 : -1,
        S = 1 - m * m;
      if (S > Number.EPSILON) {
        const C = Math.sqrt(S),
          P = Math.atan2(C, m * x);
        ((_ = Math.sin(_ * P) / C), (a = Math.sin(a * P) / C));
      }
      const w = a * x;
      if (
        ((l = l * _ + p * w),
        (u = u * _ + g * w),
        (h = h * _ + y * w),
        (d = d * _ + A * w),
        _ === 1 - a)
      ) {
        const C = 1 / Math.sqrt(l * l + u * u + h * h + d * d);
        ((l *= C), (u *= C), (h *= C), (d *= C));
      }
    }
    ((e[t] = l), (e[t + 1] = u), (e[t + 2] = h), (e[t + 3] = d));
  }
  static multiplyQuaternionsFlat(e, t, i, r, s, o) {
    const a = i[r],
      l = i[r + 1],
      u = i[r + 2],
      h = i[r + 3],
      d = s[o],
      p = s[o + 1],
      g = s[o + 2],
      y = s[o + 3];
    return (
      (e[t] = a * y + h * d + l * g - u * p),
      (e[t + 1] = l * y + h * p + u * d - a * g),
      (e[t + 2] = u * y + h * g + a * p - l * d),
      (e[t + 3] = h * y - a * d - l * p - u * g),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    ((this._x = e), this._onChangeCallback());
  }
  get y() {
    return this._y;
  }
  set y(e) {
    ((this._y = e), this._onChangeCallback());
  }
  get z() {
    return this._z;
  }
  set z(e) {
    ((this._z = e), this._onChangeCallback());
  }
  get w() {
    return this._w;
  }
  set w(e) {
    ((this._w = e), this._onChangeCallback());
  }
  set(e, t, i, r) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._w = r),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t) {
    const i = e._x,
      r = e._y,
      s = e._z,
      o = e._order,
      a = Math.cos,
      l = Math.sin,
      u = a(i / 2),
      h = a(r / 2),
      d = a(s / 2),
      p = l(i / 2),
      g = l(r / 2),
      y = l(s / 2);
    switch (o) {
      case "XYZ":
        ((this._x = p * h * d + u * g * y),
          (this._y = u * g * d - p * h * y),
          (this._z = u * h * y + p * g * d),
          (this._w = u * h * d - p * g * y));
        break;
      case "YXZ":
        ((this._x = p * h * d + u * g * y),
          (this._y = u * g * d - p * h * y),
          (this._z = u * h * y - p * g * d),
          (this._w = u * h * d + p * g * y));
        break;
      case "ZXY":
        ((this._x = p * h * d - u * g * y),
          (this._y = u * g * d + p * h * y),
          (this._z = u * h * y + p * g * d),
          (this._w = u * h * d - p * g * y));
        break;
      case "ZYX":
        ((this._x = p * h * d - u * g * y),
          (this._y = u * g * d + p * h * y),
          (this._z = u * h * y - p * g * d),
          (this._w = u * h * d + p * g * y));
        break;
      case "YZX":
        ((this._x = p * h * d + u * g * y),
          (this._y = u * g * d + p * h * y),
          (this._z = u * h * y - p * g * d),
          (this._w = u * h * d - p * g * y));
        break;
      case "XZY":
        ((this._x = p * h * d - u * g * y),
          (this._y = u * g * d - p * h * y),
          (this._z = u * h * y + p * g * d),
          (this._w = u * h * d + p * g * y));
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o
        );
    }
    return (t !== !1 && this._onChangeCallback(), this);
  }
  setFromAxisAngle(e, t) {
    const i = t / 2,
      r = Math.sin(i);
    return (
      (this._x = e.x * r),
      (this._y = e.y * r),
      (this._z = e.z * r),
      (this._w = Math.cos(i)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      i = t[0],
      r = t[4],
      s = t[8],
      o = t[1],
      a = t[5],
      l = t[9],
      u = t[2],
      h = t[6],
      d = t[10],
      p = i + a + d;
    if (p > 0) {
      const g = 0.5 / Math.sqrt(p + 1);
      ((this._w = 0.25 / g),
        (this._x = (h - l) * g),
        (this._y = (s - u) * g),
        (this._z = (o - r) * g));
    } else if (i > a && i > d) {
      const g = 2 * Math.sqrt(1 + i - a - d);
      ((this._w = (h - l) / g),
        (this._x = 0.25 * g),
        (this._y = (r + o) / g),
        (this._z = (s + u) / g));
    } else if (a > d) {
      const g = 2 * Math.sqrt(1 + a - i - d);
      ((this._w = (s - u) / g),
        (this._x = (r + o) / g),
        (this._y = 0.25 * g),
        (this._z = (l + h) / g));
    } else {
      const g = 2 * Math.sqrt(1 + d - i - a);
      ((this._w = (o - r) / g),
        (this._x = (s + u) / g),
        (this._y = (l + h) / g),
        (this._z = 0.25 * g));
    }
    return (this._onChangeCallback(), this);
  }
  setFromUnitVectors(e, t) {
    let i = e.dot(t) + 1;
    return (
      i < Number.EPSILON
        ? ((i = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = i))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = i)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = i)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(pn(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const i = this.angleTo(e);
    if (i === 0) return this;
    const r = Math.min(1, t / i);
    return (this.slerp(e, r), this);
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const i = e._x,
      r = e._y,
      s = e._z,
      o = e._w,
      a = t._x,
      l = t._y,
      u = t._z,
      h = t._w;
    return (
      (this._x = i * h + o * a + r * u - s * l),
      (this._y = r * h + o * l + s * a - i * u),
      (this._z = s * h + o * u + i * l - r * a),
      (this._w = o * h - i * a - r * l - s * u),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const i = this._x,
      r = this._y,
      s = this._z,
      o = this._w;
    let a = o * e._w + i * e._x + r * e._y + s * e._z;
    if (
      (a < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (a = -a))
        : this.copy(e),
      a >= 1)
    )
      return ((this._w = o), (this._x = i), (this._y = r), (this._z = s), this);
    const l = 1 - a * a;
    if (l <= Number.EPSILON) {
      const g = 1 - t;
      return (
        (this._w = g * o + t * this._w),
        (this._x = g * i + t * this._x),
        (this._y = g * r + t * this._y),
        (this._z = g * s + t * this._z),
        this.normalize(),
        this._onChangeCallback(),
        this
      );
    }
    const u = Math.sqrt(l),
      h = Math.atan2(u, a),
      d = Math.sin((1 - t) * h) / u,
      p = Math.sin(t * h) / u;
    return (
      (this._w = o * d + this._w * p),
      (this._x = i * d + this._x * p),
      (this._y = r * d + this._y * p),
      (this._z = s * d + this._z * p),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, t, i) {
    return this.copy(e).slerp(t, i);
  }
  random() {
    const e = Math.random(),
      t = Math.sqrt(1 - e),
      i = Math.sqrt(e),
      r = 2 * Math.PI * Math.random(),
      s = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(r),
      i * Math.sin(s),
      i * Math.cos(s),
      t * Math.sin(r)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return ((this._onChangeCallback = e), this);
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    (yield this._x, yield this._y, yield this._z, yield this._w);
  }
}
class F {
  constructor(e = 0, t = 0, i = 0) {
    ((F.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = i));
  }
  set(e, t, i) {
    return (
      i === void 0 && (i = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = i),
      this
    );
  }
  setScalar(e) {
    return ((this.x = e), (this.y = e), (this.z = e), this);
  }
  setX(e) {
    return ((this.x = e), this);
  }
  setY(e) {
    return ((this.y = e), this);
  }
  setZ(e) {
    return ((this.z = e), this);
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return ((this.x = e.x), (this.y = e.y), (this.z = e.z), this);
  }
  add(e) {
    return ((this.x += e.x), (this.y += e.y), (this.z += e.z), this);
  }
  addScalar(e) {
    return ((this.x += e), (this.y += e), (this.z += e), this);
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      this
    );
  }
  sub(e) {
    return ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this);
  }
  subScalar(e) {
    return ((this.x -= e), (this.y -= e), (this.z -= e), this);
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      this
    );
  }
  multiply(e) {
    return ((this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this);
  }
  multiplyScalar(e) {
    return ((this.x *= e), (this.y *= e), (this.z *= e), this);
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x),
      (this.y = e.y * t.y),
      (this.z = e.z * t.z),
      this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(fE.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(fE.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[3] * i + s[6] * r),
      (this.y = s[1] * t + s[4] * i + s[7] * r),
      (this.z = s[2] * t + s[5] * i + s[8] * r),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements,
      o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
    return (
      (this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o),
      (this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o),
      (this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.x,
      o = e.y,
      a = e.z,
      l = e.w,
      u = l * t + o * r - a * i,
      h = l * i + a * t - s * r,
      d = l * r + s * i - o * t,
      p = -s * t - o * i - a * r;
    return (
      (this.x = u * l + p * -s + h * -a - d * -o),
      (this.y = h * l + p * -o + d * -s - u * -a),
      (this.z = d * l + p * -a + u * -o - h * -s),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[4] * i + s[8] * r),
      (this.y = s[1] * t + s[5] * i + s[9] * r),
      (this.z = s[2] * t + s[6] * i + s[10] * r),
      this.normalize()
    );
  }
  divide(e) {
    return ((this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this);
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(t, i))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      this
    );
  }
  negate() {
    return ((this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this);
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      (this.z = e.z + (t.z - e.z) * i),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z,
      o = t.x,
      a = t.y,
      l = t.z;
    return (
      (this.x = r * l - s * a),
      (this.y = s * o - i * l),
      (this.z = i * a - r * o),
      this
    );
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const i = e.dot(this) / t;
    return this.copy(e).multiplyScalar(i);
  }
  projectOnPlane(e) {
    return (Gv.copy(this).projectOnVector(e), this.sub(Gv));
  }
  reflect(e) {
    return this.sub(Gv.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(pn(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      i = this.y - e.y,
      r = this.z - e.z;
    return t * t + i * i + r * r;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, i) {
    const r = Math.sin(t) * e;
    return (
      (this.x = r * Math.sin(i)),
      (this.y = Math.cos(t) * e),
      (this.z = r * Math.cos(i)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, i) {
    return (
      (this.x = e * Math.sin(t)),
      (this.y = i),
      (this.z = e * Math.cos(t)),
      this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return ((this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this);
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      i = this.setFromMatrixColumn(e, 1).length(),
      r = this.setFromMatrixColumn(e, 2).length();
    return ((this.x = t), (this.y = i), (this.z = r), this);
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return ((this.x = e._x), (this.y = e._y), (this.z = e._z), this);
  }
  setFromColor(e) {
    return ((this.x = e.r), (this.y = e.g), (this.z = e.b), this);
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return ((this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this);
  }
  toArray(e = [], t = 0) {
    return ((e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e);
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2,
      t = Math.random() * Math.PI * 2,
      i = Math.sqrt(1 - e ** 2);
    return (
      (this.x = i * Math.cos(t)),
      (this.y = i * Math.sin(t)),
      (this.z = e),
      this
    );
  }
  *[Symbol.iterator]() {
    (yield this.x, yield this.y, yield this.z);
  }
}
const Gv = new F(),
  fE = new Kn();
class Vr {
  constructor(
    e = new F(1 / 0, 1 / 0, 1 / 0),
    t = new F(-1 / 0, -1 / 0, -1 / 0)
  ) {
    ((this.isBox3 = !0), (this.min = e), (this.max = t));
  }
  set(e, t) {
    return (this.min.copy(e), this.max.copy(t), this);
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t += 3)
      this.expandByPoint(Ss.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, i = e.count; t < i; t++)
      this.expandByPoint(Ss.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = Ss.copy(t).multiplyScalar(0.5);
    return (this.min.copy(e).sub(i), this.max.copy(e).add(i), this);
  }
  setFromObject(e, t = !1) {
    return (this.makeEmpty(), this.expandByObject(e, t));
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.min.copy(e.min), this.max.copy(e.max), this);
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return (this.min.min(e), this.max.max(e), this);
  }
  expandByVector(e) {
    return (this.min.sub(e), this.max.add(e), this);
  }
  expandByScalar(e) {
    return (this.min.addScalar(-e), this.max.addScalar(e), this);
  }
  expandByObject(e, t = !1) {
    if ((e.updateWorldMatrix(!1, !1), e.boundingBox !== void 0))
      (e.boundingBox === null && e.computeBoundingBox(),
        Fl.copy(e.boundingBox),
        Fl.applyMatrix4(e.matrixWorld),
        this.union(Fl));
    else {
      const r = e.geometry;
      if (r !== void 0)
        if (t && r.attributes !== void 0 && r.attributes.position !== void 0) {
          const s = r.attributes.position;
          for (let o = 0, a = s.count; o < a; o++)
            (Ss.fromBufferAttribute(s, o).applyMatrix4(e.matrixWorld),
              this.expandByPoint(Ss));
        } else
          (r.boundingBox === null && r.computeBoundingBox(),
            Fl.copy(r.boundingBox),
            Fl.applyMatrix4(e.matrixWorld),
            this.union(Fl));
    }
    const i = e.children;
    for (let r = 0, s = i.length; r < s; r++) this.expandByObject(i[r], t);
    return this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y ||
      e.z < this.min.z ||
      e.z > this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y ||
      e.max.z < this.min.z ||
      e.min.z > this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, Ss),
      Ss.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, i;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (i = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (i = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (i += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (i += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (i += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (i += e.normal.z * this.min.z)),
      t <= -e.constant && i >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    (this.getCenter(Hu),
      ap.subVectors(this.max, Hu),
      Nl.subVectors(e.a, Hu),
      kl.subVectors(e.b, Hu),
      Ol.subVectors(e.c, Hu),
      po.subVectors(kl, Nl),
      mo.subVectors(Ol, kl),
      ga.subVectors(Nl, Ol));
    let t = [
      0,
      -po.z,
      po.y,
      0,
      -mo.z,
      mo.y,
      0,
      -ga.z,
      ga.y,
      po.z,
      0,
      -po.x,
      mo.z,
      0,
      -mo.x,
      ga.z,
      0,
      -ga.x,
      -po.y,
      po.x,
      0,
      -mo.y,
      mo.x,
      0,
      -ga.y,
      ga.x,
      0,
    ];
    return !Hv(t, Nl, kl, Ol, ap) ||
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !Hv(t, Nl, kl, Ol, ap))
      ? !1
      : (lp.crossVectors(po, mo),
        (t = [lp.x, lp.y, lp.z]),
        Hv(t, Nl, kl, Ol, ap));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Ss).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(Ss).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return (this.min.min(e.min), this.max.max(e.max), this);
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (Ms[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Ms[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Ms[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Ms[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Ms[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Ms[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Ms[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Ms[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Ms),
        this);
  }
  translate(e) {
    return (this.min.add(e), this.max.add(e), this);
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Ms = [
    new F(),
    new F(),
    new F(),
    new F(),
    new F(),
    new F(),
    new F(),
    new F(),
  ],
  Ss = new F(),
  Fl = new Vr(),
  Nl = new F(),
  kl = new F(),
  Ol = new F(),
  po = new F(),
  mo = new F(),
  ga = new F(),
  Hu = new F(),
  ap = new F(),
  lp = new F(),
  va = new F();
function Hv(n, e, t, i, r) {
  for (let s = 0, o = n.length - 3; s <= o; s += 3) {
    va.fromArray(n, s);
    const a =
        r.x * Math.abs(va.x) + r.y * Math.abs(va.y) + r.z * Math.abs(va.z),
      l = e.dot(va),
      u = t.dot(va),
      h = i.dot(va);
    if (Math.max(-Math.max(l, u, h), Math.min(l, u, h)) > a) return !1;
  }
  return !0;
}
const kk = new Vr(),
  Vu = new F(),
  Vv = new F();
class Wr {
  constructor(e = new F(), t = -1) {
    ((this.center = e), (this.radius = t));
  }
  set(e, t) {
    return (this.center.copy(e), (this.radius = t), this);
  }
  setFromPoints(e, t) {
    const i = this.center;
    t !== void 0 ? i.copy(t) : kk.setFromPoints(e).getCenter(i);
    let r = 0;
    for (let s = 0, o = e.length; s < o; s++)
      r = Math.max(r, i.distanceToSquared(e[s]));
    return ((this.radius = Math.sqrt(r)), this);
  }
  copy(e) {
    return (this.center.copy(e.center), (this.radius = e.radius), this);
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return (this.center.set(0, 0, 0), (this.radius = -1), this);
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const i = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      i > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return (this.center.add(e), this);
  }
  expandByPoint(e) {
    if (this.isEmpty()) return (this.center.copy(e), (this.radius = 0), this);
    Vu.subVectors(e, this.center);
    const t = Vu.lengthSq();
    if (t > this.radius * this.radius) {
      const i = Math.sqrt(t),
        r = (i - this.radius) * 0.5;
      (this.center.addScaledVector(Vu, r / i), (this.radius += r));
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
        ? (this.copy(e), this)
        : (this.center.equals(e.center) === !0
            ? (this.radius = Math.max(this.radius, e.radius))
            : (Vv.subVectors(e.center, this.center).setLength(e.radius),
              this.expandByPoint(Vu.copy(e.center).add(Vv)),
              this.expandByPoint(Vu.copy(e.center).sub(Vv))),
          this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const ws = new F(),
  Wv = new F(),
  cp = new F(),
  go = new F(),
  jv = new F(),
  up = new F(),
  Jv = new F();
class Sh {
  constructor(e = new F(), t = new F(0, 0, -1)) {
    ((this.origin = e), (this.direction = t));
  }
  set(e, t) {
    return (this.origin.copy(e), this.direction.copy(t), this);
  }
  copy(e) {
    return (this.origin.copy(e.origin), this.direction.copy(e.direction), this);
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return (this.direction.copy(e).sub(this.origin).normalize(), this);
  }
  recast(e) {
    return (this.origin.copy(this.at(e, ws)), this);
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const i = t.dot(this.direction);
    return i < 0
      ? t.copy(this.origin)
      : t.copy(this.origin).addScaledVector(this.direction, i);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = ws.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (ws.copy(this.origin).addScaledVector(this.direction, t),
        ws.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, i, r) {
    (Wv.copy(e).add(t).multiplyScalar(0.5),
      cp.copy(t).sub(e).normalize(),
      go.copy(this.origin).sub(Wv));
    const s = e.distanceTo(t) * 0.5,
      o = -this.direction.dot(cp),
      a = go.dot(this.direction),
      l = -go.dot(cp),
      u = go.lengthSq(),
      h = Math.abs(1 - o * o);
    let d, p, g, y;
    if (h > 0)
      if (((d = o * l - a), (p = o * a - l), (y = s * h), d >= 0))
        if (p >= -y)
          if (p <= y) {
            const A = 1 / h;
            ((d *= A),
              (p *= A),
              (g = d * (d + o * p + 2 * a) + p * (o * d + p + 2 * l) + u));
          } else
            ((p = s),
              (d = Math.max(0, -(o * p + a))),
              (g = -d * d + p * (p + 2 * l) + u));
        else
          ((p = -s),
            (d = Math.max(0, -(o * p + a))),
            (g = -d * d + p * (p + 2 * l) + u));
      else
        p <= -y
          ? ((d = Math.max(0, -(-o * s + a))),
            (p = d > 0 ? -s : Math.min(Math.max(-s, -l), s)),
            (g = -d * d + p * (p + 2 * l) + u))
          : p <= y
            ? ((d = 0),
              (p = Math.min(Math.max(-s, -l), s)),
              (g = p * (p + 2 * l) + u))
            : ((d = Math.max(0, -(o * s + a))),
              (p = d > 0 ? s : Math.min(Math.max(-s, -l), s)),
              (g = -d * d + p * (p + 2 * l) + u));
    else
      ((p = o > 0 ? -s : s),
        (d = Math.max(0, -(o * p + a))),
        (g = -d * d + p * (p + 2 * l) + u));
    return (
      i && i.copy(this.origin).addScaledVector(this.direction, d),
      r && r.copy(Wv).addScaledVector(cp, p),
      g
    );
  }
  intersectSphere(e, t) {
    ws.subVectors(e.center, this.origin);
    const i = ws.dot(this.direction),
      r = ws.dot(ws) - i * i,
      s = e.radius * e.radius;
    if (r > s) return null;
    const o = Math.sqrt(s - r),
      a = i - o,
      l = i + o;
    return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(e.normal) + e.constant) / t;
    return i >= 0 ? i : null;
  }
  intersectPlane(e, t) {
    const i = this.distanceToPlane(e);
    return i === null ? null : this.at(i, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let i, r, s, o, a, l;
    const u = 1 / this.direction.x,
      h = 1 / this.direction.y,
      d = 1 / this.direction.z,
      p = this.origin;
    return (
      u >= 0
        ? ((i = (e.min.x - p.x) * u), (r = (e.max.x - p.x) * u))
        : ((i = (e.max.x - p.x) * u), (r = (e.min.x - p.x) * u)),
      h >= 0
        ? ((s = (e.min.y - p.y) * h), (o = (e.max.y - p.y) * h))
        : ((s = (e.max.y - p.y) * h), (o = (e.min.y - p.y) * h)),
      i > o ||
      s > r ||
      ((s > i || isNaN(i)) && (i = s),
      (o < r || isNaN(r)) && (r = o),
      d >= 0
        ? ((a = (e.min.z - p.z) * d), (l = (e.max.z - p.z) * d))
        : ((a = (e.max.z - p.z) * d), (l = (e.min.z - p.z) * d)),
      i > l || a > r) ||
      ((a > i || i !== i) && (i = a), (l < r || r !== r) && (r = l), r < 0)
        ? null
        : this.at(i >= 0 ? i : r, t)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, ws) !== null;
  }
  intersectTriangle(e, t, i, r, s) {
    (jv.subVectors(t, e), up.subVectors(i, e), Jv.crossVectors(jv, up));
    let o = this.direction.dot(Jv),
      a;
    if (o > 0) {
      if (r) return null;
      a = 1;
    } else if (o < 0) ((a = -1), (o = -o));
    else return null;
    go.subVectors(this.origin, e);
    const l = a * this.direction.dot(up.crossVectors(go, up));
    if (l < 0) return null;
    const u = a * this.direction.dot(jv.cross(go));
    if (u < 0 || l + u > o) return null;
    const h = -a * go.dot(Jv);
    return h < 0 ? null : this.at(h / o, s);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e),
      this.direction.transformDirection(e),
      this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class ot {
  constructor() {
    ((ot.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]));
  }
  set(e, t, i, r, s, o, a, l, u, h, d, p, g, y, A, _) {
    const m = this.elements;
    return (
      (m[0] = e),
      (m[4] = t),
      (m[8] = i),
      (m[12] = r),
      (m[1] = s),
      (m[5] = o),
      (m[9] = a),
      (m[13] = l),
      (m[2] = u),
      (m[6] = h),
      (m[10] = d),
      (m[14] = p),
      (m[3] = g),
      (m[7] = y),
      (m[11] = A),
      (m[15] = _),
      this
    );
  }
  identity() {
    return (this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this);
  }
  clone() {
    return new ot().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      i = e.elements;
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      (t[9] = i[9]),
      (t[10] = i[10]),
      (t[11] = i[11]),
      (t[12] = i[12]),
      (t[13] = i[13]),
      (t[14] = i[14]),
      (t[15] = i[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      i = e.elements;
    return ((t[12] = i[12]), (t[13] = i[13]), (t[14] = i[14]), this);
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, t, i) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      i.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, i) {
    return (
      this.set(
        e.x,
        t.x,
        i.x,
        0,
        e.y,
        t.y,
        i.y,
        0,
        e.z,
        t.z,
        i.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const t = this.elements,
      i = e.elements,
      r = 1 / Ul.setFromMatrixColumn(e, 0).length(),
      s = 1 / Ul.setFromMatrixColumn(e, 1).length(),
      o = 1 / Ul.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = i[0] * r),
      (t[1] = i[1] * r),
      (t[2] = i[2] * r),
      (t[3] = 0),
      (t[4] = i[4] * s),
      (t[5] = i[5] * s),
      (t[6] = i[6] * s),
      (t[7] = 0),
      (t[8] = i[8] * o),
      (t[9] = i[9] * o),
      (t[10] = i[10] * o),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      i = e.x,
      r = e.y,
      s = e.z,
      o = Math.cos(i),
      a = Math.sin(i),
      l = Math.cos(r),
      u = Math.sin(r),
      h = Math.cos(s),
      d = Math.sin(s);
    if (e.order === "XYZ") {
      const p = o * h,
        g = o * d,
        y = a * h,
        A = a * d;
      ((t[0] = l * h),
        (t[4] = -l * d),
        (t[8] = u),
        (t[1] = g + y * u),
        (t[5] = p - A * u),
        (t[9] = -a * l),
        (t[2] = A - p * u),
        (t[6] = y + g * u),
        (t[10] = o * l));
    } else if (e.order === "YXZ") {
      const p = l * h,
        g = l * d,
        y = u * h,
        A = u * d;
      ((t[0] = p + A * a),
        (t[4] = y * a - g),
        (t[8] = o * u),
        (t[1] = o * d),
        (t[5] = o * h),
        (t[9] = -a),
        (t[2] = g * a - y),
        (t[6] = A + p * a),
        (t[10] = o * l));
    } else if (e.order === "ZXY") {
      const p = l * h,
        g = l * d,
        y = u * h,
        A = u * d;
      ((t[0] = p - A * a),
        (t[4] = -o * d),
        (t[8] = y + g * a),
        (t[1] = g + y * a),
        (t[5] = o * h),
        (t[9] = A - p * a),
        (t[2] = -o * u),
        (t[6] = a),
        (t[10] = o * l));
    } else if (e.order === "ZYX") {
      const p = o * h,
        g = o * d,
        y = a * h,
        A = a * d;
      ((t[0] = l * h),
        (t[4] = y * u - g),
        (t[8] = p * u + A),
        (t[1] = l * d),
        (t[5] = A * u + p),
        (t[9] = g * u - y),
        (t[2] = -u),
        (t[6] = a * l),
        (t[10] = o * l));
    } else if (e.order === "YZX") {
      const p = o * l,
        g = o * u,
        y = a * l,
        A = a * u;
      ((t[0] = l * h),
        (t[4] = A - p * d),
        (t[8] = y * d + g),
        (t[1] = d),
        (t[5] = o * h),
        (t[9] = -a * h),
        (t[2] = -u * h),
        (t[6] = g * d + y),
        (t[10] = p - A * d));
    } else if (e.order === "XZY") {
      const p = o * l,
        g = o * u,
        y = a * l,
        A = a * u;
      ((t[0] = l * h),
        (t[4] = -d),
        (t[8] = u * h),
        (t[1] = p * d + A),
        (t[5] = o * h),
        (t[9] = g * d - y),
        (t[2] = y * d - g),
        (t[6] = a * h),
        (t[10] = A * d + p));
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(Ok, e, Uk);
  }
  lookAt(e, t, i) {
    const r = this.elements;
    return (
      zi.subVectors(e, t),
      zi.lengthSq() === 0 && (zi.z = 1),
      zi.normalize(),
      vo.crossVectors(i, zi),
      vo.lengthSq() === 0 &&
        (Math.abs(i.z) === 1 ? (zi.x += 1e-4) : (zi.z += 1e-4),
        zi.normalize(),
        vo.crossVectors(i, zi)),
      vo.normalize(),
      fp.crossVectors(zi, vo),
      (r[0] = vo.x),
      (r[4] = fp.x),
      (r[8] = zi.x),
      (r[1] = vo.y),
      (r[5] = fp.y),
      (r[9] = zi.y),
      (r[2] = vo.z),
      (r[6] = fp.z),
      (r[10] = zi.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements,
      r = t.elements,
      s = this.elements,
      o = i[0],
      a = i[4],
      l = i[8],
      u = i[12],
      h = i[1],
      d = i[5],
      p = i[9],
      g = i[13],
      y = i[2],
      A = i[6],
      _ = i[10],
      m = i[14],
      x = i[3],
      S = i[7],
      w = i[11],
      C = i[15],
      P = r[0],
      R = r[4],
      B = r[8],
      b = r[12],
      L = r[1],
      U = r[5],
      J = r[9],
      V = r[13],
      j = r[2],
      X = r[6],
      oe = r[10],
      ae = r[14],
      I = r[3],
      G = r[7],
      z = r[11],
      q = r[15];
    return (
      (s[0] = o * P + a * L + l * j + u * I),
      (s[4] = o * R + a * U + l * X + u * G),
      (s[8] = o * B + a * J + l * oe + u * z),
      (s[12] = o * b + a * V + l * ae + u * q),
      (s[1] = h * P + d * L + p * j + g * I),
      (s[5] = h * R + d * U + p * X + g * G),
      (s[9] = h * B + d * J + p * oe + g * z),
      (s[13] = h * b + d * V + p * ae + g * q),
      (s[2] = y * P + A * L + _ * j + m * I),
      (s[6] = y * R + A * U + _ * X + m * G),
      (s[10] = y * B + A * J + _ * oe + m * z),
      (s[14] = y * b + A * V + _ * ae + m * q),
      (s[3] = x * P + S * L + w * j + C * I),
      (s[7] = x * R + S * U + w * X + C * G),
      (s[11] = x * B + S * J + w * oe + C * z),
      (s[15] = x * b + S * V + w * ae + C * q),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      i = e[4],
      r = e[8],
      s = e[12],
      o = e[1],
      a = e[5],
      l = e[9],
      u = e[13],
      h = e[2],
      d = e[6],
      p = e[10],
      g = e[14],
      y = e[3],
      A = e[7],
      _ = e[11],
      m = e[15];
    return (
      y *
        (+s * l * d -
          r * u * d -
          s * a * p +
          i * u * p +
          r * a * g -
          i * l * g) +
      A *
        (+t * l * g -
          t * u * p +
          s * o * p -
          r * o * g +
          r * u * h -
          s * l * h) +
      _ *
        (+t * u * d -
          t * a * g -
          s * o * d +
          i * o * g +
          s * a * h -
          i * u * h) +
      m *
        (-r * a * h - t * l * d + t * a * p + r * o * d - i * o * p + i * l * h)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, i) {
    const r = this.elements;
    return (
      e.isVector3
        ? ((r[12] = e.x), (r[13] = e.y), (r[14] = e.z))
        : ((r[12] = e), (r[13] = t), (r[14] = i)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      u = e[7],
      h = e[8],
      d = e[9],
      p = e[10],
      g = e[11],
      y = e[12],
      A = e[13],
      _ = e[14],
      m = e[15],
      x = d * _ * u - A * p * u + A * l * g - a * _ * g - d * l * m + a * p * m,
      S = y * p * u - h * _ * u - y * l * g + o * _ * g + h * l * m - o * p * m,
      w = h * A * u - y * d * u + y * a * g - o * A * g - h * a * m + o * d * m,
      C = y * d * l - h * A * l - y * a * p + o * A * p + h * a * _ - o * d * _,
      P = t * x + i * S + r * w + s * C;
    if (P === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const R = 1 / P;
    return (
      (e[0] = x * R),
      (e[1] =
        (A * p * s -
          d * _ * s -
          A * r * g +
          i * _ * g +
          d * r * m -
          i * p * m) *
        R),
      (e[2] =
        (a * _ * s -
          A * l * s +
          A * r * u -
          i * _ * u -
          a * r * m +
          i * l * m) *
        R),
      (e[3] =
        (d * l * s -
          a * p * s -
          d * r * u +
          i * p * u +
          a * r * g -
          i * l * g) *
        R),
      (e[4] = S * R),
      (e[5] =
        (h * _ * s -
          y * p * s +
          y * r * g -
          t * _ * g -
          h * r * m +
          t * p * m) *
        R),
      (e[6] =
        (y * l * s -
          o * _ * s -
          y * r * u +
          t * _ * u +
          o * r * m -
          t * l * m) *
        R),
      (e[7] =
        (o * p * s -
          h * l * s +
          h * r * u -
          t * p * u -
          o * r * g +
          t * l * g) *
        R),
      (e[8] = w * R),
      (e[9] =
        (y * d * s -
          h * A * s -
          y * i * g +
          t * A * g +
          h * i * m -
          t * d * m) *
        R),
      (e[10] =
        (o * A * s -
          y * a * s +
          y * i * u -
          t * A * u -
          o * i * m +
          t * a * m) *
        R),
      (e[11] =
        (h * a * s -
          o * d * s -
          h * i * u +
          t * d * u +
          o * i * g -
          t * a * g) *
        R),
      (e[12] = C * R),
      (e[13] =
        (h * A * r -
          y * d * r +
          y * i * p -
          t * A * p -
          h * i * _ +
          t * d * _) *
        R),
      (e[14] =
        (y * a * r -
          o * A * r -
          y * i * l +
          t * A * l +
          o * i * _ -
          t * a * _) *
        R),
      (e[15] =
        (o * d * r -
          h * a * r +
          h * i * l -
          t * d * l -
          o * i * p +
          t * a * p) *
        R),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      i = e.x,
      r = e.y,
      s = e.z;
    return (
      (t[0] *= i),
      (t[4] *= r),
      (t[8] *= s),
      (t[1] *= i),
      (t[5] *= r),
      (t[9] *= s),
      (t[2] *= i),
      (t[6] *= r),
      (t[10] *= s),
      (t[3] *= i),
      (t[7] *= r),
      (t[11] *= s),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, i, r));
  }
  makeTranslation(e, t, i) {
    return (this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this);
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return (this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this);
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return (this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this);
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return (this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this);
  }
  makeRotationAxis(e, t) {
    const i = Math.cos(t),
      r = Math.sin(t),
      s = 1 - i,
      o = e.x,
      a = e.y,
      l = e.z,
      u = s * o,
      h = s * a;
    return (
      this.set(
        u * o + i,
        u * a - r * l,
        u * l + r * a,
        0,
        u * a + r * l,
        h * a + i,
        h * l - r * o,
        0,
        u * l - r * a,
        h * l + r * o,
        s * l * l + i,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, t, i) {
    return (this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this);
  }
  makeShear(e, t, i, r, s, o) {
    return (this.set(1, i, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1), this);
  }
  compose(e, t, i) {
    const r = this.elements,
      s = t._x,
      o = t._y,
      a = t._z,
      l = t._w,
      u = s + s,
      h = o + o,
      d = a + a,
      p = s * u,
      g = s * h,
      y = s * d,
      A = o * h,
      _ = o * d,
      m = a * d,
      x = l * u,
      S = l * h,
      w = l * d,
      C = i.x,
      P = i.y,
      R = i.z;
    return (
      (r[0] = (1 - (A + m)) * C),
      (r[1] = (g + w) * C),
      (r[2] = (y - S) * C),
      (r[3] = 0),
      (r[4] = (g - w) * P),
      (r[5] = (1 - (p + m)) * P),
      (r[6] = (_ + x) * P),
      (r[7] = 0),
      (r[8] = (y + S) * R),
      (r[9] = (_ - x) * R),
      (r[10] = (1 - (p + A)) * R),
      (r[11] = 0),
      (r[12] = e.x),
      (r[13] = e.y),
      (r[14] = e.z),
      (r[15] = 1),
      this
    );
  }
  decompose(e, t, i) {
    const r = this.elements;
    let s = Ul.set(r[0], r[1], r[2]).length();
    const o = Ul.set(r[4], r[5], r[6]).length(),
      a = Ul.set(r[8], r[9], r[10]).length();
    (this.determinant() < 0 && (s = -s),
      (e.x = r[12]),
      (e.y = r[13]),
      (e.z = r[14]),
      Pr.copy(this));
    const u = 1 / s,
      h = 1 / o,
      d = 1 / a;
    return (
      (Pr.elements[0] *= u),
      (Pr.elements[1] *= u),
      (Pr.elements[2] *= u),
      (Pr.elements[4] *= h),
      (Pr.elements[5] *= h),
      (Pr.elements[6] *= h),
      (Pr.elements[8] *= d),
      (Pr.elements[9] *= d),
      (Pr.elements[10] *= d),
      t.setFromRotationMatrix(Pr),
      (i.x = s),
      (i.y = o),
      (i.z = a),
      this
    );
  }
  makePerspective(e, t, i, r, s, o) {
    const a = this.elements,
      l = (2 * s) / (t - e),
      u = (2 * s) / (i - r),
      h = (t + e) / (t - e),
      d = (i + r) / (i - r),
      p = -(o + s) / (o - s),
      g = (-2 * o * s) / (o - s);
    return (
      (a[0] = l),
      (a[4] = 0),
      (a[8] = h),
      (a[12] = 0),
      (a[1] = 0),
      (a[5] = u),
      (a[9] = d),
      (a[13] = 0),
      (a[2] = 0),
      (a[6] = 0),
      (a[10] = p),
      (a[14] = g),
      (a[3] = 0),
      (a[7] = 0),
      (a[11] = -1),
      (a[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, i, r, s, o) {
    const a = this.elements,
      l = 1 / (t - e),
      u = 1 / (i - r),
      h = 1 / (o - s),
      d = (t + e) * l,
      p = (i + r) * u,
      g = (o + s) * h;
    return (
      (a[0] = 2 * l),
      (a[4] = 0),
      (a[8] = 0),
      (a[12] = -d),
      (a[1] = 0),
      (a[5] = 2 * u),
      (a[9] = 0),
      (a[13] = -p),
      (a[2] = 0),
      (a[6] = 0),
      (a[10] = -2 * h),
      (a[14] = -g),
      (a[3] = 0),
      (a[7] = 0),
      (a[11] = 0),
      (a[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      i = e.elements;
    for (let r = 0; r < 16; r++) if (t[r] !== i[r]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return (
      (e[t] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      (e[t + 9] = i[9]),
      (e[t + 10] = i[10]),
      (e[t + 11] = i[11]),
      (e[t + 12] = i[12]),
      (e[t + 13] = i[13]),
      (e[t + 14] = i[14]),
      (e[t + 15] = i[15]),
      e
    );
  }
}
const Ul = new F(),
  Pr = new ot(),
  Ok = new F(0, 0, 0),
  Uk = new F(1, 1, 1),
  vo = new F(),
  fp = new F(),
  zi = new F(),
  hE = new ot(),
  dE = new Kn();
class hl {
  constructor(e = 0, t = 0, i = 0, r = hl.DEFAULT_ORDER) {
    ((this.isEuler = !0),
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._order = r));
  }
  get x() {
    return this._x;
  }
  set x(e) {
    ((this._x = e), this._onChangeCallback());
  }
  get y() {
    return this._y;
  }
  set y(e) {
    ((this._y = e), this._onChangeCallback());
  }
  get z() {
    return this._z;
  }
  set z(e) {
    ((this._z = e), this._onChangeCallback());
  }
  get order() {
    return this._order;
  }
  set order(e) {
    ((this._order = e), this._onChangeCallback());
  }
  set(e, t, i, r = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._order = r),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, i = !0) {
    const r = e.elements,
      s = r[0],
      o = r[4],
      a = r[8],
      l = r[1],
      u = r[5],
      h = r[9],
      d = r[2],
      p = r[6],
      g = r[10];
    switch (t) {
      case "XYZ":
        ((this._y = Math.asin(pn(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(-h, g)), (this._z = Math.atan2(-o, s)))
            : ((this._x = Math.atan2(p, u)), (this._z = 0)));
        break;
      case "YXZ":
        ((this._x = Math.asin(-pn(h, -1, 1))),
          Math.abs(h) < 0.9999999
            ? ((this._y = Math.atan2(a, g)), (this._z = Math.atan2(l, u)))
            : ((this._y = Math.atan2(-d, s)), (this._z = 0)));
        break;
      case "ZXY":
        ((this._x = Math.asin(pn(p, -1, 1))),
          Math.abs(p) < 0.9999999
            ? ((this._y = Math.atan2(-d, g)), (this._z = Math.atan2(-o, u)))
            : ((this._y = 0), (this._z = Math.atan2(l, s))));
        break;
      case "ZYX":
        ((this._y = Math.asin(-pn(d, -1, 1))),
          Math.abs(d) < 0.9999999
            ? ((this._x = Math.atan2(p, g)), (this._z = Math.atan2(l, s)))
            : ((this._x = 0), (this._z = Math.atan2(-o, u))));
        break;
      case "YZX":
        ((this._z = Math.asin(pn(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(-h, u)), (this._y = Math.atan2(-d, s)))
            : ((this._x = 0), (this._y = Math.atan2(a, g))));
        break;
      case "XZY":
        ((this._z = Math.asin(-pn(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(p, u)), (this._y = Math.atan2(a, s)))
            : ((this._x = Math.atan2(-h, g)), (this._y = 0)));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            t
        );
    }
    return ((this._order = t), i === !0 && this._onChangeCallback(), this);
  }
  setFromQuaternion(e, t, i) {
    return (
      hE.makeRotationFromQuaternion(e),
      this.setFromRotationMatrix(hE, t, i)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return (dE.setFromEuler(this), this.setFromQuaternion(dE, e));
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return ((this._onChangeCallback = e), this);
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    (yield this._x, yield this._y, yield this._z, yield this._order);
  }
}
hl.DEFAULT_ORDER = "XYZ";
class qa {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let zk = 0;
const pE = new F(),
  zl = new Kn(),
  Es = new ot(),
  hp = new F(),
  Wu = new F(),
  Gk = new F(),
  Hk = new Kn(),
  mE = new F(1, 0, 0),
  gE = new F(0, 1, 0),
  vE = new F(0, 0, 1),
  Vk = { type: "added" },
  yE = { type: "removed" };
class Pt extends ps {
  constructor() {
    (super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: zk++ }),
      (this.uuid = Ki()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = Pt.DEFAULT_UP.clone()));
    const e = new F(),
      t = new hl(),
      i = new Kn(),
      r = new F(1, 1, 1);
    function s() {
      i.setFromEuler(t, !1);
    }
    function o() {
      t.setFromQuaternion(i, void 0, !1);
    }
    (t._onChange(s),
      i._onChange(o),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: i },
        scale: { configurable: !0, enumerable: !0, value: r },
        modelViewMatrix: { value: new ot() },
        normalMatrix: { value: new wt() },
      }),
      (this.matrix = new ot()),
      (this.matrixWorld = new ot()),
      (this.matrixAutoUpdate = Pt.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.matrixWorldAutoUpdate = Pt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.layers = new qa()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {}));
  }
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    (this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale));
  }
  applyQuaternion(e) {
    return (this.quaternion.premultiply(e), this);
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return (zl.setFromAxisAngle(e, t), this.quaternion.multiply(zl), this);
  }
  rotateOnWorldAxis(e, t) {
    return (zl.setFromAxisAngle(e, t), this.quaternion.premultiply(zl), this);
  }
  rotateX(e) {
    return this.rotateOnAxis(mE, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(gE, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(vE, e);
  }
  translateOnAxis(e, t) {
    return (
      pE.copy(e).applyQuaternion(this.quaternion),
      this.position.add(pE.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(mE, e);
  }
  translateY(e) {
    return this.translateOnAxis(gE, e);
  }
  translateZ(e) {
    return this.translateOnAxis(vE, e);
  }
  localToWorld(e) {
    return (this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld));
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(Es.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, t, i) {
    e.isVector3 ? hp.copy(e) : hp.set(e, t, i);
    const r = this.parent;
    (this.updateWorldMatrix(!0, !1),
      Wu.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? Es.lookAt(Wu, hp, this.up)
        : Es.lookAt(hp, Wu, this.up),
      this.quaternion.setFromRotationMatrix(Es),
      r &&
        (Es.extractRotation(r.matrixWorld),
        zl.setFromRotationMatrix(Es),
        this.quaternion.premultiply(zl.invert())));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.parent !== null && e.parent.remove(e),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(Vk))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      t !== -1 &&
        ((e.parent = null), this.children.splice(t, 1), e.dispatchEvent(yE)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return (e !== null && e.remove(this), this);
  }
  clear() {
    for (let e = 0; e < this.children.length; e++) {
      const t = this.children[e];
      ((t.parent = null), t.dispatchEvent(yE));
    }
    return ((this.children.length = 0), this);
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      Es.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), Es.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(Es),
      this.add(e),
      e.updateWorldMatrix(!1, !0),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let i = 0, r = this.children.length; i < r; i++) {
      const o = this.children[i].getObjectByProperty(e, t);
      if (o !== void 0) return o;
    }
  }
  getObjectsByProperty(e, t) {
    let i = [];
    this[e] === t && i.push(this);
    for (let r = 0, s = this.children.length; r < s; r++) {
      const o = this.children[r].getObjectsByProperty(e, t);
      o.length > 0 && (i = i.concat(o));
    }
    return i;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      this.matrixWorld.decompose(Wu, e, Gk),
      e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      this.matrixWorld.decompose(Wu, Hk, e),
      e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) t[i].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) t[i].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    (this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0));
  }
  updateMatrixWorld(e) {
    (this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0)));
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const i = this.parent;
    if (
      (e === !0 &&
        i !== null &&
        i.matrixWorldAutoUpdate === !0 &&
        i.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.parent === null
        ? this.matrixWorld.copy(this.matrix)
        : this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix
          ),
      t === !0)
    ) {
      const r = this.children;
      for (let s = 0, o = r.length; s < o; s++) {
        const a = r[s];
        a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string",
      i = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (i.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const r = {};
    ((r.uuid = this.uuid),
      (r.type = this.type),
      this.name !== "" && (r.name = this.name),
      this.castShadow === !0 && (r.castShadow = !0),
      this.receiveShadow === !0 && (r.receiveShadow = !0),
      this.visible === !1 && (r.visible = !1),
      this.frustumCulled === !1 && (r.frustumCulled = !1),
      this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (r.userData = this.userData),
      (r.layers = this.layers.mask),
      (r.matrix = this.matrix.toArray()),
      (r.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((r.type = "InstancedMesh"),
        (r.count = this.count),
        (r.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (r.instanceColor = this.instanceColor.toJSON())));
    function s(a, l) {
      return (a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid);
    }
    if (this.isScene)
      (this.background &&
        (this.background.isColor
          ? (r.background = this.background.toJSON())
          : this.background.isTexture &&
            (r.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (r.environment = this.environment.toJSON(e).uuid));
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = s(e.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const l = a.shapes;
        if (Array.isArray(l))
          for (let u = 0, h = l.length; u < h; u++) {
            const d = l[u];
            s(e.shapes, d);
          }
        else s(e.shapes, l);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((r.bindMode = this.bindMode),
        (r.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (s(e.skeletons, this.skeleton), (r.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const a = [];
        for (let l = 0, u = this.material.length; l < u; l++)
          a.push(s(e.materials, this.material[l]));
        r.material = a;
      } else r.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let a = 0; a < this.children.length; a++)
        r.children.push(this.children[a].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const l = this.animations[a];
        r.animations.push(s(e.animations, l));
      }
    }
    if (t) {
      const a = o(e.geometries),
        l = o(e.materials),
        u = o(e.textures),
        h = o(e.images),
        d = o(e.shapes),
        p = o(e.skeletons),
        g = o(e.animations),
        y = o(e.nodes);
      (a.length > 0 && (i.geometries = a),
        l.length > 0 && (i.materials = l),
        u.length > 0 && (i.textures = u),
        h.length > 0 && (i.images = h),
        d.length > 0 && (i.shapes = d),
        p.length > 0 && (i.skeletons = p),
        g.length > 0 && (i.animations = g),
        y.length > 0 && (i.nodes = y));
    }
    return ((i.object = r), i);
    function o(a) {
      const l = [];
      for (const u in a) {
        const h = a[u];
        (delete h.metadata, l.push(h));
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let i = 0; i < e.children.length; i++) {
        const r = e.children[i];
        this.add(r.clone());
      }
    return this;
  }
}
Pt.DEFAULT_UP = new F(0, 1, 0);
Pt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Pt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Br = new F(),
  Cs = new F(),
  Xv = new F(),
  Ts = new F(),
  Gl = new F(),
  Hl = new F(),
  xE = new F(),
  Kv = new F(),
  Yv = new F(),
  Qv = new F();
let dp = !1;
class bi {
  constructor(e = new F(), t = new F(), i = new F()) {
    ((this.a = e), (this.b = t), (this.c = i));
  }
  static getNormal(e, t, i, r) {
    (r.subVectors(i, t), Br.subVectors(e, t), r.cross(Br));
    const s = r.lengthSq();
    return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
  }
  static getBarycoord(e, t, i, r, s) {
    (Br.subVectors(r, t), Cs.subVectors(i, t), Xv.subVectors(e, t));
    const o = Br.dot(Br),
      a = Br.dot(Cs),
      l = Br.dot(Xv),
      u = Cs.dot(Cs),
      h = Cs.dot(Xv),
      d = o * u - a * a;
    if (d === 0) return s.set(-2, -1, -1);
    const p = 1 / d,
      g = (u * l - a * h) * p,
      y = (o * h - a * l) * p;
    return s.set(1 - g - y, y, g);
  }
  static containsPoint(e, t, i, r) {
    return (
      this.getBarycoord(e, t, i, r, Ts),
      Ts.x >= 0 && Ts.y >= 0 && Ts.x + Ts.y <= 1
    );
  }
  static getUV(e, t, i, r, s, o, a, l) {
    return (
      dp === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (dp = !0)),
      this.getInterpolation(e, t, i, r, s, o, a, l)
    );
  }
  static getInterpolation(e, t, i, r, s, o, a, l) {
    return (
      this.getBarycoord(e, t, i, r, Ts),
      l.setScalar(0),
      l.addScaledVector(s, Ts.x),
      l.addScaledVector(o, Ts.y),
      l.addScaledVector(a, Ts.z),
      l
    );
  }
  static isFrontFacing(e, t, i, r) {
    return (Br.subVectors(i, t), Cs.subVectors(e, t), Br.cross(Cs).dot(r) < 0);
  }
  set(e, t, i) {
    return (this.a.copy(e), this.b.copy(t), this.c.copy(i), this);
  }
  setFromPointsAndIndices(e, t, i, r) {
    return (this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this);
  }
  setFromAttributeAndIndices(e, t, i, r) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, i),
      this.c.fromBufferAttribute(e, r),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this);
  }
  getArea() {
    return (
      Br.subVectors(this.c, this.b),
      Cs.subVectors(this.a, this.b),
      Br.cross(Cs).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return bi.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return bi.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, i, r, s) {
    return (
      dp === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (dp = !0)),
      bi.getInterpolation(e, this.a, this.b, this.c, t, i, r, s)
    );
  }
  getInterpolation(e, t, i, r, s) {
    return bi.getInterpolation(e, this.a, this.b, this.c, t, i, r, s);
  }
  containsPoint(e) {
    return bi.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return bi.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const i = this.a,
      r = this.b,
      s = this.c;
    let o, a;
    (Gl.subVectors(r, i), Hl.subVectors(s, i), Kv.subVectors(e, i));
    const l = Gl.dot(Kv),
      u = Hl.dot(Kv);
    if (l <= 0 && u <= 0) return t.copy(i);
    Yv.subVectors(e, r);
    const h = Gl.dot(Yv),
      d = Hl.dot(Yv);
    if (h >= 0 && d <= h) return t.copy(r);
    const p = l * d - h * u;
    if (p <= 0 && l >= 0 && h <= 0)
      return ((o = l / (l - h)), t.copy(i).addScaledVector(Gl, o));
    Qv.subVectors(e, s);
    const g = Gl.dot(Qv),
      y = Hl.dot(Qv);
    if (y >= 0 && g <= y) return t.copy(s);
    const A = g * u - l * y;
    if (A <= 0 && u >= 0 && y <= 0)
      return ((a = u / (u - y)), t.copy(i).addScaledVector(Hl, a));
    const _ = h * y - g * d;
    if (_ <= 0 && d - h >= 0 && g - y >= 0)
      return (
        xE.subVectors(s, r),
        (a = (d - h) / (d - h + (g - y))),
        t.copy(r).addScaledVector(xE, a)
      );
    const m = 1 / (_ + A + p);
    return (
      (o = A * m),
      (a = p * m),
      t.copy(i).addScaledVector(Gl, o).addScaledVector(Hl, a)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
let Wk = 0;
class En extends ps {
  constructor() {
    (super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: Wk++ }),
      (this.uuid = Ki()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = Ka),
      (this.side = fs),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.blendSrc = W1),
      (this.blendDst = j1),
      (this.blendEquation = Da),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.depthFunc = Ym),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = OB),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = Am),
      (this.stencilZFail = Am),
      (this.stencilZPass = Am),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0));
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    (this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e));
  }
  onBuild() {}
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const i = e[t];
        if (i === void 0) {
          console.warn(
            `THREE.Material: parameter '${t}' has value of undefined.`
          );
          continue;
        }
        const r = this[t];
        if (r === void 0) {
          console.warn(
            `THREE.Material: '${t}' is not a property of THREE.${this.type}.`
          );
          continue;
        }
        r && r.isColor
          ? r.set(i)
          : r && r.isVector3 && i && i.isVector3
            ? r.copy(i)
            : (this[t] = i);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const i = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    ((i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.color && this.color.isColor && (i.color = this.color.getHex()),
      this.roughness !== void 0 && (i.roughness = this.roughness),
      this.metalness !== void 0 && (i.metalness = this.metalness),
      this.sheen !== void 0 && (i.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (i.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (i.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (i.emissive = this.emissive.getHex()),
      this.emissiveIntensity &&
        this.emissiveIntensity !== 1 &&
        (i.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (i.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (i.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (i.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (i.shininess = this.shininess),
      this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (i.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.iridescence !== void 0 && (i.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (i.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (i.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (i.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (i.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((i.lightMap = this.lightMap.toJSON(e).uuid),
        (i.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((i.aoMap = this.aoMap.toJSON(e).uuid),
        (i.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((i.bumpMap = this.bumpMap.toJSON(e).uuid),
        (i.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((i.normalMap = this.normalMap.toJSON(e).uuid),
        (i.normalMapType = this.normalMapType),
        (i.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((i.displacementMap = this.displacementMap.toJSON(e).uuid),
        (i.displacementScale = this.displacementScale),
        (i.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (i.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((i.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (i.combine = this.combine)),
      this.envMapIntensity !== void 0 &&
        (i.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (i.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (i.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (i.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (i.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (i.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (i.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (i.size = this.size),
      this.shadowSide !== null && (i.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (i.sizeAttenuation = this.sizeAttenuation),
      this.blending !== Ka && (i.blending = this.blending),
      this.side !== fs && (i.side = this.side),
      this.vertexColors && (i.vertexColors = !0),
      this.opacity < 1 && (i.opacity = this.opacity),
      this.transparent === !0 && (i.transparent = this.transparent),
      (i.depthFunc = this.depthFunc),
      (i.depthTest = this.depthTest),
      (i.depthWrite = this.depthWrite),
      (i.colorWrite = this.colorWrite),
      (i.stencilWrite = this.stencilWrite),
      (i.stencilWriteMask = this.stencilWriteMask),
      (i.stencilFunc = this.stencilFunc),
      (i.stencilRef = this.stencilRef),
      (i.stencilFuncMask = this.stencilFuncMask),
      (i.stencilFail = this.stencilFail),
      (i.stencilZFail = this.stencilZFail),
      (i.stencilZPass = this.stencilZPass),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (i.rotation = this.rotation),
      this.polygonOffset === !0 && (i.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (i.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (i.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (i.linewidth = this.linewidth),
      this.dashSize !== void 0 && (i.dashSize = this.dashSize),
      this.gapSize !== void 0 && (i.gapSize = this.gapSize),
      this.scale !== void 0 && (i.scale = this.scale),
      this.dithering === !0 && (i.dithering = !0),
      this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
      this.alphaToCoverage === !0 && (i.alphaToCoverage = this.alphaToCoverage),
      this.premultipliedAlpha === !0 &&
        (i.premultipliedAlpha = this.premultipliedAlpha),
      this.forceSinglePass === !0 && (i.forceSinglePass = this.forceSinglePass),
      this.wireframe === !0 && (i.wireframe = this.wireframe),
      this.wireframeLinewidth > 1 &&
        (i.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (i.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (i.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (i.flatShading = this.flatShading),
      this.visible === !1 && (i.visible = !1),
      this.toneMapped === !1 && (i.toneMapped = !1),
      this.fog === !1 && (i.fog = !1),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData));
    function r(s) {
      const o = [];
      for (const a in s) {
        const l = s[a];
        (delete l.metadata, o.push(l));
      }
      return o;
    }
    if (t) {
      const s = r(e.textures),
        o = r(e.images);
      (s.length > 0 && (i.textures = s), o.length > 0 && (i.images = o));
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    ((this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite));
    const t = e.clippingPlanes;
    let i = null;
    if (t !== null) {
      const r = t.length;
      i = new Array(r);
      for (let s = 0; s !== r; ++s) i[s] = t[s].clone();
    }
    return (
      (this.clippingPlanes = i),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
const HB = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  Rr = { h: 0, s: 0, l: 0 },
  pp = { h: 0, s: 0, l: 0 };
function Zv(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
        ? e
        : t < 2 / 3
          ? n + (e - n) * 6 * (2 / 3 - t)
          : n
  );
}
class Ie {
  constructor(e, t, i) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      t === void 0 && i === void 0 ? this.set(e) : this.setRGB(e, t, i)
    );
  }
  set(e) {
    return (
      e && e.isColor
        ? this.copy(e)
        : typeof e == "number"
          ? this.setHex(e)
          : typeof e == "string" && this.setStyle(e),
      this
    );
  }
  setScalar(e) {
    return ((this.r = e), (this.g = e), (this.b = e), this);
  }
  setHex(e, t = Dr) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      Ei.toWorkingColorSpace(this, t),
      this
    );
  }
  setRGB(e, t, i, r = Ei.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = i),
      Ei.toWorkingColorSpace(this, r),
      this
    );
  }
  setHSL(e, t, i, r = Ei.workingColorSpace) {
    if (((e = Z1(e, 1)), (t = pn(t, 0, 1)), (i = pn(i, 0, 1)), t === 0))
      this.r = this.g = this.b = i;
    else {
      const s = i <= 0.5 ? i * (1 + t) : i + t - i * t,
        o = 2 * i - s;
      ((this.r = Zv(o, s, e + 1 / 3)),
        (this.g = Zv(o, s, e)),
        (this.b = Zv(o, s, e - 1 / 3)));
    }
    return (Ei.toWorkingColorSpace(this, r), this);
  }
  setStyle(e, t = Dr) {
    function i(s) {
      s !== void 0 &&
        parseFloat(s) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    let r;
    if ((r = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let s;
      const o = r[1],
        a = r[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (
            (s =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              (this.r = Math.min(255, parseInt(s[1], 10)) / 255),
              (this.g = Math.min(255, parseInt(s[2], 10)) / 255),
              (this.b = Math.min(255, parseInt(s[3], 10)) / 255),
              Ei.toWorkingColorSpace(this, t),
              i(s[4]),
              this
            );
          if (
            (s =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              (this.r = Math.min(100, parseInt(s[1], 10)) / 100),
              (this.g = Math.min(100, parseInt(s[2], 10)) / 100),
              (this.b = Math.min(100, parseInt(s[3], 10)) / 100),
              Ei.toWorkingColorSpace(this, t),
              i(s[4]),
              this
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (s =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          ) {
            const l = parseFloat(s[1]) / 360,
              u = parseFloat(s[2]) / 100,
              h = parseFloat(s[3]) / 100;
            return (i(s[4]), this.setHSL(l, u, h, t));
          }
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((r = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const s = r[1],
        o = s.length;
      if (o === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          t
        );
      if (o === 6) return this.setHex(parseInt(s, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = Dr) {
    const i = HB[e.toLowerCase()];
    return (
      i !== void 0
        ? this.setHex(i, t)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return ((this.r = e.r), (this.g = e.g), (this.b = e.b), this);
  }
  copySRGBToLinear(e) {
    return ((this.r = Rc(e.r)), (this.g = Rc(e.g)), (this.b = Rc(e.b)), this);
  }
  copyLinearToSRGB(e) {
    return ((this.r = Uv(e.r)), (this.g = Uv(e.g)), (this.b = Uv(e.b)), this);
  }
  convertSRGBToLinear() {
    return (this.copySRGBToLinear(this), this);
  }
  convertLinearToSRGB() {
    return (this.copyLinearToSRGB(this), this);
  }
  getHex(e = Dr) {
    return (
      Ei.fromWorkingColorSpace(ri.copy(this), e),
      (pn(ri.r * 255, 0, 255) << 16) ^
        (pn(ri.g * 255, 0, 255) << 8) ^
        (pn(ri.b * 255, 0, 255) << 0)
    );
  }
  getHexString(e = Dr) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = Ei.workingColorSpace) {
    Ei.fromWorkingColorSpace(ri.copy(this), t);
    const i = ri.r,
      r = ri.g,
      s = ri.b,
      o = Math.max(i, r, s),
      a = Math.min(i, r, s);
    let l, u;
    const h = (a + o) / 2;
    if (a === o) ((l = 0), (u = 0));
    else {
      const d = o - a;
      switch (((u = h <= 0.5 ? d / (o + a) : d / (2 - o - a)), o)) {
        case i:
          l = (r - s) / d + (r < s ? 6 : 0);
          break;
        case r:
          l = (s - i) / d + 2;
          break;
        case s:
          l = (i - r) / d + 4;
          break;
      }
      l /= 6;
    }
    return ((e.h = l), (e.s = u), (e.l = h), e);
  }
  getRGB(e, t = Ei.workingColorSpace) {
    return (
      Ei.fromWorkingColorSpace(ri.copy(this), t),
      (e.r = ri.r),
      (e.g = ri.g),
      (e.b = ri.b),
      e
    );
  }
  getStyle(e = Dr) {
    Ei.fromWorkingColorSpace(ri.copy(this), e);
    const t = ri.r,
      i = ri.g,
      r = ri.b;
    return e !== Dr
      ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})`
      : `rgb(${(t * 255) | 0},${(i * 255) | 0},${(r * 255) | 0})`;
  }
  offsetHSL(e, t, i) {
    return (
      this.getHSL(Rr),
      (Rr.h += e),
      (Rr.s += t),
      (Rr.l += i),
      this.setHSL(Rr.h, Rr.s, Rr.l),
      this
    );
  }
  add(e) {
    return ((this.r += e.r), (this.g += e.g), (this.b += e.b), this);
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r),
      (this.g = e.g + t.g),
      (this.b = e.b + t.b),
      this
    );
  }
  addScalar(e) {
    return ((this.r += e), (this.g += e), (this.b += e), this);
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return ((this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this);
  }
  multiplyScalar(e) {
    return ((this.r *= e), (this.g *= e), (this.b *= e), this);
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, i) {
    return (
      (this.r = e.r + (t.r - e.r) * i),
      (this.g = e.g + (t.g - e.g) * i),
      (this.b = e.b + (t.b - e.b) * i),
      this
    );
  }
  lerpHSL(e, t) {
    (this.getHSL(Rr), e.getHSL(pp));
    const i = wf(Rr.h, pp.h, t),
      r = wf(Rr.s, pp.s, t),
      s = wf(Rr.l, pp.l, t);
    return (this.setHSL(i, r, s), this);
  }
  setFromVector3(e) {
    return ((this.r = e.x), (this.g = e.y), (this.b = e.z), this);
  }
  applyMatrix3(e) {
    const t = this.r,
      i = this.g,
      r = this.b,
      s = e.elements;
    return (
      (this.r = s[0] * t + s[3] * i + s[6] * r),
      (this.g = s[1] * t + s[4] * i + s[7] * r),
      (this.b = s[2] * t + s[5] * i + s[8] * r),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return ((this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this);
  }
  toArray(e = [], t = 0) {
    return ((e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e);
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)),
      (this.g = e.getY(t)),
      (this.b = e.getZ(t)),
      this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    (yield this.r, yield this.g, yield this.b);
  }
}
const ri = new Ie();
Ie.NAMES = HB;
class Ji extends En {
  constructor(e) {
    (super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new Ie(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = Mh),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const Is = jk();
function jk() {
  const n = new ArrayBuffer(4),
    e = new Float32Array(n),
    t = new Uint32Array(n),
    i = new Uint32Array(512),
    r = new Uint32Array(512);
  for (let l = 0; l < 256; ++l) {
    const u = l - 127;
    u < -27
      ? ((i[l] = 0), (i[l | 256] = 32768), (r[l] = 24), (r[l | 256] = 24))
      : u < -14
        ? ((i[l] = 1024 >> (-u - 14)),
          (i[l | 256] = (1024 >> (-u - 14)) | 32768),
          (r[l] = -u - 1),
          (r[l | 256] = -u - 1))
        : u <= 15
          ? ((i[l] = (u + 15) << 10),
            (i[l | 256] = ((u + 15) << 10) | 32768),
            (r[l] = 13),
            (r[l | 256] = 13))
          : u < 128
            ? ((i[l] = 31744),
              (i[l | 256] = 64512),
              (r[l] = 24),
              (r[l | 256] = 24))
            : ((i[l] = 31744),
              (i[l | 256] = 64512),
              (r[l] = 13),
              (r[l | 256] = 13));
  }
  const s = new Uint32Array(2048),
    o = new Uint32Array(64),
    a = new Uint32Array(64);
  for (let l = 1; l < 1024; ++l) {
    let u = l << 13,
      h = 0;
    for (; !(u & 8388608); ) ((u <<= 1), (h -= 8388608));
    ((u &= -8388609), (h += 947912704), (s[l] = u | h));
  }
  for (let l = 1024; l < 2048; ++l) s[l] = 939524096 + ((l - 1024) << 13);
  for (let l = 1; l < 31; ++l) o[l] = l << 23;
  ((o[31] = 1199570944), (o[32] = 2147483648));
  for (let l = 33; l < 63; ++l) o[l] = 2147483648 + ((l - 32) << 23);
  o[63] = 3347054592;
  for (let l = 1; l < 64; ++l) l !== 32 && (a[l] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: i,
    shiftTable: r,
    mantissaTable: s,
    exponentTable: o,
    offsetTable: a,
  };
}
function Ci(n) {
  (Math.abs(n) > 65504 &&
    console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    (n = pn(n, -65504, 65504)),
    (Is.floatView[0] = n));
  const e = Is.uint32View[0],
    t = (e >> 23) & 511;
  return Is.baseTable[t] + ((e & 8388607) >> Is.shiftTable[t]);
}
function ff(n) {
  const e = n >> 10;
  return (
    (Is.uint32View[0] =
      Is.mantissaTable[Is.offsetTable[e] + (n & 1023)] + Is.exponentTable[e]),
    Is.floatView[0]
  );
}
const Jk = { toHalfFloat: Ci, fromHalfFloat: ff },
  Mn = new F(),
  mp = new ve();
class Dt {
  constructor(e, t, i = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    ((this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = i),
      (this.usage = nh),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0));
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return ((this.usage = e), this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, i) {
    ((e *= this.itemSize), (i *= t.itemSize));
    for (let r = 0, s = this.itemSize; r < s; r++)
      this.array[e + r] = t.array[i + r];
    return this;
  }
  copyArray(e) {
    return (this.array.set(e), this);
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, i = this.count; t < i; t++)
        (mp.fromBufferAttribute(this, t),
          mp.applyMatrix3(e),
          this.setXY(t, mp.x, mp.y));
    else if (this.itemSize === 3)
      for (let t = 0, i = this.count; t < i; t++)
        (Mn.fromBufferAttribute(this, t),
          Mn.applyMatrix3(e),
          this.setXYZ(t, Mn.x, Mn.y, Mn.z));
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.count; t < i; t++)
      (Mn.fromBufferAttribute(this, t),
        Mn.applyMatrix4(e),
        this.setXYZ(t, Mn.x, Mn.y, Mn.z));
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      (Mn.fromBufferAttribute(this, t),
        Mn.applyNormalMatrix(e),
        this.setXYZ(t, Mn.x, Mn.y, Mn.z));
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      (Mn.fromBufferAttribute(this, t),
        Mn.transformDirection(e),
        this.setXYZ(t, Mn.x, Mn.y, Mn.z));
    return this;
  }
  set(e, t = 0) {
    return (this.array.set(e, t), this);
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return (this.normalized && (t = ji(t, this.array)), t);
  }
  setX(e, t) {
    return (
      this.normalized && (t = vt(t, this.array)),
      (this.array[e * this.itemSize] = t),
      this
    );
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return (this.normalized && (t = ji(t, this.array)), t);
  }
  setY(e, t) {
    return (
      this.normalized && (t = vt(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    );
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return (this.normalized && (t = ji(t, this.array)), t);
  }
  setZ(e, t) {
    return (
      this.normalized && (t = vt(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    );
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return (this.normalized && (t = ji(t, this.array)), t);
  }
  setW(e, t) {
    return (
      this.normalized && (t = vt(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    );
  }
  setXY(e, t, i) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = vt(t, this.array)), (i = vt(i, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      this
    );
  }
  setXYZ(e, t, i, r) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = vt(t, this.array)),
        (i = vt(i, this.array)),
        (r = vt(r, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = r),
      this
    );
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = vt(t, this.array)),
        (i = vt(i, this.array)),
        (r = vt(r, this.array)),
        (s = vt(s, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = r),
      (this.array[e + 3] = s),
      this
    );
  }
  onUpload(e) {
    return ((this.onUploadCallback = e), this);
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== nh && (e.usage = this.usage),
      (this.updateRange.offset !== 0 || this.updateRange.count !== -1) &&
        (e.updateRange = this.updateRange),
      e
    );
  }
  copyColorsArray() {
    console.error(
      "THREE.BufferAttribute: copyColorsArray() was removed in r144."
    );
  }
  copyVector2sArray() {
    console.error(
      "THREE.BufferAttribute: copyVector2sArray() was removed in r144."
    );
  }
  copyVector3sArray() {
    console.error(
      "THREE.BufferAttribute: copyVector3sArray() was removed in r144."
    );
  }
  copyVector4sArray() {
    console.error(
      "THREE.BufferAttribute: copyVector4sArray() was removed in r144."
    );
  }
}
class Xk extends Dt {
  constructor(e, t, i) {
    super(new Int8Array(e), t, i);
  }
}
class Kk extends Dt {
  constructor(e, t, i) {
    super(new Uint8Array(e), t, i);
  }
}
class Yk extends Dt {
  constructor(e, t, i) {
    super(new Uint8ClampedArray(e), t, i);
  }
}
class Qk extends Dt {
  constructor(e, t, i) {
    super(new Int16Array(e), t, i);
  }
}
class tA extends Dt {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i);
  }
}
class Zk extends Dt {
  constructor(e, t, i) {
    super(new Int32Array(e), t, i);
  }
}
class nA extends Dt {
  constructor(e, t, i) {
    super(new Uint32Array(e), t, i);
  }
}
class qk extends Dt {
  constructor(e, t, i) {
    (super(new Uint16Array(e), t, i), (this.isFloat16BufferAttribute = !0));
  }
  getX(e) {
    let t = ff(this.array[e * this.itemSize]);
    return (this.normalized && (t = ji(t, this.array)), t);
  }
  setX(e, t) {
    return (
      this.normalized && (t = vt(t, this.array)),
      (this.array[e * this.itemSize] = Ci(t)),
      this
    );
  }
  getY(e) {
    let t = ff(this.array[e * this.itemSize + 1]);
    return (this.normalized && (t = ji(t, this.array)), t);
  }
  setY(e, t) {
    return (
      this.normalized && (t = vt(t, this.array)),
      (this.array[e * this.itemSize + 1] = Ci(t)),
      this
    );
  }
  getZ(e) {
    let t = ff(this.array[e * this.itemSize + 2]);
    return (this.normalized && (t = ji(t, this.array)), t);
  }
  setZ(e, t) {
    return (
      this.normalized && (t = vt(t, this.array)),
      (this.array[e * this.itemSize + 2] = Ci(t)),
      this
    );
  }
  getW(e) {
    let t = ff(this.array[e * this.itemSize + 3]);
    return (this.normalized && (t = ji(t, this.array)), t);
  }
  setW(e, t) {
    return (
      this.normalized && (t = vt(t, this.array)),
      (this.array[e * this.itemSize + 3] = Ci(t)),
      this
    );
  }
  setXY(e, t, i) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = vt(t, this.array)), (i = vt(i, this.array))),
      (this.array[e + 0] = Ci(t)),
      (this.array[e + 1] = Ci(i)),
      this
    );
  }
  setXYZ(e, t, i, r) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = vt(t, this.array)),
        (i = vt(i, this.array)),
        (r = vt(r, this.array))),
      (this.array[e + 0] = Ci(t)),
      (this.array[e + 1] = Ci(i)),
      (this.array[e + 2] = Ci(r)),
      this
    );
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = vt(t, this.array)),
        (i = vt(i, this.array)),
        (r = vt(r, this.array)),
        (s = vt(s, this.array))),
      (this.array[e + 0] = Ci(t)),
      (this.array[e + 1] = Ci(i)),
      (this.array[e + 2] = Ci(r)),
      (this.array[e + 3] = Ci(s)),
      this
    );
  }
}
class Ve extends Dt {
  constructor(e, t, i) {
    super(new Float32Array(e), t, i);
  }
}
class $k extends Dt {
  constructor(e, t, i) {
    super(new Float64Array(e), t, i);
  }
}
let eO = 0;
const cr = new ot(),
  qv = new Pt(),
  Vl = new F(),
  Gi = new Vr(),
  ju = new Vr(),
  kn = new F();
class ft extends ps {
  constructor() {
    (super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: eO++ }),
      (this.uuid = Ki()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {}));
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (GB(e) ? nA : tA)(e, 1))
        : (this.index = e),
      this
    );
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return ((this.attributes[e] = t), this);
  }
  deleteAttribute(e) {
    return (delete this.attributes[e], this);
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, i = 0) {
    this.groups.push({ start: e, count: t, materialIndex: i });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    ((this.drawRange.start = e), (this.drawRange.count = t));
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const i = this.attributes.normal;
    if (i !== void 0) {
      const s = new wt().getNormalMatrix(e);
      (i.applyNormalMatrix(s), (i.needsUpdate = !0));
    }
    const r = this.attributes.tangent;
    return (
      r !== void 0 && (r.transformDirection(e), (r.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return (cr.makeRotationFromQuaternion(e), this.applyMatrix4(cr), this);
  }
  rotateX(e) {
    return (cr.makeRotationX(e), this.applyMatrix4(cr), this);
  }
  rotateY(e) {
    return (cr.makeRotationY(e), this.applyMatrix4(cr), this);
  }
  rotateZ(e) {
    return (cr.makeRotationZ(e), this.applyMatrix4(cr), this);
  }
  translate(e, t, i) {
    return (cr.makeTranslation(e, t, i), this.applyMatrix4(cr), this);
  }
  scale(e, t, i) {
    return (cr.makeScale(e, t, i), this.applyMatrix4(cr), this);
  }
  lookAt(e) {
    return (
      qv.lookAt(e),
      qv.updateMatrix(),
      this.applyMatrix4(qv.matrix),
      this
    );
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(Vl).negate(),
      this.translate(Vl.x, Vl.y, Vl.z),
      this
    );
  }
  setFromPoints(e) {
    const t = [];
    for (let i = 0, r = e.length; i < r; i++) {
      const s = e[i];
      t.push(s.x, s.y, s.z || 0);
    }
    return (this.setAttribute("position", new Ve(t, 3)), this);
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Vr());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      (console.error(
        'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingBox.set(
          new F(-1 / 0, -1 / 0, -1 / 0),
          new F(1 / 0, 1 / 0, 1 / 0)
        ));
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let i = 0, r = t.length; i < r; i++) {
          const s = t[i];
          (Gi.setFromBufferAttribute(s),
            this.morphTargetsRelative
              ? (kn.addVectors(this.boundingBox.min, Gi.min),
                this.boundingBox.expandByPoint(kn),
                kn.addVectors(this.boundingBox.max, Gi.max),
                this.boundingBox.expandByPoint(kn))
              : (this.boundingBox.expandByPoint(Gi.min),
                this.boundingBox.expandByPoint(Gi.max)));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Wr());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      (console.error(
        'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingSphere.set(new F(), 1 / 0));
      return;
    }
    if (e) {
      const i = this.boundingSphere.center;
      if ((Gi.setFromBufferAttribute(e), t))
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s];
          (ju.setFromBufferAttribute(a),
            this.morphTargetsRelative
              ? (kn.addVectors(Gi.min, ju.min),
                Gi.expandByPoint(kn),
                kn.addVectors(Gi.max, ju.max),
                Gi.expandByPoint(kn))
              : (Gi.expandByPoint(ju.min), Gi.expandByPoint(ju.max)));
        }
      Gi.getCenter(i);
      let r = 0;
      for (let s = 0, o = e.count; s < o; s++)
        (kn.fromBufferAttribute(e, s),
          (r = Math.max(r, i.distanceToSquared(kn))));
      if (t)
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s],
            l = this.morphTargetsRelative;
          for (let u = 0, h = a.count; u < h; u++)
            (kn.fromBufferAttribute(a, u),
              l && (Vl.fromBufferAttribute(e, u), kn.add(Vl)),
              (r = Math.max(r, i.distanceToSquared(kn))));
        }
      ((this.boundingSphere.radius = Math.sqrt(r)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          ));
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (
      e === null ||
      t.position === void 0 ||
      t.normal === void 0 ||
      t.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const i = e.array,
      r = t.position.array,
      s = t.normal.array,
      o = t.uv.array,
      a = r.length / 3;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new Dt(new Float32Array(4 * a), 4));
    const l = this.getAttribute("tangent").array,
      u = [],
      h = [];
    for (let L = 0; L < a; L++) ((u[L] = new F()), (h[L] = new F()));
    const d = new F(),
      p = new F(),
      g = new F(),
      y = new ve(),
      A = new ve(),
      _ = new ve(),
      m = new F(),
      x = new F();
    function S(L, U, J) {
      (d.fromArray(r, L * 3),
        p.fromArray(r, U * 3),
        g.fromArray(r, J * 3),
        y.fromArray(o, L * 2),
        A.fromArray(o, U * 2),
        _.fromArray(o, J * 2),
        p.sub(d),
        g.sub(d),
        A.sub(y),
        _.sub(y));
      const V = 1 / (A.x * _.y - _.x * A.y);
      isFinite(V) &&
        (m
          .copy(p)
          .multiplyScalar(_.y)
          .addScaledVector(g, -A.y)
          .multiplyScalar(V),
        x
          .copy(g)
          .multiplyScalar(A.x)
          .addScaledVector(p, -_.x)
          .multiplyScalar(V),
        u[L].add(m),
        u[U].add(m),
        u[J].add(m),
        h[L].add(x),
        h[U].add(x),
        h[J].add(x));
    }
    let w = this.groups;
    w.length === 0 && (w = [{ start: 0, count: i.length }]);
    for (let L = 0, U = w.length; L < U; ++L) {
      const J = w[L],
        V = J.start,
        j = J.count;
      for (let X = V, oe = V + j; X < oe; X += 3)
        S(i[X + 0], i[X + 1], i[X + 2]);
    }
    const C = new F(),
      P = new F(),
      R = new F(),
      B = new F();
    function b(L) {
      (R.fromArray(s, L * 3), B.copy(R));
      const U = u[L];
      (C.copy(U),
        C.sub(R.multiplyScalar(R.dot(U))).normalize(),
        P.crossVectors(B, U));
      const V = P.dot(h[L]) < 0 ? -1 : 1;
      ((l[L * 4] = C.x),
        (l[L * 4 + 1] = C.y),
        (l[L * 4 + 2] = C.z),
        (l[L * 4 + 3] = V));
    }
    for (let L = 0, U = w.length; L < U; ++L) {
      const J = w[L],
        V = J.start,
        j = J.count;
      for (let X = V, oe = V + j; X < oe; X += 3)
        (b(i[X + 0]), b(i[X + 1]), b(i[X + 2]));
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute("position");
    if (t !== void 0) {
      let i = this.getAttribute("normal");
      if (i === void 0)
        ((i = new Dt(new Float32Array(t.count * 3), 3)),
          this.setAttribute("normal", i));
      else for (let p = 0, g = i.count; p < g; p++) i.setXYZ(p, 0, 0, 0);
      const r = new F(),
        s = new F(),
        o = new F(),
        a = new F(),
        l = new F(),
        u = new F(),
        h = new F(),
        d = new F();
      if (e)
        for (let p = 0, g = e.count; p < g; p += 3) {
          const y = e.getX(p + 0),
            A = e.getX(p + 1),
            _ = e.getX(p + 2);
          (r.fromBufferAttribute(t, y),
            s.fromBufferAttribute(t, A),
            o.fromBufferAttribute(t, _),
            h.subVectors(o, s),
            d.subVectors(r, s),
            h.cross(d),
            a.fromBufferAttribute(i, y),
            l.fromBufferAttribute(i, A),
            u.fromBufferAttribute(i, _),
            a.add(h),
            l.add(h),
            u.add(h),
            i.setXYZ(y, a.x, a.y, a.z),
            i.setXYZ(A, l.x, l.y, l.z),
            i.setXYZ(_, u.x, u.y, u.z));
        }
      else
        for (let p = 0, g = t.count; p < g; p += 3)
          (r.fromBufferAttribute(t, p + 0),
            s.fromBufferAttribute(t, p + 1),
            o.fromBufferAttribute(t, p + 2),
            h.subVectors(o, s),
            d.subVectors(r, s),
            h.cross(d),
            i.setXYZ(p + 0, h.x, h.y, h.z),
            i.setXYZ(p + 1, h.x, h.y, h.z),
            i.setXYZ(p + 2, h.x, h.y, h.z));
      (this.normalizeNormals(), (i.needsUpdate = !0));
    }
  }
  merge() {
    return (
      console.error(
        "THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeGeometries() instead."
      ),
      this
    );
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, i = e.count; t < i; t++)
      (kn.fromBufferAttribute(e, t),
        kn.normalize(),
        e.setXYZ(t, kn.x, kn.y, kn.z));
  }
  toNonIndexed() {
    function e(a, l) {
      const u = a.array,
        h = a.itemSize,
        d = a.normalized,
        p = new u.constructor(l.length * h);
      let g = 0,
        y = 0;
      for (let A = 0, _ = l.length; A < _; A++) {
        a.isInterleavedBufferAttribute
          ? (g = l[A] * a.data.stride + a.offset)
          : (g = l[A] * h);
        for (let m = 0; m < h; m++) p[y++] = u[g++];
      }
      return new Dt(p, h, d);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const t = new ft(),
      i = this.index.array,
      r = this.attributes;
    for (const a in r) {
      const l = r[a],
        u = e(l, i);
      t.setAttribute(a, u);
    }
    const s = this.morphAttributes;
    for (const a in s) {
      const l = [],
        u = s[a];
      for (let h = 0, d = u.length; h < d; h++) {
        const p = u[h],
          g = e(p, i);
        l.push(g);
      }
      t.morphAttributes[a] = l;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let a = 0, l = o.length; a < l; a++) {
      const u = o[a];
      t.addGroup(u.start, u.count, u.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const l = this.parameters;
      for (const u in l) l[u] !== void 0 && (e[u] = l[u]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    const i = this.attributes;
    for (const l in i) {
      const u = i[l];
      e.data.attributes[l] = u.toJSON(e.data);
    }
    const r = {};
    let s = !1;
    for (const l in this.morphAttributes) {
      const u = this.morphAttributes[l],
        h = [];
      for (let d = 0, p = u.length; d < p; d++) {
        const g = u[d];
        h.push(g.toJSON(e.data));
      }
      h.length > 0 && ((r[l] = h), (s = !0));
    }
    s &&
      ((e.data.morphAttributes = r),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const a = this.boundingSphere;
    return (
      a !== null &&
        (e.data.boundingSphere = {
          center: a.center.toArray(),
          radius: a.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    ((this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null));
    const t = {};
    this.name = e.name;
    const i = e.index;
    i !== null && this.setIndex(i.clone(t));
    const r = e.attributes;
    for (const u in r) {
      const h = r[u];
      this.setAttribute(u, h.clone(t));
    }
    const s = e.morphAttributes;
    for (const u in s) {
      const h = [],
        d = s[u];
      for (let p = 0, g = d.length; p < g; p++) h.push(d[p].clone(t));
      this.morphAttributes[u] = h;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let u = 0, h = o.length; u < h; u++) {
      const d = o[u];
      this.addGroup(d.start, d.count, d.materialIndex);
    }
    const a = e.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    const l = e.boundingSphere;
    return (
      l !== null && (this.boundingSphere = l.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const _E = new ot(),
  ns = new Sh(),
  gp = new Wr(),
  AE = new F(),
  Wl = new F(),
  jl = new F(),
  Jl = new F(),
  $v = new F(),
  vp = new F(),
  yp = new ve(),
  xp = new ve(),
  _p = new ve(),
  ME = new F(),
  SE = new F(),
  wE = new F(),
  Ap = new F(),
  Mp = new F();
class Bn extends Pt {
  constructor(e = new ft(), t = new Ji()) {
    (super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets());
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        ((this.morphTargetInfluences = []), (this.morphTargetDictionary = {}));
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          (this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s));
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const i = this.geometry,
      r = i.attributes.position,
      s = i.morphAttributes.position,
      o = i.morphTargetsRelative;
    t.fromBufferAttribute(r, e);
    const a = this.morphTargetInfluences;
    if (s && a) {
      vp.set(0, 0, 0);
      for (let l = 0, u = s.length; l < u; l++) {
        const h = a[l],
          d = s[l];
        h !== 0 &&
          ($v.fromBufferAttribute(d, e),
          o ? vp.addScaledVector($v, h) : vp.addScaledVector($v.sub(t), h));
      }
      t.add(vp);
    }
    return (this.isSkinnedMesh && this.applyBoneTransform(e, t), t);
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.material,
      s = this.matrixWorld;
    if (
      r === void 0 ||
      (i.boundingSphere === null && i.computeBoundingSphere(),
      gp.copy(i.boundingSphere),
      gp.applyMatrix4(s),
      ns.copy(e.ray).recast(e.near),
      gp.containsPoint(ns.origin) === !1 &&
        (ns.intersectSphere(gp, AE) === null ||
          ns.origin.distanceToSquared(AE) > (e.far - e.near) ** 2)) ||
      (_E.copy(s).invert(),
      ns.copy(e.ray).applyMatrix4(_E),
      i.boundingBox !== null && ns.intersectsBox(i.boundingBox) === !1)
    )
      return;
    let o;
    const a = i.index,
      l = i.attributes.position,
      u = i.attributes.uv,
      h = i.attributes.uv2,
      d = i.attributes.normal,
      p = i.groups,
      g = i.drawRange;
    if (a !== null)
      if (Array.isArray(r))
        for (let y = 0, A = p.length; y < A; y++) {
          const _ = p[y],
            m = r[_.materialIndex],
            x = Math.max(_.start, g.start),
            S = Math.min(
              a.count,
              Math.min(_.start + _.count, g.start + g.count)
            );
          for (let w = x, C = S; w < C; w += 3) {
            const P = a.getX(w),
              R = a.getX(w + 1),
              B = a.getX(w + 2);
            ((o = Sp(this, m, e, ns, u, h, d, P, R, B)),
              o &&
                ((o.faceIndex = Math.floor(w / 3)),
                (o.face.materialIndex = _.materialIndex),
                t.push(o)));
          }
        }
      else {
        const y = Math.max(0, g.start),
          A = Math.min(a.count, g.start + g.count);
        for (let _ = y, m = A; _ < m; _ += 3) {
          const x = a.getX(_),
            S = a.getX(_ + 1),
            w = a.getX(_ + 2);
          ((o = Sp(this, r, e, ns, u, h, d, x, S, w)),
            o && ((o.faceIndex = Math.floor(_ / 3)), t.push(o)));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(r))
        for (let y = 0, A = p.length; y < A; y++) {
          const _ = p[y],
            m = r[_.materialIndex],
            x = Math.max(_.start, g.start),
            S = Math.min(
              l.count,
              Math.min(_.start + _.count, g.start + g.count)
            );
          for (let w = x, C = S; w < C; w += 3) {
            const P = w,
              R = w + 1,
              B = w + 2;
            ((o = Sp(this, m, e, ns, u, h, d, P, R, B)),
              o &&
                ((o.faceIndex = Math.floor(w / 3)),
                (o.face.materialIndex = _.materialIndex),
                t.push(o)));
          }
        }
      else {
        const y = Math.max(0, g.start),
          A = Math.min(l.count, g.start + g.count);
        for (let _ = y, m = A; _ < m; _ += 3) {
          const x = _,
            S = _ + 1,
            w = _ + 2;
          ((o = Sp(this, r, e, ns, u, h, d, x, S, w)),
            o && ((o.faceIndex = Math.floor(_ / 3)), t.push(o)));
        }
      }
  }
}
function tO(n, e, t, i, r, s, o, a) {
  let l;
  if (
    (e.side === vi
      ? (l = i.intersectTriangle(o, s, r, !0, a))
      : (l = i.intersectTriangle(r, s, o, e.side === fs, a)),
    l === null)
  )
    return null;
  (Mp.copy(a), Mp.applyMatrix4(n.matrixWorld));
  const u = t.ray.origin.distanceTo(Mp);
  return u < t.near || u > t.far
    ? null
    : { distance: u, point: Mp.clone(), object: n };
}
function Sp(n, e, t, i, r, s, o, a, l, u) {
  (n.getVertexPosition(a, Wl),
    n.getVertexPosition(l, jl),
    n.getVertexPosition(u, Jl));
  const h = tO(n, e, t, i, Wl, jl, Jl, Ap);
  if (h) {
    (r &&
      (yp.fromBufferAttribute(r, a),
      xp.fromBufferAttribute(r, l),
      _p.fromBufferAttribute(r, u),
      (h.uv = bi.getInterpolation(Ap, Wl, jl, Jl, yp, xp, _p, new ve()))),
      s &&
        (yp.fromBufferAttribute(s, a),
        xp.fromBufferAttribute(s, l),
        _p.fromBufferAttribute(s, u),
        (h.uv2 = bi.getInterpolation(Ap, Wl, jl, Jl, yp, xp, _p, new ve()))),
      o &&
        (ME.fromBufferAttribute(o, a),
        SE.fromBufferAttribute(o, l),
        wE.fromBufferAttribute(o, u),
        (h.normal = bi.getInterpolation(Ap, Wl, jl, Jl, ME, SE, wE, new F())),
        h.normal.dot(i.direction) > 0 && h.normal.multiplyScalar(-1)));
    const d = { a, b: l, c: u, normal: new F(), materialIndex: 0 };
    (bi.getNormal(Wl, jl, Jl, d.normal), (h.face = d));
  }
  return h;
}
class na extends ft {
  constructor(e = 1, t = 1, i = 1, r = 1, s = 1, o = 1) {
    (super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: i,
        widthSegments: r,
        heightSegments: s,
        depthSegments: o,
      }));
    const a = this;
    ((r = Math.floor(r)), (s = Math.floor(s)), (o = Math.floor(o)));
    const l = [],
      u = [],
      h = [],
      d = [];
    let p = 0,
      g = 0;
    (y("z", "y", "x", -1, -1, i, t, e, o, s, 0),
      y("z", "y", "x", 1, -1, i, t, -e, o, s, 1),
      y("x", "z", "y", 1, 1, e, i, t, r, o, 2),
      y("x", "z", "y", 1, -1, e, i, -t, r, o, 3),
      y("x", "y", "z", 1, -1, e, t, i, r, s, 4),
      y("x", "y", "z", -1, -1, e, t, -i, r, s, 5),
      this.setIndex(l),
      this.setAttribute("position", new Ve(u, 3)),
      this.setAttribute("normal", new Ve(h, 3)),
      this.setAttribute("uv", new Ve(d, 2)));
    function y(A, _, m, x, S, w, C, P, R, B, b) {
      const L = w / R,
        U = C / B,
        J = w / 2,
        V = C / 2,
        j = P / 2,
        X = R + 1,
        oe = B + 1;
      let ae = 0,
        I = 0;
      const G = new F();
      for (let z = 0; z < oe; z++) {
        const q = z * U - V;
        for (let Q = 0; Q < X; Q++) {
          const ee = Q * L - J;
          ((G[A] = ee * x),
            (G[_] = q * S),
            (G[m] = j),
            u.push(G.x, G.y, G.z),
            (G[A] = 0),
            (G[_] = 0),
            (G[m] = P > 0 ? 1 : -1),
            h.push(G.x, G.y, G.z),
            d.push(Q / R),
            d.push(1 - z / B),
            (ae += 1));
        }
      }
      for (let z = 0; z < B; z++)
        for (let q = 0; q < R; q++) {
          const Q = p + q + X * z,
            ee = p + q + X * (z + 1),
            ne = p + (q + 1) + X * (z + 1),
            Ee = p + (q + 1) + X * z;
          (l.push(Q, ee, Ee), l.push(ee, ne, Ee), (I += 6));
        }
      (a.addGroup(g, I, b), (g += I), (p += ae));
    }
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new na(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function Xc(n) {
  const e = {};
  for (const t in n) {
    e[t] = {};
    for (const i in n[t]) {
      const r = n[t][i];
      r &&
      (r.isColor ||
        r.isMatrix3 ||
        r.isMatrix4 ||
        r.isVector2 ||
        r.isVector3 ||
        r.isVector4 ||
        r.isTexture ||
        r.isQuaternion)
        ? r.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
            ),
            (e[t][i] = null))
          : (e[t][i] = r.clone())
        : Array.isArray(r)
          ? (e[t][i] = r.slice())
          : (e[t][i] = r);
    }
  }
  return e;
}
function di(n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const i = Xc(n[t]);
    for (const r in i) e[r] = i[r];
  }
  return e;
}
function nO(n) {
  const e = [];
  for (let t = 0; t < n.length; t++) e.push(n[t].clone());
  return e;
}
function VB(n) {
  return n.getRenderTarget() === null && n.outputEncoding === Tt ? Dr : jc;
}
const WB = { clone: Xc, merge: di };
var iO = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  rO = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class ds extends En {
  constructor(e) {
    (super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = iO),
      (this.fragmentShader = rO),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1,
      }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv2: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = Xc(e.uniforms)),
      (this.uniformsGroups = nO(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    ((t.glslVersion = this.glslVersion), (t.uniforms = {}));
    for (const r in this.uniforms) {
      const o = this.uniforms[r].value;
      o && o.isTexture
        ? (t.uniforms[r] = { type: "t", value: o.toJSON(e).uuid })
        : o && o.isColor
          ? (t.uniforms[r] = { type: "c", value: o.getHex() })
          : o && o.isVector2
            ? (t.uniforms[r] = { type: "v2", value: o.toArray() })
            : o && o.isVector3
              ? (t.uniforms[r] = { type: "v3", value: o.toArray() })
              : o && o.isVector4
                ? (t.uniforms[r] = { type: "v4", value: o.toArray() })
                : o && o.isMatrix3
                  ? (t.uniforms[r] = { type: "m3", value: o.toArray() })
                  : o && o.isMatrix4
                    ? (t.uniforms[r] = { type: "m4", value: o.toArray() })
                    : (t.uniforms[r] = { value: o });
    }
    (Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader));
    const i = {};
    for (const r in this.extensions) this.extensions[r] === !0 && (i[r] = !0);
    return (Object.keys(i).length > 0 && (t.extensions = i), t);
  }
}
class wh extends Pt {
  constructor() {
    (super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new ot()),
      (this.projectionMatrix = new ot()),
      (this.projectionMatrixInverse = new ot()));
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      this
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(-t[8], -t[9], -t[10]).normalize();
  }
  updateMatrixWorld(e) {
    (super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert());
  }
  updateWorldMatrix(e, t) {
    (super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert());
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Vt extends wh {
  constructor(e = 50, t = 1, i = 0.1, r = 2e3) {
    (super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = i),
      (this.far = r),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix());
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    ((this.fov = Jc * 2 * Math.atan(t)), this.updateProjectionMatrix());
  }
  getFocalLength() {
    const e = Math.tan(Za * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return Jc * 2 * Math.atan(Math.tan(Za * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(e, t, i, r, s, o) {
    ((this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix());
  }
  clearViewOffset() {
    (this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix());
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(Za * 0.5 * this.fov)) / this.zoom,
      i = 2 * t,
      r = this.aspect * i,
      s = -0.5 * r;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = o.fullWidth,
        u = o.fullHeight;
      ((s += (o.offsetX * r) / l),
        (t -= (o.offsetY * i) / u),
        (r *= o.width / l),
        (i *= o.height / u));
    }
    const a = this.filmOffset;
    (a !== 0 && (s += (e * a) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(s, s + r, t, t - i, e, this.far),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert());
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
const Xl = -90,
  Kl = 1;
class iA extends Pt {
  constructor(e, t, i) {
    (super(), (this.type = "CubeCamera"), (this.renderTarget = i));
    const r = new Vt(Xl, Kl, e, t);
    ((r.layers = this.layers),
      r.up.set(0, 1, 0),
      r.lookAt(1, 0, 0),
      this.add(r));
    const s = new Vt(Xl, Kl, e, t);
    ((s.layers = this.layers),
      s.up.set(0, 1, 0),
      s.lookAt(-1, 0, 0),
      this.add(s));
    const o = new Vt(Xl, Kl, e, t);
    ((o.layers = this.layers),
      o.up.set(0, 0, -1),
      o.lookAt(0, 1, 0),
      this.add(o));
    const a = new Vt(Xl, Kl, e, t);
    ((a.layers = this.layers),
      a.up.set(0, 0, 1),
      a.lookAt(0, -1, 0),
      this.add(a));
    const l = new Vt(Xl, Kl, e, t);
    ((l.layers = this.layers),
      l.up.set(0, 1, 0),
      l.lookAt(0, 0, 1),
      this.add(l));
    const u = new Vt(Xl, Kl, e, t);
    ((u.layers = this.layers),
      u.up.set(0, 1, 0),
      u.lookAt(0, 0, -1),
      this.add(u));
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const i = this.renderTarget,
      [r, s, o, a, l, u] = this.children,
      h = e.getRenderTarget(),
      d = e.toneMapping,
      p = e.xr.enabled;
    ((e.toneMapping = Ur), (e.xr.enabled = !1));
    const g = i.texture.generateMipmaps;
    ((i.texture.generateMipmaps = !1),
      e.setRenderTarget(i, 0),
      e.render(t, r),
      e.setRenderTarget(i, 1),
      e.render(t, s),
      e.setRenderTarget(i, 2),
      e.render(t, o),
      e.setRenderTarget(i, 3),
      e.render(t, a),
      e.setRenderTarget(i, 4),
      e.render(t, l),
      (i.texture.generateMipmaps = g),
      e.setRenderTarget(i, 5),
      e.render(t, u),
      e.setRenderTarget(h),
      (e.toneMapping = d),
      (e.xr.enabled = p),
      (i.texture.needsPMREMUpdate = !0));
  }
}
class Eh extends en {
  constructor(e, t, i, r, s, o, a, l, u, h) {
    ((e = e !== void 0 ? e : []),
      (t = t !== void 0 ? t : Xo),
      super(e, t, i, r, s, o, a, l, u, h),
      (this.isCubeTexture = !0),
      (this.flipY = !1));
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class rA extends Hr {
  constructor(e = 1, t = {}) {
    (super(e, e, t), (this.isWebGLCubeRenderTarget = !0));
    const i = { width: e, height: e, depth: 1 },
      r = [i, i, i, i, i, i];
    ((this.texture = new Eh(
      r,
      t.mapping,
      t.wrapS,
      t.wrapT,
      t.magFilter,
      t.minFilter,
      t.format,
      t.type,
      t.anisotropy,
      t.encoding
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
      (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : rn));
  }
  fromEquirectangularTexture(e, t) {
    ((this.texture.type = t.type),
      (this.texture.encoding = t.encoding),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter));
    const i = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      r = new na(5, 5, 5),
      s = new ds({
        name: "CubemapFromEquirect",
        uniforms: Xc(i.uniforms),
        vertexShader: i.vertexShader,
        fragmentShader: i.fragmentShader,
        side: vi,
        blending: Hs,
      });
    s.uniforms.tEquirect.value = t;
    const o = new Bn(r, s),
      a = t.minFilter;
    return (
      t.minFilter === hs && (t.minFilter = rn),
      new iA(1, 10, this).update(e, o),
      (t.minFilter = a),
      o.geometry.dispose(),
      o.material.dispose(),
      this
    );
  }
  clear(e, t, i, r) {
    const s = e.getRenderTarget();
    for (let o = 0; o < 6; o++) (e.setRenderTarget(this, o), e.clear(t, i, r));
    e.setRenderTarget(s);
  }
}
const ey = new F(),
  sO = new F(),
  oO = new wt();
class Eo {
  constructor(e = new F(1, 0, 0), t = 0) {
    ((this.isPlane = !0), (this.normal = e), (this.constant = t));
  }
  set(e, t) {
    return (this.normal.copy(e), (this.constant = t), this);
  }
  setComponents(e, t, i, r) {
    return (this.normal.set(e, t, i), (this.constant = r), this);
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return (this.normal.copy(e), (this.constant = -t.dot(this.normal)), this);
  }
  setFromCoplanarPoints(e, t, i) {
    const r = ey.subVectors(i, t).cross(sO.subVectors(e, t)).normalize();
    return (this.setFromNormalAndCoplanarPoint(r, e), this);
  }
  copy(e) {
    return (this.normal.copy(e.normal), (this.constant = e.constant), this);
  }
  normalize() {
    const e = 1 / this.normal.length();
    return (this.normal.multiplyScalar(e), (this.constant *= e), this);
  }
  negate() {
    return ((this.constant *= -1), this.normal.negate(), this);
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const i = e.delta(ey),
      r = this.normal.dot(i);
    if (r === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / r;
    return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(i, s);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      i = this.distanceToPoint(e.end);
    return (t < 0 && i > 0) || (i < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const i = t || oO.getNormalMatrix(e),
      r = this.coplanarPoint(ey).applyMatrix4(e),
      s = this.normal.applyMatrix3(i).normalize();
    return ((this.constant = -r.dot(s)), this);
  }
  translate(e) {
    return ((this.constant -= e.dot(this.normal)), this);
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const ya = new Wr(),
  wp = new F();
class Og {
  constructor(
    e = new Eo(),
    t = new Eo(),
    i = new Eo(),
    r = new Eo(),
    s = new Eo(),
    o = new Eo()
  ) {
    this.planes = [e, t, i, r, s, o];
  }
  set(e, t, i, r, s, o) {
    const a = this.planes;
    return (
      a[0].copy(e),
      a[1].copy(t),
      a[2].copy(i),
      a[3].copy(r),
      a[4].copy(s),
      a[5].copy(o),
      this
    );
  }
  copy(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
    return this;
  }
  setFromProjectionMatrix(e) {
    const t = this.planes,
      i = e.elements,
      r = i[0],
      s = i[1],
      o = i[2],
      a = i[3],
      l = i[4],
      u = i[5],
      h = i[6],
      d = i[7],
      p = i[8],
      g = i[9],
      y = i[10],
      A = i[11],
      _ = i[12],
      m = i[13],
      x = i[14],
      S = i[15];
    return (
      t[0].setComponents(a - r, d - l, A - p, S - _).normalize(),
      t[1].setComponents(a + r, d + l, A + p, S + _).normalize(),
      t[2].setComponents(a + s, d + u, A + g, S + m).normalize(),
      t[3].setComponents(a - s, d - u, A - g, S - m).normalize(),
      t[4].setComponents(a - o, d - h, A - y, S - x).normalize(),
      t[5].setComponents(a + o, d + h, A + y, S + x).normalize(),
      this
    );
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      (e.boundingSphere === null && e.computeBoundingSphere(),
        ya.copy(e.boundingSphere).applyMatrix4(e.matrixWorld));
    else {
      const t = e.geometry;
      (t.boundingSphere === null && t.computeBoundingSphere(),
        ya.copy(t.boundingSphere).applyMatrix4(e.matrixWorld));
    }
    return this.intersectsSphere(ya);
  }
  intersectsSprite(e) {
    return (
      ya.center.set(0, 0, 0),
      (ya.radius = 0.7071067811865476),
      ya.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(ya)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      i = e.center,
      r = -e.radius;
    for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(i) < r) return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) {
      const r = t[i];
      if (
        ((wp.x = r.normal.x > 0 ? e.max.x : e.min.x),
        (wp.y = r.normal.y > 0 ? e.max.y : e.min.y),
        (wp.z = r.normal.z > 0 ? e.max.z : e.min.z),
        r.distanceToPoint(wp) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) if (t[i].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function jB() {
  let n = null,
    e = !1,
    t = null,
    i = null;
  function r(s, o) {
    (t(s, o), (i = n.requestAnimationFrame(r)));
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((i = n.requestAnimationFrame(r)), (e = !0));
    },
    stop: function () {
      (n.cancelAnimationFrame(i), (e = !1));
    },
    setAnimationLoop: function (s) {
      t = s;
    },
    setContext: function (s) {
      n = s;
    },
  };
}
function aO(n, e) {
  const t = e.isWebGL2,
    i = new WeakMap();
  function r(u, h) {
    const d = u.array,
      p = u.usage,
      g = n.createBuffer();
    (n.bindBuffer(h, g), n.bufferData(h, d, p), u.onUploadCallback());
    let y;
    if (d instanceof Float32Array) y = 5126;
    else if (d instanceof Uint16Array)
      if (u.isFloat16BufferAttribute)
        if (t) y = 5131;
        else
          throw new Error(
            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
          );
      else y = 5123;
    else if (d instanceof Int16Array) y = 5122;
    else if (d instanceof Uint32Array) y = 5125;
    else if (d instanceof Int32Array) y = 5124;
    else if (d instanceof Int8Array) y = 5120;
    else if (d instanceof Uint8Array) y = 5121;
    else if (d instanceof Uint8ClampedArray) y = 5121;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + d
      );
    return {
      buffer: g,
      type: y,
      bytesPerElement: d.BYTES_PER_ELEMENT,
      version: u.version,
    };
  }
  function s(u, h, d) {
    const p = h.array,
      g = h.updateRange;
    (n.bindBuffer(d, u),
      g.count === -1
        ? n.bufferSubData(d, 0, p)
        : (t
            ? n.bufferSubData(
                d,
                g.offset * p.BYTES_PER_ELEMENT,
                p,
                g.offset,
                g.count
              )
            : n.bufferSubData(
                d,
                g.offset * p.BYTES_PER_ELEMENT,
                p.subarray(g.offset, g.offset + g.count)
              ),
          (g.count = -1)),
      h.onUploadCallback());
  }
  function o(u) {
    return (u.isInterleavedBufferAttribute && (u = u.data), i.get(u));
  }
  function a(u) {
    u.isInterleavedBufferAttribute && (u = u.data);
    const h = i.get(u);
    h && (n.deleteBuffer(h.buffer), i.delete(u));
  }
  function l(u, h) {
    if (u.isGLBufferAttribute) {
      const p = i.get(u);
      (!p || p.version < u.version) &&
        i.set(u, {
          buffer: u.buffer,
          type: u.type,
          bytesPerElement: u.elementSize,
          version: u.version,
        });
      return;
    }
    u.isInterleavedBufferAttribute && (u = u.data);
    const d = i.get(u);
    d === void 0
      ? i.set(u, r(u, h))
      : d.version < u.version && (s(d.buffer, u, h), (d.version = u.version));
  }
  return { get: o, remove: a, update: l };
}
class ru extends ft {
  constructor(e = 1, t = 1, i = 1, r = 1) {
    (super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: i,
        heightSegments: r,
      }));
    const s = e / 2,
      o = t / 2,
      a = Math.floor(i),
      l = Math.floor(r),
      u = a + 1,
      h = l + 1,
      d = e / a,
      p = t / l,
      g = [],
      y = [],
      A = [],
      _ = [];
    for (let m = 0; m < h; m++) {
      const x = m * p - o;
      for (let S = 0; S < u; S++) {
        const w = S * d - s;
        (y.push(w, -x, 0), A.push(0, 0, 1), _.push(S / a), _.push(1 - m / l));
      }
    }
    for (let m = 0; m < l; m++)
      for (let x = 0; x < a; x++) {
        const S = x + u * m,
          w = x + u * (m + 1),
          C = x + 1 + u * (m + 1),
          P = x + 1 + u * m;
        (g.push(S, w, P), g.push(w, C, P));
      }
    (this.setIndex(g),
      this.setAttribute("position", new Ve(y, 3)),
      this.setAttribute("normal", new Ve(A, 3)),
      this.setAttribute("uv", new Ve(_, 2)));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new ru(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var lO = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  cO = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  uO = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
  fO = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  hO = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  dO = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  pO = "vec3 transformed = vec3( position );",
  mO = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  gO = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  vO = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  yO = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  xO = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
  _O = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  AO = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  MO = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  SO = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  wO = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  EO = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
  CO = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
  TO = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  bO = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  PO = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  BO = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  RO = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  LO = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  IO = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  DO = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  FO = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  NO = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  kO = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  OO = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  UO = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  zO = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  GO = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  HO = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  VO = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  WO = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  jO = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  JO = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
  XO = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  KO = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  YO = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  QO = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  ZO = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,
  qO = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  $O = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  eU = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  tU = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  nU = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif`,
  iU = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  rU = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  sU = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  oU = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
  aU = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  lU = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  cU = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
  uU = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
  fU = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  hU = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  dU = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  pU = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  mU = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  gU = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  vU = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  yU = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
  xU = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
  _U = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
  AU = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#ifdef USE_NORMALMAP_TANGENTSPACE
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal, vNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 geometryNormal = normal;`,
  MU = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  SU = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  wU = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  EU = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  CU = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  TU = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
  bU = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  PU = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  BU = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  RU = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  LU = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  IU = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  DU = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  FU = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  NU = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  kU = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  OU = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  UU = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
  zU = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  GU = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  HU = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  VU = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  WU = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
  jU = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  JU = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  XU = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  KU = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  YU = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  QU = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  ZU = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`,
  qU = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, vec2 fullSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		
		vec2 lodFudge = pow( 1.95, lod ) / fullSize;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec2 fullSize = vec2( textureSize( sampler, 0 ) );
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), fullSize, floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), fullSize, ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,
  $U = `#ifdef USE_UV
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  ez = `#ifdef USE_UV
	varying vec2 vUv;
#endif
#ifdef USE_UV2
	attribute vec2 uv2;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  tz = `#ifdef USE_UV
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  nz = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const iz = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  rz = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  sz = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  oz = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  az = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  lz = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  cz = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  uz = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
  fz = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  hz = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  dz = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  pz = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  mz = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  gz = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  vz = `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  yz = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  xz = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  _z = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Az = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  Mz = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Sz = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  wz = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  Ez = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  Cz = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Tz = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  bz = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Pz = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  Bz = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Rz = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  Lz = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  Iz = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  Dz = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
  Fz = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  Nz = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
  gt = {
    alphamap_fragment: lO,
    alphamap_pars_fragment: cO,
    alphatest_fragment: uO,
    alphatest_pars_fragment: fO,
    aomap_fragment: hO,
    aomap_pars_fragment: dO,
    begin_vertex: pO,
    beginnormal_vertex: mO,
    bsdfs: gO,
    iridescence_fragment: vO,
    bumpmap_pars_fragment: yO,
    clipping_planes_fragment: xO,
    clipping_planes_pars_fragment: _O,
    clipping_planes_pars_vertex: AO,
    clipping_planes_vertex: MO,
    color_fragment: SO,
    color_pars_fragment: wO,
    color_pars_vertex: EO,
    color_vertex: CO,
    common: TO,
    cube_uv_reflection_fragment: bO,
    defaultnormal_vertex: PO,
    displacementmap_pars_vertex: BO,
    displacementmap_vertex: RO,
    emissivemap_fragment: LO,
    emissivemap_pars_fragment: IO,
    encodings_fragment: DO,
    encodings_pars_fragment: FO,
    envmap_fragment: NO,
    envmap_common_pars_fragment: kO,
    envmap_pars_fragment: OO,
    envmap_pars_vertex: UO,
    envmap_physical_pars_fragment: ZO,
    envmap_vertex: zO,
    fog_vertex: GO,
    fog_pars_vertex: HO,
    fog_fragment: VO,
    fog_pars_fragment: WO,
    gradientmap_pars_fragment: jO,
    lightmap_fragment: JO,
    lightmap_pars_fragment: XO,
    lights_lambert_fragment: KO,
    lights_lambert_pars_fragment: YO,
    lights_pars_begin: QO,
    lights_toon_fragment: qO,
    lights_toon_pars_fragment: $O,
    lights_phong_fragment: eU,
    lights_phong_pars_fragment: tU,
    lights_physical_fragment: nU,
    lights_physical_pars_fragment: iU,
    lights_fragment_begin: rU,
    lights_fragment_maps: sU,
    lights_fragment_end: oU,
    logdepthbuf_fragment: aU,
    logdepthbuf_pars_fragment: lU,
    logdepthbuf_pars_vertex: cU,
    logdepthbuf_vertex: uU,
    map_fragment: fU,
    map_pars_fragment: hU,
    map_particle_fragment: dU,
    map_particle_pars_fragment: pU,
    metalnessmap_fragment: mU,
    metalnessmap_pars_fragment: gU,
    morphcolor_vertex: vU,
    morphnormal_vertex: yU,
    morphtarget_pars_vertex: xU,
    morphtarget_vertex: _U,
    normal_fragment_begin: AU,
    normal_fragment_maps: MU,
    normal_pars_fragment: SU,
    normal_pars_vertex: wU,
    normal_vertex: EU,
    normalmap_pars_fragment: CU,
    clearcoat_normal_fragment_begin: TU,
    clearcoat_normal_fragment_maps: bU,
    clearcoat_pars_fragment: PU,
    iridescence_pars_fragment: BU,
    output_fragment: RU,
    packing: LU,
    premultiplied_alpha_fragment: IU,
    project_vertex: DU,
    dithering_fragment: FU,
    dithering_pars_fragment: NU,
    roughnessmap_fragment: kU,
    roughnessmap_pars_fragment: OU,
    shadowmap_pars_fragment: UU,
    shadowmap_pars_vertex: zU,
    shadowmap_vertex: GU,
    shadowmask_pars_fragment: HU,
    skinbase_vertex: VU,
    skinning_pars_vertex: WU,
    skinning_vertex: jU,
    skinnormal_vertex: JU,
    specularmap_fragment: XU,
    specularmap_pars_fragment: KU,
    tonemapping_fragment: YU,
    tonemapping_pars_fragment: QU,
    transmission_fragment: ZU,
    transmission_pars_fragment: qU,
    uv_pars_fragment: $U,
    uv_pars_vertex: ez,
    uv_vertex: tz,
    worldpos_vertex: nz,
    background_vert: iz,
    background_frag: rz,
    backgroundCube_vert: sz,
    backgroundCube_frag: oz,
    cube_vert: az,
    cube_frag: lz,
    depth_vert: cz,
    depth_frag: uz,
    distanceRGBA_vert: fz,
    distanceRGBA_frag: hz,
    equirect_vert: dz,
    equirect_frag: pz,
    linedashed_vert: mz,
    linedashed_frag: gz,
    meshbasic_vert: vz,
    meshbasic_frag: yz,
    meshlambert_vert: xz,
    meshlambert_frag: _z,
    meshmatcap_vert: Az,
    meshmatcap_frag: Mz,
    meshnormal_vert: Sz,
    meshnormal_frag: wz,
    meshphong_vert: Ez,
    meshphong_frag: Cz,
    meshphysical_vert: Tz,
    meshphysical_frag: bz,
    meshtoon_vert: Pz,
    meshtoon_frag: Bz,
    points_vert: Rz,
    points_frag: Lz,
    shadow_vert: Iz,
    shadow_frag: Dz,
    sprite_vert: Fz,
    sprite_frag: Nz,
  },
  De = {
    common: {
      diffuse: { value: new Ie(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new wt() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new wt() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new wt() },
    },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new wt() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new wt() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new wt() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new wt() },
      normalScale: { value: new ve(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new wt() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new wt() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new wt() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new wt() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new Ie(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new Ie(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
      uvTransform: { value: new wt() },
    },
    sprite: {
      diffuse: { value: new Ie(16777215) },
      opacity: { value: 1 },
      center: { value: new ve(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new wt() },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
    },
  },
  Nr = {
    basic: {
      uniforms: di([
        De.common,
        De.specularmap,
        De.envmap,
        De.aomap,
        De.lightmap,
        De.fog,
      ]),
      vertexShader: gt.meshbasic_vert,
      fragmentShader: gt.meshbasic_frag,
    },
    lambert: {
      uniforms: di([
        De.common,
        De.specularmap,
        De.envmap,
        De.aomap,
        De.lightmap,
        De.emissivemap,
        De.bumpmap,
        De.normalmap,
        De.displacementmap,
        De.fog,
        De.lights,
        { emissive: { value: new Ie(0) } },
      ]),
      vertexShader: gt.meshlambert_vert,
      fragmentShader: gt.meshlambert_frag,
    },
    phong: {
      uniforms: di([
        De.common,
        De.specularmap,
        De.envmap,
        De.aomap,
        De.lightmap,
        De.emissivemap,
        De.bumpmap,
        De.normalmap,
        De.displacementmap,
        De.fog,
        De.lights,
        {
          emissive: { value: new Ie(0) },
          specular: { value: new Ie(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: gt.meshphong_vert,
      fragmentShader: gt.meshphong_frag,
    },
    standard: {
      uniforms: di([
        De.common,
        De.envmap,
        De.aomap,
        De.lightmap,
        De.emissivemap,
        De.bumpmap,
        De.normalmap,
        De.displacementmap,
        De.roughnessmap,
        De.metalnessmap,
        De.fog,
        De.lights,
        {
          emissive: { value: new Ie(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: gt.meshphysical_vert,
      fragmentShader: gt.meshphysical_frag,
    },
    toon: {
      uniforms: di([
        De.common,
        De.aomap,
        De.lightmap,
        De.emissivemap,
        De.bumpmap,
        De.normalmap,
        De.displacementmap,
        De.gradientmap,
        De.fog,
        De.lights,
        { emissive: { value: new Ie(0) } },
      ]),
      vertexShader: gt.meshtoon_vert,
      fragmentShader: gt.meshtoon_frag,
    },
    matcap: {
      uniforms: di([
        De.common,
        De.bumpmap,
        De.normalmap,
        De.displacementmap,
        De.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: gt.meshmatcap_vert,
      fragmentShader: gt.meshmatcap_frag,
    },
    points: {
      uniforms: di([De.points, De.fog]),
      vertexShader: gt.points_vert,
      fragmentShader: gt.points_frag,
    },
    dashed: {
      uniforms: di([
        De.common,
        De.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: gt.linedashed_vert,
      fragmentShader: gt.linedashed_frag,
    },
    depth: {
      uniforms: di([De.common, De.displacementmap]),
      vertexShader: gt.depth_vert,
      fragmentShader: gt.depth_frag,
    },
    normal: {
      uniforms: di([
        De.common,
        De.bumpmap,
        De.normalmap,
        De.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: gt.meshnormal_vert,
      fragmentShader: gt.meshnormal_frag,
    },
    sprite: {
      uniforms: di([De.sprite, De.fog]),
      vertexShader: gt.sprite_vert,
      fragmentShader: gt.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new wt() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: gt.background_vert,
      fragmentShader: gt.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: gt.backgroundCube_vert,
      fragmentShader: gt.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: gt.cube_vert,
      fragmentShader: gt.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: gt.equirect_vert,
      fragmentShader: gt.equirect_frag,
    },
    distanceRGBA: {
      uniforms: di([
        De.common,
        De.displacementmap,
        {
          referencePosition: { value: new F() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: gt.distanceRGBA_vert,
      fragmentShader: gt.distanceRGBA_frag,
    },
    shadow: {
      uniforms: di([
        De.lights,
        De.fog,
        { color: { value: new Ie(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: gt.shadow_vert,
      fragmentShader: gt.shadow_frag,
    },
  };
Nr.physical = {
  uniforms: di([
    Nr.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new wt() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new wt() },
      clearcoatNormalScale: { value: new ve(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new wt() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new wt() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new wt() },
      sheen: { value: 0 },
      sheenColor: { value: new Ie(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new wt() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new wt() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new wt() },
      transmissionSamplerSize: { value: new ve() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new wt() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Ie(0) },
      specularColor: { value: new Ie(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new wt() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new wt() },
    },
  ]),
  vertexShader: gt.meshphysical_vert,
  fragmentShader: gt.meshphysical_frag,
};
const Ep = { r: 0, b: 0, g: 0 };
function kz(n, e, t, i, r, s, o) {
  const a = new Ie(0);
  let l = s === !0 ? 0 : 1,
    u,
    h,
    d = null,
    p = 0,
    g = null;
  function y(_, m) {
    let x = !1,
      S = m.isScene === !0 ? m.background : null;
    S && S.isTexture && (S = (m.backgroundBlurriness > 0 ? t : e).get(S));
    const w = n.xr,
      C = w.getSession && w.getSession();
    (C && C.environmentBlendMode === "additive" && (S = null),
      S === null ? A(a, l) : S && S.isColor && (A(S, 1), (x = !0)),
      (n.autoClear || x) &&
        n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil),
      S && (S.isCubeTexture || S.mapping === iu)
        ? (h === void 0 &&
            ((h = new Bn(
              new na(1, 1, 1),
              new ds({
                name: "BackgroundCubeMaterial",
                uniforms: Xc(Nr.backgroundCube.uniforms),
                vertexShader: Nr.backgroundCube.vertexShader,
                fragmentShader: Nr.backgroundCube.fragmentShader,
                side: vi,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            h.geometry.deleteAttribute("normal"),
            h.geometry.deleteAttribute("uv"),
            (h.onBeforeRender = function (P, R, B) {
              this.matrixWorld.copyPosition(B.matrixWorld);
            }),
            Object.defineProperty(h.material, "envMap", {
              get: function () {
                return this.uniforms.envMap.value;
              },
            }),
            r.update(h)),
          (h.material.uniforms.envMap.value = S),
          (h.material.uniforms.flipEnvMap.value =
            S.isCubeTexture && S.isRenderTargetTexture === !1 ? -1 : 1),
          (h.material.uniforms.backgroundBlurriness.value =
            m.backgroundBlurriness),
          (h.material.uniforms.backgroundIntensity.value =
            m.backgroundIntensity),
          (h.material.toneMapped = S.encoding !== Tt),
          (d !== S || p !== S.version || g !== n.toneMapping) &&
            ((h.material.needsUpdate = !0),
            (d = S),
            (p = S.version),
            (g = n.toneMapping)),
          h.layers.enableAll(),
          _.unshift(h, h.geometry, h.material, 0, 0, null))
        : S &&
          S.isTexture &&
          (u === void 0 &&
            ((u = new Bn(
              new ru(2, 2),
              new ds({
                name: "BackgroundMaterial",
                uniforms: Xc(Nr.background.uniforms),
                vertexShader: Nr.background.vertexShader,
                fragmentShader: Nr.background.fragmentShader,
                side: fs,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            u.geometry.deleteAttribute("normal"),
            Object.defineProperty(u.material, "map", {
              get: function () {
                return this.uniforms.t2D.value;
              },
            }),
            r.update(u)),
          (u.material.uniforms.t2D.value = S),
          (u.material.uniforms.backgroundIntensity.value =
            m.backgroundIntensity),
          (u.material.toneMapped = S.encoding !== Tt),
          S.matrixAutoUpdate === !0 && S.updateMatrix(),
          u.material.uniforms.uvTransform.value.copy(S.matrix),
          (d !== S || p !== S.version || g !== n.toneMapping) &&
            ((u.material.needsUpdate = !0),
            (d = S),
            (p = S.version),
            (g = n.toneMapping)),
          u.layers.enableAll(),
          _.unshift(u, u.geometry, u.material, 0, 0, null)));
  }
  function A(_, m) {
    (_.getRGB(Ep, VB(n)), i.buffers.color.setClear(Ep.r, Ep.g, Ep.b, m, o));
  }
  return {
    getClearColor: function () {
      return a;
    },
    setClearColor: function (_, m = 1) {
      (a.set(_), (l = m), A(a, l));
    },
    getClearAlpha: function () {
      return l;
    },
    setClearAlpha: function (_) {
      ((l = _), A(a, l));
    },
    render: y,
  };
}
function Oz(n, e, t, i) {
  const r = n.getParameter(34921),
    s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
    o = i.isWebGL2 || s !== null,
    a = {},
    l = _(null);
  let u = l,
    h = !1;
  function d(j, X, oe, ae, I) {
    let G = !1;
    if (o) {
      const z = A(ae, oe, X);
      (u !== z && ((u = z), g(u.object)),
        (G = m(j, ae, oe, I)),
        G && x(j, ae, oe, I));
    } else {
      const z = X.wireframe === !0;
      (u.geometry !== ae.id || u.program !== oe.id || u.wireframe !== z) &&
        ((u.geometry = ae.id),
        (u.program = oe.id),
        (u.wireframe = z),
        (G = !0));
    }
    (I !== null && t.update(I, 34963),
      (G || h) &&
        ((h = !1),
        B(j, X, oe, ae),
        I !== null && n.bindBuffer(34963, t.get(I).buffer)));
  }
  function p() {
    return i.isWebGL2 ? n.createVertexArray() : s.createVertexArrayOES();
  }
  function g(j) {
    return i.isWebGL2 ? n.bindVertexArray(j) : s.bindVertexArrayOES(j);
  }
  function y(j) {
    return i.isWebGL2 ? n.deleteVertexArray(j) : s.deleteVertexArrayOES(j);
  }
  function A(j, X, oe) {
    const ae = oe.wireframe === !0;
    let I = a[j.id];
    I === void 0 && ((I = {}), (a[j.id] = I));
    let G = I[X.id];
    G === void 0 && ((G = {}), (I[X.id] = G));
    let z = G[ae];
    return (z === void 0 && ((z = _(p())), (G[ae] = z)), z);
  }
  function _(j) {
    const X = [],
      oe = [],
      ae = [];
    for (let I = 0; I < r; I++) ((X[I] = 0), (oe[I] = 0), (ae[I] = 0));
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: X,
      enabledAttributes: oe,
      attributeDivisors: ae,
      object: j,
      attributes: {},
      index: null,
    };
  }
  function m(j, X, oe, ae) {
    const I = u.attributes,
      G = X.attributes;
    let z = 0;
    const q = oe.getAttributes();
    for (const Q in q)
      if (q[Q].location >= 0) {
        const ne = I[Q];
        let Ee = G[Q];
        if (
          (Ee === void 0 &&
            (Q === "instanceMatrix" &&
              j.instanceMatrix &&
              (Ee = j.instanceMatrix),
            Q === "instanceColor" && j.instanceColor && (Ee = j.instanceColor)),
          ne === void 0 || ne.attribute !== Ee || (Ee && ne.data !== Ee.data))
        )
          return !0;
        z++;
      }
    return u.attributesNum !== z || u.index !== ae;
  }
  function x(j, X, oe, ae) {
    const I = {},
      G = X.attributes;
    let z = 0;
    const q = oe.getAttributes();
    for (const Q in q)
      if (q[Q].location >= 0) {
        let ne = G[Q];
        ne === void 0 &&
          (Q === "instanceMatrix" &&
            j.instanceMatrix &&
            (ne = j.instanceMatrix),
          Q === "instanceColor" && j.instanceColor && (ne = j.instanceColor));
        const Ee = {};
        ((Ee.attribute = ne),
          ne && ne.data && (Ee.data = ne.data),
          (I[Q] = Ee),
          z++);
      }
    ((u.attributes = I), (u.attributesNum = z), (u.index = ae));
  }
  function S() {
    const j = u.newAttributes;
    for (let X = 0, oe = j.length; X < oe; X++) j[X] = 0;
  }
  function w(j) {
    C(j, 0);
  }
  function C(j, X) {
    const oe = u.newAttributes,
      ae = u.enabledAttributes,
      I = u.attributeDivisors;
    ((oe[j] = 1),
      ae[j] === 0 && (n.enableVertexAttribArray(j), (ae[j] = 1)),
      I[j] !== X &&
        ((i.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))[
          i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
        ](j, X),
        (I[j] = X)));
  }
  function P() {
    const j = u.newAttributes,
      X = u.enabledAttributes;
    for (let oe = 0, ae = X.length; oe < ae; oe++)
      X[oe] !== j[oe] && (n.disableVertexAttribArray(oe), (X[oe] = 0));
  }
  function R(j, X, oe, ae, I, G) {
    i.isWebGL2 === !0 && (oe === 5124 || oe === 5125)
      ? n.vertexAttribIPointer(j, X, oe, I, G)
      : n.vertexAttribPointer(j, X, oe, ae, I, G);
  }
  function B(j, X, oe, ae) {
    if (
      i.isWebGL2 === !1 &&
      (j.isInstancedMesh || ae.isInstancedBufferGeometry) &&
      e.get("ANGLE_instanced_arrays") === null
    )
      return;
    S();
    const I = ae.attributes,
      G = oe.getAttributes(),
      z = X.defaultAttributeValues;
    for (const q in G) {
      const Q = G[q];
      if (Q.location >= 0) {
        let ee = I[q];
        if (
          (ee === void 0 &&
            (q === "instanceMatrix" &&
              j.instanceMatrix &&
              (ee = j.instanceMatrix),
            q === "instanceColor" && j.instanceColor && (ee = j.instanceColor)),
          ee !== void 0)
        ) {
          const ne = ee.normalized,
            Ee = ee.itemSize,
            Ae = t.get(ee);
          if (Ae === void 0) continue;
          const $ = Ae.buffer,
            Je = Ae.type,
            Xe = Ae.bytesPerElement;
          if (ee.isInterleavedBufferAttribute) {
            const xe = ee.data,
              Se = xe.stride,
              ge = ee.offset;
            if (xe.isInstancedInterleavedBuffer) {
              for (let se = 0; se < Q.locationSize; se++)
                C(Q.location + se, xe.meshPerAttribute);
              j.isInstancedMesh !== !0 &&
                ae._maxInstanceCount === void 0 &&
                (ae._maxInstanceCount = xe.meshPerAttribute * xe.count);
            } else
              for (let se = 0; se < Q.locationSize; se++) w(Q.location + se);
            n.bindBuffer(34962, $);
            for (let se = 0; se < Q.locationSize; se++)
              R(
                Q.location + se,
                Ee / Q.locationSize,
                Je,
                ne,
                Se * Xe,
                (ge + (Ee / Q.locationSize) * se) * Xe
              );
          } else {
            if (ee.isInstancedBufferAttribute) {
              for (let xe = 0; xe < Q.locationSize; xe++)
                C(Q.location + xe, ee.meshPerAttribute);
              j.isInstancedMesh !== !0 &&
                ae._maxInstanceCount === void 0 &&
                (ae._maxInstanceCount = ee.meshPerAttribute * ee.count);
            } else
              for (let xe = 0; xe < Q.locationSize; xe++) w(Q.location + xe);
            n.bindBuffer(34962, $);
            for (let xe = 0; xe < Q.locationSize; xe++)
              R(
                Q.location + xe,
                Ee / Q.locationSize,
                Je,
                ne,
                Ee * Xe,
                (Ee / Q.locationSize) * xe * Xe
              );
          }
        } else if (z !== void 0) {
          const ne = z[q];
          if (ne !== void 0)
            switch (ne.length) {
              case 2:
                n.vertexAttrib2fv(Q.location, ne);
                break;
              case 3:
                n.vertexAttrib3fv(Q.location, ne);
                break;
              case 4:
                n.vertexAttrib4fv(Q.location, ne);
                break;
              default:
                n.vertexAttrib1fv(Q.location, ne);
            }
        }
      }
    }
    P();
  }
  function b() {
    J();
    for (const j in a) {
      const X = a[j];
      for (const oe in X) {
        const ae = X[oe];
        for (const I in ae) (y(ae[I].object), delete ae[I]);
        delete X[oe];
      }
      delete a[j];
    }
  }
  function L(j) {
    if (a[j.id] === void 0) return;
    const X = a[j.id];
    for (const oe in X) {
      const ae = X[oe];
      for (const I in ae) (y(ae[I].object), delete ae[I]);
      delete X[oe];
    }
    delete a[j.id];
  }
  function U(j) {
    for (const X in a) {
      const oe = a[X];
      if (oe[j.id] === void 0) continue;
      const ae = oe[j.id];
      for (const I in ae) (y(ae[I].object), delete ae[I]);
      delete oe[j.id];
    }
  }
  function J() {
    (V(), (h = !0), u !== l && ((u = l), g(u.object)));
  }
  function V() {
    ((l.geometry = null), (l.program = null), (l.wireframe = !1));
  }
  return {
    setup: d,
    reset: J,
    resetDefaultState: V,
    dispose: b,
    releaseStatesOfGeometry: L,
    releaseStatesOfProgram: U,
    initAttributes: S,
    enableAttribute: w,
    disableUnusedAttributes: P,
  };
}
function Uz(n, e, t, i) {
  const r = i.isWebGL2;
  let s;
  function o(u) {
    s = u;
  }
  function a(u, h) {
    (n.drawArrays(s, u, h), t.update(h, s, 1));
  }
  function l(u, h, d) {
    if (d === 0) return;
    let p, g;
    if (r) ((p = n), (g = "drawArraysInstanced"));
    else if (
      ((p = e.get("ANGLE_instanced_arrays")),
      (g = "drawArraysInstancedANGLE"),
      p === null)
    ) {
      console.error(
        "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    (p[g](s, u, h, d), t.update(h, s, d));
  }
  ((this.setMode = o), (this.render = a), (this.renderInstances = l));
}
function zz(n, e, t) {
  let i;
  function r() {
    if (i !== void 0) return i;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const R = e.get("EXT_texture_filter_anisotropic");
      i = n.getParameter(R.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else i = 0;
    return i;
  }
  function s(R) {
    if (R === "highp") {
      if (
        n.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
        n.getShaderPrecisionFormat(35632, 36338).precision > 0
      )
        return "highp";
      R = "mediump";
    }
    return R === "mediump" &&
      n.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
      n.getShaderPrecisionFormat(35632, 36337).precision > 0
      ? "mediump"
      : "lowp";
  }
  const o =
    typeof WebGL2RenderingContext < "u" &&
    n.constructor.name === "WebGL2RenderingContext";
  let a = t.precision !== void 0 ? t.precision : "highp";
  const l = s(a);
  l !== a &&
    (console.warn(
      "THREE.WebGLRenderer:",
      a,
      "not supported, using",
      l,
      "instead."
    ),
    (a = l));
  const u = o || e.has("WEBGL_draw_buffers"),
    h = t.logarithmicDepthBuffer === !0,
    d = n.getParameter(34930),
    p = n.getParameter(35660),
    g = n.getParameter(3379),
    y = n.getParameter(34076),
    A = n.getParameter(34921),
    _ = n.getParameter(36347),
    m = n.getParameter(36348),
    x = n.getParameter(36349),
    S = p > 0,
    w = o || e.has("OES_texture_float"),
    C = S && w,
    P = o ? n.getParameter(36183) : 0;
  return {
    isWebGL2: o,
    drawBuffers: u,
    getMaxAnisotropy: r,
    getMaxPrecision: s,
    precision: a,
    logarithmicDepthBuffer: h,
    maxTextures: d,
    maxVertexTextures: p,
    maxTextureSize: g,
    maxCubemapSize: y,
    maxAttributes: A,
    maxVertexUniforms: _,
    maxVaryings: m,
    maxFragmentUniforms: x,
    vertexTextures: S,
    floatFragmentTextures: w,
    floatVertexTextures: C,
    maxSamples: P,
  };
}
function Gz(n) {
  const e = this;
  let t = null,
    i = 0,
    r = !1,
    s = !1;
  const o = new Eo(),
    a = new wt(),
    l = { value: null, needsUpdate: !1 };
  ((this.uniform = l),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (d, p) {
      const g = d.length !== 0 || p || i !== 0 || r;
      return ((r = p), (i = d.length), g);
    }),
    (this.beginShadows = function () {
      ((s = !0), h(null));
    }),
    (this.endShadows = function () {
      s = !1;
    }),
    (this.setGlobalState = function (d, p) {
      t = h(d, p, 0);
    }),
    (this.setState = function (d, p, g) {
      const y = d.clippingPlanes,
        A = d.clipIntersection,
        _ = d.clipShadows,
        m = n.get(d);
      if (!r || y === null || y.length === 0 || (s && !_)) s ? h(null) : u();
      else {
        const x = s ? 0 : i,
          S = x * 4;
        let w = m.clippingState || null;
        ((l.value = w), (w = h(y, p, S, g)));
        for (let C = 0; C !== S; ++C) w[C] = t[C];
        ((m.clippingState = w),
          (this.numIntersection = A ? this.numPlanes : 0),
          (this.numPlanes += x));
      }
    }));
  function u() {
    (l.value !== t && ((l.value = t), (l.needsUpdate = i > 0)),
      (e.numPlanes = i),
      (e.numIntersection = 0));
  }
  function h(d, p, g, y) {
    const A = d !== null ? d.length : 0;
    let _ = null;
    if (A !== 0) {
      if (((_ = l.value), y !== !0 || _ === null)) {
        const m = g + A * 4,
          x = p.matrixWorldInverse;
        (a.getNormalMatrix(x),
          (_ === null || _.length < m) && (_ = new Float32Array(m)));
        for (let S = 0, w = g; S !== A; ++S, w += 4)
          (o.copy(d[S]).applyMatrix4(x, a),
            o.normal.toArray(_, w),
            (_[w + 3] = o.constant));
      }
      ((l.value = _), (l.needsUpdate = !0));
    }
    return ((e.numPlanes = A), (e.numIntersection = 0), _);
  }
}
function Hz(n) {
  let e = new WeakMap();
  function t(o, a) {
    return (a === qf ? (o.mapping = Xo) : a === $f && (o.mapping = Ko), o);
  }
  function i(o) {
    if (o && o.isTexture && o.isRenderTargetTexture === !1) {
      const a = o.mapping;
      if (a === qf || a === $f)
        if (e.has(o)) {
          const l = e.get(o).texture;
          return t(l, o.mapping);
        } else {
          const l = o.image;
          if (l && l.height > 0) {
            const u = new rA(l.height / 2);
            return (
              u.fromEquirectangularTexture(n, o),
              e.set(o, u),
              o.addEventListener("dispose", r),
              t(u.texture, o.mapping)
            );
          } else return null;
        }
    }
    return o;
  }
  function r(o) {
    const a = o.target;
    a.removeEventListener("dispose", r);
    const l = e.get(a);
    l !== void 0 && (e.delete(a), l.dispose());
  }
  function s() {
    e = new WeakMap();
  }
  return { get: i, dispose: s };
}
class zr extends wh {
  constructor(e = -1, t = 1, i = 1, r = -1, s = 0.1, o = 2e3) {
    (super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = i),
      (this.bottom = r),
      (this.near = s),
      (this.far = o),
      this.updateProjectionMatrix());
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, i, r, s, o) {
    (this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix());
  }
  clearViewOffset() {
    (this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix());
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      i = (this.right + this.left) / 2,
      r = (this.top + this.bottom) / 2;
    let s = i - e,
      o = i + e,
      a = r + t,
      l = r - t;
    if (this.view !== null && this.view.enabled) {
      const u = (this.right - this.left) / this.view.fullWidth / this.zoom,
        h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      ((s += u * this.view.offsetX),
        (o = s + u * this.view.width),
        (a -= h * this.view.offsetY),
        (l = a - h * this.view.height));
    }
    (this.projectionMatrix.makeOrthographic(s, o, a, l, this.near, this.far),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert());
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
const yc = 4,
  EE = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  Fa = 20,
  ty = new zr(),
  CE = new Ie();
let ny = null;
const Ba = (1 + Math.sqrt(5)) / 2,
  Yl = 1 / Ba,
  TE = [
    new F(1, 1, 1),
    new F(-1, 1, 1),
    new F(1, 1, -1),
    new F(-1, 1, -1),
    new F(0, Ba, Yl),
    new F(0, Ba, -Yl),
    new F(Yl, 0, Ba),
    new F(-Yl, 0, Ba),
    new F(Ba, Yl, 0),
    new F(-Ba, Yl, 0),
  ];
class p_ {
  constructor(e) {
    ((this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial));
  }
  fromScene(e, t = 0, i = 0.1, r = 100) {
    ((ny = this._renderer.getRenderTarget()), this._setSize(256));
    const s = this._allocateTargets();
    return (
      (s.depthBuffer = !0),
      this._sceneToCubeUV(e, i, r, s),
      t > 0 && this._blur(s, 0, 0, t),
      this._applyPMREM(s),
      this._cleanup(s),
      s
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = BE()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = PE()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    (this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose());
  }
  _setSize(e) {
    ((this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax)));
  }
  _dispose() {
    (this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose());
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    (this._renderer.setRenderTarget(ny),
      (e.scissorTest = !1),
      Cp(e, 0, 0, e.width, e.height));
  }
  _fromTexture(e, t) {
    (e.mapping === Xo || e.mapping === Ko
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (ny = this._renderer.getRenderTarget()));
    const i = t || this._allocateTargets();
    return (
      this._textureToCubeUV(e, i),
      this._applyPMREM(i),
      this._cleanup(i),
      i
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      i = {
        magFilter: rn,
        minFilter: rn,
        generateMipmaps: !1,
        type: Vc,
        format: Pi,
        encoding: Qs,
        depthBuffer: !1,
      },
      r = bE(e, t, i);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== t
    ) {
      (this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = bE(e, t, i)));
      const { _lodMax: s } = this;
      (({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = Vz(s)),
        (this._blurMaterial = Wz(s, e, t)));
    }
    return r;
  }
  _compileMaterial(e) {
    const t = new Bn(this._lodPlanes[0], e);
    this._renderer.compile(t, ty);
  }
  _sceneToCubeUV(e, t, i, r) {
    const a = new Vt(90, 1, t, i),
      l = [1, -1, 1, 1, 1, 1],
      u = [1, 1, 1, -1, -1, -1],
      h = this._renderer,
      d = h.autoClear,
      p = h.toneMapping;
    (h.getClearColor(CE), (h.toneMapping = Ur), (h.autoClear = !1));
    const g = new Ji({
        name: "PMREM.Background",
        side: vi,
        depthWrite: !1,
        depthTest: !1,
      }),
      y = new Bn(new na(), g);
    let A = !1;
    const _ = e.background;
    _
      ? _.isColor && (g.color.copy(_), (e.background = null), (A = !0))
      : (g.color.copy(CE), (A = !0));
    for (let m = 0; m < 6; m++) {
      const x = m % 3;
      x === 0
        ? (a.up.set(0, l[m], 0), a.lookAt(u[m], 0, 0))
        : x === 1
          ? (a.up.set(0, 0, l[m]), a.lookAt(0, u[m], 0))
          : (a.up.set(0, l[m], 0), a.lookAt(0, 0, u[m]));
      const S = this._cubeSize;
      (Cp(r, x * S, m > 2 ? S : 0, S, S),
        h.setRenderTarget(r),
        A && h.render(y, a),
        h.render(e, a));
    }
    (y.geometry.dispose(),
      y.material.dispose(),
      (h.toneMapping = p),
      (h.autoClear = d),
      (e.background = _));
  }
  _textureToCubeUV(e, t) {
    const i = this._renderer,
      r = e.mapping === Xo || e.mapping === Ko;
    r
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = BE()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = PE());
    const s = r ? this._cubemapMaterial : this._equirectMaterial,
      o = new Bn(this._lodPlanes[0], s),
      a = s.uniforms;
    a.envMap.value = e;
    const l = this._cubeSize;
    (Cp(t, 0, 0, 3 * l, 2 * l), i.setRenderTarget(t), i.render(o, ty));
  }
  _applyPMREM(e) {
    const t = this._renderer,
      i = t.autoClear;
    t.autoClear = !1;
    for (let r = 1; r < this._lodPlanes.length; r++) {
      const s = Math.sqrt(
          this._sigmas[r] * this._sigmas[r] -
            this._sigmas[r - 1] * this._sigmas[r - 1]
        ),
        o = TE[(r - 1) % TE.length];
      this._blur(e, r - 1, r, s, o);
    }
    t.autoClear = i;
  }
  _blur(e, t, i, r, s) {
    const o = this._pingPongRenderTarget;
    (this._halfBlur(e, o, t, i, r, "latitudinal", s),
      this._halfBlur(o, e, i, i, r, "longitudinal", s));
  }
  _halfBlur(e, t, i, r, s, o, a) {
    const l = this._renderer,
      u = this._blurMaterial;
    o !== "latitudinal" &&
      o !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const h = 3,
      d = new Bn(this._lodPlanes[r], u),
      p = u.uniforms,
      g = this._sizeLods[i] - 1,
      y = isFinite(s) ? Math.PI / (2 * g) : (2 * Math.PI) / (2 * Fa - 1),
      A = s / y,
      _ = isFinite(s) ? 1 + Math.floor(h * A) : Fa;
    _ > Fa &&
      console.warn(
        `sigmaRadians, ${s}, is too large and will clip, as it requested ${_} samples when the maximum is set to ${Fa}`
      );
    const m = [];
    let x = 0;
    for (let R = 0; R < Fa; ++R) {
      const B = R / A,
        b = Math.exp((-B * B) / 2);
      (m.push(b), R === 0 ? (x += b) : R < _ && (x += 2 * b));
    }
    for (let R = 0; R < m.length; R++) m[R] = m[R] / x;
    ((p.envMap.value = e.texture),
      (p.samples.value = _),
      (p.weights.value = m),
      (p.latitudinal.value = o === "latitudinal"),
      a && (p.poleAxis.value = a));
    const { _lodMax: S } = this;
    ((p.dTheta.value = y), (p.mipInt.value = S - i));
    const w = this._sizeLods[r],
      C = 3 * w * (r > S - yc ? r - S + yc : 0),
      P = 4 * (this._cubeSize - w);
    (Cp(t, C, P, 3 * w, 2 * w), l.setRenderTarget(t), l.render(d, ty));
  }
}
function Vz(n) {
  const e = [],
    t = [],
    i = [];
  let r = n;
  const s = n - yc + 1 + EE.length;
  for (let o = 0; o < s; o++) {
    const a = Math.pow(2, r);
    t.push(a);
    let l = 1 / a;
    (o > n - yc ? (l = EE[o - n + yc - 1]) : o === 0 && (l = 0), i.push(l));
    const u = 1 / (a - 2),
      h = -u,
      d = 1 + u,
      p = [h, h, d, h, d, d, h, h, d, d, h, d],
      g = 6,
      y = 6,
      A = 3,
      _ = 2,
      m = 1,
      x = new Float32Array(A * y * g),
      S = new Float32Array(_ * y * g),
      w = new Float32Array(m * y * g);
    for (let P = 0; P < g; P++) {
      const R = ((P % 3) * 2) / 3 - 1,
        B = P > 2 ? 0 : -1,
        b = [
          R,
          B,
          0,
          R + 2 / 3,
          B,
          0,
          R + 2 / 3,
          B + 1,
          0,
          R,
          B,
          0,
          R + 2 / 3,
          B + 1,
          0,
          R,
          B + 1,
          0,
        ];
      (x.set(b, A * y * P), S.set(p, _ * y * P));
      const L = [P, P, P, P, P, P];
      w.set(L, m * y * P);
    }
    const C = new ft();
    (C.setAttribute("position", new Dt(x, A)),
      C.setAttribute("uv", new Dt(S, _)),
      C.setAttribute("faceIndex", new Dt(w, m)),
      e.push(C),
      r > yc && r--);
  }
  return { lodPlanes: e, sizeLods: t, sigmas: i };
}
function bE(n, e, t) {
  const i = new Hr(n, e, t);
  return (
    (i.texture.mapping = iu),
    (i.texture.name = "PMREM.cubeUv"),
    (i.scissorTest = !0),
    i
  );
}
function Cp(n, e, t, i, r) {
  (n.viewport.set(e, t, i, r), n.scissor.set(e, t, i, r));
}
function Wz(n, e, t) {
  const i = new Float32Array(Fa),
    r = new F(0, 1, 0);
  return new ds({
    name: "SphericalGaussianBlur",
    defines: {
      n: Fa,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${n}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: i },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: r },
    },
    vertexShader: sA(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: Hs,
    depthTest: !1,
    depthWrite: !1,
  });
}
function PE() {
  return new ds({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: sA(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: Hs,
    depthTest: !1,
    depthWrite: !1,
  });
}
function BE() {
  return new ds({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: sA(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: Hs,
    depthTest: !1,
    depthWrite: !1,
  });
}
function sA() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function jz(n) {
  let e = new WeakMap(),
    t = null;
  function i(a) {
    if (a && a.isTexture) {
      const l = a.mapping,
        u = l === qf || l === $f,
        h = l === Xo || l === Ko;
      if (u || h)
        if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
          a.needsPMREMUpdate = !1;
          let d = e.get(a);
          return (
            t === null && (t = new p_(n)),
            (d = u ? t.fromEquirectangular(a, d) : t.fromCubemap(a, d)),
            e.set(a, d),
            d.texture
          );
        } else {
          if (e.has(a)) return e.get(a).texture;
          {
            const d = a.image;
            if ((u && d && d.height > 0) || (h && d && r(d))) {
              t === null && (t = new p_(n));
              const p = u ? t.fromEquirectangular(a) : t.fromCubemap(a);
              return (e.set(a, p), a.addEventListener("dispose", s), p.texture);
            } else return null;
          }
        }
    }
    return a;
  }
  function r(a) {
    let l = 0;
    const u = 6;
    for (let h = 0; h < u; h++) a[h] !== void 0 && l++;
    return l === u;
  }
  function s(a) {
    const l = a.target;
    l.removeEventListener("dispose", s);
    const u = e.get(l);
    u !== void 0 && (e.delete(l), u.dispose());
  }
  function o() {
    ((e = new WeakMap()), t !== null && (t.dispose(), (t = null)));
  }
  return { get: i, dispose: o };
}
function Jz(n) {
  const e = {};
  function t(i) {
    if (e[i] !== void 0) return e[i];
    let r;
    switch (i) {
      case "WEBGL_depth_texture":
        r =
          n.getExtension("WEBGL_depth_texture") ||
          n.getExtension("MOZ_WEBGL_depth_texture") ||
          n.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        r =
          n.getExtension("EXT_texture_filter_anisotropic") ||
          n.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        r =
          n.getExtension("WEBGL_compressed_texture_s3tc") ||
          n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        r =
          n.getExtension("WEBGL_compressed_texture_pvrtc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        r = n.getExtension(i);
    }
    return ((e[i] = r), r);
  }
  return {
    has: function (i) {
      return t(i) !== null;
    },
    init: function (i) {
      (i.isWebGL2
        ? t("EXT_color_buffer_float")
        : (t("WEBGL_depth_texture"),
          t("OES_texture_float"),
          t("OES_texture_half_float"),
          t("OES_texture_half_float_linear"),
          t("OES_standard_derivatives"),
          t("OES_element_index_uint"),
          t("OES_vertex_array_object"),
          t("ANGLE_instanced_arrays")),
        t("OES_texture_float_linear"),
        t("EXT_color_buffer_half_float"),
        t("WEBGL_multisampled_render_to_texture"));
    },
    get: function (i) {
      const r = t(i);
      return (
        r === null &&
          console.warn(
            "THREE.WebGLRenderer: " + i + " extension not supported."
          ),
        r
      );
    },
  };
}
function Xz(n, e, t, i) {
  const r = {},
    s = new WeakMap();
  function o(d) {
    const p = d.target;
    p.index !== null && e.remove(p.index);
    for (const y in p.attributes) e.remove(p.attributes[y]);
    (p.removeEventListener("dispose", o), delete r[p.id]);
    const g = s.get(p);
    (g && (e.remove(g), s.delete(p)),
      i.releaseStatesOfGeometry(p),
      p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount,
      t.memory.geometries--);
  }
  function a(d, p) {
    return (
      r[p.id] === !0 ||
        (p.addEventListener("dispose", o),
        (r[p.id] = !0),
        t.memory.geometries++),
      p
    );
  }
  function l(d) {
    const p = d.attributes;
    for (const y in p) e.update(p[y], 34962);
    const g = d.morphAttributes;
    for (const y in g) {
      const A = g[y];
      for (let _ = 0, m = A.length; _ < m; _++) e.update(A[_], 34962);
    }
  }
  function u(d) {
    const p = [],
      g = d.index,
      y = d.attributes.position;
    let A = 0;
    if (g !== null) {
      const x = g.array;
      A = g.version;
      for (let S = 0, w = x.length; S < w; S += 3) {
        const C = x[S + 0],
          P = x[S + 1],
          R = x[S + 2];
        p.push(C, P, P, R, R, C);
      }
    } else {
      const x = y.array;
      A = y.version;
      for (let S = 0, w = x.length / 3 - 1; S < w; S += 3) {
        const C = S + 0,
          P = S + 1,
          R = S + 2;
        p.push(C, P, P, R, R, C);
      }
    }
    const _ = new (GB(p) ? nA : tA)(p, 1);
    _.version = A;
    const m = s.get(d);
    (m && e.remove(m), s.set(d, _));
  }
  function h(d) {
    const p = s.get(d);
    if (p) {
      const g = d.index;
      g !== null && p.version < g.version && u(d);
    } else u(d);
    return s.get(d);
  }
  return { get: a, update: l, getWireframeAttribute: h };
}
function Kz(n, e, t, i) {
  const r = i.isWebGL2;
  let s;
  function o(p) {
    s = p;
  }
  let a, l;
  function u(p) {
    ((a = p.type), (l = p.bytesPerElement));
  }
  function h(p, g) {
    (n.drawElements(s, g, a, p * l), t.update(g, s, 1));
  }
  function d(p, g, y) {
    if (y === 0) return;
    let A, _;
    if (r) ((A = n), (_ = "drawElementsInstanced"));
    else if (
      ((A = e.get("ANGLE_instanced_arrays")),
      (_ = "drawElementsInstancedANGLE"),
      A === null)
    ) {
      console.error(
        "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    (A[_](s, g, a, p * l, y), t.update(g, s, y));
  }
  ((this.setMode = o),
    (this.setIndex = u),
    (this.render = h),
    (this.renderInstances = d));
}
function Yz(n) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function i(s, o, a) {
    switch ((t.calls++, o)) {
      case 4:
        t.triangles += a * (s / 3);
        break;
      case 1:
        t.lines += a * (s / 2);
        break;
      case 3:
        t.lines += a * (s - 1);
        break;
      case 2:
        t.lines += a * s;
        break;
      case 0:
        t.points += a * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function r() {
    (t.frame++,
      (t.calls = 0),
      (t.triangles = 0),
      (t.points = 0),
      (t.lines = 0));
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: r,
    update: i,
  };
}
function Qz(n, e) {
  return n[0] - e[0];
}
function Zz(n, e) {
  return Math.abs(e[1]) - Math.abs(n[1]);
}
function qz(n, e, t) {
  const i = {},
    r = new Float32Array(8),
    s = new WeakMap(),
    o = new kt(),
    a = [];
  for (let u = 0; u < 8; u++) a[u] = [u, 0];
  function l(u, h, d) {
    const p = u.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const y =
          h.morphAttributes.position ||
          h.morphAttributes.normal ||
          h.morphAttributes.color,
        A = y !== void 0 ? y.length : 0;
      let _ = s.get(h);
      if (_ === void 0 || _.count !== A) {
        let X = function () {
          (V.dispose(), s.delete(h), h.removeEventListener("dispose", X));
        };
        var g = X;
        _ !== void 0 && _.texture.dispose();
        const S = h.morphAttributes.position !== void 0,
          w = h.morphAttributes.normal !== void 0,
          C = h.morphAttributes.color !== void 0,
          P = h.morphAttributes.position || [],
          R = h.morphAttributes.normal || [],
          B = h.morphAttributes.color || [];
        let b = 0;
        (S === !0 && (b = 1), w === !0 && (b = 2), C === !0 && (b = 3));
        let L = h.attributes.position.count * b,
          U = 1;
        L > e.maxTextureSize &&
          ((U = Math.ceil(L / e.maxTextureSize)), (L = e.maxTextureSize));
        const J = new Float32Array(L * U * 4 * A),
          V = new kg(J, L, U, A);
        ((V.type = Os), (V.needsUpdate = !0));
        const j = b * 4;
        for (let oe = 0; oe < A; oe++) {
          const ae = P[oe],
            I = R[oe],
            G = B[oe],
            z = L * U * 4 * oe;
          for (let q = 0; q < ae.count; q++) {
            const Q = q * j;
            (S === !0 &&
              (o.fromBufferAttribute(ae, q),
              (J[z + Q + 0] = o.x),
              (J[z + Q + 1] = o.y),
              (J[z + Q + 2] = o.z),
              (J[z + Q + 3] = 0)),
              w === !0 &&
                (o.fromBufferAttribute(I, q),
                (J[z + Q + 4] = o.x),
                (J[z + Q + 5] = o.y),
                (J[z + Q + 6] = o.z),
                (J[z + Q + 7] = 0)),
              C === !0 &&
                (o.fromBufferAttribute(G, q),
                (J[z + Q + 8] = o.x),
                (J[z + Q + 9] = o.y),
                (J[z + Q + 10] = o.z),
                (J[z + Q + 11] = G.itemSize === 4 ? o.w : 1)));
          }
        }
        ((_ = { count: A, texture: V, size: new ve(L, U) }),
          s.set(h, _),
          h.addEventListener("dispose", X));
      }
      let m = 0;
      for (let S = 0; S < p.length; S++) m += p[S];
      const x = h.morphTargetsRelative ? 1 : 1 - m;
      (d.getUniforms().setValue(n, "morphTargetBaseInfluence", x),
        d.getUniforms().setValue(n, "morphTargetInfluences", p),
        d.getUniforms().setValue(n, "morphTargetsTexture", _.texture, t),
        d.getUniforms().setValue(n, "morphTargetsTextureSize", _.size));
    } else {
      const y = p === void 0 ? 0 : p.length;
      let A = i[h.id];
      if (A === void 0 || A.length !== y) {
        A = [];
        for (let w = 0; w < y; w++) A[w] = [w, 0];
        i[h.id] = A;
      }
      for (let w = 0; w < y; w++) {
        const C = A[w];
        ((C[0] = w), (C[1] = p[w]));
      }
      A.sort(Zz);
      for (let w = 0; w < 8; w++)
        w < y && A[w][1]
          ? ((a[w][0] = A[w][0]), (a[w][1] = A[w][1]))
          : ((a[w][0] = Number.MAX_SAFE_INTEGER), (a[w][1] = 0));
      a.sort(Qz);
      const _ = h.morphAttributes.position,
        m = h.morphAttributes.normal;
      let x = 0;
      for (let w = 0; w < 8; w++) {
        const C = a[w],
          P = C[0],
          R = C[1];
        P !== Number.MAX_SAFE_INTEGER && R
          ? (_ &&
              h.getAttribute("morphTarget" + w) !== _[P] &&
              h.setAttribute("morphTarget" + w, _[P]),
            m &&
              h.getAttribute("morphNormal" + w) !== m[P] &&
              h.setAttribute("morphNormal" + w, m[P]),
            (r[w] = R),
            (x += R))
          : (_ &&
              h.hasAttribute("morphTarget" + w) === !0 &&
              h.deleteAttribute("morphTarget" + w),
            m &&
              h.hasAttribute("morphNormal" + w) === !0 &&
              h.deleteAttribute("morphNormal" + w),
            (r[w] = 0));
      }
      const S = h.morphTargetsRelative ? 1 : 1 - x;
      (d.getUniforms().setValue(n, "morphTargetBaseInfluence", S),
        d.getUniforms().setValue(n, "morphTargetInfluences", r));
    }
  }
  return { update: l };
}
function $z(n, e, t, i) {
  let r = new WeakMap();
  function s(l) {
    const u = i.render.frame,
      h = l.geometry,
      d = e.get(l, h);
    return (
      r.get(d) !== u && (e.update(d), r.set(d, u)),
      l.isInstancedMesh &&
        (l.hasEventListener("dispose", a) === !1 &&
          l.addEventListener("dispose", a),
        t.update(l.instanceMatrix, 34962),
        l.instanceColor !== null && t.update(l.instanceColor, 34962)),
      d
    );
  }
  function o() {
    r = new WeakMap();
  }
  function a(l) {
    const u = l.target;
    (u.removeEventListener("dispose", a),
      t.remove(u.instanceMatrix),
      u.instanceColor !== null && t.remove(u.instanceColor));
  }
  return { update: s, dispose: o };
}
const JB = new en(),
  XB = new kg(),
  KB = new eA(),
  YB = new Eh(),
  RE = [],
  LE = [],
  IE = new Float32Array(16),
  DE = new Float32Array(9),
  FE = new Float32Array(4);
function su(n, e, t) {
  const i = n[0];
  if (i <= 0 || i > 0) return n;
  const r = e * t;
  let s = RE[r];
  if ((s === void 0 && ((s = new Float32Array(r)), (RE[r] = s)), e !== 0)) {
    i.toArray(s, 0);
    for (let o = 1, a = 0; o !== e; ++o) ((a += t), n[o].toArray(s, a));
  }
  return s;
}
function Rn(n, e) {
  if (n.length !== e.length) return !1;
  for (let t = 0, i = n.length; t < i; t++) if (n[t] !== e[t]) return !1;
  return !0;
}
function Ln(n, e) {
  for (let t = 0, i = e.length; t < i; t++) n[t] = e[t];
}
function Ug(n, e) {
  let t = LE[e];
  t === void 0 && ((t = new Int32Array(e)), (LE[e] = t));
  for (let i = 0; i !== e; ++i) t[i] = n.allocateTextureUnit();
  return t;
}
function e4(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1f(this.addr, e), (t[0] = e));
}
function t4(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Rn(t, e)) return;
    (n.uniform2fv(this.addr, e), Ln(t, e));
  }
}
function n4(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3f(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (n.uniform3f(this.addr, e.r, e.g, e.b),
      (t[0] = e.r),
      (t[1] = e.g),
      (t[2] = e.b));
  else {
    if (Rn(t, e)) return;
    (n.uniform3fv(this.addr, e), Ln(t, e));
  }
}
function i4(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Rn(t, e)) return;
    (n.uniform4fv(this.addr, e), Ln(t, e));
  }
}
function r4(n, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (Rn(t, e)) return;
    (n.uniformMatrix2fv(this.addr, !1, e), Ln(t, e));
  } else {
    if (Rn(t, i)) return;
    (FE.set(i), n.uniformMatrix2fv(this.addr, !1, FE), Ln(t, i));
  }
}
function s4(n, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (Rn(t, e)) return;
    (n.uniformMatrix3fv(this.addr, !1, e), Ln(t, e));
  } else {
    if (Rn(t, i)) return;
    (DE.set(i), n.uniformMatrix3fv(this.addr, !1, DE), Ln(t, i));
  }
}
function o4(n, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (Rn(t, e)) return;
    (n.uniformMatrix4fv(this.addr, !1, e), Ln(t, e));
  } else {
    if (Rn(t, i)) return;
    (IE.set(i), n.uniformMatrix4fv(this.addr, !1, IE), Ln(t, i));
  }
}
function a4(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1i(this.addr, e), (t[0] = e));
}
function l4(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Rn(t, e)) return;
    (n.uniform2iv(this.addr, e), Ln(t, e));
  }
}
function c4(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3i(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Rn(t, e)) return;
    (n.uniform3iv(this.addr, e), Ln(t, e));
  }
}
function u4(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Rn(t, e)) return;
    (n.uniform4iv(this.addr, e), Ln(t, e));
  }
}
function f4(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1ui(this.addr, e), (t[0] = e));
}
function h4(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Rn(t, e)) return;
    (n.uniform2uiv(this.addr, e), Ln(t, e));
  }
}
function d4(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3ui(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Rn(t, e)) return;
    (n.uniform3uiv(this.addr, e), Ln(t, e));
  }
}
function p4(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Rn(t, e)) return;
    (n.uniform4uiv(this.addr, e), Ln(t, e));
  }
}
function m4(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  (i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTexture2D(e || JB, r));
}
function g4(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  (i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTexture3D(e || KB, r));
}
function v4(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  (i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTextureCube(e || YB, r));
}
function y4(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  (i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTexture2DArray(e || XB, r));
}
function x4(n) {
  switch (n) {
    case 5126:
      return e4;
    case 35664:
      return t4;
    case 35665:
      return n4;
    case 35666:
      return i4;
    case 35674:
      return r4;
    case 35675:
      return s4;
    case 35676:
      return o4;
    case 5124:
    case 35670:
      return a4;
    case 35667:
    case 35671:
      return l4;
    case 35668:
    case 35672:
      return c4;
    case 35669:
    case 35673:
      return u4;
    case 5125:
      return f4;
    case 36294:
      return h4;
    case 36295:
      return d4;
    case 36296:
      return p4;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return m4;
    case 35679:
    case 36299:
    case 36307:
      return g4;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return v4;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return y4;
  }
}
function _4(n, e) {
  n.uniform1fv(this.addr, e);
}
function A4(n, e) {
  const t = su(e, this.size, 2);
  n.uniform2fv(this.addr, t);
}
function M4(n, e) {
  const t = su(e, this.size, 3);
  n.uniform3fv(this.addr, t);
}
function S4(n, e) {
  const t = su(e, this.size, 4);
  n.uniform4fv(this.addr, t);
}
function w4(n, e) {
  const t = su(e, this.size, 4);
  n.uniformMatrix2fv(this.addr, !1, t);
}
function E4(n, e) {
  const t = su(e, this.size, 9);
  n.uniformMatrix3fv(this.addr, !1, t);
}
function C4(n, e) {
  const t = su(e, this.size, 16);
  n.uniformMatrix4fv(this.addr, !1, t);
}
function T4(n, e) {
  n.uniform1iv(this.addr, e);
}
function b4(n, e) {
  n.uniform2iv(this.addr, e);
}
function P4(n, e) {
  n.uniform3iv(this.addr, e);
}
function B4(n, e) {
  n.uniform4iv(this.addr, e);
}
function R4(n, e) {
  n.uniform1uiv(this.addr, e);
}
function L4(n, e) {
  n.uniform2uiv(this.addr, e);
}
function I4(n, e) {
  n.uniform3uiv(this.addr, e);
}
function D4(n, e) {
  n.uniform4uiv(this.addr, e);
}
function F4(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = Ug(t, r);
  Rn(i, s) || (n.uniform1iv(this.addr, s), Ln(i, s));
  for (let o = 0; o !== r; ++o) t.setTexture2D(e[o] || JB, s[o]);
}
function N4(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = Ug(t, r);
  Rn(i, s) || (n.uniform1iv(this.addr, s), Ln(i, s));
  for (let o = 0; o !== r; ++o) t.setTexture3D(e[o] || KB, s[o]);
}
function k4(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = Ug(t, r);
  Rn(i, s) || (n.uniform1iv(this.addr, s), Ln(i, s));
  for (let o = 0; o !== r; ++o) t.setTextureCube(e[o] || YB, s[o]);
}
function O4(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = Ug(t, r);
  Rn(i, s) || (n.uniform1iv(this.addr, s), Ln(i, s));
  for (let o = 0; o !== r; ++o) t.setTexture2DArray(e[o] || XB, s[o]);
}
function U4(n) {
  switch (n) {
    case 5126:
      return _4;
    case 35664:
      return A4;
    case 35665:
      return M4;
    case 35666:
      return S4;
    case 35674:
      return w4;
    case 35675:
      return E4;
    case 35676:
      return C4;
    case 5124:
    case 35670:
      return T4;
    case 35667:
    case 35671:
      return b4;
    case 35668:
    case 35672:
      return P4;
    case 35669:
    case 35673:
      return B4;
    case 5125:
      return R4;
    case 36294:
      return L4;
    case 36295:
      return I4;
    case 36296:
      return D4;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return F4;
    case 35679:
    case 36299:
    case 36307:
      return N4;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return k4;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return O4;
  }
}
class z4 {
  constructor(e, t, i) {
    ((this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.setValue = x4(t.type)));
  }
}
class G4 {
  constructor(e, t, i) {
    ((this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.size = t.size),
      (this.setValue = U4(t.type)));
  }
}
class H4 {
  constructor(e) {
    ((this.id = e), (this.seq = []), (this.map = {}));
  }
  setValue(e, t, i) {
    const r = this.seq;
    for (let s = 0, o = r.length; s !== o; ++s) {
      const a = r[s];
      a.setValue(e, t[a.id], i);
    }
  }
}
const iy = /(\w+)(\])?(\[|\.)?/g;
function NE(n, e) {
  (n.seq.push(e), (n.map[e.id] = e));
}
function V4(n, e, t) {
  const i = n.name,
    r = i.length;
  for (iy.lastIndex = 0; ; ) {
    const s = iy.exec(i),
      o = iy.lastIndex;
    let a = s[1];
    const l = s[2] === "]",
      u = s[3];
    if ((l && (a = a | 0), u === void 0 || (u === "[" && o + 2 === r))) {
      NE(t, u === void 0 ? new z4(a, n, e) : new G4(a, n, e));
      break;
    } else {
      let d = t.map[a];
      (d === void 0 && ((d = new H4(a)), NE(t, d)), (t = d));
    }
  }
}
class Mm {
  constructor(e, t) {
    ((this.seq = []), (this.map = {}));
    const i = e.getProgramParameter(t, 35718);
    for (let r = 0; r < i; ++r) {
      const s = e.getActiveUniform(t, r),
        o = e.getUniformLocation(t, s.name);
      V4(s, o, this);
    }
  }
  setValue(e, t, i, r) {
    const s = this.map[t];
    s !== void 0 && s.setValue(e, i, r);
  }
  setOptional(e, t, i) {
    const r = t[i];
    r !== void 0 && this.setValue(e, i, r);
  }
  static upload(e, t, i, r) {
    for (let s = 0, o = t.length; s !== o; ++s) {
      const a = t[s],
        l = i[a.id];
      l.needsUpdate !== !1 && a.setValue(e, l.value, r);
    }
  }
  static seqWithValue(e, t) {
    const i = [];
    for (let r = 0, s = e.length; r !== s; ++r) {
      const o = e[r];
      o.id in t && i.push(o);
    }
    return i;
  }
}
function kE(n, e, t) {
  const i = n.createShader(e);
  return (n.shaderSource(i, t), n.compileShader(i), i);
}
let W4 = 0;
function j4(n, e) {
  const t = n.split(`
`),
    i = [],
    r = Math.max(e - 6, 0),
    s = Math.min(e + 6, t.length);
  for (let o = r; o < s; o++) {
    const a = o + 1;
    i.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`);
  }
  return i.join(`
`);
}
function J4(n) {
  switch (n) {
    case Qs:
      return ["Linear", "( value )"];
    case Tt:
      return ["sRGB", "( value )"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported encoding:", n),
        ["Linear", "( value )"]
      );
  }
}
function OE(n, e, t) {
  const i = n.getShaderParameter(e, 35713),
    r = n.getShaderInfoLog(e).trim();
  if (i && r === "") return "";
  const s = /ERROR: 0:(\d+)/.exec(r);
  if (s) {
    const o = parseInt(s[1]);
    return (
      t.toUpperCase() +
      `

` +
      r +
      `

` +
      j4(n.getShaderSource(e), o)
    );
  } else return r;
}
function X4(n, e) {
  const t = J4(e);
  return "vec4 " + n + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }";
}
function K4(n, e) {
  let t;
  switch (e) {
    case hB:
      t = "Linear";
      break;
    case dB:
      t = "Reinhard";
      break;
    case pB:
      t = "OptimizedCineon";
      break;
    case J1:
      t = "ACESFilmic";
      break;
    case mB:
      t = "Custom";
      break;
    default:
      (console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (t = "Linear"));
  }
  return (
    "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
  );
}
function Y4(n) {
  return [
    n.extensionDerivatives ||
    n.envMapCubeUVHeight ||
    n.bumpMap ||
    n.normalMapTangentSpace ||
    n.clearcoatNormalMap ||
    n.flatShading ||
    n.shaderID === "physical"
      ? "#extension GL_OES_standard_derivatives : enable"
      : "",
    (n.extensionFragDepth || n.logarithmicDepthBuffer) &&
    n.rendererExtensionFragDepth
      ? "#extension GL_EXT_frag_depth : enable"
      : "",
    n.extensionDrawBuffers && n.rendererExtensionDrawBuffers
      ? "#extension GL_EXT_draw_buffers : require"
      : "",
    (n.extensionShaderTextureLOD || n.envMap || n.transmission) &&
    n.rendererExtensionShaderTextureLod
      ? "#extension GL_EXT_shader_texture_lod : enable"
      : "",
  ].filter(hf).join(`
`);
}
function Q4(n) {
  const e = [];
  for (const t in n) {
    const i = n[t];
    i !== !1 && e.push("#define " + t + " " + i);
  }
  return e.join(`
`);
}
function Z4(n, e) {
  const t = {},
    i = n.getProgramParameter(e, 35721);
  for (let r = 0; r < i; r++) {
    const s = n.getActiveAttrib(e, r),
      o = s.name;
    let a = 1;
    (s.type === 35674 && (a = 2),
      s.type === 35675 && (a = 3),
      s.type === 35676 && (a = 4),
      (t[o] = {
        type: s.type,
        location: n.getAttribLocation(e, o),
        locationSize: a,
      }));
  }
  return t;
}
function hf(n) {
  return n !== "";
}
function UE(n, e) {
  const t =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return n
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function zE(n, e) {
  return n
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const q4 = /^[ \t]*#include +<([\w\d./]+)>/gm;
function m_(n) {
  return n.replace(q4, $4);
}
function $4(n, e) {
  const t = gt[e];
  if (t === void 0) throw new Error("Can not resolve #include <" + e + ">");
  return m_(t);
}
const eG =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function GE(n) {
  return n.replace(eG, tG);
}
function tG(n, e, t, i) {
  let r = "";
  for (let s = parseInt(e); s < parseInt(t); s++)
    r += i
      .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, s);
  return r;
}
function HE(n) {
  let e =
    "precision " +
    n.precision +
    ` float;
precision ` +
    n.precision +
    " int;";
  return (
    n.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : n.precision === "mediump"
        ? (e += `
#define MEDIUM_PRECISION`)
        : n.precision === "lowp" &&
          (e += `
#define LOW_PRECISION`),
    e
  );
}
function nG(n) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    n.shadowMapType === Ig
      ? (e = "SHADOWMAP_TYPE_PCF")
      : n.shadowMapType === Sf
        ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
        : n.shadowMapType === za && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function iG(n) {
  let e = "ENVMAP_TYPE_CUBE";
  if (n.envMap)
    switch (n.envMapMode) {
      case Xo:
      case Ko:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case iu:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function rG(n) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (n.envMap)
    switch (n.envMapMode) {
      case Ko:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function sG(n) {
  let e = "ENVMAP_BLENDING_NONE";
  if (n.envMap)
    switch (n.combine) {
      case Mh:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case uB:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case fB:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function oG(n) {
  const e = n.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2,
    i = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
    texelHeight: i,
    maxMip: t,
  };
}
function aG(n, e, t, i) {
  const r = n.getContext(),
    s = t.defines;
  let o = t.vertexShader,
    a = t.fragmentShader;
  const l = nG(t),
    u = iG(t),
    h = rG(t),
    d = sG(t),
    p = oG(t),
    g = t.isWebGL2 ? "" : Y4(t),
    y = Q4(s),
    A = r.createProgram();
  let _,
    m,
    x = t.glslVersion
      ? "#version " +
        t.glslVersion +
        `
`
      : "";
  (t.isRawShaderMaterial
    ? ((_ = [y].filter(hf).join(`
`)),
      _.length > 0 &&
        (_ += `
`),
      (m = [g, y].filter(hf).join(`
`)),
      m.length > 0 &&
        (m += `
`))
    : ((_ = [
        HE(t),
        "#define SHADER_NAME " + t.shaderName,
        y,
        t.instancing ? "#define USE_INSTANCING" : "",
        t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + h : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.mapUv ? "#define MAP_UV " + t.mapUv : "",
        t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
        t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
        t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
        t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
        t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
        t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
        t.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv
          : "",
        t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
        t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
        t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
        t.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv
          : "",
        t.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv
          : "",
        t.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv
          : "",
        t.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv
          : "",
        t.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv
          : "",
        t.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv
          : "",
        t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
        t.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv
          : "",
        t.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv
          : "",
        t.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv
          : "",
        t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
        t.vertexTangents ? "#define USE_TANGENT" : "",
        t.vertexColors ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUvs2 ? "#define USE_UV2" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.skinning ? "#define USE_SKINNING" : "",
        t.morphTargets ? "#define USE_MORPHTARGETS" : "",
        t.morphNormals && t.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE"
          : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
          : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
          : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(hf).join(`
`)),
      (m = [
        g,
        HE(t),
        "#define SHADER_NAME " + t.shaderName,
        y,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.matcap ? "#define USE_MATCAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + u : "",
        t.envMap ? "#define " + h : "",
        t.envMap ? "#define " + d : "",
        p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "",
        p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "",
        p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.clearcoat ? "#define USE_CLEARCOAT" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescence ? "#define USE_IRIDESCENCE" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaTest ? "#define USE_ALPHATEST" : "",
        t.sheen ? "#define USE_SHEEN" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        t.vertexTangents ? "#define USE_TANGENT" : "",
        t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUvs2 ? "#define USE_UV2" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.gradientMap ? "#define USE_GRADIENTMAP" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        t.toneMapping !== Ur ? "#define TONE_MAPPING" : "",
        t.toneMapping !== Ur ? gt.tonemapping_pars_fragment : "",
        t.toneMapping !== Ur ? K4("toneMapping", t.toneMapping) : "",
        t.dithering ? "#define DITHERING" : "",
        t.opaque ? "#define OPAQUE" : "",
        gt.encodings_pars_fragment,
        X4("linearToOutputTexel", t.outputEncoding),
        t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
        `
`,
      ].filter(hf).join(`
`))),
    (o = m_(o)),
    (o = UE(o, t)),
    (o = zE(o, t)),
    (a = m_(a)),
    (a = UE(a, t)),
    (a = zE(a, t)),
    (o = GE(o)),
    (a = GE(a)),
    t.isWebGL2 &&
      t.isRawShaderMaterial !== !0 &&
      ((x = `#version 300 es
`),
      (_ =
        [
          "precision mediump sampler2DArray;",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        _),
      (m =
        [
          "#define varying in",
          t.glslVersion === h_
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          t.glslVersion === h_ ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        m)));
  const S = x + _ + o,
    w = x + m + a,
    C = kE(r, 35633, S),
    P = kE(r, 35632, w);
  if (
    (r.attachShader(A, C),
    r.attachShader(A, P),
    t.index0AttributeName !== void 0
      ? r.bindAttribLocation(A, 0, t.index0AttributeName)
      : t.morphTargets === !0 && r.bindAttribLocation(A, 0, "position"),
    r.linkProgram(A),
    n.debug.checkShaderErrors)
  ) {
    const b = r.getProgramInfoLog(A).trim(),
      L = r.getShaderInfoLog(C).trim(),
      U = r.getShaderInfoLog(P).trim();
    let J = !0,
      V = !0;
    if (r.getProgramParameter(A, 35714) === !1)
      if (((J = !1), typeof n.debug.onShaderError == "function"))
        n.debug.onShaderError(r, A, C, P);
      else {
        const j = OE(r, C, "vertex"),
          X = OE(r, P, "fragment");
        console.error(
          "THREE.WebGLProgram: Shader Error " +
            r.getError() +
            " - VALIDATE_STATUS " +
            r.getProgramParameter(A, 35715) +
            `

Program Info Log: ` +
            b +
            `
` +
            j +
            `
` +
            X
        );
      }
    else
      b !== ""
        ? console.warn("THREE.WebGLProgram: Program Info Log:", b)
        : (L === "" || U === "") && (V = !1);
    V &&
      (this.diagnostics = {
        runnable: J,
        programLog: b,
        vertexShader: { log: L, prefix: _ },
        fragmentShader: { log: U, prefix: m },
      });
  }
  (r.deleteShader(C), r.deleteShader(P));
  let R;
  this.getUniforms = function () {
    return (R === void 0 && (R = new Mm(r, A)), R);
  };
  let B;
  return (
    (this.getAttributes = function () {
      return (B === void 0 && (B = Z4(r, A)), B);
    }),
    (this.destroy = function () {
      (i.releaseStatesOfProgram(this),
        r.deleteProgram(A),
        (this.program = void 0));
    }),
    (this.name = t.shaderName),
    (this.id = W4++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = A),
    (this.vertexShader = C),
    (this.fragmentShader = P),
    this
  );
}
let lG = 0;
class cG {
  constructor() {
    ((this.shaderCache = new Map()), (this.materialCache = new Map()));
  }
  update(e) {
    const t = e.vertexShader,
      i = e.fragmentShader,
      r = this._getShaderStage(t),
      s = this._getShaderStage(i),
      o = this._getShaderCacheForMaterial(e);
    return (
      o.has(r) === !1 && (o.add(r), r.usedTimes++),
      o.has(s) === !1 && (o.add(s), s.usedTimes++),
      this
    );
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const i of t)
      (i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code));
    return (this.materialCache.delete(e), this);
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    (this.shaderCache.clear(), this.materialCache.clear());
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let i = t.get(e);
    return (i === void 0 && ((i = new Set()), t.set(e, i)), i);
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let i = t.get(e);
    return (i === void 0 && ((i = new uG(e)), t.set(e, i)), i);
  }
}
class uG {
  constructor(e) {
    ((this.id = lG++), (this.code = e), (this.usedTimes = 0));
  }
}
function fG(n, e, t, i, r, s, o) {
  const a = new qa(),
    l = new cG(),
    u = [],
    h = r.isWebGL2,
    d = r.logarithmicDepthBuffer,
    p = r.vertexTextures;
  let g = r.precision;
  const y = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function A(b) {
    return b === 1 ? "uv2" : "uv";
  }
  function _(b, L, U, J, V) {
    const j = J.fog,
      X = V.geometry,
      oe = b.isMeshStandardMaterial ? J.environment : null,
      ae = (b.isMeshStandardMaterial ? t : e).get(b.envMap || oe),
      I = ae && ae.mapping === iu ? ae.image.height : null,
      G = y[b.type];
    b.precision !== null &&
      ((g = r.getMaxPrecision(b.precision)),
      g !== b.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          b.precision,
          "not supported, using",
          g,
          "instead."
        ));
    const z =
        X.morphAttributes.position ||
        X.morphAttributes.normal ||
        X.morphAttributes.color,
      q = z !== void 0 ? z.length : 0;
    let Q = 0;
    (X.morphAttributes.position !== void 0 && (Q = 1),
      X.morphAttributes.normal !== void 0 && (Q = 2),
      X.morphAttributes.color !== void 0 && (Q = 3));
    let ee, ne, Ee, Ae;
    if (G) {
      const Oe = Nr[G];
      ((ee = Oe.vertexShader), (ne = Oe.fragmentShader));
    } else
      ((ee = b.vertexShader),
        (ne = b.fragmentShader),
        l.update(b),
        (Ee = l.getVertexShaderID(b)),
        (Ae = l.getFragmentShaderID(b)));
    const $ = n.getRenderTarget(),
      Je = V.isInstancedMesh === !0,
      Xe = !!b.map,
      xe = !!b.matcap,
      Se = !!ae,
      ge = !!b.aoMap,
      se = !!b.lightMap,
      _e = !!b.bumpMap,
      Ne = !!b.normalMap,
      Le = !!b.displacementMap,
      We = !!b.emissiveMap,
      Ke = !!b.metalnessMap,
      je = !!b.roughnessMap,
      nt = b.clearcoat > 0,
      At = b.iridescence > 0,
      O = b.sheen > 0,
      D = b.transmission > 0,
      le = nt && !!b.clearcoatMap,
      Ce = nt && !!b.clearcoatNormalMap,
      Te = nt && !!b.clearcoatRoughnessMap,
      Re = At && !!b.iridescenceMap,
      et = At && !!b.iridescenceThicknessMap,
      Ue = O && !!b.sheenColorMap,
      pe = O && !!b.sheenRoughnessMap,
      He = !!b.specularMap,
      W = !!b.specularColorMap,
      de = !!b.specularIntensityMap,
      Me = D && !!b.transmissionMap,
      Pe = D && !!b.thicknessMap,
      qe = !!b.gradientMap,
      ht = !!b.alphaMap,
      Ut = b.alphaTest > 0,
      K = !!b.extensions,
      fe = !!X.attributes.uv2;
    return {
      isWebGL2: h,
      shaderID: G,
      shaderName: b.type,
      vertexShader: ee,
      fragmentShader: ne,
      defines: b.defines,
      customVertexShaderID: Ee,
      customFragmentShaderID: Ae,
      isRawShaderMaterial: b.isRawShaderMaterial === !0,
      glslVersion: b.glslVersion,
      precision: g,
      instancing: Je,
      instancingColor: Je && V.instanceColor !== null,
      supportsVertexTextures: p,
      outputEncoding:
        $ === null
          ? n.outputEncoding
          : $.isXRRenderTarget === !0
            ? $.texture.encoding
            : Qs,
      map: Xe,
      matcap: xe,
      envMap: Se,
      envMapMode: Se && ae.mapping,
      envMapCubeUVHeight: I,
      aoMap: ge,
      lightMap: se,
      bumpMap: _e,
      normalMap: Ne,
      displacementMap: p && Le,
      emissiveMap: We,
      normalMapObjectSpace: Ne && b.normalMapType === kB,
      normalMapTangentSpace: Ne && b.normalMapType === eo,
      decodeVideoTexture:
        Xe && b.map.isVideoTexture === !0 && b.map.encoding === Tt,
      metalnessMap: Ke,
      roughnessMap: je,
      clearcoat: nt,
      clearcoatMap: le,
      clearcoatNormalMap: Ce,
      clearcoatRoughnessMap: Te,
      iridescence: At,
      iridescenceMap: Re,
      iridescenceThicknessMap: et,
      sheen: O,
      sheenColorMap: Ue,
      sheenRoughnessMap: pe,
      specularMap: He,
      specularColorMap: W,
      specularIntensityMap: de,
      transmission: D,
      transmissionMap: Me,
      thicknessMap: Pe,
      gradientMap: qe,
      opaque: b.transparent === !1 && b.blending === Ka,
      alphaMap: ht,
      alphaTest: Ut,
      combine: b.combine,
      mapUv: Xe && A(b.map.channel),
      aoMapUv: ge && A(b.aoMap.channel),
      lightMapUv: se && A(b.lightMap.channel),
      bumpMapUv: _e && A(b.bumpMap.channel),
      normalMapUv: Ne && A(b.normalMap.channel),
      displacementMapUv: Le && A(b.displacementMap.channel),
      emissiveMapUv: We && A(b.emissiveMap.channel),
      metalnessMapUv: Ke && A(b.metalnessMap.channel),
      roughnessMapUv: je && A(b.roughnessMap.channel),
      clearcoatMapUv: le && A(b.clearcoatMap.channel),
      clearcoatNormalMapUv: Ce && A(b.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Te && A(b.clearcoatRoughnessMap.channel),
      iridescenceMapUv: Re && A(b.iridescenceMap.channel),
      iridescenceThicknessMapUv: et && A(b.iridescenceThicknessMap.channel),
      sheenColorMapUv: Ue && A(b.sheenColorMap.channel),
      sheenRoughnessMapUv: pe && A(b.sheenRoughnessMap.channel),
      specularMapUv: He && A(b.specularMap.channel),
      specularColorMapUv: W && A(b.specularColorMap.channel),
      specularIntensityMapUv: de && A(b.specularIntensityMap.channel),
      transmissionMapUv: Me && A(b.transmissionMap.channel),
      thicknessMapUv: Pe && A(b.thicknessMap.channel),
      alphaMapUv: ht && A(b.alphaMap.channel),
      vertexTangents: Ne && !!X.attributes.tangent,
      vertexColors: b.vertexColors,
      vertexAlphas:
        b.vertexColors === !0 &&
        !!X.attributes.color &&
        X.attributes.color.itemSize === 4,
      vertexUvs2: fe,
      pointsUvs: V.isPoints === !0 && !!X.attributes.uv && (Xe || ht),
      fog: !!j,
      useFog: b.fog === !0,
      fogExp2: j && j.isFogExp2,
      flatShading: b.flatShading === !0,
      sizeAttenuation: b.sizeAttenuation === !0,
      logarithmicDepthBuffer: d,
      skinning: V.isSkinnedMesh === !0,
      morphTargets: X.morphAttributes.position !== void 0,
      morphNormals: X.morphAttributes.normal !== void 0,
      morphColors: X.morphAttributes.color !== void 0,
      morphTargetsCount: q,
      morphTextureStride: Q,
      numDirLights: L.directional.length,
      numPointLights: L.point.length,
      numSpotLights: L.spot.length,
      numSpotLightMaps: L.spotLightMap.length,
      numRectAreaLights: L.rectArea.length,
      numHemiLights: L.hemi.length,
      numDirLightShadows: L.directionalShadowMap.length,
      numPointLightShadows: L.pointShadowMap.length,
      numSpotLightShadows: L.spotShadowMap.length,
      numSpotLightShadowsWithMaps: L.numSpotLightShadowsWithMaps,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: b.dithering,
      shadowMapEnabled: n.shadowMap.enabled && U.length > 0,
      shadowMapType: n.shadowMap.type,
      toneMapping: b.toneMapped ? n.toneMapping : Ur,
      useLegacyLights: n.useLegacyLights,
      premultipliedAlpha: b.premultipliedAlpha,
      doubleSided: b.side === mr,
      flipSided: b.side === vi,
      useDepthPacking: b.depthPacking >= 0,
      depthPacking: b.depthPacking || 0,
      index0AttributeName: b.index0AttributeName,
      extensionDerivatives: K && b.extensions.derivatives === !0,
      extensionFragDepth: K && b.extensions.fragDepth === !0,
      extensionDrawBuffers: K && b.extensions.drawBuffers === !0,
      extensionShaderTextureLOD: K && b.extensions.shaderTextureLOD === !0,
      rendererExtensionFragDepth: h || i.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: h || i.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: h || i.has("EXT_shader_texture_lod"),
      customProgramCacheKey: b.customProgramCacheKey(),
    };
  }
  function m(b) {
    const L = [];
    if (
      (b.shaderID
        ? L.push(b.shaderID)
        : (L.push(b.customVertexShaderID), L.push(b.customFragmentShaderID)),
      b.defines !== void 0)
    )
      for (const U in b.defines) (L.push(U), L.push(b.defines[U]));
    return (
      b.isRawShaderMaterial === !1 &&
        (x(L, b), S(L, b), L.push(n.outputEncoding)),
      L.push(b.customProgramCacheKey),
      L.join()
    );
  }
  function x(b, L) {
    (b.push(L.precision),
      b.push(L.outputEncoding),
      b.push(L.envMapMode),
      b.push(L.envMapCubeUVHeight),
      b.push(L.mapUv),
      b.push(L.alphaMapUv),
      b.push(L.lightMapUv),
      b.push(L.aoMapUv),
      b.push(L.bumpMapUv),
      b.push(L.normalMapUv),
      b.push(L.displacementMapUv),
      b.push(L.emissiveMapUv),
      b.push(L.metalnessMapUv),
      b.push(L.roughnessMapUv),
      b.push(L.clearcoatMapUv),
      b.push(L.clearcoatNormalMapUv),
      b.push(L.clearcoatRoughnessMapUv),
      b.push(L.iridescenceMapUv),
      b.push(L.iridescenceThicknessMapUv),
      b.push(L.sheenColorMapUv),
      b.push(L.sheenRoughnessMapUv),
      b.push(L.specularMapUv),
      b.push(L.specularColorMapUv),
      b.push(L.specularIntensityMapUv),
      b.push(L.transmissionMapUv),
      b.push(L.thicknessMapUv),
      b.push(L.combine),
      b.push(L.fogExp2),
      b.push(L.sizeAttenuation),
      b.push(L.morphTargetsCount),
      b.push(L.morphAttributeCount),
      b.push(L.numDirLights),
      b.push(L.numPointLights),
      b.push(L.numSpotLights),
      b.push(L.numSpotLightMaps),
      b.push(L.numHemiLights),
      b.push(L.numRectAreaLights),
      b.push(L.numDirLightShadows),
      b.push(L.numPointLightShadows),
      b.push(L.numSpotLightShadows),
      b.push(L.numSpotLightShadowsWithMaps),
      b.push(L.shadowMapType),
      b.push(L.toneMapping),
      b.push(L.numClippingPlanes),
      b.push(L.numClipIntersection),
      b.push(L.depthPacking));
  }
  function S(b, L) {
    (a.disableAll(),
      L.isWebGL2 && a.enable(0),
      L.supportsVertexTextures && a.enable(1),
      L.instancing && a.enable(2),
      L.instancingColor && a.enable(3),
      L.matcap && a.enable(4),
      L.envMap && a.enable(5),
      L.normalMapObjectSpace && a.enable(6),
      L.normalMapTangentSpace && a.enable(7),
      L.clearcoat && a.enable(8),
      L.iridescence && a.enable(9),
      L.alphaTest && a.enable(10),
      L.vertexColors && a.enable(11),
      L.vertexAlphas && a.enable(12),
      L.vertexUvs2 && a.enable(13),
      L.vertexTangents && a.enable(14),
      b.push(a.mask),
      a.disableAll(),
      L.fog && a.enable(0),
      L.useFog && a.enable(1),
      L.flatShading && a.enable(2),
      L.logarithmicDepthBuffer && a.enable(3),
      L.skinning && a.enable(4),
      L.morphTargets && a.enable(5),
      L.morphNormals && a.enable(6),
      L.morphColors && a.enable(7),
      L.premultipliedAlpha && a.enable(8),
      L.shadowMapEnabled && a.enable(9),
      L.useLegacyLights && a.enable(10),
      L.doubleSided && a.enable(11),
      L.flipSided && a.enable(12),
      L.useDepthPacking && a.enable(13),
      L.dithering && a.enable(14),
      L.transmission && a.enable(15),
      L.sheen && a.enable(16),
      L.decodeVideoTexture && a.enable(17),
      L.opaque && a.enable(18),
      L.pointsUvs && a.enable(19),
      b.push(a.mask));
  }
  function w(b) {
    const L = y[b.type];
    let U;
    if (L) {
      const J = Nr[L];
      U = WB.clone(J.uniforms);
    } else U = b.uniforms;
    return U;
  }
  function C(b, L) {
    let U;
    for (let J = 0, V = u.length; J < V; J++) {
      const j = u[J];
      if (j.cacheKey === L) {
        ((U = j), ++U.usedTimes);
        break;
      }
    }
    return (U === void 0 && ((U = new aG(n, L, b, s)), u.push(U)), U);
  }
  function P(b) {
    if (--b.usedTimes === 0) {
      const L = u.indexOf(b);
      ((u[L] = u[u.length - 1]), u.pop(), b.destroy());
    }
  }
  function R(b) {
    l.remove(b);
  }
  function B() {
    l.dispose();
  }
  return {
    getParameters: _,
    getProgramCacheKey: m,
    getUniforms: w,
    acquireProgram: C,
    releaseProgram: P,
    releaseShaderCache: R,
    programs: u,
    dispose: B,
  };
}
function hG() {
  let n = new WeakMap();
  function e(s) {
    let o = n.get(s);
    return (o === void 0 && ((o = {}), n.set(s, o)), o);
  }
  function t(s) {
    n.delete(s);
  }
  function i(s, o, a) {
    n.get(s)[o] = a;
  }
  function r() {
    n = new WeakMap();
  }
  return { get: e, remove: t, update: i, dispose: r };
}
function dG(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
      ? n.renderOrder - e.renderOrder
      : n.material.id !== e.material.id
        ? n.material.id - e.material.id
        : n.z !== e.z
          ? n.z - e.z
          : n.id - e.id;
}
function VE(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
      ? n.renderOrder - e.renderOrder
      : n.z !== e.z
        ? e.z - n.z
        : n.id - e.id;
}
function WE() {
  const n = [];
  let e = 0;
  const t = [],
    i = [],
    r = [];
  function s() {
    ((e = 0), (t.length = 0), (i.length = 0), (r.length = 0));
  }
  function o(d, p, g, y, A, _) {
    let m = n[e];
    return (
      m === void 0
        ? ((m = {
            id: d.id,
            object: d,
            geometry: p,
            material: g,
            groupOrder: y,
            renderOrder: d.renderOrder,
            z: A,
            group: _,
          }),
          (n[e] = m))
        : ((m.id = d.id),
          (m.object = d),
          (m.geometry = p),
          (m.material = g),
          (m.groupOrder = y),
          (m.renderOrder = d.renderOrder),
          (m.z = A),
          (m.group = _)),
      e++,
      m
    );
  }
  function a(d, p, g, y, A, _) {
    const m = o(d, p, g, y, A, _);
    g.transmission > 0
      ? i.push(m)
      : g.transparent === !0
        ? r.push(m)
        : t.push(m);
  }
  function l(d, p, g, y, A, _) {
    const m = o(d, p, g, y, A, _);
    g.transmission > 0
      ? i.unshift(m)
      : g.transparent === !0
        ? r.unshift(m)
        : t.unshift(m);
  }
  function u(d, p) {
    (t.length > 1 && t.sort(d || dG),
      i.length > 1 && i.sort(p || VE),
      r.length > 1 && r.sort(p || VE));
  }
  function h() {
    for (let d = e, p = n.length; d < p; d++) {
      const g = n[d];
      if (g.id === null) break;
      ((g.id = null),
        (g.object = null),
        (g.geometry = null),
        (g.material = null),
        (g.group = null));
    }
  }
  return {
    opaque: t,
    transmissive: i,
    transparent: r,
    init: s,
    push: a,
    unshift: l,
    finish: h,
    sort: u,
  };
}
function pG() {
  let n = new WeakMap();
  function e(i, r) {
    const s = n.get(i);
    let o;
    return (
      s === void 0
        ? ((o = new WE()), n.set(i, [o]))
        : r >= s.length
          ? ((o = new WE()), s.push(o))
          : (o = s[r]),
      o
    );
  }
  function t() {
    n = new WeakMap();
  }
  return { get: e, dispose: t };
}
function mG() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = { direction: new F(), color: new Ie() };
          break;
        case "SpotLight":
          t = {
            position: new F(),
            direction: new F(),
            color: new Ie(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          t = { position: new F(), color: new Ie(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          t = { direction: new F(), skyColor: new Ie(), groundColor: new Ie() };
          break;
        case "RectAreaLight":
          t = {
            color: new Ie(),
            position: new F(),
            halfWidth: new F(),
            halfHeight: new F(),
          };
          break;
      }
      return ((n[e.id] = t), t);
    },
  };
}
function gG() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ve(),
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ve(),
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ve(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return ((n[e.id] = t), t);
    },
  };
}
let vG = 0;
function yG(n, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (n.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (n.map ? 1 : 0)
  );
}
function xG(n, e) {
  const t = new mG(),
    i = gG(),
    r = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
    };
  for (let h = 0; h < 9; h++) r.probe.push(new F());
  const s = new F(),
    o = new ot(),
    a = new ot();
  function l(h, d) {
    let p = 0,
      g = 0,
      y = 0;
    for (let U = 0; U < 9; U++) r.probe[U].set(0, 0, 0);
    let A = 0,
      _ = 0,
      m = 0,
      x = 0,
      S = 0,
      w = 0,
      C = 0,
      P = 0,
      R = 0,
      B = 0;
    h.sort(yG);
    const b = d === !0 ? Math.PI : 1;
    for (let U = 0, J = h.length; U < J; U++) {
      const V = h[U],
        j = V.color,
        X = V.intensity,
        oe = V.distance,
        ae = V.shadow && V.shadow.map ? V.shadow.map.texture : null;
      if (V.isAmbientLight)
        ((p += j.r * X * b), (g += j.g * X * b), (y += j.b * X * b));
      else if (V.isLightProbe)
        for (let I = 0; I < 9; I++)
          r.probe[I].addScaledVector(V.sh.coefficients[I], X);
      else if (V.isDirectionalLight) {
        const I = t.get(V);
        if (
          (I.color.copy(V.color).multiplyScalar(V.intensity * b), V.castShadow)
        ) {
          const G = V.shadow,
            z = i.get(V);
          ((z.shadowBias = G.bias),
            (z.shadowNormalBias = G.normalBias),
            (z.shadowRadius = G.radius),
            (z.shadowMapSize = G.mapSize),
            (r.directionalShadow[A] = z),
            (r.directionalShadowMap[A] = ae),
            (r.directionalShadowMatrix[A] = V.shadow.matrix),
            w++);
        }
        ((r.directional[A] = I), A++);
      } else if (V.isSpotLight) {
        const I = t.get(V);
        (I.position.setFromMatrixPosition(V.matrixWorld),
          I.color.copy(j).multiplyScalar(X * b),
          (I.distance = oe),
          (I.coneCos = Math.cos(V.angle)),
          (I.penumbraCos = Math.cos(V.angle * (1 - V.penumbra))),
          (I.decay = V.decay),
          (r.spot[m] = I));
        const G = V.shadow;
        if (
          (V.map &&
            ((r.spotLightMap[R] = V.map),
            R++,
            G.updateMatrices(V),
            V.castShadow && B++),
          (r.spotLightMatrix[m] = G.matrix),
          V.castShadow)
        ) {
          const z = i.get(V);
          ((z.shadowBias = G.bias),
            (z.shadowNormalBias = G.normalBias),
            (z.shadowRadius = G.radius),
            (z.shadowMapSize = G.mapSize),
            (r.spotShadow[m] = z),
            (r.spotShadowMap[m] = ae),
            P++);
        }
        m++;
      } else if (V.isRectAreaLight) {
        const I = t.get(V);
        (I.color.copy(j).multiplyScalar(X),
          I.halfWidth.set(V.width * 0.5, 0, 0),
          I.halfHeight.set(0, V.height * 0.5, 0),
          (r.rectArea[x] = I),
          x++);
      } else if (V.isPointLight) {
        const I = t.get(V);
        if (
          (I.color.copy(V.color).multiplyScalar(V.intensity * b),
          (I.distance = V.distance),
          (I.decay = V.decay),
          V.castShadow)
        ) {
          const G = V.shadow,
            z = i.get(V);
          ((z.shadowBias = G.bias),
            (z.shadowNormalBias = G.normalBias),
            (z.shadowRadius = G.radius),
            (z.shadowMapSize = G.mapSize),
            (z.shadowCameraNear = G.camera.near),
            (z.shadowCameraFar = G.camera.far),
            (r.pointShadow[_] = z),
            (r.pointShadowMap[_] = ae),
            (r.pointShadowMatrix[_] = V.shadow.matrix),
            C++);
        }
        ((r.point[_] = I), _++);
      } else if (V.isHemisphereLight) {
        const I = t.get(V);
        (I.skyColor.copy(V.color).multiplyScalar(X * b),
          I.groundColor.copy(V.groundColor).multiplyScalar(X * b),
          (r.hemi[S] = I),
          S++);
      }
    }
    (x > 0 &&
      (e.isWebGL2 || n.has("OES_texture_float_linear") === !0
        ? ((r.rectAreaLTC1 = De.LTC_FLOAT_1), (r.rectAreaLTC2 = De.LTC_FLOAT_2))
        : n.has("OES_texture_half_float_linear") === !0
          ? ((r.rectAreaLTC1 = De.LTC_HALF_1), (r.rectAreaLTC2 = De.LTC_HALF_2))
          : console.error(
              "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
            )),
      (r.ambient[0] = p),
      (r.ambient[1] = g),
      (r.ambient[2] = y));
    const L = r.hash;
    (L.directionalLength !== A ||
      L.pointLength !== _ ||
      L.spotLength !== m ||
      L.rectAreaLength !== x ||
      L.hemiLength !== S ||
      L.numDirectionalShadows !== w ||
      L.numPointShadows !== C ||
      L.numSpotShadows !== P ||
      L.numSpotMaps !== R) &&
      ((r.directional.length = A),
      (r.spot.length = m),
      (r.rectArea.length = x),
      (r.point.length = _),
      (r.hemi.length = S),
      (r.directionalShadow.length = w),
      (r.directionalShadowMap.length = w),
      (r.pointShadow.length = C),
      (r.pointShadowMap.length = C),
      (r.spotShadow.length = P),
      (r.spotShadowMap.length = P),
      (r.directionalShadowMatrix.length = w),
      (r.pointShadowMatrix.length = C),
      (r.spotLightMatrix.length = P + R - B),
      (r.spotLightMap.length = R),
      (r.numSpotLightShadowsWithMaps = B),
      (L.directionalLength = A),
      (L.pointLength = _),
      (L.spotLength = m),
      (L.rectAreaLength = x),
      (L.hemiLength = S),
      (L.numDirectionalShadows = w),
      (L.numPointShadows = C),
      (L.numSpotShadows = P),
      (L.numSpotMaps = R),
      (r.version = vG++));
  }
  function u(h, d) {
    let p = 0,
      g = 0,
      y = 0,
      A = 0,
      _ = 0;
    const m = d.matrixWorldInverse;
    for (let x = 0, S = h.length; x < S; x++) {
      const w = h[x];
      if (w.isDirectionalLight) {
        const C = r.directional[p];
        (C.direction.setFromMatrixPosition(w.matrixWorld),
          s.setFromMatrixPosition(w.target.matrixWorld),
          C.direction.sub(s),
          C.direction.transformDirection(m),
          p++);
      } else if (w.isSpotLight) {
        const C = r.spot[y];
        (C.position.setFromMatrixPosition(w.matrixWorld),
          C.position.applyMatrix4(m),
          C.direction.setFromMatrixPosition(w.matrixWorld),
          s.setFromMatrixPosition(w.target.matrixWorld),
          C.direction.sub(s),
          C.direction.transformDirection(m),
          y++);
      } else if (w.isRectAreaLight) {
        const C = r.rectArea[A];
        (C.position.setFromMatrixPosition(w.matrixWorld),
          C.position.applyMatrix4(m),
          a.identity(),
          o.copy(w.matrixWorld),
          o.premultiply(m),
          a.extractRotation(o),
          C.halfWidth.set(w.width * 0.5, 0, 0),
          C.halfHeight.set(0, w.height * 0.5, 0),
          C.halfWidth.applyMatrix4(a),
          C.halfHeight.applyMatrix4(a),
          A++);
      } else if (w.isPointLight) {
        const C = r.point[g];
        (C.position.setFromMatrixPosition(w.matrixWorld),
          C.position.applyMatrix4(m),
          g++);
      } else if (w.isHemisphereLight) {
        const C = r.hemi[_];
        (C.direction.setFromMatrixPosition(w.matrixWorld),
          C.direction.transformDirection(m),
          _++);
      }
    }
  }
  return { setup: l, setupView: u, state: r };
}
function jE(n, e) {
  const t = new xG(n, e),
    i = [],
    r = [];
  function s() {
    ((i.length = 0), (r.length = 0));
  }
  function o(d) {
    i.push(d);
  }
  function a(d) {
    r.push(d);
  }
  function l(d) {
    t.setup(i, d);
  }
  function u(d) {
    t.setupView(i, d);
  }
  return {
    init: s,
    state: { lightsArray: i, shadowsArray: r, lights: t },
    setupLights: l,
    setupLightsView: u,
    pushLight: o,
    pushShadow: a,
  };
}
function _G(n, e) {
  let t = new WeakMap();
  function i(s, o = 0) {
    const a = t.get(s);
    let l;
    return (
      a === void 0
        ? ((l = new jE(n, e)), t.set(s, [l]))
        : o >= a.length
          ? ((l = new jE(n, e)), a.push(l))
          : (l = a[o]),
      l
    );
  }
  function r() {
    t = new WeakMap();
  }
  return { get: i, dispose: r };
}
class oA extends En {
  constructor(e) {
    (super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = FB),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class aA extends En {
  constructor(e) {
    (super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
const AG = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  MG = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function SG(n, e, t) {
  let i = new Og();
  const r = new ve(),
    s = new ve(),
    o = new kt(),
    a = new oA({ depthPacking: NB }),
    l = new aA(),
    u = {},
    h = t.maxTextureSize,
    d = { [fs]: vi, [vi]: fs, [mr]: mr },
    p = new ds({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new ve() },
        radius: { value: 4 },
      },
      vertexShader: AG,
      fragmentShader: MG,
    }),
    g = p.clone();
  g.defines.HORIZONTAL_PASS = 1;
  const y = new ft();
  y.setAttribute(
    "position",
    new Dt(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const A = new Bn(y, p),
    _ = this;
  ((this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = Ig),
    (this.render = function (w, C, P) {
      if (
        _.enabled === !1 ||
        (_.autoUpdate === !1 && _.needsUpdate === !1) ||
        w.length === 0
      )
        return;
      const R = n.getRenderTarget(),
        B = n.getActiveCubeFace(),
        b = n.getActiveMipmapLevel(),
        L = n.state;
      (L.setBlending(Hs),
        L.buffers.color.setClear(1, 1, 1, 1),
        L.buffers.depth.setTest(!0),
        L.setScissorTest(!1));
      for (let U = 0, J = w.length; U < J; U++) {
        const V = w[U],
          j = V.shadow;
        if (j === void 0) {
          console.warn("THREE.WebGLShadowMap:", V, "has no shadow.");
          continue;
        }
        if (j.autoUpdate === !1 && j.needsUpdate === !1) continue;
        r.copy(j.mapSize);
        const X = j.getFrameExtents();
        if (
          (r.multiply(X),
          s.copy(j.mapSize),
          (r.x > h || r.y > h) &&
            (r.x > h &&
              ((s.x = Math.floor(h / X.x)),
              (r.x = s.x * X.x),
              (j.mapSize.x = s.x)),
            r.y > h &&
              ((s.y = Math.floor(h / X.y)),
              (r.y = s.y * X.y),
              (j.mapSize.y = s.y))),
          j.map === null)
        ) {
          const ae = this.type !== za ? { minFilter: dn, magFilter: dn } : {};
          ((j.map = new Hr(r.x, r.y, ae)),
            (j.map.texture.name = V.name + ".shadowMap"),
            j.camera.updateProjectionMatrix());
        }
        (n.setRenderTarget(j.map), n.clear());
        const oe = j.getViewportCount();
        for (let ae = 0; ae < oe; ae++) {
          const I = j.getViewport(ae);
          (o.set(s.x * I.x, s.y * I.y, s.x * I.z, s.y * I.w),
            L.viewport(o),
            j.updateMatrices(V, ae),
            (i = j.getFrustum()),
            S(C, P, j.camera, V, this.type));
        }
        (j.isPointLightShadow !== !0 && this.type === za && m(j, P),
          (j.needsUpdate = !1));
      }
      ((_.needsUpdate = !1), n.setRenderTarget(R, B, b));
    }));
  function m(w, C) {
    const P = e.update(A);
    (p.defines.VSM_SAMPLES !== w.blurSamples &&
      ((p.defines.VSM_SAMPLES = w.blurSamples),
      (g.defines.VSM_SAMPLES = w.blurSamples),
      (p.needsUpdate = !0),
      (g.needsUpdate = !0)),
      w.mapPass === null && (w.mapPass = new Hr(r.x, r.y)),
      (p.uniforms.shadow_pass.value = w.map.texture),
      (p.uniforms.resolution.value = w.mapSize),
      (p.uniforms.radius.value = w.radius),
      n.setRenderTarget(w.mapPass),
      n.clear(),
      n.renderBufferDirect(C, null, P, p, A, null),
      (g.uniforms.shadow_pass.value = w.mapPass.texture),
      (g.uniforms.resolution.value = w.mapSize),
      (g.uniforms.radius.value = w.radius),
      n.setRenderTarget(w.map),
      n.clear(),
      n.renderBufferDirect(C, null, P, g, A, null));
  }
  function x(w, C, P, R) {
    let B = null;
    const b =
      P.isPointLight === !0 ? w.customDistanceMaterial : w.customDepthMaterial;
    if (b !== void 0) B = b;
    else if (
      ((B = P.isPointLight === !0 ? l : a),
      (n.localClippingEnabled &&
        C.clipShadows === !0 &&
        Array.isArray(C.clippingPlanes) &&
        C.clippingPlanes.length !== 0) ||
        (C.displacementMap && C.displacementScale !== 0) ||
        (C.alphaMap && C.alphaTest > 0) ||
        (C.map && C.alphaTest > 0))
    ) {
      const L = B.uuid,
        U = C.uuid;
      let J = u[L];
      J === void 0 && ((J = {}), (u[L] = J));
      let V = J[U];
      (V === void 0 && ((V = B.clone()), (J[U] = V)), (B = V));
    }
    if (
      ((B.visible = C.visible),
      (B.wireframe = C.wireframe),
      R === za
        ? (B.side = C.shadowSide !== null ? C.shadowSide : C.side)
        : (B.side = C.shadowSide !== null ? C.shadowSide : d[C.side]),
      (B.alphaMap = C.alphaMap),
      (B.alphaTest = C.alphaTest),
      (B.map = C.map),
      (B.clipShadows = C.clipShadows),
      (B.clippingPlanes = C.clippingPlanes),
      (B.clipIntersection = C.clipIntersection),
      (B.displacementMap = C.displacementMap),
      (B.displacementScale = C.displacementScale),
      (B.displacementBias = C.displacementBias),
      (B.wireframeLinewidth = C.wireframeLinewidth),
      (B.linewidth = C.linewidth),
      P.isPointLight === !0 && B.isMeshDistanceMaterial === !0)
    ) {
      const L = n.properties.get(B);
      L.light = P;
    }
    return B;
  }
  function S(w, C, P, R, B) {
    if (w.visible === !1) return;
    if (
      w.layers.test(C.layers) &&
      (w.isMesh || w.isLine || w.isPoints) &&
      (w.castShadow || (w.receiveShadow && B === za)) &&
      (!w.frustumCulled || i.intersectsObject(w))
    ) {
      w.modelViewMatrix.multiplyMatrices(P.matrixWorldInverse, w.matrixWorld);
      const U = e.update(w),
        J = w.material;
      if (Array.isArray(J)) {
        const V = U.groups;
        for (let j = 0, X = V.length; j < X; j++) {
          const oe = V[j],
            ae = J[oe.materialIndex];
          if (ae && ae.visible) {
            const I = x(w, ae, R, B);
            n.renderBufferDirect(P, null, U, I, w, oe);
          }
        }
      } else if (J.visible) {
        const V = x(w, J, R, B);
        n.renderBufferDirect(P, null, U, V, w, null);
      }
    }
    const L = w.children;
    for (let U = 0, J = L.length; U < J; U++) S(L[U], C, P, R, B);
  }
}
function wG(n, e, t) {
  const i = t.isWebGL2;
  function r() {
    let K = !1;
    const fe = new kt();
    let we = null;
    const Oe = new kt(0, 0, 0, 0);
    return {
      setMask: function (Qe) {
        we !== Qe && !K && (n.colorMask(Qe, Qe, Qe, Qe), (we = Qe));
      },
      setLocked: function (Qe) {
        K = Qe;
      },
      setClear: function (Qe, zt, Wt, In, Ar) {
        (Ar === !0 && ((Qe *= In), (zt *= In), (Wt *= In)),
          fe.set(Qe, zt, Wt, In),
          Oe.equals(fe) === !1 && (n.clearColor(Qe, zt, Wt, In), Oe.copy(fe)));
      },
      reset: function () {
        ((K = !1), (we = null), Oe.set(-1, 0, 0, 0));
      },
    };
  }
  function s() {
    let K = !1,
      fe = null,
      we = null,
      Oe = null;
    return {
      setTest: function (Qe) {
        Qe ? $(2929) : Je(2929);
      },
      setMask: function (Qe) {
        fe !== Qe && !K && (n.depthMask(Qe), (fe = Qe));
      },
      setFunc: function (Qe) {
        if (we !== Qe) {
          switch (Qe) {
            case iB:
              n.depthFunc(512);
              break;
            case rB:
              n.depthFunc(519);
              break;
            case sB:
              n.depthFunc(513);
              break;
            case Ym:
              n.depthFunc(515);
              break;
            case oB:
              n.depthFunc(514);
              break;
            case aB:
              n.depthFunc(518);
              break;
            case lB:
              n.depthFunc(516);
              break;
            case cB:
              n.depthFunc(517);
              break;
            default:
              n.depthFunc(515);
          }
          we = Qe;
        }
      },
      setLocked: function (Qe) {
        K = Qe;
      },
      setClear: function (Qe) {
        Oe !== Qe && (n.clearDepth(Qe), (Oe = Qe));
      },
      reset: function () {
        ((K = !1), (fe = null), (we = null), (Oe = null));
      },
    };
  }
  function o() {
    let K = !1,
      fe = null,
      we = null,
      Oe = null,
      Qe = null,
      zt = null,
      Wt = null,
      In = null,
      Ar = null;
    return {
      setTest: function (Qt) {
        K || (Qt ? $(2960) : Je(2960));
      },
      setMask: function (Qt) {
        fe !== Qt && !K && (n.stencilMask(Qt), (fe = Qt));
      },
      setFunc: function (Qt, ci, er) {
        (we !== Qt || Oe !== ci || Qe !== er) &&
          (n.stencilFunc(Qt, ci, er), (we = Qt), (Oe = ci), (Qe = er));
      },
      setOp: function (Qt, ci, er) {
        (zt !== Qt || Wt !== ci || In !== er) &&
          (n.stencilOp(Qt, ci, er), (zt = Qt), (Wt = ci), (In = er));
      },
      setLocked: function (Qt) {
        K = Qt;
      },
      setClear: function (Qt) {
        Ar !== Qt && (n.clearStencil(Qt), (Ar = Qt));
      },
      reset: function () {
        ((K = !1),
          (fe = null),
          (we = null),
          (Oe = null),
          (Qe = null),
          (zt = null),
          (Wt = null),
          (In = null),
          (Ar = null));
      },
    };
  }
  const a = new r(),
    l = new s(),
    u = new o(),
    h = new WeakMap(),
    d = new WeakMap();
  let p = {},
    g = {},
    y = new WeakMap(),
    A = [],
    _ = null,
    m = !1,
    x = null,
    S = null,
    w = null,
    C = null,
    P = null,
    R = null,
    B = null,
    b = !1,
    L = null,
    U = null,
    J = null,
    V = null,
    j = null;
  const X = n.getParameter(35661);
  let oe = !1,
    ae = 0;
  const I = n.getParameter(7938);
  I.indexOf("WebGL") !== -1
    ? ((ae = parseFloat(/^WebGL (\d)/.exec(I)[1])), (oe = ae >= 1))
    : I.indexOf("OpenGL ES") !== -1 &&
      ((ae = parseFloat(/^OpenGL ES (\d)/.exec(I)[1])), (oe = ae >= 2));
  let G = null,
    z = {};
  const q = n.getParameter(3088),
    Q = n.getParameter(2978),
    ee = new kt().fromArray(q),
    ne = new kt().fromArray(Q);
  function Ee(K, fe, we) {
    const Oe = new Uint8Array(4),
      Qe = n.createTexture();
    (n.bindTexture(K, Qe),
      n.texParameteri(K, 10241, 9728),
      n.texParameteri(K, 10240, 9728));
    for (let zt = 0; zt < we; zt++)
      n.texImage2D(fe + zt, 0, 6408, 1, 1, 0, 6408, 5121, Oe);
    return Qe;
  }
  const Ae = {};
  ((Ae[3553] = Ee(3553, 3553, 1)),
    (Ae[34067] = Ee(34067, 34069, 6)),
    a.setClear(0, 0, 0, 1),
    l.setClear(1),
    u.setClear(0),
    $(2929),
    l.setFunc(Ym),
    Le(!1),
    We(kx),
    $(2884),
    _e(Hs));
  function $(K) {
    p[K] !== !0 && (n.enable(K), (p[K] = !0));
  }
  function Je(K) {
    p[K] !== !1 && (n.disable(K), (p[K] = !1));
  }
  function Xe(K, fe) {
    return g[K] !== fe
      ? (n.bindFramebuffer(K, fe),
        (g[K] = fe),
        i && (K === 36009 && (g[36160] = fe), K === 36160 && (g[36009] = fe)),
        !0)
      : !1;
  }
  function xe(K, fe) {
    let we = A,
      Oe = !1;
    if (K)
      if (
        ((we = y.get(fe)),
        we === void 0 && ((we = []), y.set(fe, we)),
        K.isWebGLMultipleRenderTargets)
      ) {
        const Qe = K.texture;
        if (we.length !== Qe.length || we[0] !== 36064) {
          for (let zt = 0, Wt = Qe.length; zt < Wt; zt++) we[zt] = 36064 + zt;
          ((we.length = Qe.length), (Oe = !0));
        }
      } else we[0] !== 36064 && ((we[0] = 36064), (Oe = !0));
    else we[0] !== 1029 && ((we[0] = 1029), (Oe = !0));
    Oe &&
      (t.isWebGL2
        ? n.drawBuffers(we)
        : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(we));
  }
  function Se(K) {
    return _ !== K ? (n.useProgram(K), (_ = K), !0) : !1;
  }
  const ge = { [Da]: 32774, [J2]: 32778, [X2]: 32779 };
  if (i) ((ge[Gx] = 32775), (ge[Hx] = 32776));
  else {
    const K = e.get("EXT_blend_minmax");
    K !== null && ((ge[Gx] = K.MIN_EXT), (ge[Hx] = K.MAX_EXT));
  }
  const se = {
    [K2]: 0,
    [Y2]: 1,
    [Q2]: 768,
    [W1]: 770,
    [nB]: 776,
    [eB]: 774,
    [q2]: 772,
    [Z2]: 769,
    [j1]: 771,
    [tB]: 775,
    [$2]: 773,
  };
  function _e(K, fe, we, Oe, Qe, zt, Wt, In) {
    if (K === Hs) {
      m === !0 && (Je(3042), (m = !1));
      return;
    }
    if ((m === !1 && ($(3042), (m = !0)), K !== j2)) {
      if (K !== x || In !== b) {
        if (
          ((S !== Da || P !== Da) &&
            (n.blendEquation(32774), (S = Da), (P = Da)),
          In)
        )
          switch (K) {
            case Ka:
              n.blendFuncSeparate(1, 771, 1, 771);
              break;
            case Ox:
              n.blendFunc(1, 1);
              break;
            case Ux:
              n.blendFuncSeparate(0, 769, 0, 1);
              break;
            case zx:
              n.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", K);
              break;
          }
        else
          switch (K) {
            case Ka:
              n.blendFuncSeparate(770, 771, 1, 771);
              break;
            case Ox:
              n.blendFunc(770, 1);
              break;
            case Ux:
              n.blendFuncSeparate(0, 769, 0, 1);
              break;
            case zx:
              n.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", K);
              break;
          }
        ((w = null), (C = null), (R = null), (B = null), (x = K), (b = In));
      }
      return;
    }
    ((Qe = Qe || fe),
      (zt = zt || we),
      (Wt = Wt || Oe),
      (fe !== S || Qe !== P) &&
        (n.blendEquationSeparate(ge[fe], ge[Qe]), (S = fe), (P = Qe)),
      (we !== w || Oe !== C || zt !== R || Wt !== B) &&
        (n.blendFuncSeparate(se[we], se[Oe], se[zt], se[Wt]),
        (w = we),
        (C = Oe),
        (R = zt),
        (B = Wt)),
      (x = K),
      (b = !1));
  }
  function Ne(K, fe) {
    K.side === mr ? Je(2884) : $(2884);
    let we = K.side === vi;
    (fe && (we = !we),
      Le(we),
      K.blending === Ka && K.transparent === !1
        ? _e(Hs)
        : _e(
            K.blending,
            K.blendEquation,
            K.blendSrc,
            K.blendDst,
            K.blendEquationAlpha,
            K.blendSrcAlpha,
            K.blendDstAlpha,
            K.premultipliedAlpha
          ),
      l.setFunc(K.depthFunc),
      l.setTest(K.depthTest),
      l.setMask(K.depthWrite),
      a.setMask(K.colorWrite));
    const Oe = K.stencilWrite;
    (u.setTest(Oe),
      Oe &&
        (u.setMask(K.stencilWriteMask),
        u.setFunc(K.stencilFunc, K.stencilRef, K.stencilFuncMask),
        u.setOp(K.stencilFail, K.stencilZFail, K.stencilZPass)),
      je(K.polygonOffset, K.polygonOffsetFactor, K.polygonOffsetUnits),
      K.alphaToCoverage === !0 ? $(32926) : Je(32926));
  }
  function Le(K) {
    L !== K && (K ? n.frontFace(2304) : n.frontFace(2305), (L = K));
  }
  function We(K) {
    (K !== H2
      ? ($(2884),
        K !== U &&
          (K === kx
            ? n.cullFace(1029)
            : K === V2
              ? n.cullFace(1028)
              : n.cullFace(1032)))
      : Je(2884),
      (U = K));
  }
  function Ke(K) {
    K !== J && (oe && n.lineWidth(K), (J = K));
  }
  function je(K, fe, we) {
    K
      ? ($(32823),
        (V !== fe || j !== we) && (n.polygonOffset(fe, we), (V = fe), (j = we)))
      : Je(32823);
  }
  function nt(K) {
    K ? $(3089) : Je(3089);
  }
  function At(K) {
    (K === void 0 && (K = 33984 + X - 1),
      G !== K && (n.activeTexture(K), (G = K)));
  }
  function O(K, fe, we) {
    we === void 0 && (G === null ? (we = 33984 + X - 1) : (we = G));
    let Oe = z[we];
    (Oe === void 0 && ((Oe = { type: void 0, texture: void 0 }), (z[we] = Oe)),
      (Oe.type !== K || Oe.texture !== fe) &&
        (G !== we && (n.activeTexture(we), (G = we)),
        n.bindTexture(K, fe || Ae[K]),
        (Oe.type = K),
        (Oe.texture = fe)));
  }
  function D() {
    const K = z[G];
    K !== void 0 &&
      K.type !== void 0 &&
      (n.bindTexture(K.type, null), (K.type = void 0), (K.texture = void 0));
  }
  function le() {
    try {
      n.compressedTexImage2D.apply(n, arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function Ce() {
    try {
      n.compressedTexImage3D.apply(n, arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function Te() {
    try {
      n.texSubImage2D.apply(n, arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function Re() {
    try {
      n.texSubImage3D.apply(n, arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function et() {
    try {
      n.compressedTexSubImage2D.apply(n, arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function Ue() {
    try {
      n.compressedTexSubImage3D.apply(n, arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function pe() {
    try {
      n.texStorage2D.apply(n, arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function He() {
    try {
      n.texStorage3D.apply(n, arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function W() {
    try {
      n.texImage2D.apply(n, arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function de() {
    try {
      n.texImage3D.apply(n, arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function Me(K) {
    ee.equals(K) === !1 && (n.scissor(K.x, K.y, K.z, K.w), ee.copy(K));
  }
  function Pe(K) {
    ne.equals(K) === !1 && (n.viewport(K.x, K.y, K.z, K.w), ne.copy(K));
  }
  function qe(K, fe) {
    let we = d.get(fe);
    we === void 0 && ((we = new WeakMap()), d.set(fe, we));
    let Oe = we.get(K);
    Oe === void 0 && ((Oe = n.getUniformBlockIndex(fe, K.name)), we.set(K, Oe));
  }
  function ht(K, fe) {
    const Oe = d.get(fe).get(K);
    h.get(fe) !== Oe &&
      (n.uniformBlockBinding(fe, Oe, K.__bindingPointIndex), h.set(fe, Oe));
  }
  function Ut() {
    (n.disable(3042),
      n.disable(2884),
      n.disable(2929),
      n.disable(32823),
      n.disable(3089),
      n.disable(2960),
      n.disable(32926),
      n.blendEquation(32774),
      n.blendFunc(1, 0),
      n.blendFuncSeparate(1, 0, 1, 0),
      n.colorMask(!0, !0, !0, !0),
      n.clearColor(0, 0, 0, 0),
      n.depthMask(!0),
      n.depthFunc(513),
      n.clearDepth(1),
      n.stencilMask(4294967295),
      n.stencilFunc(519, 0, 4294967295),
      n.stencilOp(7680, 7680, 7680),
      n.clearStencil(0),
      n.cullFace(1029),
      n.frontFace(2305),
      n.polygonOffset(0, 0),
      n.activeTexture(33984),
      n.bindFramebuffer(36160, null),
      i === !0 &&
        (n.bindFramebuffer(36009, null), n.bindFramebuffer(36008, null)),
      n.useProgram(null),
      n.lineWidth(1),
      n.scissor(0, 0, n.canvas.width, n.canvas.height),
      n.viewport(0, 0, n.canvas.width, n.canvas.height),
      (p = {}),
      (G = null),
      (z = {}),
      (g = {}),
      (y = new WeakMap()),
      (A = []),
      (_ = null),
      (m = !1),
      (x = null),
      (S = null),
      (w = null),
      (C = null),
      (P = null),
      (R = null),
      (B = null),
      (b = !1),
      (L = null),
      (U = null),
      (J = null),
      (V = null),
      (j = null),
      ee.set(0, 0, n.canvas.width, n.canvas.height),
      ne.set(0, 0, n.canvas.width, n.canvas.height),
      a.reset(),
      l.reset(),
      u.reset());
  }
  return {
    buffers: { color: a, depth: l, stencil: u },
    enable: $,
    disable: Je,
    bindFramebuffer: Xe,
    drawBuffers: xe,
    useProgram: Se,
    setBlending: _e,
    setMaterial: Ne,
    setFlipSided: Le,
    setCullFace: We,
    setLineWidth: Ke,
    setPolygonOffset: je,
    setScissorTest: nt,
    activeTexture: At,
    bindTexture: O,
    unbindTexture: D,
    compressedTexImage2D: le,
    compressedTexImage3D: Ce,
    texImage2D: W,
    texImage3D: de,
    updateUBOMapping: qe,
    uniformBlockBinding: ht,
    texStorage2D: pe,
    texStorage3D: He,
    texSubImage2D: Te,
    texSubImage3D: Re,
    compressedTexSubImage2D: et,
    compressedTexSubImage3D: Ue,
    scissor: Me,
    viewport: Pe,
    reset: Ut,
  };
}
function EG(n, e, t, i, r, s, o) {
  const a = r.isWebGL2,
    l = r.maxTextures,
    u = r.maxCubemapSize,
    h = r.maxTextureSize,
    d = r.maxSamples,
    p = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    g =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    y = new WeakMap();
  let A;
  const _ = new WeakMap();
  let m = !1;
  try {
    m =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function x(O, D) {
    return m ? new OffscreenCanvas(O, D) : ih("canvas");
  }
  function S(O, D, le, Ce) {
    let Te = 1;
    if (
      ((O.width > Ce || O.height > Ce) &&
        (Te = Ce / Math.max(O.width, O.height)),
      Te < 1 || D === !0)
    )
      if (
        (typeof HTMLImageElement < "u" && O instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && O instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && O instanceof ImageBitmap)
      ) {
        const Re = D ? zB : Math.floor,
          et = Re(Te * O.width),
          Ue = Re(Te * O.height);
        A === void 0 && (A = x(et, Ue));
        const pe = le ? x(et, Ue) : A;
        return (
          (pe.width = et),
          (pe.height = Ue),
          pe.getContext("2d").drawImage(O, 0, 0, et, Ue),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              O.width +
              "x" +
              O.height +
              ") to (" +
              et +
              "x" +
              Ue +
              ")."
          ),
          pe
        );
      } else
        return (
          "data" in O &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                O.width +
                "x" +
                O.height +
                ")."
            ),
          O
        );
    return O;
  }
  function w(O) {
    return d_(O.width) && d_(O.height);
  }
  function C(O) {
    return a
      ? !1
      : O.wrapS !== jn ||
          O.wrapT !== jn ||
          (O.minFilter !== dn && O.minFilter !== rn);
  }
  function P(O, D) {
    return O.generateMipmaps && D && O.minFilter !== dn && O.minFilter !== rn;
  }
  function R(O) {
    n.generateMipmap(O);
  }
  function B(O, D, le, Ce, Te = !1) {
    if (a === !1) return D;
    if (O !== null) {
      if (n[O] !== void 0) return n[O];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          O +
          "'"
      );
    }
    let Re = D;
    return (
      D === 6403 &&
        (le === 5126 && (Re = 33326),
        le === 5131 && (Re = 33325),
        le === 5121 && (Re = 33321)),
      D === 33319 &&
        (le === 5126 && (Re = 33328),
        le === 5131 && (Re = 33327),
        le === 5121 && (Re = 33323)),
      D === 6408 &&
        (le === 5126 && (Re = 34836),
        le === 5131 && (Re = 34842),
        le === 5121 && (Re = Ce === Tt && Te === !1 ? 35907 : 32856),
        le === 32819 && (Re = 32854),
        le === 32820 && (Re = 32855)),
      (Re === 33325 ||
        Re === 33326 ||
        Re === 33327 ||
        Re === 33328 ||
        Re === 34842 ||
        Re === 34836) &&
        e.get("EXT_color_buffer_float"),
      Re
    );
  }
  function b(O, D, le) {
    return P(O, le) === !0 ||
      (O.isFramebufferTexture && O.minFilter !== dn && O.minFilter !== rn)
      ? Math.log2(Math.max(D.width, D.height)) + 1
      : O.mipmaps !== void 0 && O.mipmaps.length > 0
        ? O.mipmaps.length
        : O.isCompressedTexture && Array.isArray(O.image)
          ? D.mipmaps.length
          : 1;
  }
  function L(O) {
    return O === dn || O === eh || O === Bc ? 9728 : 9729;
  }
  function U(O) {
    const D = O.target;
    (D.removeEventListener("dispose", U),
      V(D),
      D.isVideoTexture && y.delete(D));
  }
  function J(O) {
    const D = O.target;
    (D.removeEventListener("dispose", J), X(D));
  }
  function V(O) {
    const D = i.get(O);
    if (D.__webglInit === void 0) return;
    const le = O.source,
      Ce = _.get(le);
    if (Ce) {
      const Te = Ce[D.__cacheKey];
      (Te.usedTimes--,
        Te.usedTimes === 0 && j(O),
        Object.keys(Ce).length === 0 && _.delete(le));
    }
    i.remove(O);
  }
  function j(O) {
    const D = i.get(O);
    n.deleteTexture(D.__webglTexture);
    const le = O.source,
      Ce = _.get(le);
    (delete Ce[D.__cacheKey], o.memory.textures--);
  }
  function X(O) {
    const D = O.texture,
      le = i.get(O),
      Ce = i.get(D);
    if (
      (Ce.__webglTexture !== void 0 &&
        (n.deleteTexture(Ce.__webglTexture), o.memory.textures--),
      O.depthTexture && O.depthTexture.dispose(),
      O.isWebGLCubeRenderTarget)
    )
      for (let Te = 0; Te < 6; Te++)
        (n.deleteFramebuffer(le.__webglFramebuffer[Te]),
          le.__webglDepthbuffer &&
            n.deleteRenderbuffer(le.__webglDepthbuffer[Te]));
    else {
      if (
        (n.deleteFramebuffer(le.__webglFramebuffer),
        le.__webglDepthbuffer && n.deleteRenderbuffer(le.__webglDepthbuffer),
        le.__webglMultisampledFramebuffer &&
          n.deleteFramebuffer(le.__webglMultisampledFramebuffer),
        le.__webglColorRenderbuffer)
      )
        for (let Te = 0; Te < le.__webglColorRenderbuffer.length; Te++)
          le.__webglColorRenderbuffer[Te] &&
            n.deleteRenderbuffer(le.__webglColorRenderbuffer[Te]);
      le.__webglDepthRenderbuffer &&
        n.deleteRenderbuffer(le.__webglDepthRenderbuffer);
    }
    if (O.isWebGLMultipleRenderTargets)
      for (let Te = 0, Re = D.length; Te < Re; Te++) {
        const et = i.get(D[Te]);
        (et.__webglTexture &&
          (n.deleteTexture(et.__webglTexture), o.memory.textures--),
          i.remove(D[Te]));
      }
    (i.remove(D), i.remove(O));
  }
  let oe = 0;
  function ae() {
    oe = 0;
  }
  function I() {
    const O = oe;
    return (
      O >= l &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            O +
            " texture units while this GPU supports only " +
            l
        ),
      (oe += 1),
      O
    );
  }
  function G(O) {
    const D = [];
    return (
      D.push(O.wrapS),
      D.push(O.wrapT),
      D.push(O.wrapR || 0),
      D.push(O.magFilter),
      D.push(O.minFilter),
      D.push(O.anisotropy),
      D.push(O.internalFormat),
      D.push(O.format),
      D.push(O.type),
      D.push(O.generateMipmaps),
      D.push(O.premultiplyAlpha),
      D.push(O.flipY),
      D.push(O.unpackAlignment),
      D.push(O.encoding),
      D.join()
    );
  }
  function z(O, D) {
    const le = i.get(O);
    if (
      (O.isVideoTexture && nt(O),
      O.isRenderTargetTexture === !1 &&
        O.version > 0 &&
        le.__version !== O.version)
    ) {
      const Ce = O.image;
      if (Ce === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (Ce.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        Je(le, O, D);
        return;
      }
    }
    t.bindTexture(3553, le.__webglTexture, 33984 + D);
  }
  function q(O, D) {
    const le = i.get(O);
    if (O.version > 0 && le.__version !== O.version) {
      Je(le, O, D);
      return;
    }
    t.bindTexture(35866, le.__webglTexture, 33984 + D);
  }
  function Q(O, D) {
    const le = i.get(O);
    if (O.version > 0 && le.__version !== O.version) {
      Je(le, O, D);
      return;
    }
    t.bindTexture(32879, le.__webglTexture, 33984 + D);
  }
  function ee(O, D) {
    const le = i.get(O);
    if (O.version > 0 && le.__version !== O.version) {
      Xe(le, O, D);
      return;
    }
    t.bindTexture(34067, le.__webglTexture, 33984 + D);
  }
  const ne = { [Yo]: 10497, [jn]: 33071, [Hc]: 33648 },
    Ee = {
      [dn]: 9728,
      [eh]: 9984,
      [Bc]: 9986,
      [rn]: 9729,
      [Fg]: 9985,
      [hs]: 9987,
    };
  function Ae(O, D, le) {
    if (
      (le
        ? (n.texParameteri(O, 10242, ne[D.wrapS]),
          n.texParameteri(O, 10243, ne[D.wrapT]),
          (O === 32879 || O === 35866) &&
            n.texParameteri(O, 32882, ne[D.wrapR]),
          n.texParameteri(O, 10240, Ee[D.magFilter]),
          n.texParameteri(O, 10241, Ee[D.minFilter]))
        : (n.texParameteri(O, 10242, 33071),
          n.texParameteri(O, 10243, 33071),
          (O === 32879 || O === 35866) && n.texParameteri(O, 32882, 33071),
          (D.wrapS !== jn || D.wrapT !== jn) &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
            ),
          n.texParameteri(O, 10240, L(D.magFilter)),
          n.texParameteri(O, 10241, L(D.minFilter)),
          D.minFilter !== dn &&
            D.minFilter !== rn &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
            )),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      const Ce = e.get("EXT_texture_filter_anisotropic");
      if (
        D.magFilter === dn ||
        (D.minFilter !== Bc && D.minFilter !== hs) ||
        (D.type === Os && e.has("OES_texture_float_linear") === !1) ||
        (a === !1 &&
          D.type === Vc &&
          e.has("OES_texture_half_float_linear") === !1)
      )
        return;
      (D.anisotropy > 1 || i.get(D).__currentAnisotropy) &&
        (n.texParameterf(
          O,
          Ce.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(D.anisotropy, r.getMaxAnisotropy())
        ),
        (i.get(D).__currentAnisotropy = D.anisotropy));
    }
  }
  function $(O, D) {
    let le = !1;
    O.__webglInit === void 0 &&
      ((O.__webglInit = !0), D.addEventListener("dispose", U));
    const Ce = D.source;
    let Te = _.get(Ce);
    Te === void 0 && ((Te = {}), _.set(Ce, Te));
    const Re = G(D);
    if (Re !== O.__cacheKey) {
      (Te[Re] === void 0 &&
        ((Te[Re] = { texture: n.createTexture(), usedTimes: 0 }),
        o.memory.textures++,
        (le = !0)),
        Te[Re].usedTimes++);
      const et = Te[O.__cacheKey];
      (et !== void 0 &&
        (Te[O.__cacheKey].usedTimes--, et.usedTimes === 0 && j(D)),
        (O.__cacheKey = Re),
        (O.__webglTexture = Te[Re].texture));
    }
    return le;
  }
  function Je(O, D, le) {
    let Ce = 3553;
    ((D.isDataArrayTexture || D.isCompressedArrayTexture) && (Ce = 35866),
      D.isData3DTexture && (Ce = 32879));
    const Te = $(O, D),
      Re = D.source;
    t.bindTexture(Ce, O.__webglTexture, 33984 + le);
    const et = i.get(Re);
    if (Re.version !== et.__version || Te === !0) {
      (t.activeTexture(33984 + le),
        n.pixelStorei(37440, D.flipY),
        n.pixelStorei(37441, D.premultiplyAlpha),
        n.pixelStorei(3317, D.unpackAlignment),
        n.pixelStorei(37443, 0));
      const Ue = C(D) && w(D.image) === !1;
      let pe = S(D.image, Ue, !1, h);
      pe = At(D, pe);
      const He = w(pe) || a,
        W = s.convert(D.format, D.encoding);
      let de = s.convert(D.type),
        Me = B(D.internalFormat, W, de, D.encoding, D.isVideoTexture);
      Ae(Ce, D, He);
      let Pe;
      const qe = D.mipmaps,
        ht = a && D.isVideoTexture !== !0,
        Ut = et.__version === void 0 || Te === !0,
        K = b(D, pe, He);
      if (D.isDepthTexture)
        ((Me = 6402),
          a
            ? D.type === Os
              ? (Me = 36012)
              : D.type === Ro
                ? (Me = 33190)
                : D.type === Ya
                  ? (Me = 35056)
                  : (Me = 33189)
            : D.type === Os &&
              console.error(
                "WebGLRenderer: Floating point depth texture requires WebGL2."
              ),
          D.format === Ho &&
            Me === 6402 &&
            D.type !== X1 &&
            D.type !== Ro &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
            ),
            (D.type = Ro),
            (de = s.convert(D.type))),
          D.format === sl &&
            Me === 6402 &&
            ((Me = 34041),
            D.type !== Ya &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
              ),
              (D.type = Ya),
              (de = s.convert(D.type)))),
          Ut &&
            (ht
              ? t.texStorage2D(3553, 1, Me, pe.width, pe.height)
              : t.texImage2D(
                  3553,
                  0,
                  Me,
                  pe.width,
                  pe.height,
                  0,
                  W,
                  de,
                  null
                )));
      else if (D.isDataTexture)
        if (qe.length > 0 && He) {
          ht && Ut && t.texStorage2D(3553, K, Me, qe[0].width, qe[0].height);
          for (let fe = 0, we = qe.length; fe < we; fe++)
            ((Pe = qe[fe]),
              ht
                ? t.texSubImage2D(
                    3553,
                    fe,
                    0,
                    0,
                    Pe.width,
                    Pe.height,
                    W,
                    de,
                    Pe.data
                  )
                : t.texImage2D(
                    3553,
                    fe,
                    Me,
                    Pe.width,
                    Pe.height,
                    0,
                    W,
                    de,
                    Pe.data
                  ));
          D.generateMipmaps = !1;
        } else
          ht
            ? (Ut && t.texStorage2D(3553, K, Me, pe.width, pe.height),
              t.texSubImage2D(
                3553,
                0,
                0,
                0,
                pe.width,
                pe.height,
                W,
                de,
                pe.data
              ))
            : t.texImage2D(3553, 0, Me, pe.width, pe.height, 0, W, de, pe.data);
      else if (D.isCompressedTexture)
        if (D.isCompressedArrayTexture) {
          ht &&
            Ut &&
            t.texStorage3D(35866, K, Me, qe[0].width, qe[0].height, pe.depth);
          for (let fe = 0, we = qe.length; fe < we; fe++)
            ((Pe = qe[fe]),
              D.format !== Pi
                ? W !== null
                  ? ht
                    ? t.compressedTexSubImage3D(
                        35866,
                        fe,
                        0,
                        0,
                        0,
                        Pe.width,
                        Pe.height,
                        pe.depth,
                        W,
                        Pe.data,
                        0,
                        0
                      )
                    : t.compressedTexImage3D(
                        35866,
                        fe,
                        Me,
                        Pe.width,
                        Pe.height,
                        pe.depth,
                        0,
                        Pe.data,
                        0,
                        0
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : ht
                  ? t.texSubImage3D(
                      35866,
                      fe,
                      0,
                      0,
                      0,
                      Pe.width,
                      Pe.height,
                      pe.depth,
                      W,
                      de,
                      Pe.data
                    )
                  : t.texImage3D(
                      35866,
                      fe,
                      Me,
                      Pe.width,
                      Pe.height,
                      pe.depth,
                      0,
                      W,
                      de,
                      Pe.data
                    ));
        } else {
          ht && Ut && t.texStorage2D(3553, K, Me, qe[0].width, qe[0].height);
          for (let fe = 0, we = qe.length; fe < we; fe++)
            ((Pe = qe[fe]),
              D.format !== Pi
                ? W !== null
                  ? ht
                    ? t.compressedTexSubImage2D(
                        3553,
                        fe,
                        0,
                        0,
                        Pe.width,
                        Pe.height,
                        W,
                        Pe.data
                      )
                    : t.compressedTexImage2D(
                        3553,
                        fe,
                        Me,
                        Pe.width,
                        Pe.height,
                        0,
                        Pe.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : ht
                  ? t.texSubImage2D(
                      3553,
                      fe,
                      0,
                      0,
                      Pe.width,
                      Pe.height,
                      W,
                      de,
                      Pe.data
                    )
                  : t.texImage2D(
                      3553,
                      fe,
                      Me,
                      Pe.width,
                      Pe.height,
                      0,
                      W,
                      de,
                      Pe.data
                    ));
        }
      else if (D.isDataArrayTexture)
        ht
          ? (Ut && t.texStorage3D(35866, K, Me, pe.width, pe.height, pe.depth),
            t.texSubImage3D(
              35866,
              0,
              0,
              0,
              0,
              pe.width,
              pe.height,
              pe.depth,
              W,
              de,
              pe.data
            ))
          : t.texImage3D(
              35866,
              0,
              Me,
              pe.width,
              pe.height,
              pe.depth,
              0,
              W,
              de,
              pe.data
            );
      else if (D.isData3DTexture)
        ht
          ? (Ut && t.texStorage3D(32879, K, Me, pe.width, pe.height, pe.depth),
            t.texSubImage3D(
              32879,
              0,
              0,
              0,
              0,
              pe.width,
              pe.height,
              pe.depth,
              W,
              de,
              pe.data
            ))
          : t.texImage3D(
              32879,
              0,
              Me,
              pe.width,
              pe.height,
              pe.depth,
              0,
              W,
              de,
              pe.data
            );
      else if (D.isFramebufferTexture) {
        if (Ut)
          if (ht) t.texStorage2D(3553, K, Me, pe.width, pe.height);
          else {
            let fe = pe.width,
              we = pe.height;
            for (let Oe = 0; Oe < K; Oe++)
              (t.texImage2D(3553, Oe, Me, fe, we, 0, W, de, null),
                (fe >>= 1),
                (we >>= 1));
          }
      } else if (qe.length > 0 && He) {
        ht && Ut && t.texStorage2D(3553, K, Me, qe[0].width, qe[0].height);
        for (let fe = 0, we = qe.length; fe < we; fe++)
          ((Pe = qe[fe]),
            ht
              ? t.texSubImage2D(3553, fe, 0, 0, W, de, Pe)
              : t.texImage2D(3553, fe, Me, W, de, Pe));
        D.generateMipmaps = !1;
      } else
        ht
          ? (Ut && t.texStorage2D(3553, K, Me, pe.width, pe.height),
            t.texSubImage2D(3553, 0, 0, 0, W, de, pe))
          : t.texImage2D(3553, 0, Me, W, de, pe);
      (P(D, He) && R(Ce),
        (et.__version = Re.version),
        D.onUpdate && D.onUpdate(D));
    }
    O.__version = D.version;
  }
  function Xe(O, D, le) {
    if (D.image.length !== 6) return;
    const Ce = $(O, D),
      Te = D.source;
    t.bindTexture(34067, O.__webglTexture, 33984 + le);
    const Re = i.get(Te);
    if (Te.version !== Re.__version || Ce === !0) {
      (t.activeTexture(33984 + le),
        n.pixelStorei(37440, D.flipY),
        n.pixelStorei(37441, D.premultiplyAlpha),
        n.pixelStorei(3317, D.unpackAlignment),
        n.pixelStorei(37443, 0));
      const et = D.isCompressedTexture || D.image[0].isCompressedTexture,
        Ue = D.image[0] && D.image[0].isDataTexture,
        pe = [];
      for (let fe = 0; fe < 6; fe++)
        (!et && !Ue
          ? (pe[fe] = S(D.image[fe], !1, !0, u))
          : (pe[fe] = Ue ? D.image[fe].image : D.image[fe]),
          (pe[fe] = At(D, pe[fe])));
      const He = pe[0],
        W = w(He) || a,
        de = s.convert(D.format, D.encoding),
        Me = s.convert(D.type),
        Pe = B(D.internalFormat, de, Me, D.encoding),
        qe = a && D.isVideoTexture !== !0,
        ht = Re.__version === void 0 || Ce === !0;
      let Ut = b(D, He, W);
      Ae(34067, D, W);
      let K;
      if (et) {
        qe && ht && t.texStorage2D(34067, Ut, Pe, He.width, He.height);
        for (let fe = 0; fe < 6; fe++) {
          K = pe[fe].mipmaps;
          for (let we = 0; we < K.length; we++) {
            const Oe = K[we];
            D.format !== Pi
              ? de !== null
                ? qe
                  ? t.compressedTexSubImage2D(
                      34069 + fe,
                      we,
                      0,
                      0,
                      Oe.width,
                      Oe.height,
                      de,
                      Oe.data
                    )
                  : t.compressedTexImage2D(
                      34069 + fe,
                      we,
                      Pe,
                      Oe.width,
                      Oe.height,
                      0,
                      Oe.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : qe
                ? t.texSubImage2D(
                    34069 + fe,
                    we,
                    0,
                    0,
                    Oe.width,
                    Oe.height,
                    de,
                    Me,
                    Oe.data
                  )
                : t.texImage2D(
                    34069 + fe,
                    we,
                    Pe,
                    Oe.width,
                    Oe.height,
                    0,
                    de,
                    Me,
                    Oe.data
                  );
          }
        }
      } else {
        ((K = D.mipmaps),
          qe &&
            ht &&
            (K.length > 0 && Ut++,
            t.texStorage2D(34067, Ut, Pe, pe[0].width, pe[0].height)));
        for (let fe = 0; fe < 6; fe++)
          if (Ue) {
            qe
              ? t.texSubImage2D(
                  34069 + fe,
                  0,
                  0,
                  0,
                  pe[fe].width,
                  pe[fe].height,
                  de,
                  Me,
                  pe[fe].data
                )
              : t.texImage2D(
                  34069 + fe,
                  0,
                  Pe,
                  pe[fe].width,
                  pe[fe].height,
                  0,
                  de,
                  Me,
                  pe[fe].data
                );
            for (let we = 0; we < K.length; we++) {
              const Qe = K[we].image[fe].image;
              qe
                ? t.texSubImage2D(
                    34069 + fe,
                    we + 1,
                    0,
                    0,
                    Qe.width,
                    Qe.height,
                    de,
                    Me,
                    Qe.data
                  )
                : t.texImage2D(
                    34069 + fe,
                    we + 1,
                    Pe,
                    Qe.width,
                    Qe.height,
                    0,
                    de,
                    Me,
                    Qe.data
                  );
            }
          } else {
            qe
              ? t.texSubImage2D(34069 + fe, 0, 0, 0, de, Me, pe[fe])
              : t.texImage2D(34069 + fe, 0, Pe, de, Me, pe[fe]);
            for (let we = 0; we < K.length; we++) {
              const Oe = K[we];
              qe
                ? t.texSubImage2D(
                    34069 + fe,
                    we + 1,
                    0,
                    0,
                    de,
                    Me,
                    Oe.image[fe]
                  )
                : t.texImage2D(34069 + fe, we + 1, Pe, de, Me, Oe.image[fe]);
            }
          }
      }
      (P(D, W) && R(34067),
        (Re.__version = Te.version),
        D.onUpdate && D.onUpdate(D));
    }
    O.__version = D.version;
  }
  function xe(O, D, le, Ce, Te) {
    const Re = s.convert(le.format, le.encoding),
      et = s.convert(le.type),
      Ue = B(le.internalFormat, Re, et, le.encoding);
    (i.get(D).__hasExternalTextures ||
      (Te === 32879 || Te === 35866
        ? t.texImage3D(Te, 0, Ue, D.width, D.height, D.depth, 0, Re, et, null)
        : t.texImage2D(Te, 0, Ue, D.width, D.height, 0, Re, et, null)),
      t.bindFramebuffer(36160, O),
      je(D)
        ? p.framebufferTexture2DMultisampleEXT(
            36160,
            Ce,
            Te,
            i.get(le).__webglTexture,
            0,
            Ke(D)
          )
        : (Te === 3553 || (Te >= 34069 && Te <= 34074)) &&
          n.framebufferTexture2D(36160, Ce, Te, i.get(le).__webglTexture, 0),
      t.bindFramebuffer(36160, null));
  }
  function Se(O, D, le) {
    if ((n.bindRenderbuffer(36161, O), D.depthBuffer && !D.stencilBuffer)) {
      let Ce = 33189;
      if (le || je(D)) {
        const Te = D.depthTexture;
        Te &&
          Te.isDepthTexture &&
          (Te.type === Os ? (Ce = 36012) : Te.type === Ro && (Ce = 33190));
        const Re = Ke(D);
        je(D)
          ? p.renderbufferStorageMultisampleEXT(
              36161,
              Re,
              Ce,
              D.width,
              D.height
            )
          : n.renderbufferStorageMultisample(36161, Re, Ce, D.width, D.height);
      } else n.renderbufferStorage(36161, Ce, D.width, D.height);
      n.framebufferRenderbuffer(36160, 36096, 36161, O);
    } else if (D.depthBuffer && D.stencilBuffer) {
      const Ce = Ke(D);
      (le && je(D) === !1
        ? n.renderbufferStorageMultisample(36161, Ce, 35056, D.width, D.height)
        : je(D)
          ? p.renderbufferStorageMultisampleEXT(
              36161,
              Ce,
              35056,
              D.width,
              D.height
            )
          : n.renderbufferStorage(36161, 34041, D.width, D.height),
        n.framebufferRenderbuffer(36160, 33306, 36161, O));
    } else {
      const Ce =
        D.isWebGLMultipleRenderTargets === !0 ? D.texture : [D.texture];
      for (let Te = 0; Te < Ce.length; Te++) {
        const Re = Ce[Te],
          et = s.convert(Re.format, Re.encoding),
          Ue = s.convert(Re.type),
          pe = B(Re.internalFormat, et, Ue, Re.encoding),
          He = Ke(D);
        le && je(D) === !1
          ? n.renderbufferStorageMultisample(36161, He, pe, D.width, D.height)
          : je(D)
            ? p.renderbufferStorageMultisampleEXT(
                36161,
                He,
                pe,
                D.width,
                D.height
              )
            : n.renderbufferStorage(36161, pe, D.width, D.height);
      }
    }
    n.bindRenderbuffer(36161, null);
  }
  function ge(O, D) {
    if (D && D.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (t.bindFramebuffer(36160, O),
      !(D.depthTexture && D.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    ((!i.get(D.depthTexture).__webglTexture ||
      D.depthTexture.image.width !== D.width ||
      D.depthTexture.image.height !== D.height) &&
      ((D.depthTexture.image.width = D.width),
      (D.depthTexture.image.height = D.height),
      (D.depthTexture.needsUpdate = !0)),
      z(D.depthTexture, 0));
    const Ce = i.get(D.depthTexture).__webglTexture,
      Te = Ke(D);
    if (D.depthTexture.format === Ho)
      je(D)
        ? p.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, Ce, 0, Te)
        : n.framebufferTexture2D(36160, 36096, 3553, Ce, 0);
    else if (D.depthTexture.format === sl)
      je(D)
        ? p.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, Ce, 0, Te)
        : n.framebufferTexture2D(36160, 33306, 3553, Ce, 0);
    else throw new Error("Unknown depthTexture format");
  }
  function se(O) {
    const D = i.get(O),
      le = O.isWebGLCubeRenderTarget === !0;
    if (O.depthTexture && !D.__autoAllocateDepthBuffer) {
      if (le)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      ge(D.__webglFramebuffer, O);
    } else if (le) {
      D.__webglDepthbuffer = [];
      for (let Ce = 0; Ce < 6; Ce++)
        (t.bindFramebuffer(36160, D.__webglFramebuffer[Ce]),
          (D.__webglDepthbuffer[Ce] = n.createRenderbuffer()),
          Se(D.__webglDepthbuffer[Ce], O, !1));
    } else
      (t.bindFramebuffer(36160, D.__webglFramebuffer),
        (D.__webglDepthbuffer = n.createRenderbuffer()),
        Se(D.__webglDepthbuffer, O, !1));
    t.bindFramebuffer(36160, null);
  }
  function _e(O, D, le) {
    const Ce = i.get(O);
    (D !== void 0 && xe(Ce.__webglFramebuffer, O, O.texture, 36064, 3553),
      le !== void 0 && se(O));
  }
  function Ne(O) {
    const D = O.texture,
      le = i.get(O),
      Ce = i.get(D);
    (O.addEventListener("dispose", J),
      O.isWebGLMultipleRenderTargets !== !0 &&
        (Ce.__webglTexture === void 0 &&
          (Ce.__webglTexture = n.createTexture()),
        (Ce.__version = D.version),
        o.memory.textures++));
    const Te = O.isWebGLCubeRenderTarget === !0,
      Re = O.isWebGLMultipleRenderTargets === !0,
      et = w(O) || a;
    if (Te) {
      le.__webglFramebuffer = [];
      for (let Ue = 0; Ue < 6; Ue++)
        le.__webglFramebuffer[Ue] = n.createFramebuffer();
    } else {
      if (((le.__webglFramebuffer = n.createFramebuffer()), Re))
        if (r.drawBuffers) {
          const Ue = O.texture;
          for (let pe = 0, He = Ue.length; pe < He; pe++) {
            const W = i.get(Ue[pe]);
            W.__webglTexture === void 0 &&
              ((W.__webglTexture = n.createTexture()), o.memory.textures++);
          }
        } else
          console.warn(
            "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
          );
      if (a && O.samples > 0 && je(O) === !1) {
        const Ue = Re ? D : [D];
        ((le.__webglMultisampledFramebuffer = n.createFramebuffer()),
          (le.__webglColorRenderbuffer = []),
          t.bindFramebuffer(36160, le.__webglMultisampledFramebuffer));
        for (let pe = 0; pe < Ue.length; pe++) {
          const He = Ue[pe];
          ((le.__webglColorRenderbuffer[pe] = n.createRenderbuffer()),
            n.bindRenderbuffer(36161, le.__webglColorRenderbuffer[pe]));
          const W = s.convert(He.format, He.encoding),
            de = s.convert(He.type),
            Me = B(
              He.internalFormat,
              W,
              de,
              He.encoding,
              O.isXRRenderTarget === !0
            ),
            Pe = Ke(O);
          (n.renderbufferStorageMultisample(36161, Pe, Me, O.width, O.height),
            n.framebufferRenderbuffer(
              36160,
              36064 + pe,
              36161,
              le.__webglColorRenderbuffer[pe]
            ));
        }
        (n.bindRenderbuffer(36161, null),
          O.depthBuffer &&
            ((le.__webglDepthRenderbuffer = n.createRenderbuffer()),
            Se(le.__webglDepthRenderbuffer, O, !0)),
          t.bindFramebuffer(36160, null));
      }
    }
    if (Te) {
      (t.bindTexture(34067, Ce.__webglTexture), Ae(34067, D, et));
      for (let Ue = 0; Ue < 6; Ue++)
        xe(le.__webglFramebuffer[Ue], O, D, 36064, 34069 + Ue);
      (P(D, et) && R(34067), t.unbindTexture());
    } else if (Re) {
      const Ue = O.texture;
      for (let pe = 0, He = Ue.length; pe < He; pe++) {
        const W = Ue[pe],
          de = i.get(W);
        (t.bindTexture(3553, de.__webglTexture),
          Ae(3553, W, et),
          xe(le.__webglFramebuffer, O, W, 36064 + pe, 3553),
          P(W, et) && R(3553));
      }
      t.unbindTexture();
    } else {
      let Ue = 3553;
      ((O.isWebGL3DRenderTarget || O.isWebGLArrayRenderTarget) &&
        (a
          ? (Ue = O.isWebGL3DRenderTarget ? 32879 : 35866)
          : console.error(
              "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
            )),
        t.bindTexture(Ue, Ce.__webglTexture),
        Ae(Ue, D, et),
        xe(le.__webglFramebuffer, O, D, 36064, Ue),
        P(D, et) && R(Ue),
        t.unbindTexture());
    }
    O.depthBuffer && se(O);
  }
  function Le(O) {
    const D = w(O) || a,
      le = O.isWebGLMultipleRenderTargets === !0 ? O.texture : [O.texture];
    for (let Ce = 0, Te = le.length; Ce < Te; Ce++) {
      const Re = le[Ce];
      if (P(Re, D)) {
        const et = O.isWebGLCubeRenderTarget ? 34067 : 3553,
          Ue = i.get(Re).__webglTexture;
        (t.bindTexture(et, Ue), R(et), t.unbindTexture());
      }
    }
  }
  function We(O) {
    if (a && O.samples > 0 && je(O) === !1) {
      const D = O.isWebGLMultipleRenderTargets ? O.texture : [O.texture],
        le = O.width,
        Ce = O.height;
      let Te = 16384;
      const Re = [],
        et = O.stencilBuffer ? 33306 : 36096,
        Ue = i.get(O),
        pe = O.isWebGLMultipleRenderTargets === !0;
      if (pe)
        for (let He = 0; He < D.length; He++)
          (t.bindFramebuffer(36160, Ue.__webglMultisampledFramebuffer),
            n.framebufferRenderbuffer(36160, 36064 + He, 36161, null),
            t.bindFramebuffer(36160, Ue.__webglFramebuffer),
            n.framebufferTexture2D(36009, 36064 + He, 3553, null, 0));
      (t.bindFramebuffer(36008, Ue.__webglMultisampledFramebuffer),
        t.bindFramebuffer(36009, Ue.__webglFramebuffer));
      for (let He = 0; He < D.length; He++) {
        (Re.push(36064 + He), O.depthBuffer && Re.push(et));
        const W =
          Ue.__ignoreDepthValues !== void 0 ? Ue.__ignoreDepthValues : !1;
        if (
          (W === !1 &&
            (O.depthBuffer && (Te |= 256), O.stencilBuffer && (Te |= 1024)),
          pe &&
            n.framebufferRenderbuffer(
              36008,
              36064,
              36161,
              Ue.__webglColorRenderbuffer[He]
            ),
          W === !0 &&
            (n.invalidateFramebuffer(36008, [et]),
            n.invalidateFramebuffer(36009, [et])),
          pe)
        ) {
          const de = i.get(D[He]).__webglTexture;
          n.framebufferTexture2D(36009, 36064, 3553, de, 0);
        }
        (n.blitFramebuffer(0, 0, le, Ce, 0, 0, le, Ce, Te, 9728),
          g && n.invalidateFramebuffer(36008, Re));
      }
      if ((t.bindFramebuffer(36008, null), t.bindFramebuffer(36009, null), pe))
        for (let He = 0; He < D.length; He++) {
          (t.bindFramebuffer(36160, Ue.__webglMultisampledFramebuffer),
            n.framebufferRenderbuffer(
              36160,
              36064 + He,
              36161,
              Ue.__webglColorRenderbuffer[He]
            ));
          const W = i.get(D[He]).__webglTexture;
          (t.bindFramebuffer(36160, Ue.__webglFramebuffer),
            n.framebufferTexture2D(36009, 36064 + He, 3553, W, 0));
        }
      t.bindFramebuffer(36009, Ue.__webglMultisampledFramebuffer);
    }
  }
  function Ke(O) {
    return Math.min(d, O.samples);
  }
  function je(O) {
    const D = i.get(O);
    return (
      a &&
      O.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      D.__useRenderToTexture !== !1
    );
  }
  function nt(O) {
    const D = o.render.frame;
    y.get(O) !== D && (y.set(O, D), O.update());
  }
  function At(O, D) {
    const le = O.encoding,
      Ce = O.format,
      Te = O.type;
    return (
      O.isCompressedTexture === !0 ||
        O.isVideoTexture === !0 ||
        O.format === Qm ||
        (le !== Qs &&
          (le === Tt
            ? a === !1
              ? e.has("EXT_sRGB") === !0 && Ce === Pi
                ? ((O.format = Qm),
                  (O.minFilter = rn),
                  (O.generateMipmaps = !1))
                : (D = $1.sRGBToLinear(D))
              : (Ce !== Pi || Te !== Ys) &&
                console.warn(
                  "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture encoding:",
                le
              ))),
      D
    );
  }
  ((this.allocateTextureUnit = I),
    (this.resetTextureUnits = ae),
    (this.setTexture2D = z),
    (this.setTexture2DArray = q),
    (this.setTexture3D = Q),
    (this.setTextureCube = ee),
    (this.rebindTextures = _e),
    (this.setupRenderTarget = Ne),
    (this.updateRenderTargetMipmap = Le),
    (this.updateMultisampleRenderTarget = We),
    (this.setupDepthRenderbuffer = se),
    (this.setupFrameBufferTexture = xe),
    (this.useMultisampledRTT = je));
}
function QB(n, e, t) {
  const i = t.isWebGL2;
  function r(s, o = null) {
    let a;
    if (s === Ys) return 5121;
    if (s === xB) return 32819;
    if (s === _B) return 32820;
    if (s === gB) return 5120;
    if (s === vB) return 5122;
    if (s === X1) return 5123;
    if (s === yB) return 5124;
    if (s === Ro) return 5125;
    if (s === Os) return 5126;
    if (s === Vc)
      return i
        ? 5131
        : ((a = e.get("OES_texture_half_float")),
          a !== null ? a.HALF_FLOAT_OES : null);
    if (s === AB) return 6406;
    if (s === Pi) return 6408;
    if (s === MB) return 6409;
    if (s === SB) return 6410;
    if (s === Ho) return 6402;
    if (s === sl) return 34041;
    if (s === Qm)
      return ((a = e.get("EXT_sRGB")), a !== null ? a.SRGB_ALPHA_EXT : null);
    if (s === wB) return 6403;
    if (s === EB) return 36244;
    if (s === CB) return 33319;
    if (s === TB) return 33320;
    if (s === bB) return 36249;
    if (s === mm || s === gm || s === vm || s === ym)
      if (o === Tt)
        if (((a = e.get("WEBGL_compressed_texture_s3tc_srgb")), a !== null)) {
          if (s === mm) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (s === gm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (s === vm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (s === ym) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((a = e.get("WEBGL_compressed_texture_s3tc")), a !== null)) {
        if (s === mm) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (s === gm) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (s === vm) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (s === ym) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (s === Vx || s === Wx || s === jx || s === Jx)
      if (((a = e.get("WEBGL_compressed_texture_pvrtc")), a !== null)) {
        if (s === Vx) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (s === Wx) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (s === jx) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (s === Jx) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (s === PB)
      return (
        (a = e.get("WEBGL_compressed_texture_etc1")),
        a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null
      );
    if (s === Xx || s === Kx)
      if (((a = e.get("WEBGL_compressed_texture_etc")), a !== null)) {
        if (s === Xx)
          return o === Tt ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
        if (s === Kx)
          return o === Tt
            ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : a.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      s === Yx ||
      s === Qx ||
      s === Zx ||
      s === qx ||
      s === $x ||
      s === e_ ||
      s === t_ ||
      s === n_ ||
      s === i_ ||
      s === r_ ||
      s === s_ ||
      s === o_ ||
      s === a_ ||
      s === l_
    )
      if (((a = e.get("WEBGL_compressed_texture_astc")), a !== null)) {
        if (s === Yx)
          return o === Tt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (s === Qx)
          return o === Tt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (s === Zx)
          return o === Tt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (s === qx)
          return o === Tt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (s === $x)
          return o === Tt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (s === e_)
          return o === Tt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (s === t_)
          return o === Tt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (s === n_)
          return o === Tt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (s === i_)
          return o === Tt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (s === r_)
          return o === Tt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (s === s_)
          return o === Tt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (s === o_)
          return o === Tt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (s === a_)
          return o === Tt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (s === l_)
          return o === Tt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (s === xm)
      if (((a = e.get("EXT_texture_compression_bptc")), a !== null)) {
        if (s === xm)
          return o === Tt
            ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else return null;
    if (s === BB || s === c_ || s === u_ || s === f_)
      if (((a = e.get("EXT_texture_compression_rgtc")), a !== null)) {
        if (s === xm) return a.COMPRESSED_RED_RGTC1_EXT;
        if (s === c_) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (s === u_) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (s === f_) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return s === Ya
      ? i
        ? 34042
        : ((a = e.get("WEBGL_depth_texture")),
          a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null)
      : n[s] !== void 0
        ? n[s]
        : null;
  }
  return { convert: r };
}
class ZB extends Vt {
  constructor(e = []) {
    (super(), (this.isArrayCamera = !0), (this.cameras = e));
  }
}
class Us extends Pt {
  constructor() {
    (super(), (this.isGroup = !0), (this.type = "Group"));
  }
}
const CG = { type: "move" };
class ry {
  constructor() {
    ((this._targetRay = null), (this._grip = null), (this._hand = null));
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new Us()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new Us()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new F()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new F())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new Us()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new F()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new F())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const i of e.hand.values()) this._getHandJoint(t, i);
    }
    return (this.dispatchEvent({ type: "connected", data: e }), this);
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, i) {
    let r = null,
      s = null,
      o = null;
    const a = this._targetRay,
      l = this._grip,
      u = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (u && e.hand) {
        o = !0;
        for (const A of e.hand.values()) {
          const _ = t.getJointPose(A, i),
            m = this._getHandJoint(u, A);
          (_ !== null &&
            (m.matrix.fromArray(_.transform.matrix),
            m.matrix.decompose(m.position, m.rotation, m.scale),
            (m.jointRadius = _.radius)),
            (m.visible = _ !== null));
        }
        const h = u.joints["index-finger-tip"],
          d = u.joints["thumb-tip"],
          p = h.position.distanceTo(d.position),
          g = 0.02,
          y = 0.005;
        u.inputState.pinching && p > g + y
          ? ((u.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !u.inputState.pinching &&
            p <= g - y &&
            ((u.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        l !== null &&
          e.gripSpace &&
          ((s = t.getPose(e.gripSpace, i)),
          s !== null &&
            (l.matrix.fromArray(s.transform.matrix),
            l.matrix.decompose(l.position, l.rotation, l.scale),
            s.linearVelocity
              ? ((l.hasLinearVelocity = !0),
                l.linearVelocity.copy(s.linearVelocity))
              : (l.hasLinearVelocity = !1),
            s.angularVelocity
              ? ((l.hasAngularVelocity = !0),
                l.angularVelocity.copy(s.angularVelocity))
              : (l.hasAngularVelocity = !1)));
      a !== null &&
        ((r = t.getPose(e.targetRaySpace, i)),
        r === null && s !== null && (r = s),
        r !== null &&
          (a.matrix.fromArray(r.transform.matrix),
          a.matrix.decompose(a.position, a.rotation, a.scale),
          r.linearVelocity
            ? ((a.hasLinearVelocity = !0),
              a.linearVelocity.copy(r.linearVelocity))
            : (a.hasLinearVelocity = !1),
          r.angularVelocity
            ? ((a.hasAngularVelocity = !0),
              a.angularVelocity.copy(r.angularVelocity))
            : (a.hasAngularVelocity = !1),
          this.dispatchEvent(CG)));
    }
    return (
      a !== null && (a.visible = r !== null),
      l !== null && (l.visible = s !== null),
      u !== null && (u.visible = o !== null),
      this
    );
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const i = new Us();
      ((i.matrixAutoUpdate = !1),
        (i.visible = !1),
        (e.joints[t.jointName] = i),
        e.add(i));
    }
    return e.joints[t.jointName];
  }
}
class qB extends en {
  constructor(e, t, i, r, s, o, a, l, u, h) {
    if (((h = h !== void 0 ? h : Ho), h !== Ho && h !== sl))
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    (i === void 0 && h === Ho && (i = Ro),
      i === void 0 && h === sl && (i = Ya),
      super(null, r, s, o, a, l, h, i, u),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: t }),
      (this.magFilter = a !== void 0 ? a : dn),
      (this.minFilter = l !== void 0 ? l : dn),
      (this.flipY = !1),
      (this.generateMipmaps = !1));
  }
}
class TG extends ps {
  constructor(e, t) {
    super();
    const i = this;
    let r = null,
      s = 1,
      o = null,
      a = "local-floor",
      l = 1,
      u = null,
      h = null,
      d = null,
      p = null,
      g = null,
      y = null;
    const A = t.getContextAttributes();
    let _ = null,
      m = null;
    const x = [],
      S = [],
      w = new Set(),
      C = new Map(),
      P = new Vt();
    (P.layers.enable(1), (P.viewport = new kt()));
    const R = new Vt();
    (R.layers.enable(2), (R.viewport = new kt()));
    const B = [P, R],
      b = new ZB();
    (b.layers.enable(1), b.layers.enable(2));
    let L = null,
      U = null;
    ((this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (ee) {
        let ne = x[ee];
        return (
          ne === void 0 && ((ne = new ry()), (x[ee] = ne)),
          ne.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (ee) {
        let ne = x[ee];
        return (
          ne === void 0 && ((ne = new ry()), (x[ee] = ne)),
          ne.getGripSpace()
        );
      }),
      (this.getHand = function (ee) {
        let ne = x[ee];
        return (
          ne === void 0 && ((ne = new ry()), (x[ee] = ne)),
          ne.getHandSpace()
        );
      }));
    function J(ee) {
      const ne = S.indexOf(ee.inputSource);
      if (ne === -1) return;
      const Ee = x[ne];
      Ee !== void 0 &&
        Ee.dispatchEvent({ type: ee.type, data: ee.inputSource });
    }
    function V() {
      (r.removeEventListener("select", J),
        r.removeEventListener("selectstart", J),
        r.removeEventListener("selectend", J),
        r.removeEventListener("squeeze", J),
        r.removeEventListener("squeezestart", J),
        r.removeEventListener("squeezeend", J),
        r.removeEventListener("end", V),
        r.removeEventListener("inputsourceschange", j));
      for (let ee = 0; ee < x.length; ee++) {
        const ne = S[ee];
        ne !== null && ((S[ee] = null), x[ee].disconnect(ne));
      }
      ((L = null),
        (U = null),
        e.setRenderTarget(_),
        (g = null),
        (p = null),
        (d = null),
        (r = null),
        (m = null),
        Q.stop(),
        (i.isPresenting = !1),
        i.dispatchEvent({ type: "sessionend" }));
    }
    ((this.setFramebufferScaleFactor = function (ee) {
      ((s = ee),
        i.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          ));
    }),
      (this.setReferenceSpaceType = function (ee) {
        ((a = ee),
          i.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            ));
      }),
      (this.getReferenceSpace = function () {
        return u || o;
      }),
      (this.setReferenceSpace = function (ee) {
        u = ee;
      }),
      (this.getBaseLayer = function () {
        return p !== null ? p : g;
      }),
      (this.getBinding = function () {
        return d;
      }),
      (this.getFrame = function () {
        return y;
      }),
      (this.getSession = function () {
        return r;
      }),
      (this.setSession = async function (ee) {
        if (((r = ee), r !== null)) {
          if (
            ((_ = e.getRenderTarget()),
            r.addEventListener("select", J),
            r.addEventListener("selectstart", J),
            r.addEventListener("selectend", J),
            r.addEventListener("squeeze", J),
            r.addEventListener("squeezestart", J),
            r.addEventListener("squeezeend", J),
            r.addEventListener("end", V),
            r.addEventListener("inputsourceschange", j),
            A.xrCompatible !== !0 && (await t.makeXRCompatible()),
            r.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1)
          ) {
            const ne = {
              antialias: r.renderState.layers === void 0 ? A.antialias : !0,
              alpha: A.alpha,
              depth: A.depth,
              stencil: A.stencil,
              framebufferScaleFactor: s,
            };
            ((g = new XRWebGLLayer(r, t, ne)),
              r.updateRenderState({ baseLayer: g }),
              (m = new Hr(g.framebufferWidth, g.framebufferHeight, {
                format: Pi,
                type: Ys,
                encoding: e.outputEncoding,
                stencilBuffer: A.stencil,
              })));
          } else {
            let ne = null,
              Ee = null,
              Ae = null;
            A.depth &&
              ((Ae = A.stencil ? 35056 : 33190),
              (ne = A.stencil ? sl : Ho),
              (Ee = A.stencil ? Ya : Ro));
            const $ = { colorFormat: 32856, depthFormat: Ae, scaleFactor: s };
            ((d = new XRWebGLBinding(r, t)),
              (p = d.createProjectionLayer($)),
              r.updateRenderState({ layers: [p] }),
              (m = new Hr(p.textureWidth, p.textureHeight, {
                format: Pi,
                type: Ys,
                depthTexture: new qB(
                  p.textureWidth,
                  p.textureHeight,
                  Ee,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  ne
                ),
                stencilBuffer: A.stencil,
                encoding: e.outputEncoding,
                samples: A.antialias ? 4 : 0,
              })));
            const Je = e.properties.get(m);
            Je.__ignoreDepthValues = p.ignoreDepthValues;
          }
          ((m.isXRRenderTarget = !0),
            this.setFoveation(l),
            (u = null),
            (o = await r.requestReferenceSpace(a)),
            Q.setContext(r),
            Q.start(),
            (i.isPresenting = !0),
            i.dispatchEvent({ type: "sessionstart" }));
        }
      }));
    function j(ee) {
      for (let ne = 0; ne < ee.removed.length; ne++) {
        const Ee = ee.removed[ne],
          Ae = S.indexOf(Ee);
        Ae >= 0 && ((S[Ae] = null), x[Ae].disconnect(Ee));
      }
      for (let ne = 0; ne < ee.added.length; ne++) {
        const Ee = ee.added[ne];
        let Ae = S.indexOf(Ee);
        if (Ae === -1) {
          for (let Je = 0; Je < x.length; Je++)
            if (Je >= S.length) {
              (S.push(Ee), (Ae = Je));
              break;
            } else if (S[Je] === null) {
              ((S[Je] = Ee), (Ae = Je));
              break;
            }
          if (Ae === -1) break;
        }
        const $ = x[Ae];
        $ && $.connect(Ee);
      }
    }
    const X = new F(),
      oe = new F();
    function ae(ee, ne, Ee) {
      (X.setFromMatrixPosition(ne.matrixWorld),
        oe.setFromMatrixPosition(Ee.matrixWorld));
      const Ae = X.distanceTo(oe),
        $ = ne.projectionMatrix.elements,
        Je = Ee.projectionMatrix.elements,
        Xe = $[14] / ($[10] - 1),
        xe = $[14] / ($[10] + 1),
        Se = ($[9] + 1) / $[5],
        ge = ($[9] - 1) / $[5],
        se = ($[8] - 1) / $[0],
        _e = (Je[8] + 1) / Je[0],
        Ne = Xe * se,
        Le = Xe * _e,
        We = Ae / (-se + _e),
        Ke = We * -se;
      (ne.matrixWorld.decompose(ee.position, ee.quaternion, ee.scale),
        ee.translateX(Ke),
        ee.translateZ(We),
        ee.matrixWorld.compose(ee.position, ee.quaternion, ee.scale),
        ee.matrixWorldInverse.copy(ee.matrixWorld).invert());
      const je = Xe + We,
        nt = xe + We,
        At = Ne - Ke,
        O = Le + (Ae - Ke),
        D = ((Se * xe) / nt) * je,
        le = ((ge * xe) / nt) * je;
      (ee.projectionMatrix.makePerspective(At, O, D, le, je, nt),
        ee.projectionMatrixInverse.copy(ee.projectionMatrix).invert());
    }
    function I(ee, ne) {
      (ne === null
        ? ee.matrixWorld.copy(ee.matrix)
        : ee.matrixWorld.multiplyMatrices(ne.matrixWorld, ee.matrix),
        ee.matrixWorldInverse.copy(ee.matrixWorld).invert());
    }
    this.updateCamera = function (ee) {
      if (r === null) return;
      ((b.near = R.near = P.near = ee.near),
        (b.far = R.far = P.far = ee.far),
        (L !== b.near || U !== b.far) &&
          (r.updateRenderState({ depthNear: b.near, depthFar: b.far }),
          (L = b.near),
          (U = b.far)));
      const ne = ee.parent,
        Ee = b.cameras;
      I(b, ne);
      for (let Ae = 0; Ae < Ee.length; Ae++) I(Ee[Ae], ne);
      (Ee.length === 2
        ? ae(b, P, R)
        : b.projectionMatrix.copy(P.projectionMatrix),
        G(ee, b, ne));
    };
    function G(ee, ne, Ee) {
      (Ee === null
        ? ee.matrix.copy(ne.matrixWorld)
        : (ee.matrix.copy(Ee.matrixWorld),
          ee.matrix.invert(),
          ee.matrix.multiply(ne.matrixWorld)),
        ee.matrix.decompose(ee.position, ee.quaternion, ee.scale),
        ee.updateMatrixWorld(!0));
      const Ae = ee.children;
      for (let $ = 0, Je = Ae.length; $ < Je; $++) Ae[$].updateMatrixWorld(!0);
      (ee.projectionMatrix.copy(ne.projectionMatrix),
        ee.projectionMatrixInverse.copy(ne.projectionMatrixInverse),
        ee.isPerspectiveCamera &&
          ((ee.fov = Jc * 2 * Math.atan(1 / ee.projectionMatrix.elements[5])),
          (ee.zoom = 1)));
    }
    ((this.getCamera = function () {
      return b;
    }),
      (this.getFoveation = function () {
        if (!(p === null && g === null)) return l;
      }),
      (this.setFoveation = function (ee) {
        ((l = ee),
          p !== null && (p.fixedFoveation = ee),
          g !== null && g.fixedFoveation !== void 0 && (g.fixedFoveation = ee));
      }),
      (this.getPlanes = function () {
        return w;
      }));
    let z = null;
    function q(ee, ne) {
      if (((h = ne.getViewerPose(u || o)), (y = ne), h !== null)) {
        const Ee = h.views;
        g !== null &&
          (e.setRenderTargetFramebuffer(m, g.framebuffer),
          e.setRenderTarget(m));
        let Ae = !1;
        Ee.length !== b.cameras.length && ((b.cameras.length = 0), (Ae = !0));
        for (let $ = 0; $ < Ee.length; $++) {
          const Je = Ee[$];
          let Xe = null;
          if (g !== null) Xe = g.getViewport(Je);
          else {
            const Se = d.getViewSubImage(p, Je);
            ((Xe = Se.viewport),
              $ === 0 &&
                (e.setRenderTargetTextures(
                  m,
                  Se.colorTexture,
                  p.ignoreDepthValues ? void 0 : Se.depthStencilTexture
                ),
                e.setRenderTarget(m)));
          }
          let xe = B[$];
          (xe === void 0 &&
            ((xe = new Vt()),
            xe.layers.enable($),
            (xe.viewport = new kt()),
            (B[$] = xe)),
            xe.matrix.fromArray(Je.transform.matrix),
            xe.matrix.decompose(xe.position, xe.quaternion, xe.scale),
            xe.projectionMatrix.fromArray(Je.projectionMatrix),
            xe.projectionMatrixInverse.copy(xe.projectionMatrix).invert(),
            xe.viewport.set(Xe.x, Xe.y, Xe.width, Xe.height),
            $ === 0 &&
              (b.matrix.copy(xe.matrix),
              b.matrix.decompose(b.position, b.quaternion, b.scale)),
            Ae === !0 && b.cameras.push(xe));
        }
      }
      for (let Ee = 0; Ee < x.length; Ee++) {
        const Ae = S[Ee],
          $ = x[Ee];
        Ae !== null && $ !== void 0 && $.update(Ae, ne, u || o);
      }
      if ((z && z(ee, ne), ne.detectedPlanes)) {
        i.dispatchEvent({ type: "planesdetected", data: ne.detectedPlanes });
        let Ee = null;
        for (const Ae of w)
          ne.detectedPlanes.has(Ae) || (Ee === null && (Ee = []), Ee.push(Ae));
        if (Ee !== null)
          for (const Ae of Ee)
            (w.delete(Ae),
              C.delete(Ae),
              i.dispatchEvent({ type: "planeremoved", data: Ae }));
        for (const Ae of ne.detectedPlanes)
          if (!w.has(Ae))
            (w.add(Ae),
              C.set(Ae, ne.lastChangedTime),
              i.dispatchEvent({ type: "planeadded", data: Ae }));
          else {
            const $ = C.get(Ae);
            Ae.lastChangedTime > $ &&
              (C.set(Ae, Ae.lastChangedTime),
              i.dispatchEvent({ type: "planechanged", data: Ae }));
          }
      }
      y = null;
    }
    const Q = new jB();
    (Q.setAnimationLoop(q),
      (this.setAnimationLoop = function (ee) {
        z = ee;
      }),
      (this.dispose = function () {}));
  }
}
function bG(n, e) {
  function t(_, m) {
    (_.matrixAutoUpdate === !0 && _.updateMatrix(), m.value.copy(_.matrix));
  }
  function i(_, m) {
    (m.color.getRGB(_.fogColor.value, VB(n)),
      m.isFog
        ? ((_.fogNear.value = m.near), (_.fogFar.value = m.far))
        : m.isFogExp2 && (_.fogDensity.value = m.density));
  }
  function r(_, m, x, S, w) {
    m.isMeshBasicMaterial || m.isMeshLambertMaterial
      ? s(_, m)
      : m.isMeshToonMaterial
        ? (s(_, m), d(_, m))
        : m.isMeshPhongMaterial
          ? (s(_, m), h(_, m))
          : m.isMeshStandardMaterial
            ? (s(_, m), p(_, m), m.isMeshPhysicalMaterial && g(_, m, w))
            : m.isMeshMatcapMaterial
              ? (s(_, m), y(_, m))
              : m.isMeshDepthMaterial
                ? s(_, m)
                : m.isMeshDistanceMaterial
                  ? (s(_, m), A(_, m))
                  : m.isMeshNormalMaterial
                    ? s(_, m)
                    : m.isLineBasicMaterial
                      ? (o(_, m), m.isLineDashedMaterial && a(_, m))
                      : m.isPointsMaterial
                        ? l(_, m, x, S)
                        : m.isSpriteMaterial
                          ? u(_, m)
                          : m.isShadowMaterial
                            ? (_.color.value.copy(m.color),
                              (_.opacity.value = m.opacity))
                            : m.isShaderMaterial && (m.uniformsNeedUpdate = !1);
  }
  function s(_, m) {
    ((_.opacity.value = m.opacity),
      m.color && _.diffuse.value.copy(m.color),
      m.emissive &&
        _.emissive.value.copy(m.emissive).multiplyScalar(m.emissiveIntensity),
      m.map && ((_.map.value = m.map), t(m.map, _.mapTransform)),
      m.alphaMap &&
        ((_.alphaMap.value = m.alphaMap), t(m.alphaMap, _.alphaMapTransform)),
      m.bumpMap &&
        ((_.bumpMap.value = m.bumpMap),
        t(m.bumpMap, _.bumpMapTransform),
        (_.bumpScale.value = m.bumpScale),
        m.side === vi && (_.bumpScale.value *= -1)),
      m.normalMap &&
        ((_.normalMap.value = m.normalMap),
        t(m.normalMap, _.normalMapTransform),
        _.normalScale.value.copy(m.normalScale),
        m.side === vi && _.normalScale.value.negate()),
      m.displacementMap &&
        ((_.displacementMap.value = m.displacementMap),
        t(m.displacementMap, _.displacementMapTransform),
        (_.displacementScale.value = m.displacementScale),
        (_.displacementBias.value = m.displacementBias)),
      m.emissiveMap &&
        ((_.emissiveMap.value = m.emissiveMap),
        t(m.emissiveMap, _.emissiveMapTransform)),
      m.specularMap &&
        ((_.specularMap.value = m.specularMap),
        t(m.specularMap, _.specularMapTransform)),
      m.alphaTest > 0 && (_.alphaTest.value = m.alphaTest));
    const x = e.get(m).envMap;
    if (
      (x &&
        ((_.envMap.value = x),
        (_.flipEnvMap.value =
          x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1),
        (_.reflectivity.value = m.reflectivity),
        (_.ior.value = m.ior),
        (_.refractionRatio.value = m.refractionRatio)),
      m.lightMap)
    ) {
      _.lightMap.value = m.lightMap;
      const S = n.useLegacyLights === !0 ? Math.PI : 1;
      ((_.lightMapIntensity.value = m.lightMapIntensity * S),
        t(m.lightMap, _.lightMapTransform));
    }
    m.aoMap &&
      ((_.aoMap.value = m.aoMap),
      (_.aoMapIntensity.value = m.aoMapIntensity),
      t(m.aoMap, _.aoMapTransform));
  }
  function o(_, m) {
    (_.diffuse.value.copy(m.color),
      (_.opacity.value = m.opacity),
      m.map && ((_.map.value = m.map), t(m.map, _.mapTransform)));
  }
  function a(_, m) {
    ((_.dashSize.value = m.dashSize),
      (_.totalSize.value = m.dashSize + m.gapSize),
      (_.scale.value = m.scale));
  }
  function l(_, m, x, S) {
    (_.diffuse.value.copy(m.color),
      (_.opacity.value = m.opacity),
      (_.size.value = m.size * x),
      (_.scale.value = S * 0.5),
      m.map && ((_.map.value = m.map), t(m.map, _.uvTransform)),
      m.alphaMap && (_.alphaMap.value = m.alphaMap),
      m.alphaTest > 0 && (_.alphaTest.value = m.alphaTest));
  }
  function u(_, m) {
    (_.diffuse.value.copy(m.color),
      (_.opacity.value = m.opacity),
      (_.rotation.value = m.rotation),
      m.map && ((_.map.value = m.map), t(m.map, _.mapTransform)),
      m.alphaMap && (_.alphaMap.value = m.alphaMap),
      m.alphaTest > 0 && (_.alphaTest.value = m.alphaTest));
  }
  function h(_, m) {
    (_.specular.value.copy(m.specular),
      (_.shininess.value = Math.max(m.shininess, 1e-4)));
  }
  function d(_, m) {
    m.gradientMap && (_.gradientMap.value = m.gradientMap);
  }
  function p(_, m) {
    ((_.metalness.value = m.metalness),
      m.metalnessMap &&
        ((_.metalnessMap.value = m.metalnessMap),
        t(m.metalnessMap, _.metalnessMapTransform)),
      (_.roughness.value = m.roughness),
      m.roughnessMap &&
        ((_.roughnessMap.value = m.roughnessMap),
        t(m.roughnessMap, _.roughnessMapTransform)),
      e.get(m).envMap && (_.envMapIntensity.value = m.envMapIntensity));
  }
  function g(_, m, x) {
    ((_.ior.value = m.ior),
      m.sheen > 0 &&
        (_.sheenColor.value.copy(m.sheenColor).multiplyScalar(m.sheen),
        (_.sheenRoughness.value = m.sheenRoughness),
        m.sheenColorMap &&
          ((_.sheenColorMap.value = m.sheenColorMap),
          t(m.sheenColorMap, _.sheenColorMapTransform)),
        m.sheenRoughnessMap &&
          ((_.sheenRoughnessMap.value = m.sheenRoughnessMap),
          t(m.sheenRoughnessMap, _.sheenRoughnessMapTransform))),
      m.clearcoat > 0 &&
        ((_.clearcoat.value = m.clearcoat),
        (_.clearcoatRoughness.value = m.clearcoatRoughness),
        m.clearcoatMap &&
          ((_.clearcoatMap.value = m.clearcoatMap),
          t(m.clearcoatMap, _.clearcoatMapTransform)),
        m.clearcoatRoughnessMap &&
          ((_.clearcoatRoughnessMap.value = m.clearcoatRoughnessMap),
          t(m.clearcoatRoughnessMap, _.clearcoatRoughnessMapTransform)),
        m.clearcoatNormalMap &&
          ((_.clearcoatNormalMap.value = m.clearcoatNormalMap),
          t(m.clearcoatNormalMap, _.clearcoatNormalMapTransform),
          _.clearcoatNormalScale.value.copy(m.clearcoatNormalScale),
          m.side === vi && _.clearcoatNormalScale.value.negate())),
      m.iridescence > 0 &&
        ((_.iridescence.value = m.iridescence),
        (_.iridescenceIOR.value = m.iridescenceIOR),
        (_.iridescenceThicknessMinimum.value = m.iridescenceThicknessRange[0]),
        (_.iridescenceThicknessMaximum.value = m.iridescenceThicknessRange[1]),
        m.iridescenceMap &&
          ((_.iridescenceMap.value = m.iridescenceMap),
          t(m.iridescenceMap, _.iridescenceMapTransform)),
        m.iridescenceThicknessMap &&
          ((_.iridescenceThicknessMap.value = m.iridescenceThicknessMap),
          t(m.iridescenceThicknessMap, _.iridescenceThicknessMapTransform))),
      m.transmission > 0 &&
        ((_.transmission.value = m.transmission),
        (_.transmissionSamplerMap.value = x.texture),
        _.transmissionSamplerSize.value.set(x.width, x.height),
        m.transmissionMap &&
          ((_.transmissionMap.value = m.transmissionMap),
          t(m.transmissionMap, _.transmissionMapTransform)),
        (_.thickness.value = m.thickness),
        m.thicknessMap &&
          ((_.thicknessMap.value = m.thicknessMap),
          t(m.thicknessMap, _.thicknessMapTransform)),
        (_.attenuationDistance.value = m.attenuationDistance),
        _.attenuationColor.value.copy(m.attenuationColor)),
      (_.specularIntensity.value = m.specularIntensity),
      _.specularColor.value.copy(m.specularColor),
      m.specularColorMap &&
        ((_.specularColorMap.value = m.specularColorMap),
        t(m.specularColorMap, _.specularColorMapTransform)),
      m.specularIntensityMap &&
        ((_.specularIntensityMap.value = m.specularIntensityMap),
        t(m.specularIntensityMap, _.specularIntensityMapTransform)));
  }
  function y(_, m) {
    m.matcap && (_.matcap.value = m.matcap);
  }
  function A(_, m) {
    const x = e.get(m).light;
    (_.referencePosition.value.setFromMatrixPosition(x.matrixWorld),
      (_.nearDistance.value = x.shadow.camera.near),
      (_.farDistance.value = x.shadow.camera.far));
  }
  return { refreshFogUniforms: i, refreshMaterialUniforms: r };
}
function PG(n, e, t, i) {
  let r = {},
    s = {},
    o = [];
  const a = t.isWebGL2 ? n.getParameter(35375) : 0;
  function l(x, S) {
    const w = S.program;
    i.uniformBlockBinding(x, w);
  }
  function u(x, S) {
    let w = r[x.id];
    w === void 0 &&
      (y(x), (w = h(x)), (r[x.id] = w), x.addEventListener("dispose", _));
    const C = S.program;
    i.updateUBOMapping(x, C);
    const P = e.render.frame;
    s[x.id] !== P && (p(x), (s[x.id] = P));
  }
  function h(x) {
    const S = d();
    x.__bindingPointIndex = S;
    const w = n.createBuffer(),
      C = x.__size,
      P = x.usage;
    return (
      n.bindBuffer(35345, w),
      n.bufferData(35345, C, P),
      n.bindBuffer(35345, null),
      n.bindBufferBase(35345, S, w),
      w
    );
  }
  function d() {
    for (let x = 0; x < a; x++) if (o.indexOf(x) === -1) return (o.push(x), x);
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function p(x) {
    const S = r[x.id],
      w = x.uniforms,
      C = x.__cache;
    n.bindBuffer(35345, S);
    for (let P = 0, R = w.length; P < R; P++) {
      const B = w[P];
      if (g(B, P, C) === !0) {
        const b = B.__offset,
          L = Array.isArray(B.value) ? B.value : [B.value];
        let U = 0;
        for (let J = 0; J < L.length; J++) {
          const V = L[J],
            j = A(V);
          typeof V == "number"
            ? ((B.__data[0] = V), n.bufferSubData(35345, b + U, B.__data))
            : V.isMatrix3
              ? ((B.__data[0] = V.elements[0]),
                (B.__data[1] = V.elements[1]),
                (B.__data[2] = V.elements[2]),
                (B.__data[3] = V.elements[0]),
                (B.__data[4] = V.elements[3]),
                (B.__data[5] = V.elements[4]),
                (B.__data[6] = V.elements[5]),
                (B.__data[7] = V.elements[0]),
                (B.__data[8] = V.elements[6]),
                (B.__data[9] = V.elements[7]),
                (B.__data[10] = V.elements[8]),
                (B.__data[11] = V.elements[0]))
              : (V.toArray(B.__data, U),
                (U += j.storage / Float32Array.BYTES_PER_ELEMENT));
        }
        n.bufferSubData(35345, b, B.__data);
      }
    }
    n.bindBuffer(35345, null);
  }
  function g(x, S, w) {
    const C = x.value;
    if (w[S] === void 0) {
      if (typeof C == "number") w[S] = C;
      else {
        const P = Array.isArray(C) ? C : [C],
          R = [];
        for (let B = 0; B < P.length; B++) R.push(P[B].clone());
        w[S] = R;
      }
      return !0;
    } else if (typeof C == "number") {
      if (w[S] !== C) return ((w[S] = C), !0);
    } else {
      const P = Array.isArray(w[S]) ? w[S] : [w[S]],
        R = Array.isArray(C) ? C : [C];
      for (let B = 0; B < P.length; B++) {
        const b = P[B];
        if (b.equals(R[B]) === !1) return (b.copy(R[B]), !0);
      }
    }
    return !1;
  }
  function y(x) {
    const S = x.uniforms;
    let w = 0;
    const C = 16;
    let P = 0;
    for (let R = 0, B = S.length; R < B; R++) {
      const b = S[R],
        L = { boundary: 0, storage: 0 },
        U = Array.isArray(b.value) ? b.value : [b.value];
      for (let J = 0, V = U.length; J < V; J++) {
        const j = U[J],
          X = A(j);
        ((L.boundary += X.boundary), (L.storage += X.storage));
      }
      if (
        ((b.__data = new Float32Array(
          L.storage / Float32Array.BYTES_PER_ELEMENT
        )),
        (b.__offset = w),
        R > 0)
      ) {
        P = w % C;
        const J = C - P;
        P !== 0 && J - L.boundary < 0 && ((w += C - P), (b.__offset = w));
      }
      w += L.storage;
    }
    return (
      (P = w % C),
      P > 0 && (w += C - P),
      (x.__size = w),
      (x.__cache = {}),
      this
    );
  }
  function A(x) {
    const S = { boundary: 0, storage: 0 };
    return (
      typeof x == "number"
        ? ((S.boundary = 4), (S.storage = 4))
        : x.isVector2
          ? ((S.boundary = 8), (S.storage = 8))
          : x.isVector3 || x.isColor
            ? ((S.boundary = 16), (S.storage = 12))
            : x.isVector4
              ? ((S.boundary = 16), (S.storage = 16))
              : x.isMatrix3
                ? ((S.boundary = 48), (S.storage = 48))
                : x.isMatrix4
                  ? ((S.boundary = 64), (S.storage = 64))
                  : x.isTexture
                    ? console.warn(
                        "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
                      )
                    : console.warn(
                        "THREE.WebGLRenderer: Unsupported uniform value type.",
                        x
                      ),
      S
    );
  }
  function _(x) {
    const S = x.target;
    S.removeEventListener("dispose", _);
    const w = o.indexOf(S.__bindingPointIndex);
    (o.splice(w, 1), n.deleteBuffer(r[S.id]), delete r[S.id], delete s[S.id]);
  }
  function m() {
    for (const x in r) n.deleteBuffer(r[x]);
    ((o = []), (r = {}), (s = {}));
  }
  return { bind: l, update: u, dispose: m };
}
function BG() {
  const n = ih("canvas");
  return ((n.style.display = "block"), n);
}
class lA {
  constructor(e = {}) {
    const {
      canvas: t = BG(),
      context: i = null,
      depth: r = !0,
      stencil: s = !0,
      alpha: o = !1,
      antialias: a = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: u = !1,
      powerPreference: h = "default",
      failIfMajorPerformanceCaveat: d = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let p;
    i !== null ? (p = i.getContextAttributes().alpha) : (p = o);
    let g = null,
      y = null;
    const A = [],
      _ = [];
    ((this.domElement = t),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this.outputEncoding = Qs),
      (this.useLegacyLights = !0),
      (this.toneMapping = Ur),
      (this.toneMappingExposure = 1));
    const m = this;
    let x = !1,
      S = 0,
      w = 0,
      C = null,
      P = -1,
      R = null;
    const B = new kt(),
      b = new kt();
    let L = null,
      U = t.width,
      J = t.height,
      V = 1,
      j = null,
      X = null;
    const oe = new kt(0, 0, U, J),
      ae = new kt(0, 0, U, J);
    let I = !1;
    const G = new Og();
    let z = !1,
      q = !1,
      Q = null;
    const ee = new ot(),
      ne = new F(),
      Ee = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    function Ae() {
      return C === null ? V : 1;
    }
    let $ = i;
    function Je(N, re) {
      for (let me = 0; me < N.length; me++) {
        const te = N[me],
          ye = t.getContext(te, re);
        if (ye !== null) return ye;
      }
      return null;
    }
    try {
      const N = {
        alpha: !0,
        depth: r,
        stencil: s,
        antialias: a,
        premultipliedAlpha: l,
        preserveDrawingBuffer: u,
        powerPreference: h,
        failIfMajorPerformanceCaveat: d,
      };
      if (
        ("setAttribute" in t &&
          t.setAttribute("data-engine", `three.js r${Lg}`),
        t.addEventListener("webglcontextlost", Pe, !1),
        t.addEventListener("webglcontextrestored", qe, !1),
        t.addEventListener("webglcontextcreationerror", ht, !1),
        $ === null)
      ) {
        const re = ["webgl2", "webgl", "experimental-webgl"];
        if (
          (m.isWebGL1Renderer === !0 && re.shift(), ($ = Je(re, N)), $ === null)
        )
          throw Je(re)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
      $.getShaderPrecisionFormat === void 0 &&
        ($.getShaderPrecisionFormat = function () {
          return { rangeMin: 1, rangeMax: 1, precision: 1 };
        });
    } catch (N) {
      throw (console.error("THREE.WebGLRenderer: " + N.message), N);
    }
    let Xe,
      xe,
      Se,
      ge,
      se,
      _e,
      Ne,
      Le,
      We,
      Ke,
      je,
      nt,
      At,
      O,
      D,
      le,
      Ce,
      Te,
      Re,
      et,
      Ue,
      pe,
      He,
      W;
    function de() {
      ((Xe = new Jz($)),
        (xe = new zz($, Xe, e)),
        Xe.init(xe),
        (pe = new QB($, Xe, xe)),
        (Se = new wG($, Xe, xe)),
        (ge = new Yz()),
        (se = new hG()),
        (_e = new EG($, Xe, Se, se, xe, pe, ge)),
        (Ne = new Hz(m)),
        (Le = new jz(m)),
        (We = new aO($, xe)),
        (He = new Oz($, Xe, We, xe)),
        (Ke = new Xz($, We, ge, He)),
        (je = new $z($, Ke, We, ge)),
        (Re = new qz($, xe, _e)),
        (le = new Gz(se)),
        (nt = new fG(m, Ne, Le, Xe, xe, He, le)),
        (At = new bG(m, se)),
        (O = new pG()),
        (D = new _G(Xe, xe)),
        (Te = new kz(m, Ne, Le, Se, je, p, l)),
        (Ce = new SG(m, je, xe)),
        (W = new PG($, ge, xe, Se)),
        (et = new Uz($, Xe, ge, xe)),
        (Ue = new Kz($, Xe, ge, xe)),
        (ge.programs = nt.programs),
        (m.capabilities = xe),
        (m.extensions = Xe),
        (m.properties = se),
        (m.renderLists = O),
        (m.shadowMap = Ce),
        (m.state = Se),
        (m.info = ge));
    }
    de();
    const Me = new TG(m, $);
    ((this.xr = Me),
      (this.getContext = function () {
        return $;
      }),
      (this.getContextAttributes = function () {
        return $.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const N = Xe.get("WEBGL_lose_context");
        N && N.loseContext();
      }),
      (this.forceContextRestore = function () {
        const N = Xe.get("WEBGL_lose_context");
        N && N.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return V;
      }),
      (this.setPixelRatio = function (N) {
        N !== void 0 && ((V = N), this.setSize(U, J, !1));
      }),
      (this.getSize = function (N) {
        return N.set(U, J);
      }),
      (this.setSize = function (N, re, me = !0) {
        if (Me.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          );
          return;
        }
        ((U = N),
          (J = re),
          (t.width = Math.floor(N * V)),
          (t.height = Math.floor(re * V)),
          me === !0 &&
            ((t.style.width = N + "px"), (t.style.height = re + "px")),
          this.setViewport(0, 0, N, re));
      }),
      (this.getDrawingBufferSize = function (N) {
        return N.set(U * V, J * V).floor();
      }),
      (this.setDrawingBufferSize = function (N, re, me) {
        ((U = N),
          (J = re),
          (V = me),
          (t.width = Math.floor(N * me)),
          (t.height = Math.floor(re * me)),
          this.setViewport(0, 0, N, re));
      }),
      (this.getCurrentViewport = function (N) {
        return N.copy(B);
      }),
      (this.getViewport = function (N) {
        return N.copy(oe);
      }),
      (this.setViewport = function (N, re, me, te) {
        (N.isVector4 ? oe.set(N.x, N.y, N.z, N.w) : oe.set(N, re, me, te),
          Se.viewport(B.copy(oe).multiplyScalar(V).floor()));
      }),
      (this.getScissor = function (N) {
        return N.copy(ae);
      }),
      (this.setScissor = function (N, re, me, te) {
        (N.isVector4 ? ae.set(N.x, N.y, N.z, N.w) : ae.set(N, re, me, te),
          Se.scissor(b.copy(ae).multiplyScalar(V).floor()));
      }),
      (this.getScissorTest = function () {
        return I;
      }),
      (this.setScissorTest = function (N) {
        Se.setScissorTest((I = N));
      }),
      (this.setOpaqueSort = function (N) {
        j = N;
      }),
      (this.setTransparentSort = function (N) {
        X = N;
      }),
      (this.getClearColor = function (N) {
        return N.copy(Te.getClearColor());
      }),
      (this.setClearColor = function () {
        Te.setClearColor.apply(Te, arguments);
      }),
      (this.getClearAlpha = function () {
        return Te.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        Te.setClearAlpha.apply(Te, arguments);
      }),
      (this.clear = function (N = !0, re = !0, me = !0) {
        let te = 0;
        (N && (te |= 16384),
          re && (te |= 256),
          me && (te |= 1024),
          $.clear(te));
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        (t.removeEventListener("webglcontextlost", Pe, !1),
          t.removeEventListener("webglcontextrestored", qe, !1),
          t.removeEventListener("webglcontextcreationerror", ht, !1),
          O.dispose(),
          D.dispose(),
          se.dispose(),
          Ne.dispose(),
          Le.dispose(),
          je.dispose(),
          He.dispose(),
          W.dispose(),
          nt.dispose(),
          Me.dispose(),
          Me.removeEventListener("sessionstart", Qe),
          Me.removeEventListener("sessionend", zt),
          Q && (Q.dispose(), (Q = null)),
          Wt.stop());
      }));
    function Pe(N) {
      (N.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (x = !0));
    }
    function qe() {
      (console.log("THREE.WebGLRenderer: Context Restored."), (x = !1));
      const N = ge.autoReset,
        re = Ce.enabled,
        me = Ce.autoUpdate,
        te = Ce.needsUpdate,
        ye = Ce.type;
      (de(),
        (ge.autoReset = N),
        (Ce.enabled = re),
        (Ce.autoUpdate = me),
        (Ce.needsUpdate = te),
        (Ce.type = ye));
    }
    function ht(N) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        N.statusMessage
      );
    }
    function Ut(N) {
      const re = N.target;
      (re.removeEventListener("dispose", Ut), K(re));
    }
    function K(N) {
      (fe(N), se.remove(N));
    }
    function fe(N) {
      const re = se.get(N).programs;
      re !== void 0 &&
        (re.forEach(function (me) {
          nt.releaseProgram(me);
        }),
        N.isShaderMaterial && nt.releaseShaderCache(N));
    }
    ((this.renderBufferDirect = function (N, re, me, te, ye, $e) {
      re === null && (re = Ee);
      const st = ye.isMesh && ye.matrixWorld.determinant() < 0,
        at = Yh(N, re, me, te, ye);
      Se.setMaterial(te, st);
      let dt = me.index,
        yt = 1;
      te.wireframe === !0 && ((dt = Ke.getWireframeAttribute(me)), (yt = 2));
      const xt = me.drawRange,
        Mt = me.attributes.position;
      let Ft = xt.start * yt,
        Gn = (xt.start + xt.count) * yt;
      ($e !== null &&
        ((Ft = Math.max(Ft, $e.start * yt)),
        (Gn = Math.min(Gn, ($e.start + $e.count) * yt))),
        dt !== null
          ? ((Ft = Math.max(Ft, 0)), (Gn = Math.min(Gn, dt.count)))
          : Mt != null &&
            ((Ft = Math.max(Ft, 0)), (Gn = Math.min(Gn, Mt.count))));
      const Fi = Gn - Ft;
      if (Fi < 0 || Fi === 1 / 0) return;
      He.setup(ye, te, at, me, dt);
      let Mr,
        jt = et;
      if (
        (dt !== null && ((Mr = We.get(dt)), (jt = Ue), jt.setIndex(Mr)),
        ye.isMesh)
      )
        te.wireframe === !0
          ? (Se.setLineWidth(te.wireframeLinewidth * Ae()), jt.setMode(1))
          : jt.setMode(4);
      else if (ye.isLine) {
        let St = te.linewidth;
        (St === void 0 && (St = 1),
          Se.setLineWidth(St * Ae()),
          ye.isLineSegments
            ? jt.setMode(1)
            : ye.isLineLoop
              ? jt.setMode(2)
              : jt.setMode(3));
      } else ye.isPoints ? jt.setMode(0) : ye.isSprite && jt.setMode(4);
      if (ye.isInstancedMesh) jt.renderInstances(Ft, Fi, ye.count);
      else if (me.isInstancedBufferGeometry) {
        const St =
            me._maxInstanceCount !== void 0 ? me._maxInstanceCount : 1 / 0,
          oa = Math.min(me.instanceCount, St);
        jt.renderInstances(Ft, Fi, oa);
      } else jt.render(Ft, Fi);
    }),
      (this.compile = function (N, re) {
        function me(te, ye, $e) {
          te.transparent === !0 && te.side === mr && te.forceSinglePass === !1
            ? ((te.side = vi),
              (te.needsUpdate = !0),
              _l(te, ye, $e),
              (te.side = fs),
              (te.needsUpdate = !0),
              _l(te, ye, $e),
              (te.side = mr))
            : _l(te, ye, $e);
        }
        ((y = D.get(N)),
          y.init(),
          _.push(y),
          N.traverseVisible(function (te) {
            te.isLight &&
              te.layers.test(re.layers) &&
              (y.pushLight(te), te.castShadow && y.pushShadow(te));
          }),
          y.setupLights(m.useLegacyLights),
          N.traverse(function (te) {
            const ye = te.material;
            if (ye)
              if (Array.isArray(ye))
                for (let $e = 0; $e < ye.length; $e++) {
                  const st = ye[$e];
                  me(st, N, te);
                }
              else me(ye, N, te);
          }),
          _.pop(),
          (y = null));
      }));
    let we = null;
    function Oe(N) {
      we && we(N);
    }
    function Qe() {
      Wt.stop();
    }
    function zt() {
      Wt.start();
    }
    const Wt = new jB();
    (Wt.setAnimationLoop(Oe),
      typeof self < "u" && Wt.setContext(self),
      (this.setAnimationLoop = function (N) {
        ((we = N), Me.setAnimationLoop(N), N === null ? Wt.stop() : Wt.start());
      }),
      Me.addEventListener("sessionstart", Qe),
      Me.addEventListener("sessionend", zt),
      (this.render = function (N, re) {
        if (re !== void 0 && re.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
          return;
        }
        if (x === !0) return;
        (N.matrixWorldAutoUpdate === !0 && N.updateMatrixWorld(),
          re.parent === null &&
            re.matrixWorldAutoUpdate === !0 &&
            re.updateMatrixWorld(),
          Me.enabled === !0 &&
            Me.isPresenting === !0 &&
            (Me.cameraAutoUpdate === !0 && Me.updateCamera(re),
            (re = Me.getCamera())),
          N.isScene === !0 && N.onBeforeRender(m, N, re, C),
          (y = D.get(N, _.length)),
          y.init(),
          _.push(y),
          ee.multiplyMatrices(re.projectionMatrix, re.matrixWorldInverse),
          G.setFromProjectionMatrix(ee),
          (q = this.localClippingEnabled),
          (z = le.init(this.clippingPlanes, q)),
          (g = O.get(N, A.length)),
          g.init(),
          A.push(g),
          In(N, re, 0, m.sortObjects),
          g.finish(),
          m.sortObjects === !0 && g.sort(j, X),
          z === !0 && le.beginShadows());
        const me = y.state.shadowsArray;
        if (
          (Ce.render(me, N, re),
          z === !0 && le.endShadows(),
          this.info.autoReset === !0 && this.info.reset(),
          Te.render(g, N),
          y.setupLights(m.useLegacyLights),
          re.isArrayCamera)
        ) {
          const te = re.cameras;
          for (let ye = 0, $e = te.length; ye < $e; ye++) {
            const st = te[ye];
            Ar(g, N, st, st.viewport);
          }
        } else Ar(g, N, re);
        (C !== null &&
          (_e.updateMultisampleRenderTarget(C), _e.updateRenderTargetMipmap(C)),
          N.isScene === !0 && N.onAfterRender(m, N, re),
          He.resetDefaultState(),
          (P = -1),
          (R = null),
          _.pop(),
          _.length > 0 ? (y = _[_.length - 1]) : (y = null),
          A.pop(),
          A.length > 0 ? (g = A[A.length - 1]) : (g = null));
      }));
    function In(N, re, me, te) {
      if (N.visible === !1) return;
      if (N.layers.test(re.layers)) {
        if (N.isGroup) me = N.renderOrder;
        else if (N.isLOD) N.autoUpdate === !0 && N.update(re);
        else if (N.isLight) (y.pushLight(N), N.castShadow && y.pushShadow(N));
        else if (N.isSprite) {
          if (!N.frustumCulled || G.intersectsSprite(N)) {
            te && ne.setFromMatrixPosition(N.matrixWorld).applyMatrix4(ee);
            const st = je.update(N),
              at = N.material;
            at.visible && g.push(N, st, at, me, ne.z, null);
          }
        } else if (
          (N.isMesh || N.isLine || N.isPoints) &&
          (N.isSkinnedMesh &&
            N.skeleton.frame !== ge.render.frame &&
            (N.skeleton.update(), (N.skeleton.frame = ge.render.frame)),
          !N.frustumCulled || G.intersectsObject(N))
        ) {
          te && ne.setFromMatrixPosition(N.matrixWorld).applyMatrix4(ee);
          const st = je.update(N),
            at = N.material;
          if (Array.isArray(at)) {
            const dt = st.groups;
            for (let yt = 0, xt = dt.length; yt < xt; yt++) {
              const Mt = dt[yt],
                Ft = at[Mt.materialIndex];
              Ft && Ft.visible && g.push(N, st, Ft, me, ne.z, Mt);
            }
          } else at.visible && g.push(N, st, at, me, ne.z, null);
        }
      }
      const $e = N.children;
      for (let st = 0, at = $e.length; st < at; st++) In($e[st], re, me, te);
    }
    function Ar(N, re, me, te) {
      const ye = N.opaque,
        $e = N.transmissive,
        st = N.transparent;
      (y.setupLightsView(me),
        z === !0 && le.setGlobalState(m.clippingPlanes, me),
        $e.length > 0 && Qt(ye, $e, re, me),
        te && Se.viewport(B.copy(te)),
        ye.length > 0 && ci(ye, re, me),
        $e.length > 0 && ci($e, re, me),
        st.length > 0 && ci(st, re, me),
        Se.buffers.depth.setTest(!0),
        Se.buffers.depth.setMask(!0),
        Se.buffers.color.setMask(!0),
        Se.setPolygonOffset(!1));
    }
    function Qt(N, re, me, te) {
      if (Q === null) {
        const at = xe.isWebGL2;
        Q = new Hr(1024, 1024, {
          generateMipmaps: !0,
          type: Xe.has("EXT_color_buffer_half_float") ? Vc : Ys,
          minFilter: hs,
          samples: at && a === !0 ? 4 : 0,
        });
      }
      const ye = m.getRenderTarget();
      (m.setRenderTarget(Q), m.clear());
      const $e = m.toneMapping;
      ((m.toneMapping = Ur),
        ci(N, me, te),
        _e.updateMultisampleRenderTarget(Q),
        _e.updateRenderTargetMipmap(Q));
      let st = !1;
      for (let at = 0, dt = re.length; at < dt; at++) {
        const yt = re[at],
          xt = yt.object,
          Mt = yt.geometry,
          Ft = yt.material,
          Gn = yt.group;
        if (Ft.side === mr && xt.layers.test(te.layers)) {
          const Fi = Ft.side;
          ((Ft.side = vi),
            (Ft.needsUpdate = !0),
            er(xt, me, te, Mt, Ft, Gn),
            (Ft.side = Fi),
            (Ft.needsUpdate = !0),
            (st = !0));
        }
      }
      (st === !0 &&
        (_e.updateMultisampleRenderTarget(Q), _e.updateRenderTargetMipmap(Q)),
        m.setRenderTarget(ye),
        (m.toneMapping = $e));
    }
    function ci(N, re, me) {
      const te = re.isScene === !0 ? re.overrideMaterial : null;
      for (let ye = 0, $e = N.length; ye < $e; ye++) {
        const st = N[ye],
          at = st.object,
          dt = st.geometry,
          yt = te === null ? st.material : te,
          xt = st.group;
        at.layers.test(me.layers) && er(at, re, me, dt, yt, xt);
      }
    }
    function er(N, re, me, te, ye, $e) {
      (N.onBeforeRender(m, re, me, te, ye, $e),
        N.modelViewMatrix.multiplyMatrices(
          me.matrixWorldInverse,
          N.matrixWorld
        ),
        N.normalMatrix.getNormalMatrix(N.modelViewMatrix),
        ye.onBeforeRender(m, re, me, te, N, $e),
        ye.transparent === !0 && ye.side === mr && ye.forceSinglePass === !1
          ? ((ye.side = vi),
            (ye.needsUpdate = !0),
            m.renderBufferDirect(me, re, te, ye, N, $e),
            (ye.side = fs),
            (ye.needsUpdate = !0),
            m.renderBufferDirect(me, re, te, ye, N, $e),
            (ye.side = mr))
          : m.renderBufferDirect(me, re, te, ye, N, $e),
        N.onAfterRender(m, re, me, te, ye, $e));
    }
    function _l(N, re, me) {
      re.isScene !== !0 && (re = Ee);
      const te = se.get(N),
        ye = y.state.lights,
        $e = y.state.shadowsArray,
        st = ye.state.version,
        at = nt.getParameters(N, ye.state, $e, re, me),
        dt = nt.getProgramCacheKey(at);
      let yt = te.programs;
      ((te.environment = N.isMeshStandardMaterial ? re.environment : null),
        (te.fog = re.fog),
        (te.envMap = (N.isMeshStandardMaterial ? Le : Ne).get(
          N.envMap || te.environment
        )),
        yt === void 0 &&
          (N.addEventListener("dispose", Ut),
          (yt = new Map()),
          (te.programs = yt)));
      let xt = yt.get(dt);
      if (xt !== void 0) {
        if (te.currentProgram === xt && te.lightsStateVersion === st)
          return (Kh(N, at), xt);
      } else
        ((at.uniforms = nt.getUniforms(N)),
          N.onBuild(me, at, m),
          N.onBeforeCompile(at, m),
          (xt = nt.acquireProgram(at, dt)),
          yt.set(dt, xt),
          (te.uniforms = at.uniforms));
      const Mt = te.uniforms;
      (((!N.isShaderMaterial && !N.isRawShaderMaterial) || N.clipping === !0) &&
        (Mt.clippingPlanes = le.uniform),
        Kh(N, at),
        (te.needsLights = s0(N)),
        (te.lightsStateVersion = st),
        te.needsLights &&
          ((Mt.ambientLightColor.value = ye.state.ambient),
          (Mt.lightProbe.value = ye.state.probe),
          (Mt.directionalLights.value = ye.state.directional),
          (Mt.directionalLightShadows.value = ye.state.directionalShadow),
          (Mt.spotLights.value = ye.state.spot),
          (Mt.spotLightShadows.value = ye.state.spotShadow),
          (Mt.rectAreaLights.value = ye.state.rectArea),
          (Mt.ltc_1.value = ye.state.rectAreaLTC1),
          (Mt.ltc_2.value = ye.state.rectAreaLTC2),
          (Mt.pointLights.value = ye.state.point),
          (Mt.pointLightShadows.value = ye.state.pointShadow),
          (Mt.hemisphereLights.value = ye.state.hemi),
          (Mt.directionalShadowMap.value = ye.state.directionalShadowMap),
          (Mt.directionalShadowMatrix.value = ye.state.directionalShadowMatrix),
          (Mt.spotShadowMap.value = ye.state.spotShadowMap),
          (Mt.spotLightMatrix.value = ye.state.spotLightMatrix),
          (Mt.spotLightMap.value = ye.state.spotLightMap),
          (Mt.pointShadowMap.value = ye.state.pointShadowMap),
          (Mt.pointShadowMatrix.value = ye.state.pointShadowMatrix)));
      const Ft = xt.getUniforms(),
        Gn = Mm.seqWithValue(Ft.seq, Mt);
      return ((te.currentProgram = xt), (te.uniformsList = Gn), xt);
    }
    function Kh(N, re) {
      const me = se.get(N);
      ((me.outputEncoding = re.outputEncoding),
        (me.instancing = re.instancing),
        (me.skinning = re.skinning),
        (me.morphTargets = re.morphTargets),
        (me.morphNormals = re.morphNormals),
        (me.morphColors = re.morphColors),
        (me.morphTargetsCount = re.morphTargetsCount),
        (me.numClippingPlanes = re.numClippingPlanes),
        (me.numIntersection = re.numClipIntersection),
        (me.vertexAlphas = re.vertexAlphas),
        (me.vertexTangents = re.vertexTangents),
        (me.toneMapping = re.toneMapping));
    }
    function Yh(N, re, me, te, ye) {
      (re.isScene !== !0 && (re = Ee), _e.resetTextureUnits());
      const $e = re.fog,
        st = te.isMeshStandardMaterial ? re.environment : null,
        at =
          C === null
            ? m.outputEncoding
            : C.isXRRenderTarget === !0
              ? C.texture.encoding
              : Qs,
        dt = (te.isMeshStandardMaterial ? Le : Ne).get(te.envMap || st),
        yt =
          te.vertexColors === !0 &&
          !!me.attributes.color &&
          me.attributes.color.itemSize === 4,
        xt = !!te.normalMap && !!me.attributes.tangent,
        Mt = !!me.morphAttributes.position,
        Ft = !!me.morphAttributes.normal,
        Gn = !!me.morphAttributes.color,
        Fi = te.toneMapped ? m.toneMapping : Ur,
        Mr =
          me.morphAttributes.position ||
          me.morphAttributes.normal ||
          me.morphAttributes.color,
        jt = Mr !== void 0 ? Mr.length : 0,
        St = se.get(te),
        oa = y.state.lights;
      if (z === !0 && (q === !0 || N !== R)) {
        const Gt = N === R && te.id === P;
        le.setState(te, N, Gt);
      }
      let yn = !1;
      te.version === St.__version
        ? ((St.needsLights && St.lightsStateVersion !== oa.state.version) ||
            St.outputEncoding !== at ||
            (ye.isInstancedMesh && St.instancing === !1) ||
            (!ye.isInstancedMesh && St.instancing === !0) ||
            (ye.isSkinnedMesh && St.skinning === !1) ||
            (!ye.isSkinnedMesh && St.skinning === !0) ||
            St.envMap !== dt ||
            (te.fog === !0 && St.fog !== $e) ||
            (St.numClippingPlanes !== void 0 &&
              (St.numClippingPlanes !== le.numPlanes ||
                St.numIntersection !== le.numIntersection)) ||
            St.vertexAlphas !== yt ||
            St.vertexTangents !== xt ||
            St.morphTargets !== Mt ||
            St.morphNormals !== Ft ||
            St.morphColors !== Gn ||
            St.toneMapping !== Fi ||
            (xe.isWebGL2 === !0 && St.morphTargetsCount !== jt)) &&
          (yn = !0)
        : ((yn = !0), (St.__version = te.version));
      let Sr = St.currentProgram;
      yn === !0 && (Sr = _l(te, re, ye));
      let ms = !1,
        Ai = !1,
        Nt = !1;
      const pt = Sr.getUniforms(),
        Qn = St.uniforms;
      if (
        (Se.useProgram(Sr.program) && ((ms = !0), (Ai = !0), (Nt = !0)),
        te.id !== P && ((P = te.id), (Ai = !0)),
        ms || R !== N)
      ) {
        if (
          (pt.setValue($, "projectionMatrix", N.projectionMatrix),
          xe.logarithmicDepthBuffer &&
            pt.setValue(
              $,
              "logDepthBufFC",
              2 / (Math.log(N.far + 1) / Math.LN2)
            ),
          R !== N && ((R = N), (Ai = !0), (Nt = !0)),
          te.isShaderMaterial ||
            te.isMeshPhongMaterial ||
            te.isMeshToonMaterial ||
            te.isMeshStandardMaterial ||
            te.envMap)
        ) {
          const Gt = pt.map.cameraPosition;
          Gt !== void 0 &&
            Gt.setValue($, ne.setFromMatrixPosition(N.matrixWorld));
        }
        ((te.isMeshPhongMaterial ||
          te.isMeshToonMaterial ||
          te.isMeshLambertMaterial ||
          te.isMeshBasicMaterial ||
          te.isMeshStandardMaterial ||
          te.isShaderMaterial) &&
          pt.setValue($, "isOrthographic", N.isOrthographicCamera === !0),
          (te.isMeshPhongMaterial ||
            te.isMeshToonMaterial ||
            te.isMeshLambertMaterial ||
            te.isMeshBasicMaterial ||
            te.isMeshStandardMaterial ||
            te.isShaderMaterial ||
            te.isShadowMaterial ||
            ye.isSkinnedMesh) &&
            pt.setValue($, "viewMatrix", N.matrixWorldInverse));
      }
      if (ye.isSkinnedMesh) {
        (pt.setOptional($, ye, "bindMatrix"),
          pt.setOptional($, ye, "bindMatrixInverse"));
        const Gt = ye.skeleton;
        Gt &&
          (xe.floatVertexTextures
            ? (Gt.boneTexture === null && Gt.computeBoneTexture(),
              pt.setValue($, "boneTexture", Gt.boneTexture, _e),
              pt.setValue($, "boneTextureSize", Gt.boneTextureSize))
            : console.warn(
                "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
              ));
      }
      const xn = me.morphAttributes;
      if (
        ((xn.position !== void 0 ||
          xn.normal !== void 0 ||
          (xn.color !== void 0 && xe.isWebGL2 === !0)) &&
          Re.update(ye, me, Sr),
        (Ai || St.receiveShadow !== ye.receiveShadow) &&
          ((St.receiveShadow = ye.receiveShadow),
          pt.setValue($, "receiveShadow", ye.receiveShadow)),
        te.isMeshGouraudMaterial &&
          te.envMap !== null &&
          ((Qn.envMap.value = dt),
          (Qn.flipEnvMap.value =
            dt.isCubeTexture && dt.isRenderTargetTexture === !1 ? -1 : 1)),
        Ai &&
          (pt.setValue($, "toneMappingExposure", m.toneMappingExposure),
          St.needsLights && pu(Qn, Nt),
          $e && te.fog === !0 && At.refreshFogUniforms(Qn, $e),
          At.refreshMaterialUniforms(Qn, te, V, J, Q),
          Mm.upload($, St.uniformsList, Qn, _e)),
        te.isShaderMaterial &&
          te.uniformsNeedUpdate === !0 &&
          (Mm.upload($, St.uniformsList, Qn, _e), (te.uniformsNeedUpdate = !1)),
        te.isSpriteMaterial && pt.setValue($, "center", ye.center),
        pt.setValue($, "modelViewMatrix", ye.modelViewMatrix),
        pt.setValue($, "normalMatrix", ye.normalMatrix),
        pt.setValue($, "modelMatrix", ye.matrixWorld),
        te.isShaderMaterial || te.isRawShaderMaterial)
      ) {
        const Gt = te.uniformsGroups;
        for (let wr = 0, io = Gt.length; wr < io; wr++)
          if (xe.isWebGL2) {
            const Hn = Gt[wr];
            (W.update(Hn, Sr), W.bind(Hn, Sr));
          } else
            console.warn(
              "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
            );
      }
      return Sr;
    }
    function pu(N, re) {
      ((N.ambientLightColor.needsUpdate = re),
        (N.lightProbe.needsUpdate = re),
        (N.directionalLights.needsUpdate = re),
        (N.directionalLightShadows.needsUpdate = re),
        (N.pointLights.needsUpdate = re),
        (N.pointLightShadows.needsUpdate = re),
        (N.spotLights.needsUpdate = re),
        (N.spotLightShadows.needsUpdate = re),
        (N.rectAreaLights.needsUpdate = re),
        (N.hemisphereLights.needsUpdate = re));
    }
    function s0(N) {
      return (
        N.isMeshLambertMaterial ||
        N.isMeshToonMaterial ||
        N.isMeshPhongMaterial ||
        N.isMeshStandardMaterial ||
        N.isShadowMaterial ||
        (N.isShaderMaterial && N.lights === !0)
      );
    }
    ((this.getActiveCubeFace = function () {
      return S;
    }),
      (this.getActiveMipmapLevel = function () {
        return w;
      }),
      (this.getRenderTarget = function () {
        return C;
      }),
      (this.setRenderTargetTextures = function (N, re, me) {
        ((se.get(N.texture).__webglTexture = re),
          (se.get(N.depthTexture).__webglTexture = me));
        const te = se.get(N);
        ((te.__hasExternalTextures = !0),
          te.__hasExternalTextures &&
            ((te.__autoAllocateDepthBuffer = me === void 0),
            te.__autoAllocateDepthBuffer ||
              (Xe.has("WEBGL_multisampled_render_to_texture") === !0 &&
                (console.warn(
                  "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                ),
                (te.__useRenderToTexture = !1)))));
      }),
      (this.setRenderTargetFramebuffer = function (N, re) {
        const me = se.get(N);
        ((me.__webglFramebuffer = re),
          (me.__useDefaultFramebuffer = re === void 0));
      }),
      (this.setRenderTarget = function (N, re = 0, me = 0) {
        ((C = N), (S = re), (w = me));
        let te = !0,
          ye = null,
          $e = !1,
          st = !1;
        if (N) {
          const dt = se.get(N);
          dt.__useDefaultFramebuffer !== void 0
            ? (Se.bindFramebuffer(36160, null), (te = !1))
            : dt.__webglFramebuffer === void 0
              ? _e.setupRenderTarget(N)
              : dt.__hasExternalTextures &&
                _e.rebindTextures(
                  N,
                  se.get(N.texture).__webglTexture,
                  se.get(N.depthTexture).__webglTexture
                );
          const yt = N.texture;
          (yt.isData3DTexture ||
            yt.isDataArrayTexture ||
            yt.isCompressedArrayTexture) &&
            (st = !0);
          const xt = se.get(N).__webglFramebuffer;
          (N.isWebGLCubeRenderTarget
            ? ((ye = xt[re]), ($e = !0))
            : xe.isWebGL2 && N.samples > 0 && _e.useMultisampledRTT(N) === !1
              ? (ye = se.get(N).__webglMultisampledFramebuffer)
              : (ye = xt),
            B.copy(N.viewport),
            b.copy(N.scissor),
            (L = N.scissorTest));
        } else
          (B.copy(oe).multiplyScalar(V).floor(),
            b.copy(ae).multiplyScalar(V).floor(),
            (L = I));
        if (
          (Se.bindFramebuffer(36160, ye) &&
            xe.drawBuffers &&
            te &&
            Se.drawBuffers(N, ye),
          Se.viewport(B),
          Se.scissor(b),
          Se.setScissorTest(L),
          $e)
        ) {
          const dt = se.get(N.texture);
          $.framebufferTexture2D(
            36160,
            36064,
            34069 + re,
            dt.__webglTexture,
            me
          );
        } else if (st) {
          const dt = se.get(N.texture),
            yt = re || 0;
          $.framebufferTextureLayer(
            36160,
            36064,
            dt.__webglTexture,
            me || 0,
            yt
          );
        }
        P = -1;
      }),
      (this.readRenderTargetPixels = function (N, re, me, te, ye, $e, st) {
        if (!(N && N.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
          return;
        }
        let at = se.get(N).__webglFramebuffer;
        if ((N.isWebGLCubeRenderTarget && st !== void 0 && (at = at[st]), at)) {
          Se.bindFramebuffer(36160, at);
          try {
            const dt = N.texture,
              yt = dt.format,
              xt = dt.type;
            if (yt !== Pi && pe.convert(yt) !== $.getParameter(35739)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
              return;
            }
            const Mt =
              xt === Vc &&
              (Xe.has("EXT_color_buffer_half_float") ||
                (xe.isWebGL2 && Xe.has("EXT_color_buffer_float")));
            if (
              xt !== Ys &&
              pe.convert(xt) !== $.getParameter(35738) &&
              !(
                xt === Os &&
                (xe.isWebGL2 ||
                  Xe.has("OES_texture_float") ||
                  Xe.has("WEBGL_color_buffer_float"))
              ) &&
              !Mt
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
              return;
            }
            re >= 0 &&
              re <= N.width - te &&
              me >= 0 &&
              me <= N.height - ye &&
              $.readPixels(re, me, te, ye, pe.convert(yt), pe.convert(xt), $e);
          } finally {
            const dt = C !== null ? se.get(C).__webglFramebuffer : null;
            Se.bindFramebuffer(36160, dt);
          }
        }
      }),
      (this.copyFramebufferToTexture = function (N, re, me = 0) {
        const te = Math.pow(2, -me),
          ye = Math.floor(re.image.width * te),
          $e = Math.floor(re.image.height * te);
        (_e.setTexture2D(re, 0),
          $.copyTexSubImage2D(3553, me, 0, 0, N.x, N.y, ye, $e),
          Se.unbindTexture());
      }),
      (this.copyTextureToTexture = function (N, re, me, te = 0) {
        const ye = re.image.width,
          $e = re.image.height,
          st = pe.convert(me.format),
          at = pe.convert(me.type);
        (_e.setTexture2D(me, 0),
          $.pixelStorei(37440, me.flipY),
          $.pixelStorei(37441, me.premultiplyAlpha),
          $.pixelStorei(3317, me.unpackAlignment),
          re.isDataTexture
            ? $.texSubImage2D(3553, te, N.x, N.y, ye, $e, st, at, re.image.data)
            : re.isCompressedTexture
              ? $.compressedTexSubImage2D(
                  3553,
                  te,
                  N.x,
                  N.y,
                  re.mipmaps[0].width,
                  re.mipmaps[0].height,
                  st,
                  re.mipmaps[0].data
                )
              : $.texSubImage2D(3553, te, N.x, N.y, st, at, re.image),
          te === 0 && me.generateMipmaps && $.generateMipmap(3553),
          Se.unbindTexture());
      }),
      (this.copyTextureToTexture3D = function (N, re, me, te, ye = 0) {
        if (m.isWebGL1Renderer) {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
          );
          return;
        }
        const $e = N.max.x - N.min.x + 1,
          st = N.max.y - N.min.y + 1,
          at = N.max.z - N.min.z + 1,
          dt = pe.convert(te.format),
          yt = pe.convert(te.type);
        let xt;
        if (te.isData3DTexture) (_e.setTexture3D(te, 0), (xt = 32879));
        else if (te.isDataArrayTexture)
          (_e.setTexture2DArray(te, 0), (xt = 35866));
        else {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
          );
          return;
        }
        ($.pixelStorei(37440, te.flipY),
          $.pixelStorei(37441, te.premultiplyAlpha),
          $.pixelStorei(3317, te.unpackAlignment));
        const Mt = $.getParameter(3314),
          Ft = $.getParameter(32878),
          Gn = $.getParameter(3316),
          Fi = $.getParameter(3315),
          Mr = $.getParameter(32877),
          jt = me.isCompressedTexture ? me.mipmaps[0] : me.image;
        ($.pixelStorei(3314, jt.width),
          $.pixelStorei(32878, jt.height),
          $.pixelStorei(3316, N.min.x),
          $.pixelStorei(3315, N.min.y),
          $.pixelStorei(32877, N.min.z),
          me.isDataTexture || me.isData3DTexture
            ? $.texSubImage3D(
                xt,
                ye,
                re.x,
                re.y,
                re.z,
                $e,
                st,
                at,
                dt,
                yt,
                jt.data
              )
            : me.isCompressedArrayTexture
              ? (console.warn(
                  "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
                ),
                $.compressedTexSubImage3D(
                  xt,
                  ye,
                  re.x,
                  re.y,
                  re.z,
                  $e,
                  st,
                  at,
                  dt,
                  jt.data
                ))
              : $.texSubImage3D(
                  xt,
                  ye,
                  re.x,
                  re.y,
                  re.z,
                  $e,
                  st,
                  at,
                  dt,
                  yt,
                  jt
                ),
          $.pixelStorei(3314, Mt),
          $.pixelStorei(32878, Ft),
          $.pixelStorei(3316, Gn),
          $.pixelStorei(3315, Fi),
          $.pixelStorei(32877, Mr),
          ye === 0 && te.generateMipmaps && $.generateMipmap(xt),
          Se.unbindTexture());
      }),
      (this.initTexture = function (N) {
        (N.isCubeTexture
          ? _e.setTextureCube(N, 0)
          : N.isData3DTexture
            ? _e.setTexture3D(N, 0)
            : N.isDataArrayTexture || N.isCompressedArrayTexture
              ? _e.setTexture2DArray(N, 0)
              : _e.setTexture2D(N, 0),
          Se.unbindTexture());
      }),
      (this.resetState = function () {
        ((S = 0), (w = 0), (C = null), Se.reset(), He.reset());
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        ));
  }
  get physicallyCorrectLights() {
    return (
      console.warn(
        "THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
      ),
      !this.useLegacyLights
    );
  }
  set physicallyCorrectLights(e) {
    (console.warn(
      "THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
    ),
      (this.useLegacyLights = !e));
  }
}
class $B extends lA {}
$B.prototype.isWebGL1Renderer = !0;
class zg {
  constructor(e, t = 25e-5) {
    ((this.isFogExp2 = !0),
      (this.name = ""),
      (this.color = new Ie(e)),
      (this.density = t));
  }
  clone() {
    return new zg(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density,
    };
  }
}
class Gg {
  constructor(e, t = 1, i = 1e3) {
    ((this.isFog = !0),
      (this.name = ""),
      (this.color = new Ie(e)),
      (this.near = t),
      (this.far = i));
  }
  clone() {
    return new Gg(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
class Zm extends Pt {
  constructor() {
    (super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        ));
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.fog !== null && (t.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (t.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (t.object.backgroundIntensity = this.backgroundIntensity),
      t
    );
  }
  get autoUpdate() {
    return (
      console.warn(
        "THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."
      ),
      this.matrixWorldAutoUpdate
    );
  }
  set autoUpdate(e) {
    (console.warn(
      "THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."
    ),
      (this.matrixWorldAutoUpdate = e));
  }
}
class Ch {
  constructor(e, t) {
    ((this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = nh),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0),
      (this.uuid = Ki()));
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return ((this.usage = e), this);
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, i) {
    ((e *= this.stride), (i *= t.stride));
    for (let r = 0, s = this.stride; r < s; r++)
      this.array[e + r] = t.array[i + r];
    return this;
  }
  set(e, t = 0) {
    return (this.array.set(e, t), this);
  }
  clone(e) {
    (e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ki()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer));
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      i = new this.constructor(t, this.stride);
    return (i.setUsage(this.usage), i);
  }
  onUpload(e) {
    return ((this.onUploadCallback = e), this);
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ki()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const hi = new F();
class Qo {
  constructor(e, t, i, r = !1) {
    ((this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = i),
      (this.normalized = r));
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.data.count; t < i; t++)
      (hi.fromBufferAttribute(this, t),
        hi.applyMatrix4(e),
        this.setXYZ(t, hi.x, hi.y, hi.z));
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      (hi.fromBufferAttribute(this, t),
        hi.applyNormalMatrix(e),
        this.setXYZ(t, hi.x, hi.y, hi.z));
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      (hi.fromBufferAttribute(this, t),
        hi.transformDirection(e),
        this.setXYZ(t, hi.x, hi.y, hi.z));
    return this;
  }
  setX(e, t) {
    return (
      this.normalized && (t = vt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    );
  }
  setY(e, t) {
    return (
      this.normalized && (t = vt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    );
  }
  setZ(e, t) {
    return (
      this.normalized && (t = vt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    );
  }
  setW(e, t) {
    return (
      this.normalized && (t = vt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    );
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return (this.normalized && (t = ji(t, this.array)), t);
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return (this.normalized && (t = ji(t, this.array)), t);
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return (this.normalized && (t = ji(t, this.array)), t);
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return (this.normalized && (t = ji(t, this.array)), t);
  }
  setXY(e, t, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((t = vt(t, this.array)), (i = vt(i, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      this
    );
  }
  setXYZ(e, t, i, r) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = vt(t, this.array)),
        (i = vt(i, this.array)),
        (r = vt(r, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = r),
      this
    );
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = vt(t, this.array)),
        (i = vt(i, this.array)),
        (r = vt(r, this.array)),
        (s = vt(s, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = r),
      (this.data.array[e + 3] = s),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
      }
      return new Dt(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new Qo(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
class cA extends En {
  constructor(e) {
    (super(),
      (this.isSpriteMaterial = !0),
      (this.type = "SpriteMaterial"),
      (this.color = new Ie(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.rotation = e.rotation),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
let Ql;
const Ju = new F(),
  Zl = new F(),
  ql = new F(),
  $l = new ve(),
  Xu = new ve(),
  eR = new ot(),
  Tp = new F(),
  Ku = new F(),
  bp = new F(),
  JE = new ve(),
  sy = new ve(),
  XE = new ve();
class tR extends Pt {
  constructor(e) {
    if (
      (super(), (this.isSprite = !0), (this.type = "Sprite"), Ql === void 0)
    ) {
      Ql = new ft();
      const t = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        i = new Ch(t, 5);
      (Ql.setIndex([0, 1, 2, 0, 2, 3]),
        Ql.setAttribute("position", new Qo(i, 3, 0, !1)),
        Ql.setAttribute("uv", new Qo(i, 2, 3, !1)));
    }
    ((this.geometry = Ql),
      (this.material = e !== void 0 ? e : new cA()),
      (this.center = new ve(0.5, 0.5)));
  }
  raycast(e, t) {
    (e.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
      ),
      Zl.setFromMatrixScale(this.matrixWorld),
      eR.copy(e.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        e.camera.matrixWorldInverse,
        this.matrixWorld
      ),
      ql.setFromMatrixPosition(this.modelViewMatrix),
      e.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        Zl.multiplyScalar(-ql.z));
    const i = this.material.rotation;
    let r, s;
    i !== 0 && ((s = Math.cos(i)), (r = Math.sin(i)));
    const o = this.center;
    (Pp(Tp.set(-0.5, -0.5, 0), ql, o, Zl, r, s),
      Pp(Ku.set(0.5, -0.5, 0), ql, o, Zl, r, s),
      Pp(bp.set(0.5, 0.5, 0), ql, o, Zl, r, s),
      JE.set(0, 0),
      sy.set(1, 0),
      XE.set(1, 1));
    let a = e.ray.intersectTriangle(Tp, Ku, bp, !1, Ju);
    if (
      a === null &&
      (Pp(Ku.set(-0.5, 0.5, 0), ql, o, Zl, r, s),
      sy.set(0, 1),
      (a = e.ray.intersectTriangle(Tp, bp, Ku, !1, Ju)),
      a === null)
    )
      return;
    const l = e.ray.origin.distanceTo(Ju);
    l < e.near ||
      l > e.far ||
      t.push({
        distance: l,
        point: Ju.clone(),
        uv: bi.getInterpolation(Ju, Tp, Ku, bp, JE, sy, XE, new ve()),
        face: null,
        object: this,
      });
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.center !== void 0 && this.center.copy(e.center),
      (this.material = e.material),
      this
    );
  }
}
function Pp(n, e, t, i, r, s) {
  ($l.subVectors(n, t).addScalar(0.5).multiply(i),
    r !== void 0
      ? ((Xu.x = s * $l.x - r * $l.y), (Xu.y = r * $l.x + s * $l.y))
      : Xu.copy($l),
    n.copy(e),
    (n.x += Xu.x),
    (n.y += Xu.y),
    n.applyMatrix4(eR));
}
const Bp = new F(),
  KE = new F();
class nR extends Pt {
  constructor() {
    (super(),
      (this._currentLevel = 0),
      (this.type = "LOD"),
      Object.defineProperties(this, {
        levels: { enumerable: !0, value: [] },
        isLOD: { value: !0 },
      }),
      (this.autoUpdate = !0));
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      this.addLevel(s.object.clone(), s.distance, s.hysteresis);
    }
    return ((this.autoUpdate = e.autoUpdate), this);
  }
  addLevel(e, t = 0, i = 0) {
    t = Math.abs(t);
    const r = this.levels;
    let s;
    for (s = 0; s < r.length && !(t < r[s].distance); s++);
    return (
      r.splice(s, 0, { distance: t, hysteresis: i, object: e }),
      this.add(e),
      this
    );
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let i, r;
      for (i = 1, r = t.length; i < r; i++) {
        let s = t[i].distance;
        if ((t[i].object.visible && (s -= s * t[i].hysteresis), e < s)) break;
      }
      return t[i - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      Bp.setFromMatrixPosition(this.matrixWorld);
      const r = e.ray.origin.distanceTo(Bp);
      this.getObjectForDistance(r).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      (Bp.setFromMatrixPosition(e.matrixWorld),
        KE.setFromMatrixPosition(this.matrixWorld));
      const i = Bp.distanceTo(KE) / e.zoom;
      t[0].object.visible = !0;
      let r, s;
      for (r = 1, s = t.length; r < s; r++) {
        let o = t[r].distance;
        if ((t[r].object.visible && (o -= o * t[r].hysteresis), i >= o))
          ((t[r - 1].object.visible = !1), (t[r].object.visible = !0));
        else break;
      }
      for (this._currentLevel = r - 1; r < s; r++) t[r].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    (this.autoUpdate === !1 && (t.object.autoUpdate = !1),
      (t.object.levels = []));
    const i = this.levels;
    for (let r = 0, s = i.length; r < s; r++) {
      const o = i[r];
      t.object.levels.push({
        object: o.object.uuid,
        distance: o.distance,
        hysteresis: o.hysteresis,
      });
    }
    return t;
  }
}
const YE = new F(),
  QE = new kt(),
  ZE = new kt(),
  RG = new F(),
  qE = new ot(),
  ec = new F();
class uA extends Bn {
  constructor(e, t) {
    (super(e, t),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = "attached"),
      (this.bindMatrix = new ot()),
      (this.bindMatrixInverse = new ot()),
      (this.boundingBox = null),
      (this.boundingSphere = null));
  }
  computeBoundingBox() {
    const e = this.geometry;
    (this.boundingBox === null && (this.boundingBox = new Vr()),
      this.boundingBox.makeEmpty());
    const t = e.getAttribute("position");
    for (let i = 0; i < t.count; i++)
      (ec.fromBufferAttribute(t, i),
        this.applyBoneTransform(i, ec),
        this.boundingBox.expandByPoint(ec));
  }
  computeBoundingSphere() {
    const e = this.geometry;
    (this.boundingSphere === null && (this.boundingSphere = new Wr()),
      this.boundingSphere.makeEmpty());
    const t = e.getAttribute("position");
    for (let i = 0; i < t.count; i++)
      (ec.fromBufferAttribute(t, i),
        this.applyBoneTransform(i, ec),
        this.boundingSphere.expandByPoint(ec));
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      this
    );
  }
  bind(e, t) {
    ((this.skeleton = e),
      t === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert());
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new kt(),
      t = this.geometry.attributes.skinWeight;
    for (let i = 0, r = t.count; i < r; i++) {
      e.fromBufferAttribute(t, i);
      const s = 1 / e.manhattanLength();
      (s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
        t.setXYZW(i, e.x, e.y, e.z, e.w));
    }
  }
  updateMatrixWorld(e) {
    (super.updateMatrixWorld(e),
      this.bindMode === "attached"
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === "detached"
          ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
          : console.warn(
              "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
            ));
  }
  applyBoneTransform(e, t) {
    const i = this.skeleton,
      r = this.geometry;
    (QE.fromBufferAttribute(r.attributes.skinIndex, e),
      ZE.fromBufferAttribute(r.attributes.skinWeight, e),
      YE.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0));
    for (let s = 0; s < 4; s++) {
      const o = ZE.getComponent(s);
      if (o !== 0) {
        const a = QE.getComponent(s);
        (qE.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]),
          t.addScaledVector(RG.copy(YE).applyMatrix4(qE), o));
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
  boneTransform(e, t) {
    return (
      console.warn(
        "THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."
      ),
      this.applyBoneTransform(e, t)
    );
  }
}
class Hg extends Pt {
  constructor() {
    (super(), (this.isBone = !0), (this.type = "Bone"));
  }
}
class Lc extends en {
  constructor(e = null, t = 1, i = 1, r, s, o, a, l, u = dn, h = dn, d, p) {
    (super(null, o, a, l, u, h, r, s, d, p),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: t, height: i }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1));
  }
}
const $E = new ot(),
  LG = new ot();
class Th {
  constructor(e = [], t = []) {
    ((this.uuid = Ki()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      (this.boneTextureSize = 0),
      (this.frame = -1),
      this.init());
  }
  init() {
    const e = this.bones,
      t = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
      this.calculateInverses();
    else if (e.length !== t.length) {
      (console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = []));
      for (let i = 0, r = this.bones.length; i < r; i++)
        this.boneInverses.push(new ot());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = new ot();
      (this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(i));
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i && i.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i &&
        (i.parent && i.parent.isBone
          ? (i.matrix.copy(i.parent.matrixWorld).invert(),
            i.matrix.multiply(i.matrixWorld))
          : i.matrix.copy(i.matrixWorld),
        i.matrix.decompose(i.position, i.quaternion, i.scale));
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      i = this.boneMatrices,
      r = this.boneTexture;
    for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s] ? e[s].matrixWorld : LG;
      ($E.multiplyMatrices(a, t[s]), $E.toArray(i, s * 16));
    }
    r !== null && (r.needsUpdate = !0);
  }
  clone() {
    return new Th(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    ((e = UB(e)), (e = Math.max(e, 4)));
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const i = new Lc(t, e, e, Pi, Os);
    return (
      (i.needsUpdate = !0),
      (this.boneMatrices = t),
      (this.boneTexture = i),
      (this.boneTextureSize = e),
      this
    );
  }
  getBoneByName(e) {
    for (let t = 0, i = this.bones.length; t < i; t++) {
      const r = this.bones[t];
      if (r.name === e) return r;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let i = 0, r = e.bones.length; i < r; i++) {
      const s = e.bones[i];
      let o = t[s];
      (o === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", s),
        (o = new Hg())),
        this.bones.push(o),
        this.boneInverses.push(new ot().fromArray(e.boneInverses[i])));
    }
    return (this.init(), this);
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const t = this.bones,
      i = this.boneInverses;
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r];
      e.bones.push(o.uuid);
      const a = i[r];
      e.boneInverses.push(a.toArray());
    }
    return e;
  }
}
class Kc extends Dt {
  constructor(e, t, i, r = 1) {
    (super(e, t, i),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = r));
  }
  copy(e) {
    return (super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this);
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const tc = new ot(),
  eC = new ot(),
  Rp = [],
  tC = new Vr(),
  IG = new ot(),
  Yu = new Bn(),
  Qu = new Wr();
class iR extends Bn {
  constructor(e, t, i) {
    (super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new Kc(new Float32Array(i * 16), 16)),
      (this.instanceColor = null),
      (this.count = i),
      (this.boundingBox = null),
      (this.boundingSphere = null));
    for (let r = 0; r < i; r++) this.setMatrixAt(r, IG);
  }
  computeBoundingBox() {
    const e = this.geometry,
      t = this.count;
    (this.boundingBox === null && (this.boundingBox = new Vr()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty());
    for (let i = 0; i < t; i++)
      (this.getMatrixAt(i, tc),
        tC.copy(e.boundingBox).applyMatrix4(tc),
        this.boundingBox.union(tC));
  }
  computeBoundingSphere() {
    const e = this.geometry,
      t = this.count;
    (this.boundingSphere === null && (this.boundingSphere = new Wr()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty());
    for (let i = 0; i < t; i++)
      (this.getMatrixAt(i, tc),
        Qu.copy(e.boundingSphere).applyMatrix4(tc),
        this.boundingSphere.union(Qu));
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const i = this.matrixWorld,
      r = this.count;
    if (
      ((Yu.geometry = this.geometry),
      (Yu.material = this.material),
      Yu.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        Qu.copy(this.boundingSphere),
        Qu.applyMatrix4(i),
        e.ray.intersectsSphere(Qu) !== !1))
    )
      for (let s = 0; s < r; s++) {
        (this.getMatrixAt(s, tc),
          eC.multiplyMatrices(i, tc),
          (Yu.matrixWorld = eC),
          Yu.raycast(e, Rp));
        for (let o = 0, a = Rp.length; o < a; o++) {
          const l = Rp[o];
          ((l.instanceId = s), (l.object = this), t.push(l));
        }
        Rp.length = 0;
      }
  }
  setColorAt(e, t) {
    (this.instanceColor === null &&
      (this.instanceColor = new Kc(
        new Float32Array(this.instanceMatrix.count * 3),
        3
      )),
      t.toArray(this.instanceColor.array, e * 3));
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {}
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class li extends En {
  constructor(e) {
    (super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new Ie(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const nC = new F(),
  iC = new F(),
  rC = new ot(),
  oy = new Sh(),
  Lp = new Wr();
class Zs extends Pt {
  constructor(e = new ft(), t = new li()) {
    (super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets());
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        i = [0];
      for (let r = 1, s = t.count; r < s; r++)
        (nC.fromBufferAttribute(t, r - 1),
          iC.fromBufferAttribute(t, r),
          (i[r] = i[r - 1]),
          (i[r] += nC.distanceTo(iC)));
      e.setAttribute("lineDistance", new Ve(i, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.matrixWorld,
      s = e.params.Line.threshold,
      o = i.drawRange;
    if (
      (i.boundingSphere === null && i.computeBoundingSphere(),
      Lp.copy(i.boundingSphere),
      Lp.applyMatrix4(r),
      (Lp.radius += s),
      e.ray.intersectsSphere(Lp) === !1)
    )
      return;
    (rC.copy(r).invert(), oy.copy(e.ray).applyMatrix4(rC));
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = a * a,
      u = new F(),
      h = new F(),
      d = new F(),
      p = new F(),
      g = this.isLineSegments ? 2 : 1,
      y = i.index,
      _ = i.attributes.position;
    if (y !== null) {
      const m = Math.max(0, o.start),
        x = Math.min(y.count, o.start + o.count);
      for (let S = m, w = x - 1; S < w; S += g) {
        const C = y.getX(S),
          P = y.getX(S + 1);
        if (
          (u.fromBufferAttribute(_, C),
          h.fromBufferAttribute(_, P),
          oy.distanceSqToSegment(u, h, p, d) > l)
        )
          continue;
        p.applyMatrix4(this.matrixWorld);
        const B = e.ray.origin.distanceTo(p);
        B < e.near ||
          B > e.far ||
          t.push({
            distance: B,
            point: d.clone().applyMatrix4(this.matrixWorld),
            index: S,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    } else {
      const m = Math.max(0, o.start),
        x = Math.min(_.count, o.start + o.count);
      for (let S = m, w = x - 1; S < w; S += g) {
        if (
          (u.fromBufferAttribute(_, S),
          h.fromBufferAttribute(_, S + 1),
          oy.distanceSqToSegment(u, h, p, d) > l)
        )
          continue;
        p.applyMatrix4(this.matrixWorld);
        const P = e.ray.origin.distanceTo(p);
        P < e.near ||
          P > e.far ||
          t.push({
            distance: P,
            point: d.clone().applyMatrix4(this.matrixWorld),
            index: S,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        ((this.morphTargetInfluences = []), (this.morphTargetDictionary = {}));
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          (this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s));
        }
      }
    }
  }
}
const sC = new F(),
  oC = new F();
class jr extends Zs {
  constructor(e, t) {
    (super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments"));
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        i = [];
      for (let r = 0, s = t.count; r < s; r += 2)
        (sC.fromBufferAttribute(t, r),
          oC.fromBufferAttribute(t, r + 1),
          (i[r] = r === 0 ? 0 : i[r - 1]),
          (i[r + 1] = i[r] + sC.distanceTo(oC)));
      e.setAttribute("lineDistance", new Ve(i, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
}
class fA extends Zs {
  constructor(e, t) {
    (super(e, t), (this.isLineLoop = !0), (this.type = "LineLoop"));
  }
}
class bh extends En {
  constructor(e) {
    (super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new Ie(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const aC = new ot(),
  g_ = new Sh(),
  Ip = new Wr(),
  Dp = new F();
let hA = class extends Pt {
  constructor(e = new ft(), t = new bh()) {
    (super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets());
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.matrixWorld,
      s = e.params.Points.threshold,
      o = i.drawRange;
    if (
      (i.boundingSphere === null && i.computeBoundingSphere(),
      Ip.copy(i.boundingSphere),
      Ip.applyMatrix4(r),
      (Ip.radius += s),
      e.ray.intersectsSphere(Ip) === !1)
    )
      return;
    (aC.copy(r).invert(), g_.copy(e.ray).applyMatrix4(aC));
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = a * a,
      u = i.index,
      d = i.attributes.position;
    if (u !== null) {
      const p = Math.max(0, o.start),
        g = Math.min(u.count, o.start + o.count);
      for (let y = p, A = g; y < A; y++) {
        const _ = u.getX(y);
        (Dp.fromBufferAttribute(d, _), lC(Dp, _, l, r, e, t, this));
      }
    } else {
      const p = Math.max(0, o.start),
        g = Math.min(d.count, o.start + o.count);
      for (let y = p, A = g; y < A; y++)
        (Dp.fromBufferAttribute(d, y), lC(Dp, y, l, r, e, t, this));
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        ((this.morphTargetInfluences = []), (this.morphTargetDictionary = {}));
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          (this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s));
        }
      }
    }
  }
};
function lC(n, e, t, i, r, s, o) {
  const a = g_.distanceSqToPoint(n);
  if (a < t) {
    const l = new F();
    (g_.closestPointToPoint(n, l), l.applyMatrix4(i));
    const u = r.ray.origin.distanceTo(l);
    if (u < r.near || u > r.far) return;
    s.push({
      distance: u,
      distanceToRay: Math.sqrt(a),
      point: l,
      index: e,
      face: null,
      object: o,
    });
  }
}
class DG extends en {
  constructor(e, t, i, r, s, o, a, l, u) {
    (super(e, t, i, r, s, o, a, l, u),
      (this.isVideoTexture = !0),
      (this.minFilter = o !== void 0 ? o : rn),
      (this.magFilter = s !== void 0 ? s : rn),
      (this.generateMipmaps = !1));
    const h = this;
    function d() {
      ((h.needsUpdate = !0), e.requestVideoFrameCallback(d));
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(d);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 &&
      e.readyState >= e.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0);
  }
}
class FG extends en {
  constructor(e, t, i) {
    (super({ width: e, height: t }),
      (this.isFramebufferTexture = !0),
      (this.format = i),
      (this.magFilter = dn),
      (this.minFilter = dn),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0));
  }
}
class dA extends en {
  constructor(e, t, i, r, s, o, a, l, u, h, d, p) {
    (super(null, o, a, l, u, h, r, s, d, p),
      (this.isCompressedTexture = !0),
      (this.image = { width: t, height: i }),
      (this.mipmaps = e),
      (this.flipY = !1),
      (this.generateMipmaps = !1));
  }
}
class NG extends dA {
  constructor(e, t, i, r, s, o) {
    (super(e, t, i, s, o),
      (this.isCompressedArrayTexture = !0),
      (this.image.depth = r),
      (this.wrapR = jn));
  }
}
class kG extends en {
  constructor(e, t, i, r, s, o, a, l, u) {
    (super(e, t, i, r, s, o, a, l, u),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0));
  }
}
class Jr {
  constructor() {
    ((this.type = "Curve"), (this.arcLengthDivisions = 200));
  }
  getPoint() {
    return (console.warn("THREE.Curve: .getPoint() not implemented."), null);
  }
  getPointAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getPoint(i, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let i,
      r = this.getPoint(0),
      s = 0;
    t.push(0);
    for (let o = 1; o <= e; o++)
      ((i = this.getPoint(o / e)), (s += i.distanceTo(r)), t.push(s), (r = i));
    return ((this.cacheArcLengths = t), t);
  }
  updateArcLengths() {
    ((this.needsUpdate = !0), this.getLengths());
  }
  getUtoTmapping(e, t) {
    const i = this.getLengths();
    let r = 0;
    const s = i.length;
    let o;
    t ? (o = t) : (o = e * i[s - 1]);
    let a = 0,
      l = s - 1,
      u;
    for (; a <= l; )
      if (((r = Math.floor(a + (l - a) / 2)), (u = i[r] - o), u < 0)) a = r + 1;
      else if (u > 0) l = r - 1;
      else {
        l = r;
        break;
      }
    if (((r = l), i[r] === o)) return r / (s - 1);
    const h = i[r],
      p = i[r + 1] - h,
      g = (o - h) / p;
    return (r + g) / (s - 1);
  }
  getTangent(e, t) {
    let r = e - 1e-4,
      s = e + 1e-4;
    (r < 0 && (r = 0), s > 1 && (s = 1));
    const o = this.getPoint(r),
      a = this.getPoint(s),
      l = t || (o.isVector2 ? new ve() : new F());
    return (l.copy(a).sub(o).normalize(), l);
  }
  getTangentAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getTangent(i, t);
  }
  computeFrenetFrames(e, t) {
    const i = new F(),
      r = [],
      s = [],
      o = [],
      a = new F(),
      l = new ot();
    for (let g = 0; g <= e; g++) {
      const y = g / e;
      r[g] = this.getTangentAt(y, new F());
    }
    ((s[0] = new F()), (o[0] = new F()));
    let u = Number.MAX_VALUE;
    const h = Math.abs(r[0].x),
      d = Math.abs(r[0].y),
      p = Math.abs(r[0].z);
    (h <= u && ((u = h), i.set(1, 0, 0)),
      d <= u && ((u = d), i.set(0, 1, 0)),
      p <= u && i.set(0, 0, 1),
      a.crossVectors(r[0], i).normalize(),
      s[0].crossVectors(r[0], a),
      o[0].crossVectors(r[0], s[0]));
    for (let g = 1; g <= e; g++) {
      if (
        ((s[g] = s[g - 1].clone()),
        (o[g] = o[g - 1].clone()),
        a.crossVectors(r[g - 1], r[g]),
        a.length() > Number.EPSILON)
      ) {
        a.normalize();
        const y = Math.acos(pn(r[g - 1].dot(r[g]), -1, 1));
        s[g].applyMatrix4(l.makeRotationAxis(a, y));
      }
      o[g].crossVectors(r[g], s[g]);
    }
    if (t === !0) {
      let g = Math.acos(pn(s[0].dot(s[e]), -1, 1));
      ((g /= e), r[0].dot(a.crossVectors(s[0], s[e])) > 0 && (g = -g));
      for (let y = 1; y <= e; y++)
        (s[y].applyMatrix4(l.makeRotationAxis(r[y], g * y)),
          o[y].crossVectors(r[y], s[y]));
    }
    return { tangents: r, normals: s, binormals: o };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return ((this.arcLengthDivisions = e.arcLengthDivisions), this);
  }
  toJSON() {
    const e = {
      metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions),
      (e.type = this.type),
      e
    );
  }
  fromJSON(e) {
    return ((this.arcLengthDivisions = e.arcLengthDivisions), this);
  }
}
class Vg extends Jr {
  constructor(
    e = 0,
    t = 0,
    i = 1,
    r = 1,
    s = 0,
    o = Math.PI * 2,
    a = !1,
    l = 0
  ) {
    (super(),
      (this.isEllipseCurve = !0),
      (this.type = "EllipseCurve"),
      (this.aX = e),
      (this.aY = t),
      (this.xRadius = i),
      (this.yRadius = r),
      (this.aStartAngle = s),
      (this.aEndAngle = o),
      (this.aClockwise = a),
      (this.aRotation = l));
  }
  getPoint(e, t) {
    const i = t || new ve(),
      r = Math.PI * 2;
    let s = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(s) < Number.EPSILON;
    for (; s < 0; ) s += r;
    for (; s > r; ) s -= r;
    (s < Number.EPSILON && (o ? (s = 0) : (s = r)),
      this.aClockwise === !0 && !o && (s === r ? (s = -r) : (s = s - r)));
    const a = this.aStartAngle + e * s;
    let l = this.aX + this.xRadius * Math.cos(a),
      u = this.aY + this.yRadius * Math.sin(a);
    if (this.aRotation !== 0) {
      const h = Math.cos(this.aRotation),
        d = Math.sin(this.aRotation),
        p = l - this.aX,
        g = u - this.aY;
      ((l = p * h - g * d + this.aX), (u = p * d + g * h + this.aY));
    }
    return i.set(l, u);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.aX = this.aX),
      (e.aY = this.aY),
      (e.xRadius = this.xRadius),
      (e.yRadius = this.yRadius),
      (e.aStartAngle = this.aStartAngle),
      (e.aEndAngle = this.aEndAngle),
      (e.aClockwise = this.aClockwise),
      (e.aRotation = this.aRotation),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
}
class rR extends Vg {
  constructor(e, t, i, r, s, o) {
    (super(e, t, i, i, r, s, o),
      (this.isArcCurve = !0),
      (this.type = "ArcCurve"));
  }
}
function pA() {
  let n = 0,
    e = 0,
    t = 0,
    i = 0;
  function r(s, o, a, l) {
    ((n = s),
      (e = a),
      (t = -3 * s + 3 * o - 2 * a - l),
      (i = 2 * s - 2 * o + a + l));
  }
  return {
    initCatmullRom: function (s, o, a, l, u) {
      r(o, a, u * (a - s), u * (l - o));
    },
    initNonuniformCatmullRom: function (s, o, a, l, u, h, d) {
      let p = (o - s) / u - (a - s) / (u + h) + (a - o) / h,
        g = (a - o) / h - (l - o) / (h + d) + (l - a) / d;
      ((p *= h), (g *= h), r(o, a, p, g));
    },
    calc: function (s) {
      const o = s * s,
        a = o * s;
      return n + e * s + t * o + i * a;
    },
  };
}
const Fp = new F(),
  ay = new pA(),
  ly = new pA(),
  cy = new pA();
class sR extends Jr {
  constructor(e = [], t = !1, i = "centripetal", r = 0.5) {
    (super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = "CatmullRomCurve3"),
      (this.points = e),
      (this.closed = t),
      (this.curveType = i),
      (this.tension = r));
  }
  getPoint(e, t = new F()) {
    const i = t,
      r = this.points,
      s = r.length,
      o = (s - (this.closed ? 0 : 1)) * e;
    let a = Math.floor(o),
      l = o - a;
    this.closed
      ? (a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s)
      : l === 0 && a === s - 1 && ((a = s - 2), (l = 1));
    let u, h;
    this.closed || a > 0
      ? (u = r[(a - 1) % s])
      : (Fp.subVectors(r[0], r[1]).add(r[0]), (u = Fp));
    const d = r[a % s],
      p = r[(a + 1) % s];
    if (
      (this.closed || a + 2 < s
        ? (h = r[(a + 2) % s])
        : (Fp.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), (h = Fp)),
      this.curveType === "centripetal" || this.curveType === "chordal")
    ) {
      const g = this.curveType === "chordal" ? 0.5 : 0.25;
      let y = Math.pow(u.distanceToSquared(d), g),
        A = Math.pow(d.distanceToSquared(p), g),
        _ = Math.pow(p.distanceToSquared(h), g);
      (A < 1e-4 && (A = 1),
        y < 1e-4 && (y = A),
        _ < 1e-4 && (_ = A),
        ay.initNonuniformCatmullRom(u.x, d.x, p.x, h.x, y, A, _),
        ly.initNonuniformCatmullRom(u.y, d.y, p.y, h.y, y, A, _),
        cy.initNonuniformCatmullRom(u.z, d.z, p.z, h.z, y, A, _));
    } else
      this.curveType === "catmullrom" &&
        (ay.initCatmullRom(u.x, d.x, p.x, h.x, this.tension),
        ly.initCatmullRom(u.y, d.y, p.y, h.y, this.tension),
        cy.initCatmullRom(u.z, d.z, p.z, h.z, this.tension));
    return (i.set(ay.calc(l), ly.calc(l), cy.calc(l)), i);
  }
  copy(e) {
    (super.copy(e), (this.points = []));
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return (
      (e.closed = this.closed),
      (e.curveType = this.curveType),
      (e.tension = this.tension),
      e
    );
  }
  fromJSON(e) {
    (super.fromJSON(e), (this.points = []));
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(new F().fromArray(r));
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
}
function cC(n, e, t, i, r) {
  const s = (i - e) * 0.5,
    o = (r - t) * 0.5,
    a = n * n,
    l = n * a;
  return (
    (2 * t - 2 * i + s + o) * l + (-3 * t + 3 * i - 2 * s - o) * a + s * n + t
  );
}
function OG(n, e) {
  const t = 1 - n;
  return t * t * e;
}
function UG(n, e) {
  return 2 * (1 - n) * n * e;
}
function zG(n, e) {
  return n * n * e;
}
function Ef(n, e, t, i) {
  return OG(n, e) + UG(n, t) + zG(n, i);
}
function GG(n, e) {
  const t = 1 - n;
  return t * t * t * e;
}
function HG(n, e) {
  const t = 1 - n;
  return 3 * t * t * n * e;
}
function VG(n, e) {
  return 3 * (1 - n) * n * n * e;
}
function WG(n, e) {
  return n * n * n * e;
}
function Cf(n, e, t, i, r) {
  return GG(n, e) + HG(n, t) + VG(n, i) + WG(n, r);
}
class mA extends Jr {
  constructor(e = new ve(), t = new ve(), i = new ve(), r = new ve()) {
    (super(),
      (this.isCubicBezierCurve = !0),
      (this.type = "CubicBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i),
      (this.v3 = r));
  }
  getPoint(e, t = new ve()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2,
      a = this.v3;
    return (i.set(Cf(e, r.x, s.x, o.x, a.x), Cf(e, r.y, s.y, o.y, a.y)), i);
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class oR extends Jr {
  constructor(e = new F(), t = new F(), i = new F(), r = new F()) {
    (super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = "CubicBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i),
      (this.v3 = r));
  }
  getPoint(e, t = new F()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2,
      a = this.v3;
    return (
      i.set(
        Cf(e, r.x, s.x, o.x, a.x),
        Cf(e, r.y, s.y, o.y, a.y),
        Cf(e, r.z, s.z, o.z, a.z)
      ),
      i
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class Wg extends Jr {
  constructor(e = new ve(), t = new ve()) {
    (super(),
      (this.isLineCurve = !0),
      (this.type = "LineCurve"),
      (this.v1 = e),
      (this.v2 = t));
  }
  getPoint(e, t = new ve()) {
    const i = t;
    return (
      e === 1
        ? i.copy(this.v2)
        : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)),
      i
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new ve()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return (super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this);
  }
  toJSON() {
    const e = super.toJSON();
    return ((e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e);
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class aR extends Jr {
  constructor(e = new F(), t = new F()) {
    (super(),
      (this.isLineCurve3 = !0),
      (this.type = "LineCurve3"),
      (this.v1 = e),
      (this.v2 = t));
  }
  getPoint(e, t = new F()) {
    const i = t;
    return (
      e === 1
        ? i.copy(this.v2)
        : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)),
      i
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new F()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return (super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this);
  }
  toJSON() {
    const e = super.toJSON();
    return ((e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e);
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class gA extends Jr {
  constructor(e = new ve(), t = new ve(), i = new ve()) {
    (super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i));
  }
  getPoint(e, t = new ve()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2;
    return (i.set(Ef(e, r.x, s.x, o.x), Ef(e, r.y, s.y, o.y)), i);
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class vA extends Jr {
  constructor(e = new F(), t = new F(), i = new F()) {
    (super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = "QuadraticBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i));
  }
  getPoint(e, t = new F()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2;
    return (
      i.set(Ef(e, r.x, s.x, o.x), Ef(e, r.y, s.y, o.y), Ef(e, r.z, s.z, o.z)),
      i
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class yA extends Jr {
  constructor(e = []) {
    (super(),
      (this.isSplineCurve = !0),
      (this.type = "SplineCurve"),
      (this.points = e));
  }
  getPoint(e, t = new ve()) {
    const i = t,
      r = this.points,
      s = (r.length - 1) * e,
      o = Math.floor(s),
      a = s - o,
      l = r[o === 0 ? o : o - 1],
      u = r[o],
      h = r[o > r.length - 2 ? r.length - 1 : o + 1],
      d = r[o > r.length - 3 ? r.length - 1 : o + 2];
    return (i.set(cC(a, l.x, u.x, h.x, d.x), cC(a, l.y, u.y, h.y, d.y)), i);
  }
  copy(e) {
    (super.copy(e), (this.points = []));
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return e;
  }
  fromJSON(e) {
    (super.fromJSON(e), (this.points = []));
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(new ve().fromArray(r));
    }
    return this;
  }
}
var xA = Object.freeze({
  __proto__: null,
  ArcCurve: rR,
  CatmullRomCurve3: sR,
  CubicBezierCurve: mA,
  CubicBezierCurve3: oR,
  EllipseCurve: Vg,
  LineCurve: Wg,
  LineCurve3: aR,
  QuadraticBezierCurve: gA,
  QuadraticBezierCurve3: vA,
  SplineCurve: yA,
});
class lR extends Jr {
  constructor() {
    (super(),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1));
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0),
      t = this.curves[this.curves.length - 1].getPoint(1);
    e.equals(t) || this.curves.push(new Wg(t, e));
  }
  getPoint(e, t) {
    const i = e * this.getLength(),
      r = this.getCurveLengths();
    let s = 0;
    for (; s < r.length; ) {
      if (r[s] >= i) {
        const o = r[s] - i,
          a = this.curves[s],
          l = a.getLength(),
          u = l === 0 ? 0 : 1 - o / l;
        return a.getPointAt(u, t);
      }
      s++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    ((this.needsUpdate = !0),
      (this.cacheLengths = null),
      this.getCurveLengths());
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let i = 0, r = this.curves.length; i < r; i++)
      ((t += this.curves[i].getLength()), e.push(t));
    return ((this.cacheLengths = e), e);
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
    return (this.autoClose && t.push(t[0]), t);
  }
  getPoints(e = 12) {
    const t = [];
    let i;
    for (let r = 0, s = this.curves; r < s.length; r++) {
      const o = s[r],
        a = o.isEllipseCurve
          ? e * 2
          : o.isLineCurve || o.isLineCurve3
            ? 1
            : o.isSplineCurve
              ? e * o.points.length
              : e,
        l = o.getPoints(a);
      for (let u = 0; u < l.length; u++) {
        const h = l[u];
        (i && i.equals(h)) || (t.push(h), (i = h));
      }
    }
    return (
      this.autoClose &&
        t.length > 1 &&
        !t[t.length - 1].equals(t[0]) &&
        t.push(t[0]),
      t
    );
  }
  copy(e) {
    (super.copy(e), (this.curves = []));
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const r = e.curves[t];
      this.curves.push(r.clone());
    }
    return ((this.autoClose = e.autoClose), this);
  }
  toJSON() {
    const e = super.toJSON();
    ((e.autoClose = this.autoClose), (e.curves = []));
    for (let t = 0, i = this.curves.length; t < i; t++) {
      const r = this.curves[t];
      e.curves.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    (super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []));
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const r = e.curves[t];
      this.curves.push(new xA[r.type]().fromJSON(r));
    }
    return this;
  }
}
class rh extends lR {
  constructor(e) {
    (super(),
      (this.type = "Path"),
      (this.currentPoint = new ve()),
      e && this.setFromPoints(e));
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return (this.currentPoint.set(e, t), this);
  }
  lineTo(e, t) {
    const i = new Wg(this.currentPoint.clone(), new ve(e, t));
    return (this.curves.push(i), this.currentPoint.set(e, t), this);
  }
  quadraticCurveTo(e, t, i, r) {
    const s = new gA(this.currentPoint.clone(), new ve(e, t), new ve(i, r));
    return (this.curves.push(s), this.currentPoint.set(i, r), this);
  }
  bezierCurveTo(e, t, i, r, s, o) {
    const a = new mA(
      this.currentPoint.clone(),
      new ve(e, t),
      new ve(i, r),
      new ve(s, o)
    );
    return (this.curves.push(a), this.currentPoint.set(s, o), this);
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e),
      i = new yA(t);
    return (this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this);
  }
  arc(e, t, i, r, s, o) {
    const a = this.currentPoint.x,
      l = this.currentPoint.y;
    return (this.absarc(e + a, t + l, i, r, s, o), this);
  }
  absarc(e, t, i, r, s, o) {
    return (this.absellipse(e, t, i, i, r, s, o), this);
  }
  ellipse(e, t, i, r, s, o, a, l) {
    const u = this.currentPoint.x,
      h = this.currentPoint.y;
    return (this.absellipse(e + u, t + h, i, r, s, o, a, l), this);
  }
  absellipse(e, t, i, r, s, o, a, l) {
    const u = new Vg(e, t, i, r, s, o, a, l);
    if (this.curves.length > 0) {
      const d = u.getPoint(0);
      d.equals(this.currentPoint) || this.lineTo(d.x, d.y);
    }
    this.curves.push(u);
    const h = u.getPoint(1);
    return (this.currentPoint.copy(h), this);
  }
  copy(e) {
    return (super.copy(e), this.currentPoint.copy(e.currentPoint), this);
  }
  toJSON() {
    const e = super.toJSON();
    return ((e.currentPoint = this.currentPoint.toArray()), e);
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.currentPoint.fromArray(e.currentPoint),
      this
    );
  }
}
class ou extends ft {
  constructor(
    e = [new ve(0, -0.5), new ve(0.5, 0), new ve(0, 0.5)],
    t = 12,
    i = 0,
    r = Math.PI * 2
  ) {
    (super(),
      (this.type = "LatheGeometry"),
      (this.parameters = { points: e, segments: t, phiStart: i, phiLength: r }),
      (t = Math.floor(t)),
      (r = pn(r, 0, Math.PI * 2)));
    const s = [],
      o = [],
      a = [],
      l = [],
      u = [],
      h = 1 / t,
      d = new F(),
      p = new ve(),
      g = new F(),
      y = new F(),
      A = new F();
    let _ = 0,
      m = 0;
    for (let x = 0; x <= e.length - 1; x++)
      switch (x) {
        case 0:
          ((_ = e[x + 1].x - e[x].x),
            (m = e[x + 1].y - e[x].y),
            (g.x = m * 1),
            (g.y = -_),
            (g.z = m * 0),
            A.copy(g),
            g.normalize(),
            l.push(g.x, g.y, g.z));
          break;
        case e.length - 1:
          l.push(A.x, A.y, A.z);
          break;
        default:
          ((_ = e[x + 1].x - e[x].x),
            (m = e[x + 1].y - e[x].y),
            (g.x = m * 1),
            (g.y = -_),
            (g.z = m * 0),
            y.copy(g),
            (g.x += A.x),
            (g.y += A.y),
            (g.z += A.z),
            g.normalize(),
            l.push(g.x, g.y, g.z),
            A.copy(y));
      }
    for (let x = 0; x <= t; x++) {
      const S = i + x * h * r,
        w = Math.sin(S),
        C = Math.cos(S);
      for (let P = 0; P <= e.length - 1; P++) {
        ((d.x = e[P].x * w),
          (d.y = e[P].y),
          (d.z = e[P].x * C),
          o.push(d.x, d.y, d.z),
          (p.x = x / t),
          (p.y = P / (e.length - 1)),
          a.push(p.x, p.y));
        const R = l[3 * P + 0] * w,
          B = l[3 * P + 1],
          b = l[3 * P + 0] * C;
        u.push(R, B, b);
      }
    }
    for (let x = 0; x < t; x++)
      for (let S = 0; S < e.length - 1; S++) {
        const w = S + x * e.length,
          C = w,
          P = w + e.length,
          R = w + e.length + 1,
          B = w + 1;
        (s.push(C, P, B), s.push(R, B, P));
      }
    (this.setIndex(s),
      this.setAttribute("position", new Ve(o, 3)),
      this.setAttribute("uv", new Ve(a, 2)),
      this.setAttribute("normal", new Ve(u, 3)));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new ou(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class Ph extends ou {
  constructor(e = 1, t = 1, i = 4, r = 8) {
    const s = new rh();
    (s.absarc(0, -t / 2, e, Math.PI * 1.5, 0),
      s.absarc(0, t / 2, e, 0, Math.PI * 0.5),
      super(s.getPoints(i), r),
      (this.type = "CapsuleGeometry"),
      (this.parameters = {
        radius: e,
        height: t,
        capSegments: i,
        radialSegments: r,
      }));
  }
  static fromJSON(e) {
    return new Ph(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class Bh extends ft {
  constructor(e = 1, t = 32, i = 0, r = Math.PI * 2) {
    (super(),
      (this.type = "CircleGeometry"),
      (this.parameters = {
        radius: e,
        segments: t,
        thetaStart: i,
        thetaLength: r,
      }),
      (t = Math.max(3, t)));
    const s = [],
      o = [],
      a = [],
      l = [],
      u = new F(),
      h = new ve();
    (o.push(0, 0, 0), a.push(0, 0, 1), l.push(0.5, 0.5));
    for (let d = 0, p = 3; d <= t; d++, p += 3) {
      const g = i + (d / t) * r;
      ((u.x = e * Math.cos(g)),
        (u.y = e * Math.sin(g)),
        o.push(u.x, u.y, u.z),
        a.push(0, 0, 1),
        (h.x = (o[p] / e + 1) / 2),
        (h.y = (o[p + 1] / e + 1) / 2),
        l.push(h.x, h.y));
    }
    for (let d = 1; d <= t; d++) s.push(d, d + 1, 0);
    (this.setIndex(s),
      this.setAttribute("position", new Ve(o, 3)),
      this.setAttribute("normal", new Ve(a, 3)),
      this.setAttribute("uv", new Ve(l, 2)));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new Bh(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class dl extends ft {
  constructor(
    e = 1,
    t = 1,
    i = 1,
    r = 32,
    s = 1,
    o = !1,
    a = 0,
    l = Math.PI * 2
  ) {
    (super(),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: t,
        height: i,
        radialSegments: r,
        heightSegments: s,
        openEnded: o,
        thetaStart: a,
        thetaLength: l,
      }));
    const u = this;
    ((r = Math.floor(r)), (s = Math.floor(s)));
    const h = [],
      d = [],
      p = [],
      g = [];
    let y = 0;
    const A = [],
      _ = i / 2;
    let m = 0;
    (x(),
      o === !1 && (e > 0 && S(!0), t > 0 && S(!1)),
      this.setIndex(h),
      this.setAttribute("position", new Ve(d, 3)),
      this.setAttribute("normal", new Ve(p, 3)),
      this.setAttribute("uv", new Ve(g, 2)));
    function x() {
      const w = new F(),
        C = new F();
      let P = 0;
      const R = (t - e) / i;
      for (let B = 0; B <= s; B++) {
        const b = [],
          L = B / s,
          U = L * (t - e) + e;
        for (let J = 0; J <= r; J++) {
          const V = J / r,
            j = V * l + a,
            X = Math.sin(j),
            oe = Math.cos(j);
          ((C.x = U * X),
            (C.y = -L * i + _),
            (C.z = U * oe),
            d.push(C.x, C.y, C.z),
            w.set(X, R, oe).normalize(),
            p.push(w.x, w.y, w.z),
            g.push(V, 1 - L),
            b.push(y++));
        }
        A.push(b);
      }
      for (let B = 0; B < r; B++)
        for (let b = 0; b < s; b++) {
          const L = A[b][B],
            U = A[b + 1][B],
            J = A[b + 1][B + 1],
            V = A[b][B + 1];
          (h.push(L, U, V), h.push(U, J, V), (P += 6));
        }
      (u.addGroup(m, P, 0), (m += P));
    }
    function S(w) {
      const C = y,
        P = new ve(),
        R = new F();
      let B = 0;
      const b = w === !0 ? e : t,
        L = w === !0 ? 1 : -1;
      for (let J = 1; J <= r; J++)
        (d.push(0, _ * L, 0), p.push(0, L, 0), g.push(0.5, 0.5), y++);
      const U = y;
      for (let J = 0; J <= r; J++) {
        const j = (J / r) * l + a,
          X = Math.cos(j),
          oe = Math.sin(j);
        ((R.x = b * oe),
          (R.y = _ * L),
          (R.z = b * X),
          d.push(R.x, R.y, R.z),
          p.push(0, L, 0),
          (P.x = X * 0.5 + 0.5),
          (P.y = oe * 0.5 * L + 0.5),
          g.push(P.x, P.y),
          y++);
      }
      for (let J = 0; J < r; J++) {
        const V = C + J,
          j = U + J;
        (w === !0 ? h.push(j, j + 1, V) : h.push(j + 1, j, V), (B += 3));
      }
      (u.addGroup(m, B, w === !0 ? 1 : 2), (m += B));
    }
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new dl(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Rh extends dl {
  constructor(e = 1, t = 1, i = 32, r = 1, s = !1, o = 0, a = Math.PI * 2) {
    (super(0, e, t, i, r, s, o, a),
      (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: e,
        height: t,
        radialSegments: i,
        heightSegments: r,
        openEnded: s,
        thetaStart: o,
        thetaLength: a,
      }));
  }
  static fromJSON(e) {
    return new Rh(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class to extends ft {
  constructor(e = [], t = [], i = 1, r = 0) {
    (super(),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = { vertices: e, indices: t, radius: i, detail: r }));
    const s = [],
      o = [];
    (a(r),
      u(i),
      h(),
      this.setAttribute("position", new Ve(s, 3)),
      this.setAttribute("normal", new Ve(s.slice(), 3)),
      this.setAttribute("uv", new Ve(o, 2)),
      r === 0 ? this.computeVertexNormals() : this.normalizeNormals());
    function a(x) {
      const S = new F(),
        w = new F(),
        C = new F();
      for (let P = 0; P < t.length; P += 3)
        (g(t[P + 0], S), g(t[P + 1], w), g(t[P + 2], C), l(S, w, C, x));
    }
    function l(x, S, w, C) {
      const P = C + 1,
        R = [];
      for (let B = 0; B <= P; B++) {
        R[B] = [];
        const b = x.clone().lerp(w, B / P),
          L = S.clone().lerp(w, B / P),
          U = P - B;
        for (let J = 0; J <= U; J++)
          J === 0 && B === P
            ? (R[B][J] = b)
            : (R[B][J] = b.clone().lerp(L, J / U));
      }
      for (let B = 0; B < P; B++)
        for (let b = 0; b < 2 * (P - B) - 1; b++) {
          const L = Math.floor(b / 2);
          b % 2 === 0
            ? (p(R[B][L + 1]), p(R[B + 1][L]), p(R[B][L]))
            : (p(R[B][L + 1]), p(R[B + 1][L + 1]), p(R[B + 1][L]));
        }
    }
    function u(x) {
      const S = new F();
      for (let w = 0; w < s.length; w += 3)
        ((S.x = s[w + 0]),
          (S.y = s[w + 1]),
          (S.z = s[w + 2]),
          S.normalize().multiplyScalar(x),
          (s[w + 0] = S.x),
          (s[w + 1] = S.y),
          (s[w + 2] = S.z));
    }
    function h() {
      const x = new F();
      for (let S = 0; S < s.length; S += 3) {
        ((x.x = s[S + 0]), (x.y = s[S + 1]), (x.z = s[S + 2]));
        const w = _(x) / 2 / Math.PI + 0.5,
          C = m(x) / Math.PI + 0.5;
        o.push(w, 1 - C);
      }
      (y(), d());
    }
    function d() {
      for (let x = 0; x < o.length; x += 6) {
        const S = o[x + 0],
          w = o[x + 2],
          C = o[x + 4],
          P = Math.max(S, w, C),
          R = Math.min(S, w, C);
        P > 0.9 &&
          R < 0.1 &&
          (S < 0.2 && (o[x + 0] += 1),
          w < 0.2 && (o[x + 2] += 1),
          C < 0.2 && (o[x + 4] += 1));
      }
    }
    function p(x) {
      s.push(x.x, x.y, x.z);
    }
    function g(x, S) {
      const w = x * 3;
      ((S.x = e[w + 0]), (S.y = e[w + 1]), (S.z = e[w + 2]));
    }
    function y() {
      const x = new F(),
        S = new F(),
        w = new F(),
        C = new F(),
        P = new ve(),
        R = new ve(),
        B = new ve();
      for (let b = 0, L = 0; b < s.length; b += 9, L += 6) {
        (x.set(s[b + 0], s[b + 1], s[b + 2]),
          S.set(s[b + 3], s[b + 4], s[b + 5]),
          w.set(s[b + 6], s[b + 7], s[b + 8]),
          P.set(o[L + 0], o[L + 1]),
          R.set(o[L + 2], o[L + 3]),
          B.set(o[L + 4], o[L + 5]),
          C.copy(x).add(S).add(w).divideScalar(3));
        const U = _(C);
        (A(P, L + 0, x, U), A(R, L + 2, S, U), A(B, L + 4, w, U));
      }
    }
    function A(x, S, w, C) {
      (C < 0 && x.x === 1 && (o[S] = x.x - 1),
        w.x === 0 && w.z === 0 && (o[S] = C / 2 / Math.PI + 0.5));
    }
    function _(x) {
      return Math.atan2(x.z, -x.x);
    }
    function m(x) {
      return Math.atan2(-x.y, Math.sqrt(x.x * x.x + x.z * x.z));
    }
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new to(e.vertices, e.indices, e.radius, e.details);
  }
}
class Lh extends to {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2,
      r = 1 / i,
      s = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -r,
        -i,
        0,
        -r,
        i,
        0,
        r,
        -i,
        0,
        r,
        i,
        -r,
        -i,
        0,
        -r,
        i,
        0,
        r,
        -i,
        0,
        r,
        i,
        0,
        -i,
        0,
        -r,
        i,
        0,
        -r,
        -i,
        0,
        r,
        i,
        0,
        r,
      ],
      o = [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ];
    (super(s, o, e, t),
      (this.type = "DodecahedronGeometry"),
      (this.parameters = { radius: e, detail: t }));
  }
  static fromJSON(e) {
    return new Lh(e.radius, e.detail);
  }
}
const Np = new F(),
  kp = new F(),
  uy = new F(),
  Op = new bi();
class cR extends ft {
  constructor(e = null, t = 1) {
    if (
      (super(),
      (this.type = "EdgesGeometry"),
      (this.parameters = { geometry: e, thresholdAngle: t }),
      e !== null)
    ) {
      const r = Math.pow(10, 4),
        s = Math.cos(Za * t),
        o = e.getIndex(),
        a = e.getAttribute("position"),
        l = o ? o.count : a.count,
        u = [0, 0, 0],
        h = ["a", "b", "c"],
        d = new Array(3),
        p = {},
        g = [];
      for (let y = 0; y < l; y += 3) {
        o
          ? ((u[0] = o.getX(y)), (u[1] = o.getX(y + 1)), (u[2] = o.getX(y + 2)))
          : ((u[0] = y), (u[1] = y + 1), (u[2] = y + 2));
        const { a: A, b: _, c: m } = Op;
        if (
          (A.fromBufferAttribute(a, u[0]),
          _.fromBufferAttribute(a, u[1]),
          m.fromBufferAttribute(a, u[2]),
          Op.getNormal(uy),
          (d[0] = `${Math.round(A.x * r)},${Math.round(A.y * r)},${Math.round(A.z * r)}`),
          (d[1] = `${Math.round(_.x * r)},${Math.round(_.y * r)},${Math.round(_.z * r)}`),
          (d[2] = `${Math.round(m.x * r)},${Math.round(m.y * r)},${Math.round(m.z * r)}`),
          !(d[0] === d[1] || d[1] === d[2] || d[2] === d[0]))
        )
          for (let x = 0; x < 3; x++) {
            const S = (x + 1) % 3,
              w = d[x],
              C = d[S],
              P = Op[h[x]],
              R = Op[h[S]],
              B = `${w}_${C}`,
              b = `${C}_${w}`;
            b in p && p[b]
              ? (uy.dot(p[b].normal) <= s &&
                  (g.push(P.x, P.y, P.z), g.push(R.x, R.y, R.z)),
                (p[b] = null))
              : B in p ||
                (p[B] = { index0: u[x], index1: u[S], normal: uy.clone() });
          }
      }
      for (const y in p)
        if (p[y]) {
          const { index0: A, index1: _ } = p[y];
          (Np.fromBufferAttribute(a, A),
            kp.fromBufferAttribute(a, _),
            g.push(Np.x, Np.y, Np.z),
            g.push(kp.x, kp.y, kp.z));
        }
      this.setAttribute("position", new Ve(g, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
}
class $a extends rh {
  constructor(e) {
    (super(e), (this.uuid = Ki()), (this.type = "Shape"), (this.holes = []));
  }
  getPointsHoles(e) {
    const t = [];
    for (let i = 0, r = this.holes.length; i < r; i++)
      t[i] = this.holes[i].getPoints(e);
    return t;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    (super.copy(e), (this.holes = []));
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const r = e.holes[t];
      this.holes.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    ((e.uuid = this.uuid), (e.holes = []));
    for (let t = 0, i = this.holes.length; t < i; t++) {
      const r = this.holes[t];
      e.holes.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    (super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []));
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const r = e.holes[t];
      this.holes.push(new rh().fromJSON(r));
    }
    return this;
  }
}
const jG = {
  triangulate: function (n, e, t = 2) {
    const i = e && e.length,
      r = i ? e[0] * t : n.length;
    let s = uR(n, 0, r, t, !0);
    const o = [];
    if (!s || s.next === s.prev) return o;
    let a, l, u, h, d, p, g;
    if ((i && (s = QG(n, e, s, t)), n.length > 80 * t)) {
      ((a = u = n[0]), (l = h = n[1]));
      for (let y = t; y < r; y += t)
        ((d = n[y]),
          (p = n[y + 1]),
          d < a && (a = d),
          p < l && (l = p),
          d > u && (u = d),
          p > h && (h = p));
      ((g = Math.max(u - a, h - l)), (g = g !== 0 ? 32767 / g : 0));
    }
    return (sh(s, o, t, a, l, g, 0), o);
  },
};
function uR(n, e, t, i, r) {
  let s, o;
  if (r === aH(n, e, t, i) > 0)
    for (s = e; s < t; s += i) o = uC(s, n[s], n[s + 1], o);
  else for (s = t - i; s >= e; s -= i) o = uC(s, n[s], n[s + 1], o);
  return (o && jg(o, o.next) && (ah(o), (o = o.next)), o);
}
function al(n, e) {
  if (!n) return n;
  e || (e = n);
  let t = n,
    i;
  do
    if (
      ((i = !1), !t.steiner && (jg(t, t.next) || sn(t.prev, t, t.next) === 0))
    ) {
      if ((ah(t), (t = e = t.prev), t === t.next)) break;
      i = !0;
    } else t = t.next;
  while (i || t !== e);
  return e;
}
function sh(n, e, t, i, r, s, o) {
  if (!n) return;
  !o && s && tH(n, i, r, s);
  let a = n,
    l,
    u;
  for (; n.prev !== n.next; ) {
    if (((l = n.prev), (u = n.next), s ? XG(n, i, r, s) : JG(n))) {
      (e.push((l.i / t) | 0),
        e.push((n.i / t) | 0),
        e.push((u.i / t) | 0),
        ah(n),
        (n = u.next),
        (a = u.next));
      continue;
    }
    if (((n = u), n === a)) {
      o
        ? o === 1
          ? ((n = KG(al(n), e, t)), sh(n, e, t, i, r, s, 2))
          : o === 2 && YG(n, e, t, i, r, s)
        : sh(al(n), e, t, i, r, s, 1);
      break;
    }
  }
}
function JG(n) {
  const e = n.prev,
    t = n,
    i = n.next;
  if (sn(e, t, i) >= 0) return !1;
  const r = e.x,
    s = t.x,
    o = i.x,
    a = e.y,
    l = t.y,
    u = i.y,
    h = r < s ? (r < o ? r : o) : s < o ? s : o,
    d = a < l ? (a < u ? a : u) : l < u ? l : u,
    p = r > s ? (r > o ? r : o) : s > o ? s : o,
    g = a > l ? (a > u ? a : u) : l > u ? l : u;
  let y = i.next;
  for (; y !== e; ) {
    if (
      y.x >= h &&
      y.x <= p &&
      y.y >= d &&
      y.y <= g &&
      xc(r, a, s, l, o, u, y.x, y.y) &&
      sn(y.prev, y, y.next) >= 0
    )
      return !1;
    y = y.next;
  }
  return !0;
}
function XG(n, e, t, i) {
  const r = n.prev,
    s = n,
    o = n.next;
  if (sn(r, s, o) >= 0) return !1;
  const a = r.x,
    l = s.x,
    u = o.x,
    h = r.y,
    d = s.y,
    p = o.y,
    g = a < l ? (a < u ? a : u) : l < u ? l : u,
    y = h < d ? (h < p ? h : p) : d < p ? d : p,
    A = a > l ? (a > u ? a : u) : l > u ? l : u,
    _ = h > d ? (h > p ? h : p) : d > p ? d : p,
    m = v_(g, y, e, t, i),
    x = v_(A, _, e, t, i);
  let S = n.prevZ,
    w = n.nextZ;
  for (; S && S.z >= m && w && w.z <= x; ) {
    if (
      (S.x >= g &&
        S.x <= A &&
        S.y >= y &&
        S.y <= _ &&
        S !== r &&
        S !== o &&
        xc(a, h, l, d, u, p, S.x, S.y) &&
        sn(S.prev, S, S.next) >= 0) ||
      ((S = S.prevZ),
      w.x >= g &&
        w.x <= A &&
        w.y >= y &&
        w.y <= _ &&
        w !== r &&
        w !== o &&
        xc(a, h, l, d, u, p, w.x, w.y) &&
        sn(w.prev, w, w.next) >= 0)
    )
      return !1;
    w = w.nextZ;
  }
  for (; S && S.z >= m; ) {
    if (
      S.x >= g &&
      S.x <= A &&
      S.y >= y &&
      S.y <= _ &&
      S !== r &&
      S !== o &&
      xc(a, h, l, d, u, p, S.x, S.y) &&
      sn(S.prev, S, S.next) >= 0
    )
      return !1;
    S = S.prevZ;
  }
  for (; w && w.z <= x; ) {
    if (
      w.x >= g &&
      w.x <= A &&
      w.y >= y &&
      w.y <= _ &&
      w !== r &&
      w !== o &&
      xc(a, h, l, d, u, p, w.x, w.y) &&
      sn(w.prev, w, w.next) >= 0
    )
      return !1;
    w = w.nextZ;
  }
  return !0;
}
function KG(n, e, t) {
  let i = n;
  do {
    const r = i.prev,
      s = i.next.next;
    (!jg(r, s) &&
      fR(r, i, i.next, s) &&
      oh(r, s) &&
      oh(s, r) &&
      (e.push((r.i / t) | 0),
      e.push((i.i / t) | 0),
      e.push((s.i / t) | 0),
      ah(i),
      ah(i.next),
      (i = n = s)),
      (i = i.next));
  } while (i !== n);
  return al(i);
}
function YG(n, e, t, i, r, s) {
  let o = n;
  do {
    let a = o.next.next;
    for (; a !== o.prev; ) {
      if (o.i !== a.i && rH(o, a)) {
        let l = hR(o, a);
        ((o = al(o, o.next)),
          (l = al(l, l.next)),
          sh(o, e, t, i, r, s, 0),
          sh(l, e, t, i, r, s, 0));
        return;
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== n);
}
function QG(n, e, t, i) {
  const r = [];
  let s, o, a, l, u;
  for (s = 0, o = e.length; s < o; s++)
    ((a = e[s] * i),
      (l = s < o - 1 ? e[s + 1] * i : n.length),
      (u = uR(n, a, l, i, !1)),
      u === u.next && (u.steiner = !0),
      r.push(iH(u)));
  for (r.sort(ZG), s = 0; s < r.length; s++) t = qG(r[s], t);
  return t;
}
function ZG(n, e) {
  return n.x - e.x;
}
function qG(n, e) {
  const t = $G(n, e);
  if (!t) return e;
  const i = hR(t, n);
  return (al(i, i.next), al(t, t.next));
}
function $G(n, e) {
  let t = e,
    i = -1 / 0,
    r;
  const s = n.x,
    o = n.y;
  do {
    if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
      const p = t.x + ((o - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
      if (
        p <= s &&
        p > i &&
        ((i = p), (r = t.x < t.next.x ? t : t.next), p === s)
      )
        return r;
    }
    t = t.next;
  } while (t !== e);
  if (!r) return null;
  const a = r,
    l = r.x,
    u = r.y;
  let h = 1 / 0,
    d;
  t = r;
  do
    (s >= t.x &&
      t.x >= l &&
      s !== t.x &&
      xc(o < u ? s : i, o, l, u, o < u ? i : s, o, t.x, t.y) &&
      ((d = Math.abs(o - t.y) / (s - t.x)),
      oh(t, n) &&
        (d < h || (d === h && (t.x > r.x || (t.x === r.x && eH(r, t))))) &&
        ((r = t), (h = d))),
      (t = t.next));
  while (t !== a);
  return r;
}
function eH(n, e) {
  return sn(n.prev, n, e.prev) < 0 && sn(e.next, n, n.next) < 0;
}
function tH(n, e, t, i) {
  let r = n;
  do
    (r.z === 0 && (r.z = v_(r.x, r.y, e, t, i)),
      (r.prevZ = r.prev),
      (r.nextZ = r.next),
      (r = r.next));
  while (r !== n);
  ((r.prevZ.nextZ = null), (r.prevZ = null), nH(r));
}
function nH(n) {
  let e,
    t,
    i,
    r,
    s,
    o,
    a,
    l,
    u = 1;
  do {
    for (t = n, n = null, s = null, o = 0; t; ) {
      for (o++, i = t, a = 0, e = 0; e < u && (a++, (i = i.nextZ), !!i); e++);
      for (l = u; a > 0 || (l > 0 && i); )
        (a !== 0 && (l === 0 || !i || t.z <= i.z)
          ? ((r = t), (t = t.nextZ), a--)
          : ((r = i), (i = i.nextZ), l--),
          s ? (s.nextZ = r) : (n = r),
          (r.prevZ = s),
          (s = r));
      t = i;
    }
    ((s.nextZ = null), (u *= 2));
  } while (o > 1);
  return n;
}
function v_(n, e, t, i, r) {
  return (
    (n = ((n - t) * r) | 0),
    (e = ((e - i) * r) | 0),
    (n = (n | (n << 8)) & 16711935),
    (n = (n | (n << 4)) & 252645135),
    (n = (n | (n << 2)) & 858993459),
    (n = (n | (n << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    n | (e << 1)
  );
}
function iH(n) {
  let e = n,
    t = n;
  do ((e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next));
  while (e !== n);
  return t;
}
function xc(n, e, t, i, r, s, o, a) {
  return (
    (r - o) * (e - a) >= (n - o) * (s - a) &&
    (n - o) * (i - a) >= (t - o) * (e - a) &&
    (t - o) * (s - a) >= (r - o) * (i - a)
  );
}
function rH(n, e) {
  return (
    n.next.i !== e.i &&
    n.prev.i !== e.i &&
    !sH(n, e) &&
    ((oh(n, e) &&
      oh(e, n) &&
      oH(n, e) &&
      (sn(n.prev, n, e.prev) || sn(n, e.prev, e))) ||
      (jg(n, e) && sn(n.prev, n, n.next) > 0 && sn(e.prev, e, e.next) > 0))
  );
}
function sn(n, e, t) {
  return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y);
}
function jg(n, e) {
  return n.x === e.x && n.y === e.y;
}
function fR(n, e, t, i) {
  const r = zp(sn(n, e, t)),
    s = zp(sn(n, e, i)),
    o = zp(sn(t, i, n)),
    a = zp(sn(t, i, e));
  return !!(
    (r !== s && o !== a) ||
    (r === 0 && Up(n, t, e)) ||
    (s === 0 && Up(n, i, e)) ||
    (o === 0 && Up(t, n, i)) ||
    (a === 0 && Up(t, e, i))
  );
}
function Up(n, e, t) {
  return (
    e.x <= Math.max(n.x, t.x) &&
    e.x >= Math.min(n.x, t.x) &&
    e.y <= Math.max(n.y, t.y) &&
    e.y >= Math.min(n.y, t.y)
  );
}
function zp(n) {
  return n > 0 ? 1 : n < 0 ? -1 : 0;
}
function sH(n, e) {
  let t = n;
  do {
    if (
      t.i !== n.i &&
      t.next.i !== n.i &&
      t.i !== e.i &&
      t.next.i !== e.i &&
      fR(t, t.next, n, e)
    )
      return !0;
    t = t.next;
  } while (t !== n);
  return !1;
}
function oh(n, e) {
  return sn(n.prev, n, n.next) < 0
    ? sn(n, e, n.next) >= 0 && sn(n, n.prev, e) >= 0
    : sn(n, e, n.prev) < 0 || sn(n, n.next, e) < 0;
}
function oH(n, e) {
  let t = n,
    i = !1;
  const r = (n.x + e.x) / 2,
    s = (n.y + e.y) / 2;
  do
    (t.y > s != t.next.y > s &&
      t.next.y !== t.y &&
      r < ((t.next.x - t.x) * (s - t.y)) / (t.next.y - t.y) + t.x &&
      (i = !i),
      (t = t.next));
  while (t !== n);
  return i;
}
function hR(n, e) {
  const t = new y_(n.i, n.x, n.y),
    i = new y_(e.i, e.x, e.y),
    r = n.next,
    s = e.prev;
  return (
    (n.next = e),
    (e.prev = n),
    (t.next = r),
    (r.prev = t),
    (i.next = t),
    (t.prev = i),
    (s.next = i),
    (i.prev = s),
    i
  );
}
function uC(n, e, t, i) {
  const r = new y_(n, e, t);
  return (
    i
      ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
      : ((r.prev = r), (r.next = r)),
    r
  );
}
function ah(n) {
  ((n.next.prev = n.prev),
    (n.prev.next = n.next),
    n.prevZ && (n.prevZ.nextZ = n.nextZ),
    n.nextZ && (n.nextZ.prevZ = n.prevZ));
}
function y_(n, e, t) {
  ((this.i = n),
    (this.x = e),
    (this.y = t),
    (this.prev = null),
    (this.next = null),
    (this.z = 0),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1));
}
function aH(n, e, t, i) {
  let r = 0;
  for (let s = e, o = t - i; s < t; s += i)
    ((r += (n[o] - n[s]) * (n[s + 1] + n[o + 1])), (o = s));
  return r;
}
class ls {
  static area(e) {
    const t = e.length;
    let i = 0;
    for (let r = t - 1, s = 0; s < t; r = s++)
      i += e[r].x * e[s].y - e[s].x * e[r].y;
    return i * 0.5;
  }
  static isClockWise(e) {
    return ls.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const i = [],
      r = [],
      s = [];
    (fC(e), hC(i, e));
    let o = e.length;
    t.forEach(fC);
    for (let l = 0; l < t.length; l++)
      (r.push(o), (o += t[l].length), hC(i, t[l]));
    const a = jG.triangulate(i, r);
    for (let l = 0; l < a.length; l += 3) s.push(a.slice(l, l + 3));
    return s;
  }
}
function fC(n) {
  const e = n.length;
  e > 2 && n[e - 1].equals(n[0]) && n.pop();
}
function hC(n, e) {
  for (let t = 0; t < e.length; t++) (n.push(e[t].x), n.push(e[t].y));
}
class Ih extends ft {
  constructor(
    e = new $a([
      new ve(0.5, 0.5),
      new ve(-0.5, 0.5),
      new ve(-0.5, -0.5),
      new ve(0.5, -0.5),
    ]),
    t = {}
  ) {
    (super(),
      (this.type = "ExtrudeGeometry"),
      (this.parameters = { shapes: e, options: t }),
      (e = Array.isArray(e) ? e : [e]));
    const i = this,
      r = [],
      s = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const u = e[a];
      o(u);
    }
    (this.setAttribute("position", new Ve(r, 3)),
      this.setAttribute("uv", new Ve(s, 2)),
      this.computeVertexNormals());
    function o(a) {
      const l = [],
        u = t.curveSegments !== void 0 ? t.curveSegments : 12,
        h = t.steps !== void 0 ? t.steps : 1,
        d = t.depth !== void 0 ? t.depth : 1;
      let p = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
        g = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
        y = t.bevelSize !== void 0 ? t.bevelSize : g - 0.1,
        A = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
        _ = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const m = t.extrudePath,
        x = t.UVGenerator !== void 0 ? t.UVGenerator : lH;
      let S,
        w = !1,
        C,
        P,
        R,
        B;
      (m &&
        ((S = m.getSpacedPoints(h)),
        (w = !0),
        (p = !1),
        (C = m.computeFrenetFrames(h, !1)),
        (P = new F()),
        (R = new F()),
        (B = new F())),
        p || ((_ = 0), (g = 0), (y = 0), (A = 0)));
      const b = a.extractPoints(u);
      let L = b.shape;
      const U = b.holes;
      if (!ls.isClockWise(L)) {
        L = L.reverse();
        for (let ge = 0, se = U.length; ge < se; ge++) {
          const _e = U[ge];
          ls.isClockWise(_e) && (U[ge] = _e.reverse());
        }
      }
      const V = ls.triangulateShape(L, U),
        j = L;
      for (let ge = 0, se = U.length; ge < se; ge++) {
        const _e = U[ge];
        L = L.concat(_e);
      }
      function X(ge, se, _e) {
        return (
          se || console.error("THREE.ExtrudeGeometry: vec does not exist"),
          ge.clone().addScaledVector(se, _e)
        );
      }
      const oe = L.length,
        ae = V.length;
      function I(ge, se, _e) {
        let Ne, Le, We;
        const Ke = ge.x - se.x,
          je = ge.y - se.y,
          nt = _e.x - ge.x,
          At = _e.y - ge.y,
          O = Ke * Ke + je * je,
          D = Ke * At - je * nt;
        if (Math.abs(D) > Number.EPSILON) {
          const le = Math.sqrt(O),
            Ce = Math.sqrt(nt * nt + At * At),
            Te = se.x - je / le,
            Re = se.y + Ke / le,
            et = _e.x - At / Ce,
            Ue = _e.y + nt / Ce,
            pe = ((et - Te) * At - (Ue - Re) * nt) / (Ke * At - je * nt);
          ((Ne = Te + Ke * pe - ge.x), (Le = Re + je * pe - ge.y));
          const He = Ne * Ne + Le * Le;
          if (He <= 2) return new ve(Ne, Le);
          We = Math.sqrt(He / 2);
        } else {
          let le = !1;
          (Ke > Number.EPSILON
            ? nt > Number.EPSILON && (le = !0)
            : Ke < -Number.EPSILON
              ? nt < -Number.EPSILON && (le = !0)
              : Math.sign(je) === Math.sign(At) && (le = !0),
            le
              ? ((Ne = -je), (Le = Ke), (We = Math.sqrt(O)))
              : ((Ne = Ke), (Le = je), (We = Math.sqrt(O / 2))));
        }
        return new ve(Ne / We, Le / We);
      }
      const G = [];
      for (
        let ge = 0, se = j.length, _e = se - 1, Ne = ge + 1;
        ge < se;
        ge++, _e++, Ne++
      )
        (_e === se && (_e = 0),
          Ne === se && (Ne = 0),
          (G[ge] = I(j[ge], j[_e], j[Ne])));
      const z = [];
      let q,
        Q = G.concat();
      for (let ge = 0, se = U.length; ge < se; ge++) {
        const _e = U[ge];
        q = [];
        for (
          let Ne = 0, Le = _e.length, We = Le - 1, Ke = Ne + 1;
          Ne < Le;
          Ne++, We++, Ke++
        )
          (We === Le && (We = 0),
            Ke === Le && (Ke = 0),
            (q[Ne] = I(_e[Ne], _e[We], _e[Ke])));
        (z.push(q), (Q = Q.concat(q)));
      }
      for (let ge = 0; ge < _; ge++) {
        const se = ge / _,
          _e = g * Math.cos((se * Math.PI) / 2),
          Ne = y * Math.sin((se * Math.PI) / 2) + A;
        for (let Le = 0, We = j.length; Le < We; Le++) {
          const Ke = X(j[Le], G[Le], Ne);
          $(Ke.x, Ke.y, -_e);
        }
        for (let Le = 0, We = U.length; Le < We; Le++) {
          const Ke = U[Le];
          q = z[Le];
          for (let je = 0, nt = Ke.length; je < nt; je++) {
            const At = X(Ke[je], q[je], Ne);
            $(At.x, At.y, -_e);
          }
        }
      }
      const ee = y + A;
      for (let ge = 0; ge < oe; ge++) {
        const se = p ? X(L[ge], Q[ge], ee) : L[ge];
        w
          ? (R.copy(C.normals[0]).multiplyScalar(se.x),
            P.copy(C.binormals[0]).multiplyScalar(se.y),
            B.copy(S[0]).add(R).add(P),
            $(B.x, B.y, B.z))
          : $(se.x, se.y, 0);
      }
      for (let ge = 1; ge <= h; ge++)
        for (let se = 0; se < oe; se++) {
          const _e = p ? X(L[se], Q[se], ee) : L[se];
          w
            ? (R.copy(C.normals[ge]).multiplyScalar(_e.x),
              P.copy(C.binormals[ge]).multiplyScalar(_e.y),
              B.copy(S[ge]).add(R).add(P),
              $(B.x, B.y, B.z))
            : $(_e.x, _e.y, (d / h) * ge);
        }
      for (let ge = _ - 1; ge >= 0; ge--) {
        const se = ge / _,
          _e = g * Math.cos((se * Math.PI) / 2),
          Ne = y * Math.sin((se * Math.PI) / 2) + A;
        for (let Le = 0, We = j.length; Le < We; Le++) {
          const Ke = X(j[Le], G[Le], Ne);
          $(Ke.x, Ke.y, d + _e);
        }
        for (let Le = 0, We = U.length; Le < We; Le++) {
          const Ke = U[Le];
          q = z[Le];
          for (let je = 0, nt = Ke.length; je < nt; je++) {
            const At = X(Ke[je], q[je], Ne);
            w
              ? $(At.x, At.y + S[h - 1].y, S[h - 1].x + _e)
              : $(At.x, At.y, d + _e);
          }
        }
      }
      (ne(), Ee());
      function ne() {
        const ge = r.length / 3;
        if (p) {
          let se = 0,
            _e = oe * se;
          for (let Ne = 0; Ne < ae; Ne++) {
            const Le = V[Ne];
            Je(Le[2] + _e, Le[1] + _e, Le[0] + _e);
          }
          ((se = h + _ * 2), (_e = oe * se));
          for (let Ne = 0; Ne < ae; Ne++) {
            const Le = V[Ne];
            Je(Le[0] + _e, Le[1] + _e, Le[2] + _e);
          }
        } else {
          for (let se = 0; se < ae; se++) {
            const _e = V[se];
            Je(_e[2], _e[1], _e[0]);
          }
          for (let se = 0; se < ae; se++) {
            const _e = V[se];
            Je(_e[0] + oe * h, _e[1] + oe * h, _e[2] + oe * h);
          }
        }
        i.addGroup(ge, r.length / 3 - ge, 0);
      }
      function Ee() {
        const ge = r.length / 3;
        let se = 0;
        (Ae(j, se), (se += j.length));
        for (let _e = 0, Ne = U.length; _e < Ne; _e++) {
          const Le = U[_e];
          (Ae(Le, se), (se += Le.length));
        }
        i.addGroup(ge, r.length / 3 - ge, 1);
      }
      function Ae(ge, se) {
        let _e = ge.length;
        for (; --_e >= 0; ) {
          const Ne = _e;
          let Le = _e - 1;
          Le < 0 && (Le = ge.length - 1);
          for (let We = 0, Ke = h + _ * 2; We < Ke; We++) {
            const je = oe * We,
              nt = oe * (We + 1),
              At = se + Ne + je,
              O = se + Le + je,
              D = se + Le + nt,
              le = se + Ne + nt;
            Xe(At, O, D, le);
          }
        }
      }
      function $(ge, se, _e) {
        (l.push(ge), l.push(se), l.push(_e));
      }
      function Je(ge, se, _e) {
        (xe(ge), xe(se), xe(_e));
        const Ne = r.length / 3,
          Le = x.generateTopUV(i, r, Ne - 3, Ne - 2, Ne - 1);
        (Se(Le[0]), Se(Le[1]), Se(Le[2]));
      }
      function Xe(ge, se, _e, Ne) {
        (xe(ge), xe(se), xe(Ne), xe(se), xe(_e), xe(Ne));
        const Le = r.length / 3,
          We = x.generateSideWallUV(i, r, Le - 6, Le - 3, Le - 2, Le - 1);
        (Se(We[0]), Se(We[1]), Se(We[3]), Se(We[1]), Se(We[2]), Se(We[3]));
      }
      function xe(ge) {
        (r.push(l[ge * 3 + 0]), r.push(l[ge * 3 + 1]), r.push(l[ge * 3 + 2]));
      }
      function Se(ge) {
        (s.push(ge.x), s.push(ge.y));
      }
    }
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes,
      i = this.parameters.options;
    return cH(t, i, e);
  }
  static fromJSON(e, t) {
    const i = [];
    for (let s = 0, o = e.shapes.length; s < o; s++) {
      const a = t[e.shapes[s]];
      i.push(a);
    }
    const r = e.options.extrudePath;
    return (
      r !== void 0 && (e.options.extrudePath = new xA[r.type]().fromJSON(r)),
      new Ih(i, e.options)
    );
  }
}
const lH = {
  generateTopUV: function (n, e, t, i, r) {
    const s = e[t * 3],
      o = e[t * 3 + 1],
      a = e[i * 3],
      l = e[i * 3 + 1],
      u = e[r * 3],
      h = e[r * 3 + 1];
    return [new ve(s, o), new ve(a, l), new ve(u, h)];
  },
  generateSideWallUV: function (n, e, t, i, r, s) {
    const o = e[t * 3],
      a = e[t * 3 + 1],
      l = e[t * 3 + 2],
      u = e[i * 3],
      h = e[i * 3 + 1],
      d = e[i * 3 + 2],
      p = e[r * 3],
      g = e[r * 3 + 1],
      y = e[r * 3 + 2],
      A = e[s * 3],
      _ = e[s * 3 + 1],
      m = e[s * 3 + 2];
    return Math.abs(a - h) < Math.abs(o - u)
      ? [new ve(o, 1 - l), new ve(u, 1 - d), new ve(p, 1 - y), new ve(A, 1 - m)]
      : [
          new ve(a, 1 - l),
          new ve(h, 1 - d),
          new ve(g, 1 - y),
          new ve(_, 1 - m),
        ];
  },
};
function cH(n, e, t) {
  if (((t.shapes = []), Array.isArray(n)))
    for (let i = 0, r = n.length; i < r; i++) {
      const s = n[i];
      t.shapes.push(s.uuid);
    }
  else t.shapes.push(n.uuid);
  return (
    (t.options = Object.assign({}, e)),
    e.extrudePath !== void 0 &&
      (t.options.extrudePath = e.extrudePath.toJSON()),
    t
  );
}
class Dh extends to {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2,
      r = [
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        0,
        0,
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        i,
        0,
        -1,
        i,
        0,
        1,
        -i,
        0,
        -1,
        -i,
        0,
        1,
      ],
      s = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ];
    (super(r, s, e, t),
      (this.type = "IcosahedronGeometry"),
      (this.parameters = { radius: e, detail: t }));
  }
  static fromJSON(e) {
    return new Dh(e.radius, e.detail);
  }
}
class au extends to {
  constructor(e = 1, t = 0) {
    const i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      r = [
        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2,
      ];
    (super(i, r, e, t),
      (this.type = "OctahedronGeometry"),
      (this.parameters = { radius: e, detail: t }));
  }
  static fromJSON(e) {
    return new au(e.radius, e.detail);
  }
}
class Fh extends ft {
  constructor(e = 0.5, t = 1, i = 32, r = 1, s = 0, o = Math.PI * 2) {
    (super(),
      (this.type = "RingGeometry"),
      (this.parameters = {
        innerRadius: e,
        outerRadius: t,
        thetaSegments: i,
        phiSegments: r,
        thetaStart: s,
        thetaLength: o,
      }),
      (i = Math.max(3, i)),
      (r = Math.max(1, r)));
    const a = [],
      l = [],
      u = [],
      h = [];
    let d = e;
    const p = (t - e) / r,
      g = new F(),
      y = new ve();
    for (let A = 0; A <= r; A++) {
      for (let _ = 0; _ <= i; _++) {
        const m = s + (_ / i) * o;
        ((g.x = d * Math.cos(m)),
          (g.y = d * Math.sin(m)),
          l.push(g.x, g.y, g.z),
          u.push(0, 0, 1),
          (y.x = (g.x / t + 1) / 2),
          (y.y = (g.y / t + 1) / 2),
          h.push(y.x, y.y));
      }
      d += p;
    }
    for (let A = 0; A < r; A++) {
      const _ = A * (i + 1);
      for (let m = 0; m < i; m++) {
        const x = m + _,
          S = x,
          w = x + i + 1,
          C = x + i + 2,
          P = x + 1;
        (a.push(S, w, P), a.push(w, C, P));
      }
    }
    (this.setIndex(a),
      this.setAttribute("position", new Ve(l, 3)),
      this.setAttribute("normal", new Ve(u, 3)),
      this.setAttribute("uv", new Ve(h, 2)));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new Fh(
      e.innerRadius,
      e.outerRadius,
      e.thetaSegments,
      e.phiSegments,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Nh extends ft {
  constructor(
    e = new $a([new ve(0, 0.5), new ve(-0.5, -0.5), new ve(0.5, -0.5)]),
    t = 12
  ) {
    (super(),
      (this.type = "ShapeGeometry"),
      (this.parameters = { shapes: e, curveSegments: t }));
    const i = [],
      r = [],
      s = [],
      o = [];
    let a = 0,
      l = 0;
    if (Array.isArray(e) === !1) u(e);
    else
      for (let h = 0; h < e.length; h++)
        (u(e[h]), this.addGroup(a, l, h), (a += l), (l = 0));
    (this.setIndex(i),
      this.setAttribute("position", new Ve(r, 3)),
      this.setAttribute("normal", new Ve(s, 3)),
      this.setAttribute("uv", new Ve(o, 2)));
    function u(h) {
      const d = r.length / 3,
        p = h.extractPoints(t);
      let g = p.shape;
      const y = p.holes;
      ls.isClockWise(g) === !1 && (g = g.reverse());
      for (let _ = 0, m = y.length; _ < m; _++) {
        const x = y[_];
        ls.isClockWise(x) === !0 && (y[_] = x.reverse());
      }
      const A = ls.triangulateShape(g, y);
      for (let _ = 0, m = y.length; _ < m; _++) {
        const x = y[_];
        g = g.concat(x);
      }
      for (let _ = 0, m = g.length; _ < m; _++) {
        const x = g[_];
        (r.push(x.x, x.y, 0), s.push(0, 0, 1), o.push(x.x, x.y));
      }
      for (let _ = 0, m = A.length; _ < m; _++) {
        const x = A[_],
          S = x[0] + d,
          w = x[1] + d,
          C = x[2] + d;
        (i.push(S, w, C), (l += 3));
      }
    }
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes;
    return uH(t, e);
  }
  static fromJSON(e, t) {
    const i = [];
    for (let r = 0, s = e.shapes.length; r < s; r++) {
      const o = t[e.shapes[r]];
      i.push(o);
    }
    return new Nh(i, e.curveSegments);
  }
}
function uH(n, e) {
  if (((e.shapes = []), Array.isArray(n)))
    for (let t = 0, i = n.length; t < i; t++) {
      const r = n[t];
      e.shapes.push(r.uuid);
    }
  else e.shapes.push(n.uuid);
  return e;
}
class lu extends ft {
  constructor(
    e = 1,
    t = 32,
    i = 16,
    r = 0,
    s = Math.PI * 2,
    o = 0,
    a = Math.PI
  ) {
    (super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: i,
        phiStart: r,
        phiLength: s,
        thetaStart: o,
        thetaLength: a,
      }),
      (t = Math.max(3, Math.floor(t))),
      (i = Math.max(2, Math.floor(i))));
    const l = Math.min(o + a, Math.PI);
    let u = 0;
    const h = [],
      d = new F(),
      p = new F(),
      g = [],
      y = [],
      A = [],
      _ = [];
    for (let m = 0; m <= i; m++) {
      const x = [],
        S = m / i;
      let w = 0;
      m === 0 && o === 0
        ? (w = 0.5 / t)
        : m === i && l === Math.PI && (w = -0.5 / t);
      for (let C = 0; C <= t; C++) {
        const P = C / t;
        ((d.x = -e * Math.cos(r + P * s) * Math.sin(o + S * a)),
          (d.y = e * Math.cos(o + S * a)),
          (d.z = e * Math.sin(r + P * s) * Math.sin(o + S * a)),
          y.push(d.x, d.y, d.z),
          p.copy(d).normalize(),
          A.push(p.x, p.y, p.z),
          _.push(P + w, 1 - S),
          x.push(u++));
      }
      h.push(x);
    }
    for (let m = 0; m < i; m++)
      for (let x = 0; x < t; x++) {
        const S = h[m][x + 1],
          w = h[m][x],
          C = h[m + 1][x],
          P = h[m + 1][x + 1];
        ((m !== 0 || o > 0) && g.push(S, w, P),
          (m !== i - 1 || l < Math.PI) && g.push(w, C, P));
      }
    (this.setIndex(g),
      this.setAttribute("position", new Ve(y, 3)),
      this.setAttribute("normal", new Ve(A, 3)),
      this.setAttribute("uv", new Ve(_, 2)));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new lu(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class kh extends to {
  constructor(e = 1, t = 0) {
    const i = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    (super(i, r, e, t),
      (this.type = "TetrahedronGeometry"),
      (this.parameters = { radius: e, detail: t }));
  }
  static fromJSON(e) {
    return new kh(e.radius, e.detail);
  }
}
class Oh extends ft {
  constructor(e = 1, t = 0.4, i = 12, r = 48, s = Math.PI * 2) {
    (super(),
      (this.type = "TorusGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        radialSegments: i,
        tubularSegments: r,
        arc: s,
      }),
      (i = Math.floor(i)),
      (r = Math.floor(r)));
    const o = [],
      a = [],
      l = [],
      u = [],
      h = new F(),
      d = new F(),
      p = new F();
    for (let g = 0; g <= i; g++)
      for (let y = 0; y <= r; y++) {
        const A = (y / r) * s,
          _ = (g / i) * Math.PI * 2;
        ((d.x = (e + t * Math.cos(_)) * Math.cos(A)),
          (d.y = (e + t * Math.cos(_)) * Math.sin(A)),
          (d.z = t * Math.sin(_)),
          a.push(d.x, d.y, d.z),
          (h.x = e * Math.cos(A)),
          (h.y = e * Math.sin(A)),
          p.subVectors(d, h).normalize(),
          l.push(p.x, p.y, p.z),
          u.push(y / r),
          u.push(g / i));
      }
    for (let g = 1; g <= i; g++)
      for (let y = 1; y <= r; y++) {
        const A = (r + 1) * g + y - 1,
          _ = (r + 1) * (g - 1) + y - 1,
          m = (r + 1) * (g - 1) + y,
          x = (r + 1) * g + y;
        (o.push(A, _, x), o.push(_, m, x));
      }
    (this.setIndex(o),
      this.setAttribute("position", new Ve(a, 3)),
      this.setAttribute("normal", new Ve(l, 3)),
      this.setAttribute("uv", new Ve(u, 2)));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new Oh(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class Uh extends ft {
  constructor(e = 1, t = 0.4, i = 64, r = 8, s = 2, o = 3) {
    (super(),
      (this.type = "TorusKnotGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        tubularSegments: i,
        radialSegments: r,
        p: s,
        q: o,
      }),
      (i = Math.floor(i)),
      (r = Math.floor(r)));
    const a = [],
      l = [],
      u = [],
      h = [],
      d = new F(),
      p = new F(),
      g = new F(),
      y = new F(),
      A = new F(),
      _ = new F(),
      m = new F();
    for (let S = 0; S <= i; ++S) {
      const w = (S / i) * s * Math.PI * 2;
      (x(w, s, o, e, g),
        x(w + 0.01, s, o, e, y),
        _.subVectors(y, g),
        m.addVectors(y, g),
        A.crossVectors(_, m),
        m.crossVectors(A, _),
        A.normalize(),
        m.normalize());
      for (let C = 0; C <= r; ++C) {
        const P = (C / r) * Math.PI * 2,
          R = -t * Math.cos(P),
          B = t * Math.sin(P);
        ((d.x = g.x + (R * m.x + B * A.x)),
          (d.y = g.y + (R * m.y + B * A.y)),
          (d.z = g.z + (R * m.z + B * A.z)),
          l.push(d.x, d.y, d.z),
          p.subVectors(d, g).normalize(),
          u.push(p.x, p.y, p.z),
          h.push(S / i),
          h.push(C / r));
      }
    }
    for (let S = 1; S <= i; S++)
      for (let w = 1; w <= r; w++) {
        const C = (r + 1) * (S - 1) + (w - 1),
          P = (r + 1) * S + (w - 1),
          R = (r + 1) * S + w,
          B = (r + 1) * (S - 1) + w;
        (a.push(C, P, B), a.push(P, R, B));
      }
    (this.setIndex(a),
      this.setAttribute("position", new Ve(l, 3)),
      this.setAttribute("normal", new Ve(u, 3)),
      this.setAttribute("uv", new Ve(h, 2)));
    function x(S, w, C, P, R) {
      const B = Math.cos(S),
        b = Math.sin(S),
        L = (C / w) * S,
        U = Math.cos(L);
      ((R.x = P * (2 + U) * 0.5 * B),
        (R.y = P * (2 + U) * b * 0.5),
        (R.z = P * Math.sin(L) * 0.5));
    }
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new Uh(
      e.radius,
      e.tube,
      e.tubularSegments,
      e.radialSegments,
      e.p,
      e.q
    );
  }
}
class zh extends ft {
  constructor(
    e = new vA(new F(-1, -1, 0), new F(-1, 1, 0), new F(1, 1, 0)),
    t = 64,
    i = 1,
    r = 8,
    s = !1
  ) {
    (super(),
      (this.type = "TubeGeometry"),
      (this.parameters = {
        path: e,
        tubularSegments: t,
        radius: i,
        radialSegments: r,
        closed: s,
      }));
    const o = e.computeFrenetFrames(t, s);
    ((this.tangents = o.tangents),
      (this.normals = o.normals),
      (this.binormals = o.binormals));
    const a = new F(),
      l = new F(),
      u = new ve();
    let h = new F();
    const d = [],
      p = [],
      g = [],
      y = [];
    (A(),
      this.setIndex(y),
      this.setAttribute("position", new Ve(d, 3)),
      this.setAttribute("normal", new Ve(p, 3)),
      this.setAttribute("uv", new Ve(g, 2)));
    function A() {
      for (let S = 0; S < t; S++) _(S);
      (_(s === !1 ? t : 0), x(), m());
    }
    function _(S) {
      h = e.getPointAt(S / t, h);
      const w = o.normals[S],
        C = o.binormals[S];
      for (let P = 0; P <= r; P++) {
        const R = (P / r) * Math.PI * 2,
          B = Math.sin(R),
          b = -Math.cos(R);
        ((l.x = b * w.x + B * C.x),
          (l.y = b * w.y + B * C.y),
          (l.z = b * w.z + B * C.z),
          l.normalize(),
          p.push(l.x, l.y, l.z),
          (a.x = h.x + i * l.x),
          (a.y = h.y + i * l.y),
          (a.z = h.z + i * l.z),
          d.push(a.x, a.y, a.z));
      }
    }
    function m() {
      for (let S = 1; S <= t; S++)
        for (let w = 1; w <= r; w++) {
          const C = (r + 1) * (S - 1) + (w - 1),
            P = (r + 1) * S + (w - 1),
            R = (r + 1) * S + w,
            B = (r + 1) * (S - 1) + w;
          (y.push(C, P, B), y.push(P, R, B));
        }
    }
    function x() {
      for (let S = 0; S <= t; S++)
        for (let w = 0; w <= r; w++)
          ((u.x = S / t), (u.y = w / r), g.push(u.x, u.y));
    }
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return ((e.path = this.parameters.path.toJSON()), e);
  }
  static fromJSON(e) {
    return new zh(
      new xA[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class dR extends ft {
  constructor(e = null) {
    if (
      (super(),
      (this.type = "WireframeGeometry"),
      (this.parameters = { geometry: e }),
      e !== null)
    ) {
      const t = [],
        i = new Set(),
        r = new F(),
        s = new F();
      if (e.index !== null) {
        const o = e.attributes.position,
          a = e.index;
        let l = e.groups;
        l.length === 0 &&
          (l = [{ start: 0, count: a.count, materialIndex: 0 }]);
        for (let u = 0, h = l.length; u < h; ++u) {
          const d = l[u],
            p = d.start,
            g = d.count;
          for (let y = p, A = p + g; y < A; y += 3)
            for (let _ = 0; _ < 3; _++) {
              const m = a.getX(y + _),
                x = a.getX(y + ((_ + 1) % 3));
              (r.fromBufferAttribute(o, m),
                s.fromBufferAttribute(o, x),
                dC(r, s, i) === !0 &&
                  (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z)));
            }
        }
      } else {
        const o = e.attributes.position;
        for (let a = 0, l = o.count / 3; a < l; a++)
          for (let u = 0; u < 3; u++) {
            const h = 3 * a + u,
              d = 3 * a + ((u + 1) % 3);
            (r.fromBufferAttribute(o, h),
              s.fromBufferAttribute(o, d),
              dC(r, s, i) === !0 &&
                (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z)));
          }
      }
      this.setAttribute("position", new Ve(t, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
}
function dC(n, e, t) {
  const i = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`,
    r = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
  return t.has(i) === !0 || t.has(r) === !0 ? !1 : (t.add(i), t.add(r), !0);
}
var pC = Object.freeze({
  __proto__: null,
  BoxGeometry: na,
  CapsuleGeometry: Ph,
  CircleGeometry: Bh,
  ConeGeometry: Rh,
  CylinderGeometry: dl,
  DodecahedronGeometry: Lh,
  EdgesGeometry: cR,
  ExtrudeGeometry: Ih,
  IcosahedronGeometry: Dh,
  LatheGeometry: ou,
  OctahedronGeometry: au,
  PlaneGeometry: ru,
  PolyhedronGeometry: to,
  RingGeometry: Fh,
  ShapeGeometry: Nh,
  SphereGeometry: lu,
  TetrahedronGeometry: kh,
  TorusGeometry: Oh,
  TorusKnotGeometry: Uh,
  TubeGeometry: zh,
  WireframeGeometry: dR,
});
class pR extends En {
  constructor(e) {
    (super(),
      (this.isShadowMaterial = !0),
      (this.type = "ShadowMaterial"),
      (this.color = new Ie(0)),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (super.copy(e), this.color.copy(e.color), (this.fog = e.fog), this);
  }
}
class mR extends ds {
  constructor(e) {
    (super(e),
      (this.isRawShaderMaterial = !0),
      (this.type = "RawShaderMaterial"));
  }
}
class cu extends En {
  constructor(e) {
    (super(),
      (this.isMeshStandardMaterial = !0),
      (this.defines = { STANDARD: "" }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new Ie(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Ie(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = eo),
      (this.normalScale = new ve(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class no extends cu {
  constructor(e) {
    (super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new ve(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return pn((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new Ie(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new Ie(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new Ie(1, 1, 1)),
      (this.specularColorMap = null),
      (this._sheen = 0),
      (this._clearcoat = 0),
      (this._iridescence = 0),
      (this._transmission = 0),
      this.setValues(e));
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    (this._sheen > 0 != e > 0 && this.version++, (this._sheen = e));
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    (this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e));
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    (this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e));
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    (this._transmission > 0 != e > 0 && this.version++,
      (this._transmission = e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
class gR extends En {
  constructor(e) {
    (super(),
      (this.isMeshPhongMaterial = !0),
      (this.type = "MeshPhongMaterial"),
      (this.color = new Ie(16777215)),
      (this.specular = new Ie(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Ie(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = eo),
      (this.normalScale = new ve(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = Mh),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      this.specular.copy(e.specular),
      (this.shininess = e.shininess),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class vR extends En {
  constructor(e) {
    (super(),
      (this.isMeshToonMaterial = !0),
      (this.defines = { TOON: "" }),
      (this.type = "MeshToonMaterial"),
      (this.color = new Ie(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Ie(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = eo),
      (this.normalScale = new ve(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.gradientMap = e.gradientMap),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
class yR extends En {
  constructor(e) {
    (super(),
      (this.isMeshNormalMaterial = !0),
      (this.type = "MeshNormalMaterial"),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = eo),
      (this.normalScale = new ve(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.flatShading = !1),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.flatShading = e.flatShading),
      this
    );
  }
}
class xR extends En {
  constructor(e) {
    (super(),
      (this.isMeshLambertMaterial = !0),
      (this.type = "MeshLambertMaterial"),
      (this.color = new Ie(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Ie(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = eo),
      (this.normalScale = new ve(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = Mh),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class _R extends En {
  constructor(e) {
    (super(),
      (this.isMeshMatcapMaterial = !0),
      (this.defines = { MATCAP: "" }),
      (this.type = "MeshMatcapMaterial"),
      (this.color = new Ie(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = eo),
      (this.normalScale = new ve(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { MATCAP: "" }),
      this.color.copy(e.color),
      (this.matcap = e.matcap),
      (this.map = e.map),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class AR extends li {
  constructor(e) {
    (super(),
      (this.isLineDashedMaterial = !0),
      (this.type = "LineDashedMaterial"),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.scale = e.scale),
      (this.dashSize = e.dashSize),
      (this.gapSize = e.gapSize),
      this
    );
  }
}
function hr(n, e, t) {
  return _A(n)
    ? new n.constructor(n.subarray(e, t !== void 0 ? t : n.length))
    : n.slice(e, t);
}
function Wa(n, e, t) {
  return !n || (!t && n.constructor === e)
    ? n
    : typeof e.BYTES_PER_ELEMENT == "number"
      ? new e(n)
      : Array.prototype.slice.call(n);
}
function _A(n) {
  return ArrayBuffer.isView(n) && !(n instanceof DataView);
}
function MR(n) {
  function e(r, s) {
    return n[r] - n[s];
  }
  const t = n.length,
    i = new Array(t);
  for (let r = 0; r !== t; ++r) i[r] = r;
  return (i.sort(e), i);
}
function x_(n, e, t) {
  const i = n.length,
    r = new n.constructor(i);
  for (let s = 0, o = 0; o !== i; ++s) {
    const a = t[s] * e;
    for (let l = 0; l !== e; ++l) r[o++] = n[a + l];
  }
  return r;
}
function AA(n, e, t, i) {
  let r = 1,
    s = n[0];
  for (; s !== void 0 && s[i] === void 0; ) s = n[r++];
  if (s === void 0) return;
  let o = s[i];
  if (o !== void 0)
    if (Array.isArray(o))
      do
        ((o = s[i]),
          o !== void 0 && (e.push(s.time), t.push.apply(t, o)),
          (s = n[r++]));
      while (s !== void 0);
    else if (o.toArray !== void 0)
      do
        ((o = s[i]),
          o !== void 0 && (e.push(s.time), o.toArray(t, t.length)),
          (s = n[r++]));
      while (s !== void 0);
    else
      do
        ((o = s[i]), o !== void 0 && (e.push(s.time), t.push(o)), (s = n[r++]));
      while (s !== void 0);
}
function fH(n, e, t, i, r = 30) {
  const s = n.clone();
  s.name = e;
  const o = [];
  for (let l = 0; l < s.tracks.length; ++l) {
    const u = s.tracks[l],
      h = u.getValueSize(),
      d = [],
      p = [];
    for (let g = 0; g < u.times.length; ++g) {
      const y = u.times[g] * r;
      if (!(y < t || y >= i)) {
        d.push(u.times[g]);
        for (let A = 0; A < h; ++A) p.push(u.values[g * h + A]);
      }
    }
    d.length !== 0 &&
      ((u.times = Wa(d, u.times.constructor)),
      (u.values = Wa(p, u.values.constructor)),
      o.push(u));
  }
  s.tracks = o;
  let a = 1 / 0;
  for (let l = 0; l < s.tracks.length; ++l)
    a > s.tracks[l].times[0] && (a = s.tracks[l].times[0]);
  for (let l = 0; l < s.tracks.length; ++l) s.tracks[l].shift(-1 * a);
  return (s.resetDuration(), s);
}
function hH(n, e = 0, t = n, i = 30) {
  i <= 0 && (i = 30);
  const r = t.tracks.length,
    s = e / i;
  for (let o = 0; o < r; ++o) {
    const a = t.tracks[o],
      l = a.ValueTypeName;
    if (l === "bool" || l === "string") continue;
    const u = n.tracks.find(function (m) {
      return m.name === a.name && m.ValueTypeName === l;
    });
    if (u === void 0) continue;
    let h = 0;
    const d = a.getValueSize();
    a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (h = d / 3);
    let p = 0;
    const g = u.getValueSize();
    u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (p = g / 3);
    const y = a.times.length - 1;
    let A;
    if (s <= a.times[0]) {
      const m = h,
        x = d - h;
      A = hr(a.values, m, x);
    } else if (s >= a.times[y]) {
      const m = y * d + h,
        x = m + d - h;
      A = hr(a.values, m, x);
    } else {
      const m = a.createInterpolant(),
        x = h,
        S = d - h;
      (m.evaluate(s), (A = hr(m.resultBuffer, x, S)));
    }
    l === "quaternion" &&
      new Kn().fromArray(A).normalize().conjugate().toArray(A);
    const _ = u.times.length;
    for (let m = 0; m < _; ++m) {
      const x = m * g + p;
      if (l === "quaternion")
        Kn.multiplyQuaternionsFlat(u.values, x, A, 0, u.values, x);
      else {
        const S = g - p * 2;
        for (let w = 0; w < S; ++w) u.values[x + w] -= A[w];
      }
    }
  }
  return ((n.blendMode = K1), n);
}
const dH = {
  arraySlice: hr,
  convertArray: Wa,
  isTypedArray: _A,
  getKeyframeOrder: MR,
  sortedArray: x_,
  flattenJSON: AA,
  subclip: fH,
  makeClipAdditive: hH,
};
class uu {
  constructor(e, t, i, r) {
    ((this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = r !== void 0 ? r : new t.constructor(i)),
      (this.sampleValues = t),
      (this.valueSize = i),
      (this.settings = null),
      (this.DefaultSettings_ = {}));
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let i = this._cachedIndex,
      r = t[i],
      s = t[i - 1];
    e: {
      t: {
        let o;
        n: {
          i: if (!(e < r)) {
            for (let a = i + 2; ; ) {
              if (r === void 0) {
                if (e < s) break i;
                return (
                  (i = t.length),
                  (this._cachedIndex = i),
                  this.copySampleValue_(i - 1)
                );
              }
              if (i === a) break;
              if (((s = r), (r = t[++i]), e < r)) break t;
            }
            o = t.length;
            break n;
          }
          if (!(e >= s)) {
            const a = t[1];
            e < a && ((i = 2), (s = a));
            for (let l = i - 2; ; ) {
              if (s === void 0)
                return ((this._cachedIndex = 0), this.copySampleValue_(0));
              if (i === l) break;
              if (((r = s), (s = t[--i - 1]), e >= s)) break t;
            }
            ((o = i), (i = 0));
            break n;
          }
          break e;
        }
        for (; i < o; ) {
          const a = (i + o) >>> 1;
          e < t[a] ? (o = a) : (i = a + 1);
        }
        if (((r = t[i]), (s = t[i - 1]), s === void 0))
          return ((this._cachedIndex = 0), this.copySampleValue_(0));
        if (r === void 0)
          return (
            (i = t.length),
            (this._cachedIndex = i),
            this.copySampleValue_(i - 1)
          );
      }
      ((this._cachedIndex = i), this.intervalChanged_(i, s, r));
    }
    return this.interpolate_(i, s, e, r);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      i = this.sampleValues,
      r = this.valueSize,
      s = e * r;
    for (let o = 0; o !== r; ++o) t[o] = i[s + o];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class SR extends uu {
  constructor(e, t, i, r) {
    (super(e, t, i, r),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: Ga, endingEnd: Ga }));
  }
  intervalChanged_(e, t, i) {
    const r = this.parameterPositions;
    let s = e - 2,
      o = e + 1,
      a = r[s],
      l = r[o];
    if (a === void 0)
      switch (this.getSettings_().endingStart) {
        case Ha:
          ((s = e), (a = 2 * t - i));
          break;
        case th:
          ((s = r.length - 2), (a = t + r[s] - r[s + 1]));
          break;
        default:
          ((s = e), (a = i));
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case Ha:
          ((o = e), (l = 2 * i - t));
          break;
        case th:
          ((o = 1), (l = i + r[1] - r[0]));
          break;
        default:
          ((o = e - 1), (l = t));
      }
    const u = (i - t) * 0.5,
      h = this.valueSize;
    ((this._weightPrev = u / (t - a)),
      (this._weightNext = u / (l - i)),
      (this._offsetPrev = s * h),
      (this._offsetNext = o * h));
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = e * a,
      u = l - a,
      h = this._offsetPrev,
      d = this._offsetNext,
      p = this._weightPrev,
      g = this._weightNext,
      y = (i - t) / (r - t),
      A = y * y,
      _ = A * y,
      m = -p * _ + 2 * p * A - p * y,
      x = (1 + p) * _ + (-1.5 - 2 * p) * A + (-0.5 + p) * y + 1,
      S = (-1 - g) * _ + (1.5 + g) * A + 0.5 * y,
      w = g * _ - g * A;
    for (let C = 0; C !== a; ++C)
      s[C] = m * o[h + C] + x * o[u + C] + S * o[l + C] + w * o[d + C];
    return s;
  }
}
class MA extends uu {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = e * a,
      u = l - a,
      h = (i - t) / (r - t),
      d = 1 - h;
    for (let p = 0; p !== a; ++p) s[p] = o[u + p] * d + o[l + p] * h;
    return s;
  }
}
class wR extends uu {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class Xr {
  constructor(e, t, i, r) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    ((this.name = e),
      (this.times = Wa(t, this.TimeBufferType)),
      (this.values = Wa(i, this.ValueBufferType)),
      this.setInterpolation(r || this.DefaultInterpolation));
  }
  static toJSON(e) {
    const t = e.constructor;
    let i;
    if (t.toJSON !== this.toJSON) i = t.toJSON(e);
    else {
      i = {
        name: e.name,
        times: Wa(e.times, Array),
        values: Wa(e.values, Array),
      };
      const r = e.getInterpolation();
      r !== e.DefaultInterpolation && (i.interpolation = r);
    }
    return ((i.type = e.ValueTypeName), i);
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new wR(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new MA(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new SR(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case Wc:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case ol:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case _m:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const i =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(i);
      return (console.warn("THREE.KeyframeTrack:", i), this);
    }
    return ((this.createInterpolant = t), this);
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return Wc;
      case this.InterpolantFactoryMethodLinear:
        return ol;
      case this.InterpolantFactoryMethodSmooth:
        return _m;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let i = 0, r = t.length; i !== r; ++i) t[i] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let i = 0, r = t.length; i !== r; ++i) t[i] *= e;
    }
    return this;
  }
  trim(e, t) {
    const i = this.times,
      r = i.length;
    let s = 0,
      o = r - 1;
    for (; s !== r && i[s] < e; ) ++s;
    for (; o !== -1 && i[o] > t; ) --o;
    if ((++o, s !== 0 || o !== r)) {
      s >= o && ((o = Math.max(o, 1)), (s = o - 1));
      const a = this.getValueSize();
      ((this.times = hr(i, s, o)),
        (this.values = hr(this.values, s * a, o * a)));
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1));
    const i = this.times,
      r = this.values,
      s = i.length;
    s === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
    let o = null;
    for (let a = 0; a !== s; a++) {
      const l = i[a];
      if (typeof l == "number" && isNaN(l)) {
        (console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          a,
          l
        ),
          (e = !1));
        break;
      }
      if (o !== null && o > l) {
        (console.error(
          "THREE.KeyframeTrack: Out of order keys.",
          this,
          a,
          l,
          o
        ),
          (e = !1));
        break;
      }
      o = l;
    }
    if (r !== void 0 && _A(r))
      for (let a = 0, l = r.length; a !== l; ++a) {
        const u = r[a];
        if (isNaN(u)) {
          (console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            a,
            u
          ),
            (e = !1));
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = hr(this.times),
      t = hr(this.values),
      i = this.getValueSize(),
      r = this.getInterpolation() === _m,
      s = e.length - 1;
    let o = 1;
    for (let a = 1; a < s; ++a) {
      let l = !1;
      const u = e[a],
        h = e[a + 1];
      if (u !== h && (a !== 1 || u !== e[0]))
        if (r) l = !0;
        else {
          const d = a * i,
            p = d - i,
            g = d + i;
          for (let y = 0; y !== i; ++y) {
            const A = t[d + y];
            if (A !== t[p + y] || A !== t[g + y]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (a !== o) {
          e[o] = e[a];
          const d = a * i,
            p = o * i;
          for (let g = 0; g !== i; ++g) t[p + g] = t[d + g];
        }
        ++o;
      }
    }
    if (s > 0) {
      e[o] = e[s];
      for (let a = s * i, l = o * i, u = 0; u !== i; ++u) t[l + u] = t[a + u];
      ++o;
    }
    return (
      o !== e.length
        ? ((this.times = hr(e, 0, o)), (this.values = hr(t, 0, o * i)))
        : ((this.times = e), (this.values = t)),
      this
    );
  }
  clone() {
    const e = hr(this.times, 0),
      t = hr(this.values, 0),
      i = this.constructor,
      r = new i(this.name, e, t);
    return ((r.createInterpolant = this.createInterpolant), r);
  }
}
Xr.prototype.TimeBufferType = Float32Array;
Xr.prototype.ValueBufferType = Float32Array;
Xr.prototype.DefaultInterpolation = ol;
class pl extends Xr {}
pl.prototype.ValueTypeName = "bool";
pl.prototype.ValueBufferType = Array;
pl.prototype.DefaultInterpolation = Wc;
pl.prototype.InterpolantFactoryMethodLinear = void 0;
pl.prototype.InterpolantFactoryMethodSmooth = void 0;
class SA extends Xr {}
SA.prototype.ValueTypeName = "color";
class Yc extends Xr {}
Yc.prototype.ValueTypeName = "number";
class ER extends uu {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = (i - t) / (r - t);
    let u = e * a;
    for (let h = u + a; u !== h; u += 4) Kn.slerpFlat(s, 0, o, u - a, o, u, l);
    return s;
  }
}
class Zo extends Xr {
  InterpolantFactoryMethodLinear(e) {
    return new ER(this.times, this.values, this.getValueSize(), e);
  }
}
Zo.prototype.ValueTypeName = "quaternion";
Zo.prototype.DefaultInterpolation = ol;
Zo.prototype.InterpolantFactoryMethodSmooth = void 0;
class ml extends Xr {}
ml.prototype.ValueTypeName = "string";
ml.prototype.ValueBufferType = Array;
ml.prototype.DefaultInterpolation = Wc;
ml.prototype.InterpolantFactoryMethodLinear = void 0;
ml.prototype.InterpolantFactoryMethodSmooth = void 0;
class Qc extends Xr {}
Qc.prototype.ValueTypeName = "vector";
class Zc {
  constructor(e, t = -1, i, r = Ng) {
    ((this.name = e),
      (this.tracks = i),
      (this.duration = t),
      (this.blendMode = r),
      (this.uuid = Ki()),
      this.duration < 0 && this.resetDuration());
  }
  static parse(e) {
    const t = [],
      i = e.tracks,
      r = 1 / (e.fps || 1);
    for (let o = 0, a = i.length; o !== a; ++o) t.push(mH(i[o]).scale(r));
    const s = new this(e.name, e.duration, t, e.blendMode);
    return ((s.uuid = e.uuid), s);
  }
  static toJSON(e) {
    const t = [],
      i = e.tracks,
      r = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let s = 0, o = i.length; s !== o; ++s) t.push(Xr.toJSON(i[s]));
    return r;
  }
  static CreateFromMorphTargetSequence(e, t, i, r) {
    const s = t.length,
      o = [];
    for (let a = 0; a < s; a++) {
      let l = [],
        u = [];
      (l.push((a + s - 1) % s, a, (a + 1) % s), u.push(0, 1, 0));
      const h = MR(l);
      ((l = x_(l, 1, h)),
        (u = x_(u, 1, h)),
        !r && l[0] === 0 && (l.push(s), u.push(u[0])),
        o.push(
          new Yc(".morphTargetInfluences[" + t[a].name + "]", l, u).scale(1 / i)
        ));
    }
    return new this(e, -1, o);
  }
  static findByName(e, t) {
    let i = e;
    if (!Array.isArray(e)) {
      const r = e;
      i = (r.geometry && r.geometry.animations) || r.animations;
    }
    for (let r = 0; r < i.length; r++) if (i[r].name === t) return i[r];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, i) {
    const r = {},
      s = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, l = e.length; a < l; a++) {
      const u = e[a],
        h = u.name.match(s);
      if (h && h.length > 1) {
        const d = h[1];
        let p = r[d];
        (p || (r[d] = p = []), p.push(u));
      }
    }
    const o = [];
    for (const a in r)
      o.push(this.CreateFromMorphTargetSequence(a, r[a], t, i));
    return o;
  }
  static parseAnimation(e, t) {
    if (!e)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const i = function (d, p, g, y, A) {
        if (g.length !== 0) {
          const _ = [],
            m = [];
          (AA(g, _, m, y), _.length !== 0 && A.push(new d(p, _, m)));
        }
      },
      r = [],
      s = e.name || "default",
      o = e.fps || 30,
      a = e.blendMode;
    let l = e.length || -1;
    const u = e.hierarchy || [];
    for (let d = 0; d < u.length; d++) {
      const p = u[d].keys;
      if (!(!p || p.length === 0))
        if (p[0].morphTargets) {
          const g = {};
          let y;
          for (y = 0; y < p.length; y++)
            if (p[y].morphTargets)
              for (let A = 0; A < p[y].morphTargets.length; A++)
                g[p[y].morphTargets[A]] = -1;
          for (const A in g) {
            const _ = [],
              m = [];
            for (let x = 0; x !== p[y].morphTargets.length; ++x) {
              const S = p[y];
              (_.push(S.time), m.push(S.morphTarget === A ? 1 : 0));
            }
            r.push(new Yc(".morphTargetInfluence[" + A + "]", _, m));
          }
          l = g.length * o;
        } else {
          const g = ".bones[" + t[d].name + "]";
          (i(Qc, g + ".position", p, "pos", r),
            i(Zo, g + ".quaternion", p, "rot", r),
            i(Qc, g + ".scale", p, "scl", r));
        }
    }
    return r.length === 0 ? null : new this(s, l, r, a);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let i = 0, r = e.length; i !== r; ++i) {
      const s = this.tracks[i];
      t = Math.max(t, s.times[s.times.length - 1]);
    }
    return ((this.duration = t), this);
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function pH(n) {
  switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return Yc;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return Qc;
    case "color":
      return SA;
    case "quaternion":
      return Zo;
    case "bool":
    case "boolean":
      return pl;
    case "string":
      return ml;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n);
}
function mH(n) {
  if (n.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = pH(n.type);
  if (n.times === void 0) {
    const t = [],
      i = [];
    (AA(n.keys, t, i, "value"), (n.times = t), (n.values = i));
  }
  return e.parse !== void 0
    ? e.parse(n)
    : new e(n.name, n.times, n.values, n.interpolation);
}
const ll = {
  enabled: !1,
  files: {},
  add: function (n, e) {
    this.enabled !== !1 && (this.files[n] = e);
  },
  get: function (n) {
    if (this.enabled !== !1) return this.files[n];
  },
  remove: function (n) {
    delete this.files[n];
  },
  clear: function () {
    this.files = {};
  },
};
class wA {
  constructor(e, t, i) {
    const r = this;
    let s = !1,
      o = 0,
      a = 0,
      l;
    const u = [];
    ((this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = i),
      (this.itemStart = function (h) {
        (a++, s === !1 && r.onStart !== void 0 && r.onStart(h, o, a), (s = !0));
      }),
      (this.itemEnd = function (h) {
        (o++,
          r.onProgress !== void 0 && r.onProgress(h, o, a),
          o === a && ((s = !1), r.onLoad !== void 0 && r.onLoad()));
      }),
      (this.itemError = function (h) {
        r.onError !== void 0 && r.onError(h);
      }),
      (this.resolveURL = function (h) {
        return l ? l(h) : h;
      }),
      (this.setURLModifier = function (h) {
        return ((l = h), this);
      }),
      (this.addHandler = function (h, d) {
        return (u.push(h, d), this);
      }),
      (this.removeHandler = function (h) {
        const d = u.indexOf(h);
        return (d !== -1 && u.splice(d, 2), this);
      }),
      (this.getHandler = function (h) {
        for (let d = 0, p = u.length; d < p; d += 2) {
          const g = u[d],
            y = u[d + 1];
          if ((g.global && (g.lastIndex = 0), g.test(h))) return y;
        }
        return null;
      }));
  }
}
const _c = new wA();
class _i {
  constructor(e) {
    ((this.manager = e !== void 0 ? e : _c),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {}));
  }
  load() {}
  loadAsync(e, t) {
    const i = this;
    return new Promise(function (r, s) {
      i.load(e, r, t, s);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return ((this.crossOrigin = e), this);
  }
  setWithCredentials(e) {
    return ((this.withCredentials = e), this);
  }
  setPath(e) {
    return ((this.path = e), this);
  }
  setResourcePath(e) {
    return ((this.resourcePath = e), this);
  }
  setRequestHeader(e) {
    return ((this.requestHeader = e), this);
  }
}
const bs = {};
class gH extends Error {
  constructor(e, t) {
    (super(e), (this.response = t));
  }
}
class Qi extends _i {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    (e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e)));
    const s = ll.get(e);
    if (s !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          (t && t(s), this.manager.itemEnd(e));
        }, 0),
        s
      );
    if (bs[e] !== void 0) {
      bs[e].push({ onLoad: t, onProgress: i, onError: r });
      return;
    }
    ((bs[e] = []), bs[e].push({ onLoad: t, onProgress: i, onError: r }));
    const o = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      a = this.mimeType,
      l = this.responseType;
    (fetch(o)
      .then((u) => {
        if (u.status === 200 || u.status === 0) {
          if (
            (u.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              u.body === void 0 ||
              u.body.getReader === void 0)
          )
            return u;
          const h = bs[e],
            d = u.body.getReader(),
            p = u.headers.get("Content-Length") || u.headers.get("X-File-Size"),
            g = p ? parseInt(p) : 0,
            y = g !== 0;
          let A = 0;
          const _ = new ReadableStream({
            start(m) {
              x();
              function x() {
                d.read().then(({ done: S, value: w }) => {
                  if (S) m.close();
                  else {
                    A += w.byteLength;
                    const C = new ProgressEvent("progress", {
                      lengthComputable: y,
                      loaded: A,
                      total: g,
                    });
                    for (let P = 0, R = h.length; P < R; P++) {
                      const B = h[P];
                      B.onProgress && B.onProgress(C);
                    }
                    (m.enqueue(w), x());
                  }
                });
              }
            },
          });
          return new Response(_);
        } else
          throw new gH(
            `fetch for "${u.url}" responded with ${u.status}: ${u.statusText}`,
            u
          );
      })
      .then((u) => {
        switch (l) {
          case "arraybuffer":
            return u.arrayBuffer();
          case "blob":
            return u.blob();
          case "document":
            return u.text().then((h) => new DOMParser().parseFromString(h, a));
          case "json":
            return u.json();
          default:
            if (a === void 0) return u.text();
            {
              const d = /charset="?([^;"\s]*)"?/i.exec(a),
                p = d && d[1] ? d[1].toLowerCase() : void 0,
                g = new TextDecoder(p);
              return u.arrayBuffer().then((y) => g.decode(y));
            }
        }
      })
      .then((u) => {
        ll.add(e, u);
        const h = bs[e];
        delete bs[e];
        for (let d = 0, p = h.length; d < p; d++) {
          const g = h[d];
          g.onLoad && g.onLoad(u);
        }
      })
      .catch((u) => {
        const h = bs[e];
        if (h === void 0) throw (this.manager.itemError(e), u);
        delete bs[e];
        for (let d = 0, p = h.length; d < p; d++) {
          const g = h[d];
          g.onError && g.onError(u);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e));
  }
  setResponseType(e) {
    return ((this.responseType = e), this);
  }
  setMimeType(e) {
    return ((this.mimeType = e), this);
  }
}
class vH extends _i {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = new Qi(this.manager);
    (o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)));
          } catch (l) {
            (r ? r(l) : console.error(l), s.manager.itemError(e));
          }
        },
        i,
        r
      ));
  }
  parse(e) {
    const t = [];
    for (let i = 0; i < e.length; i++) {
      const r = Zc.parse(e[i]);
      t.push(r);
    }
    return t;
  }
}
class yH extends _i {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = [],
      a = new dA(),
      l = new Qi(this.manager);
    (l.setPath(this.path),
      l.setResponseType("arraybuffer"),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(s.withCredentials));
    let u = 0;
    function h(d) {
      l.load(
        e[d],
        function (p) {
          const g = s.parse(p, !0);
          ((o[d] = {
            width: g.width,
            height: g.height,
            format: g.format,
            mipmaps: g.mipmaps,
          }),
            (u += 1),
            u === 6 &&
              (g.mipmapCount === 1 && (a.minFilter = rn),
              (a.image = o),
              (a.format = g.format),
              (a.needsUpdate = !0),
              t && t(a)));
        },
        i,
        r
      );
    }
    if (Array.isArray(e)) for (let d = 0, p = e.length; d < p; ++d) h(d);
    else
      l.load(
        e,
        function (d) {
          const p = s.parse(d, !0);
          if (p.isCubemap) {
            const g = p.mipmaps.length / p.mipmapCount;
            for (let y = 0; y < g; y++) {
              o[y] = { mipmaps: [] };
              for (let A = 0; A < p.mipmapCount; A++)
                (o[y].mipmaps.push(p.mipmaps[y * p.mipmapCount + A]),
                  (o[y].format = p.format),
                  (o[y].width = p.width),
                  (o[y].height = p.height));
            }
            a.image = o;
          } else
            ((a.image.width = p.width),
              (a.image.height = p.height),
              (a.mipmaps = p.mipmaps));
          (p.mipmapCount === 1 && (a.minFilter = rn),
            (a.format = p.format),
            (a.needsUpdate = !0),
            t && t(a));
        },
        i,
        r
      );
    return a;
  }
}
class lh extends _i {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    (this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e)));
    const s = this,
      o = ll.get(e);
    if (o !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          (t && t(o), s.manager.itemEnd(e));
        }, 0),
        o
      );
    const a = ih("img");
    function l() {
      (h(), ll.add(e, this), t && t(this), s.manager.itemEnd(e));
    }
    function u(d) {
      (h(), r && r(d), s.manager.itemError(e), s.manager.itemEnd(e));
    }
    function h() {
      (a.removeEventListener("load", l, !1),
        a.removeEventListener("error", u, !1));
    }
    return (
      a.addEventListener("load", l, !1),
      a.addEventListener("error", u, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (a.crossOrigin = this.crossOrigin),
      s.manager.itemStart(e),
      (a.src = e),
      a
    );
  }
}
class xH extends _i {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = new Eh(),
      o = new lh(this.manager);
    (o.setCrossOrigin(this.crossOrigin), o.setPath(this.path));
    let a = 0;
    function l(u) {
      o.load(
        e[u],
        function (h) {
          ((s.images[u] = h),
            a++,
            a === 6 && ((s.needsUpdate = !0), t && t(s)));
        },
        void 0,
        r
      );
    }
    for (let u = 0; u < e.length; ++u) l(u);
    return s;
  }
}
class _H extends _i {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = new Lc(),
      a = new Qi(this.manager);
    return (
      a.setResponseType("arraybuffer"),
      a.setRequestHeader(this.requestHeader),
      a.setPath(this.path),
      a.setWithCredentials(s.withCredentials),
      a.load(
        e,
        function (l) {
          const u = s.parse(l);
          u &&
            (u.image !== void 0
              ? (o.image = u.image)
              : u.data !== void 0 &&
                ((o.image.width = u.width),
                (o.image.height = u.height),
                (o.image.data = u.data)),
            (o.wrapS = u.wrapS !== void 0 ? u.wrapS : jn),
            (o.wrapT = u.wrapT !== void 0 ? u.wrapT : jn),
            (o.magFilter = u.magFilter !== void 0 ? u.magFilter : rn),
            (o.minFilter = u.minFilter !== void 0 ? u.minFilter : rn),
            (o.anisotropy = u.anisotropy !== void 0 ? u.anisotropy : 1),
            u.encoding !== void 0 && (o.encoding = u.encoding),
            u.flipY !== void 0 && (o.flipY = u.flipY),
            u.format !== void 0 && (o.format = u.format),
            u.type !== void 0 && (o.type = u.type),
            u.mipmaps !== void 0 &&
              ((o.mipmaps = u.mipmaps), (o.minFilter = hs)),
            u.mipmapCount === 1 && (o.minFilter = rn),
            u.generateMipmaps !== void 0 &&
              (o.generateMipmaps = u.generateMipmaps),
            (o.needsUpdate = !0),
            t && t(o, u));
        },
        i,
        r
      ),
      o
    );
  }
}
class Gh extends _i {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = new en(),
      o = new lh(this.manager);
    return (
      o.setCrossOrigin(this.crossOrigin),
      o.setPath(this.path),
      o.load(
        e,
        function (a) {
          ((s.image = a), (s.needsUpdate = !0), t !== void 0 && t(s));
        },
        i,
        r
      ),
      s
    );
  }
}
class ia extends Pt {
  constructor(e, t = 1) {
    (super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new Ie(e)),
      (this.intensity = t));
  }
  dispose() {}
  copy(e, t) {
    return (
      super.copy(e, t),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      t
    );
  }
}
class CR extends ia {
  constructor(e, t, i) {
    (super(e, i),
      (this.isHemisphereLight = !0),
      (this.type = "HemisphereLight"),
      this.position.copy(Pt.DEFAULT_UP),
      this.updateMatrix(),
      (this.groundColor = new Ie(t)));
  }
  copy(e, t) {
    return (super.copy(e, t), this.groundColor.copy(e.groundColor), this);
  }
}
const fy = new ot(),
  mC = new F(),
  gC = new F();
class EA {
  constructor(e) {
    ((this.camera = e),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new ve(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new ot()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new Og()),
      (this._frameExtents = new ve(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new kt(0, 0, 1, 1)]));
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      i = this.matrix;
    (mC.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(mC),
      gC.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(gC),
      t.updateMatrixWorld(),
      fy.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(fy),
      i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      i.multiply(fy));
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    (this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose());
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class AH extends EA {
  constructor() {
    (super(new Vt(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1));
  }
  updateMatrices(e) {
    const t = this.camera,
      i = Jc * 2 * e.angle * this.focus,
      r = this.mapSize.width / this.mapSize.height,
      s = e.distance || t.far;
    ((i !== t.fov || r !== t.aspect || s !== t.far) &&
      ((t.fov = i), (t.aspect = r), (t.far = s), t.updateProjectionMatrix()),
      super.updateMatrices(e));
  }
  copy(e) {
    return (super.copy(e), (this.focus = e.focus), this);
  }
}
class CA extends ia {
  constructor(e, t, i = 0, r = Math.PI / 3, s = 0, o = 2) {
    (super(e, t),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(Pt.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Pt()),
      (this.distance = i),
      (this.angle = r),
      (this.penumbra = s),
      (this.decay = o),
      (this.map = null),
      (this.shadow = new AH()));
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const vC = new ot(),
  Zu = new F(),
  hy = new F();
class MH extends EA {
  constructor() {
    (super(new Vt(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new ve(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new kt(2, 1, 1, 1),
        new kt(0, 1, 1, 1),
        new kt(3, 1, 1, 1),
        new kt(1, 1, 1, 1),
        new kt(3, 0, 1, 1),
        new kt(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new F(1, 0, 0),
        new F(-1, 0, 0),
        new F(0, 0, 1),
        new F(0, 0, -1),
        new F(0, 1, 0),
        new F(0, -1, 0),
      ]),
      (this._cubeUps = [
        new F(0, 1, 0),
        new F(0, 1, 0),
        new F(0, 1, 0),
        new F(0, 1, 0),
        new F(0, 0, 1),
        new F(0, 0, -1),
      ]));
  }
  updateMatrices(e, t = 0) {
    const i = this.camera,
      r = this.matrix,
      s = e.distance || i.far;
    (s !== i.far && ((i.far = s), i.updateProjectionMatrix()),
      Zu.setFromMatrixPosition(e.matrixWorld),
      i.position.copy(Zu),
      hy.copy(i.position),
      hy.add(this._cubeDirections[t]),
      i.up.copy(this._cubeUps[t]),
      i.lookAt(hy),
      i.updateMatrixWorld(),
      r.makeTranslation(-Zu.x, -Zu.y, -Zu.z),
      vC.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(vC));
  }
}
class TA extends ia {
  constructor(e, t, i = 0, r = 2) {
    (super(e, t),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = i),
      (this.decay = r),
      (this.shadow = new MH()));
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class SH extends EA {
  constructor() {
    (super(new zr(-5, 5, 5, -5, 0.5, 500)),
      (this.isDirectionalLightShadow = !0));
  }
}
class bA extends ia {
  constructor(e, t) {
    (super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(Pt.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Pt()),
      (this.shadow = new SH()));
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class TR extends ia {
  constructor(e, t) {
    (super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight"));
  }
}
class bR extends ia {
  constructor(e, t, i = 10, r = 10) {
    (super(e, t),
      (this.isRectAreaLight = !0),
      (this.type = "RectAreaLight"),
      (this.width = i),
      (this.height = r));
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.width = e.width),
      (this.height = e.height),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return ((t.object.width = this.width), (t.object.height = this.height), t);
  }
}
class PR {
  constructor() {
    ((this.isSphericalHarmonics3 = !0), (this.coefficients = []));
    for (let e = 0; e < 9; e++) this.coefficients.push(new F());
  }
  set(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
    return this;
  }
  getAt(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z,
      o = this.coefficients;
    return (
      t.copy(o[0]).multiplyScalar(0.282095),
      t.addScaledVector(o[1], 0.488603 * r),
      t.addScaledVector(o[2], 0.488603 * s),
      t.addScaledVector(o[3], 0.488603 * i),
      t.addScaledVector(o[4], 1.092548 * (i * r)),
      t.addScaledVector(o[5], 1.092548 * (r * s)),
      t.addScaledVector(o[6], 0.315392 * (3 * s * s - 1)),
      t.addScaledVector(o[7], 1.092548 * (i * s)),
      t.addScaledVector(o[8], 0.546274 * (i * i - r * r)),
      t
    );
  }
  getIrradianceAt(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z,
      o = this.coefficients;
    return (
      t.copy(o[0]).multiplyScalar(0.886227),
      t.addScaledVector(o[1], 2 * 0.511664 * r),
      t.addScaledVector(o[2], 2 * 0.511664 * s),
      t.addScaledVector(o[3], 2 * 0.511664 * i),
      t.addScaledVector(o[4], 2 * 0.429043 * i * r),
      t.addScaledVector(o[5], 2 * 0.429043 * r * s),
      t.addScaledVector(o[6], 0.743125 * s * s - 0.247708),
      t.addScaledVector(o[7], 2 * 0.429043 * i * s),
      t.addScaledVector(o[8], 0.429043 * (i * i - r * r)),
      t
    );
  }
  add(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].addScaledVector(e.coefficients[i], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let i = 0; i < 9; i++) this.coefficients[i].lerp(e.coefficients[i], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const i = this.coefficients;
    for (let r = 0; r < 9; r++) i[r].fromArray(e, t + r * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.coefficients;
    for (let r = 0; r < 9; r++) i[r].toArray(e, t + r * 3);
    return e;
  }
  static getBasisAt(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z;
    ((t[0] = 0.282095),
      (t[1] = 0.488603 * r),
      (t[2] = 0.488603 * s),
      (t[3] = 0.488603 * i),
      (t[4] = 1.092548 * i * r),
      (t[5] = 1.092548 * r * s),
      (t[6] = 0.315392 * (3 * s * s - 1)),
      (t[7] = 1.092548 * i * s),
      (t[8] = 0.546274 * (i * i - r * r)));
  }
}
class Jg extends ia {
  constructor(e = new PR(), t = 1) {
    (super(void 0, t), (this.isLightProbe = !0), (this.sh = e));
  }
  copy(e) {
    return (super.copy(e), this.sh.copy(e.sh), this);
  }
  fromJSON(e) {
    return ((this.intensity = e.intensity), this.sh.fromArray(e.sh), this);
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return ((t.object.sh = this.sh.toArray()), t);
  }
}
class Xg extends _i {
  constructor(e) {
    (super(e), (this.textures = {}));
  }
  load(e, t, i, r) {
    const s = this,
      o = new Qi(s.manager);
    (o.setPath(s.path),
      o.setRequestHeader(s.requestHeader),
      o.setWithCredentials(s.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)));
          } catch (l) {
            (r ? r(l) : console.error(l), s.manager.itemError(e));
          }
        },
        i,
        r
      ));
  }
  parse(e) {
    const t = this.textures;
    function i(s) {
      return (
        t[s] === void 0 &&
          console.warn("THREE.MaterialLoader: Undefined texture", s),
        t[s]
      );
    }
    const r = Xg.createMaterialFromType(e.type);
    if (
      (e.uuid !== void 0 && (r.uuid = e.uuid),
      e.name !== void 0 && (r.name = e.name),
      e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color),
      e.roughness !== void 0 && (r.roughness = e.roughness),
      e.metalness !== void 0 && (r.metalness = e.metalness),
      e.sheen !== void 0 && (r.sheen = e.sheen),
      e.sheenColor !== void 0 && (r.sheenColor = new Ie().setHex(e.sheenColor)),
      e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness),
      e.emissive !== void 0 &&
        r.emissive !== void 0 &&
        r.emissive.setHex(e.emissive),
      e.specular !== void 0 &&
        r.specular !== void 0 &&
        r.specular.setHex(e.specular),
      e.specularIntensity !== void 0 &&
        (r.specularIntensity = e.specularIntensity),
      e.specularColor !== void 0 &&
        r.specularColor !== void 0 &&
        r.specularColor.setHex(e.specularColor),
      e.shininess !== void 0 && (r.shininess = e.shininess),
      e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat),
      e.clearcoatRoughness !== void 0 &&
        (r.clearcoatRoughness = e.clearcoatRoughness),
      e.iridescence !== void 0 && (r.iridescence = e.iridescence),
      e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR),
      e.iridescenceThicknessRange !== void 0 &&
        (r.iridescenceThicknessRange = e.iridescenceThicknessRange),
      e.transmission !== void 0 && (r.transmission = e.transmission),
      e.thickness !== void 0 && (r.thickness = e.thickness),
      e.attenuationDistance !== void 0 &&
        (r.attenuationDistance = e.attenuationDistance),
      e.attenuationColor !== void 0 &&
        r.attenuationColor !== void 0 &&
        r.attenuationColor.setHex(e.attenuationColor),
      e.fog !== void 0 && (r.fog = e.fog),
      e.flatShading !== void 0 && (r.flatShading = e.flatShading),
      e.blending !== void 0 && (r.blending = e.blending),
      e.combine !== void 0 && (r.combine = e.combine),
      e.side !== void 0 && (r.side = e.side),
      e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide),
      e.opacity !== void 0 && (r.opacity = e.opacity),
      e.transparent !== void 0 && (r.transparent = e.transparent),
      e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest),
      e.depthTest !== void 0 && (r.depthTest = e.depthTest),
      e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite),
      e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite),
      e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite),
      e.stencilWriteMask !== void 0 &&
        (r.stencilWriteMask = e.stencilWriteMask),
      e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc),
      e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef),
      e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask),
      e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail),
      e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail),
      e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass),
      e.wireframe !== void 0 && (r.wireframe = e.wireframe),
      e.wireframeLinewidth !== void 0 &&
        (r.wireframeLinewidth = e.wireframeLinewidth),
      e.wireframeLinecap !== void 0 &&
        (r.wireframeLinecap = e.wireframeLinecap),
      e.wireframeLinejoin !== void 0 &&
        (r.wireframeLinejoin = e.wireframeLinejoin),
      e.rotation !== void 0 && (r.rotation = e.rotation),
      e.linewidth !== 1 && (r.linewidth = e.linewidth),
      e.dashSize !== void 0 && (r.dashSize = e.dashSize),
      e.gapSize !== void 0 && (r.gapSize = e.gapSize),
      e.scale !== void 0 && (r.scale = e.scale),
      e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset),
      e.polygonOffsetFactor !== void 0 &&
        (r.polygonOffsetFactor = e.polygonOffsetFactor),
      e.polygonOffsetUnits !== void 0 &&
        (r.polygonOffsetUnits = e.polygonOffsetUnits),
      e.dithering !== void 0 && (r.dithering = e.dithering),
      e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage),
      e.premultipliedAlpha !== void 0 &&
        (r.premultipliedAlpha = e.premultipliedAlpha),
      e.forceSinglePass !== void 0 && (r.forceSinglePass = e.forceSinglePass),
      e.visible !== void 0 && (r.visible = e.visible),
      e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped),
      e.userData !== void 0 && (r.userData = e.userData),
      e.vertexColors !== void 0 &&
        (typeof e.vertexColors == "number"
          ? (r.vertexColors = e.vertexColors > 0)
          : (r.vertexColors = e.vertexColors)),
      e.uniforms !== void 0)
    )
      for (const s in e.uniforms) {
        const o = e.uniforms[s];
        switch (((r.uniforms[s] = {}), o.type)) {
          case "t":
            r.uniforms[s].value = i(o.value);
            break;
          case "c":
            r.uniforms[s].value = new Ie().setHex(o.value);
            break;
          case "v2":
            r.uniforms[s].value = new ve().fromArray(o.value);
            break;
          case "v3":
            r.uniforms[s].value = new F().fromArray(o.value);
            break;
          case "v4":
            r.uniforms[s].value = new kt().fromArray(o.value);
            break;
          case "m3":
            r.uniforms[s].value = new wt().fromArray(o.value);
            break;
          case "m4":
            r.uniforms[s].value = new ot().fromArray(o.value);
            break;
          default:
            r.uniforms[s].value = o.value;
        }
      }
    if (
      (e.defines !== void 0 && (r.defines = e.defines),
      e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader),
      e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader),
      e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion),
      e.extensions !== void 0)
    )
      for (const s in e.extensions) r.extensions[s] = e.extensions[s];
    if (
      (e.size !== void 0 && (r.size = e.size),
      e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation),
      e.map !== void 0 && (r.map = i(e.map)),
      e.matcap !== void 0 && (r.matcap = i(e.matcap)),
      e.alphaMap !== void 0 && (r.alphaMap = i(e.alphaMap)),
      e.bumpMap !== void 0 && (r.bumpMap = i(e.bumpMap)),
      e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale),
      e.normalMap !== void 0 && (r.normalMap = i(e.normalMap)),
      e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType),
      e.normalScale !== void 0)
    ) {
      let s = e.normalScale;
      (Array.isArray(s) === !1 && (s = [s, s]),
        (r.normalScale = new ve().fromArray(s)));
    }
    return (
      e.displacementMap !== void 0 &&
        (r.displacementMap = i(e.displacementMap)),
      e.displacementScale !== void 0 &&
        (r.displacementScale = e.displacementScale),
      e.displacementBias !== void 0 &&
        (r.displacementBias = e.displacementBias),
      e.roughnessMap !== void 0 && (r.roughnessMap = i(e.roughnessMap)),
      e.metalnessMap !== void 0 && (r.metalnessMap = i(e.metalnessMap)),
      e.emissiveMap !== void 0 && (r.emissiveMap = i(e.emissiveMap)),
      e.emissiveIntensity !== void 0 &&
        (r.emissiveIntensity = e.emissiveIntensity),
      e.specularMap !== void 0 && (r.specularMap = i(e.specularMap)),
      e.specularIntensityMap !== void 0 &&
        (r.specularIntensityMap = i(e.specularIntensityMap)),
      e.specularColorMap !== void 0 &&
        (r.specularColorMap = i(e.specularColorMap)),
      e.envMap !== void 0 && (r.envMap = i(e.envMap)),
      e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity),
      e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity),
      e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio),
      e.lightMap !== void 0 && (r.lightMap = i(e.lightMap)),
      e.lightMapIntensity !== void 0 &&
        (r.lightMapIntensity = e.lightMapIntensity),
      e.aoMap !== void 0 && (r.aoMap = i(e.aoMap)),
      e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity),
      e.gradientMap !== void 0 && (r.gradientMap = i(e.gradientMap)),
      e.clearcoatMap !== void 0 && (r.clearcoatMap = i(e.clearcoatMap)),
      e.clearcoatRoughnessMap !== void 0 &&
        (r.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)),
      e.clearcoatNormalMap !== void 0 &&
        (r.clearcoatNormalMap = i(e.clearcoatNormalMap)),
      e.clearcoatNormalScale !== void 0 &&
        (r.clearcoatNormalScale = new ve().fromArray(e.clearcoatNormalScale)),
      e.iridescenceMap !== void 0 && (r.iridescenceMap = i(e.iridescenceMap)),
      e.iridescenceThicknessMap !== void 0 &&
        (r.iridescenceThicknessMap = i(e.iridescenceThicknessMap)),
      e.transmissionMap !== void 0 &&
        (r.transmissionMap = i(e.transmissionMap)),
      e.thicknessMap !== void 0 && (r.thicknessMap = i(e.thicknessMap)),
      e.sheenColorMap !== void 0 && (r.sheenColorMap = i(e.sheenColorMap)),
      e.sheenRoughnessMap !== void 0 &&
        (r.sheenRoughnessMap = i(e.sheenRoughnessMap)),
      r
    );
  }
  setTextures(e) {
    return ((this.textures = e), this);
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: pR,
      SpriteMaterial: cA,
      RawShaderMaterial: mR,
      ShaderMaterial: ds,
      PointsMaterial: bh,
      MeshPhysicalMaterial: no,
      MeshStandardMaterial: cu,
      MeshPhongMaterial: gR,
      MeshToonMaterial: vR,
      MeshNormalMaterial: yR,
      MeshLambertMaterial: xR,
      MeshDepthMaterial: oA,
      MeshDistanceMaterial: aA,
      MeshBasicMaterial: Ji,
      MeshMatcapMaterial: _R,
      LineDashedMaterial: AR,
      LineBasicMaterial: li,
      Material: En,
    };
    return new t[e]();
  }
}
class cs {
  static decodeText(e) {
    if (typeof TextDecoder < "u") return new TextDecoder().decode(e);
    let t = "";
    for (let i = 0, r = e.length; i < r; i++) t += String.fromCharCode(e[i]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : t + e);
  }
}
class BR extends ft {
  constructor() {
    (super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = "InstancedBufferGeometry"),
      (this.instanceCount = 1 / 0));
  }
  copy(e) {
    return (super.copy(e), (this.instanceCount = e.instanceCount), this);
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.instanceCount = this.instanceCount),
      (e.isInstancedBufferGeometry = !0),
      e
    );
  }
}
class RR extends _i {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = new Qi(s.manager);
    (o.setPath(s.path),
      o.setRequestHeader(s.requestHeader),
      o.setWithCredentials(s.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)));
          } catch (l) {
            (r ? r(l) : console.error(l), s.manager.itemError(e));
          }
        },
        i,
        r
      ));
  }
  parse(e) {
    const t = {},
      i = {};
    function r(g, y) {
      if (t[y] !== void 0) return t[y];
      const _ = g.interleavedBuffers[y],
        m = s(g, _.buffer),
        x = vc(_.type, m),
        S = new Ch(x, _.stride);
      return ((S.uuid = _.uuid), (t[y] = S), S);
    }
    function s(g, y) {
      if (i[y] !== void 0) return i[y];
      const _ = g.arrayBuffers[y],
        m = new Uint32Array(_).buffer;
      return ((i[y] = m), m);
    }
    const o = e.isInstancedBufferGeometry ? new BR() : new ft(),
      a = e.data.index;
    if (a !== void 0) {
      const g = vc(a.type, a.array);
      o.setIndex(new Dt(g, 1));
    }
    const l = e.data.attributes;
    for (const g in l) {
      const y = l[g];
      let A;
      if (y.isInterleavedBufferAttribute) {
        const _ = r(e.data, y.data);
        A = new Qo(_, y.itemSize, y.offset, y.normalized);
      } else {
        const _ = vc(y.type, y.array),
          m = y.isInstancedBufferAttribute ? Kc : Dt;
        A = new m(_, y.itemSize, y.normalized);
      }
      (y.name !== void 0 && (A.name = y.name),
        y.usage !== void 0 && A.setUsage(y.usage),
        y.updateRange !== void 0 &&
          ((A.updateRange.offset = y.updateRange.offset),
          (A.updateRange.count = y.updateRange.count)),
        o.setAttribute(g, A));
    }
    const u = e.data.morphAttributes;
    if (u)
      for (const g in u) {
        const y = u[g],
          A = [];
        for (let _ = 0, m = y.length; _ < m; _++) {
          const x = y[_];
          let S;
          if (x.isInterleavedBufferAttribute) {
            const w = r(e.data, x.data);
            S = new Qo(w, x.itemSize, x.offset, x.normalized);
          } else {
            const w = vc(x.type, x.array);
            S = new Dt(w, x.itemSize, x.normalized);
          }
          (x.name !== void 0 && (S.name = x.name), A.push(S));
        }
        o.morphAttributes[g] = A;
      }
    e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
    const d = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (d !== void 0)
      for (let g = 0, y = d.length; g !== y; ++g) {
        const A = d[g];
        o.addGroup(A.start, A.count, A.materialIndex);
      }
    const p = e.data.boundingSphere;
    if (p !== void 0) {
      const g = new F();
      (p.center !== void 0 && g.fromArray(p.center),
        (o.boundingSphere = new Wr(g, p.radius)));
    }
    return (
      e.name && (o.name = e.name),
      e.userData && (o.userData = e.userData),
      o
    );
  }
}
class wH extends _i {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = this.path === "" ? cs.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || o;
    const a = new Qi(this.manager);
    (a.setPath(this.path),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        e,
        function (l) {
          let u = null;
          try {
            u = JSON.parse(l);
          } catch (d) {
            (r !== void 0 && r(d),
              console.error(
                "THREE:ObjectLoader: Can't parse " + e + ".",
                d.message
              ));
            return;
          }
          const h = u.metadata;
          if (
            h === void 0 ||
            h.type === void 0 ||
            h.type.toLowerCase() === "geometry"
          ) {
            (r !== void 0 &&
              r(new Error("THREE.ObjectLoader: Can't load " + e)),
              console.error("THREE.ObjectLoader: Can't load " + e));
            return;
          }
          s.parse(u, t);
        },
        i,
        r
      ));
  }
  async loadAsync(e, t) {
    const i = this,
      r = this.path === "" ? cs.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || r;
    const s = new Qi(this.manager);
    (s.setPath(this.path),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials));
    const o = await s.loadAsync(e, t),
      a = JSON.parse(o),
      l = a.metadata;
    if (
      l === void 0 ||
      l.type === void 0 ||
      l.type.toLowerCase() === "geometry"
    )
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await i.parseAsync(a);
  }
  parse(e, t) {
    const i = this.parseAnimations(e.animations),
      r = this.parseShapes(e.shapes),
      s = this.parseGeometries(e.geometries, r),
      o = this.parseImages(e.images, function () {
        t !== void 0 && t(u);
      }),
      a = this.parseTextures(e.textures, o),
      l = this.parseMaterials(e.materials, a),
      u = this.parseObject(e.object, s, l, a, i),
      h = this.parseSkeletons(e.skeletons, u);
    if ((this.bindSkeletons(u, h), t !== void 0)) {
      let d = !1;
      for (const p in o)
        if (o[p].data instanceof HTMLImageElement) {
          d = !0;
          break;
        }
      d === !1 && t(u);
    }
    return u;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations),
      i = this.parseShapes(e.shapes),
      r = this.parseGeometries(e.geometries, i),
      s = await this.parseImagesAsync(e.images),
      o = this.parseTextures(e.textures, s),
      a = this.parseMaterials(e.materials, o),
      l = this.parseObject(e.object, r, a, o, t),
      u = this.parseSkeletons(e.skeletons, l);
    return (this.bindSkeletons(l, u), l);
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let i = 0, r = e.length; i < r; i++) {
        const s = new $a().fromJSON(e[i]);
        t[s.uuid] = s;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const i = {},
      r = {};
    if (
      (t.traverse(function (s) {
        s.isBone && (r[s.uuid] = s);
      }),
      e !== void 0)
    )
      for (let s = 0, o = e.length; s < o; s++) {
        const a = new Th().fromJSON(e[s], r);
        i[a.uuid] = a;
      }
    return i;
  }
  parseGeometries(e, t) {
    const i = {};
    if (e !== void 0) {
      const r = new RR();
      for (let s = 0, o = e.length; s < o; s++) {
        let a;
        const l = e[s];
        switch (l.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            a = r.parse(l);
            break;
          default:
            l.type in pC
              ? (a = pC[l.type].fromJSON(l, t))
              : console.warn(
                  `THREE.ObjectLoader: Unsupported geometry type "${l.type}"`
                );
        }
        ((a.uuid = l.uuid),
          l.name !== void 0 && (a.name = l.name),
          l.userData !== void 0 && (a.userData = l.userData),
          (i[l.uuid] = a));
      }
    }
    return i;
  }
  parseMaterials(e, t) {
    const i = {},
      r = {};
    if (e !== void 0) {
      const s = new Xg();
      s.setTextures(t);
      for (let o = 0, a = e.length; o < a; o++) {
        const l = e[o];
        (i[l.uuid] === void 0 && (i[l.uuid] = s.parse(l)),
          (r[l.uuid] = i[l.uuid]));
      }
    }
    return r;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let i = 0; i < e.length; i++) {
        const r = e[i],
          s = Zc.parse(r);
        t[s.uuid] = s;
      }
    return t;
  }
  parseImages(e, t) {
    const i = this,
      r = {};
    let s;
    function o(l) {
      return (
        i.manager.itemStart(l),
        s.load(
          l,
          function () {
            i.manager.itemEnd(l);
          },
          void 0,
          function () {
            (i.manager.itemError(l), i.manager.itemEnd(l));
          }
        )
      );
    }
    function a(l) {
      if (typeof l == "string") {
        const u = l,
          h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : i.resourcePath + u;
        return o(h);
      } else
        return l.data
          ? { data: vc(l.type, l.data), width: l.width, height: l.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      const l = new wA(t);
      ((s = new lh(l)), s.setCrossOrigin(this.crossOrigin));
      for (let u = 0, h = e.length; u < h; u++) {
        const d = e[u],
          p = d.url;
        if (Array.isArray(p)) {
          const g = [];
          for (let y = 0, A = p.length; y < A; y++) {
            const _ = p[y],
              m = a(_);
            m !== null &&
              (m instanceof HTMLImageElement
                ? g.push(m)
                : g.push(new Lc(m.data, m.width, m.height)));
          }
          r[d.uuid] = new Va(g);
        } else {
          const g = a(d.url);
          r[d.uuid] = new Va(g);
        }
      }
    }
    return r;
  }
  async parseImagesAsync(e) {
    const t = this,
      i = {};
    let r;
    async function s(o) {
      if (typeof o == "string") {
        const a = o,
          l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
        return await r.loadAsync(l);
      } else
        return o.data
          ? { data: vc(o.type, o.data), width: o.width, height: o.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      ((r = new lh(this.manager)), r.setCrossOrigin(this.crossOrigin));
      for (let o = 0, a = e.length; o < a; o++) {
        const l = e[o],
          u = l.url;
        if (Array.isArray(u)) {
          const h = [];
          for (let d = 0, p = u.length; d < p; d++) {
            const g = u[d],
              y = await s(g);
            y !== null &&
              (y instanceof HTMLImageElement
                ? h.push(y)
                : h.push(new Lc(y.data, y.width, y.height)));
          }
          i[l.uuid] = new Va(h);
        } else {
          const h = await s(l.url);
          i[l.uuid] = new Va(h);
        }
      }
    }
    return i;
  }
  parseTextures(e, t) {
    function i(s, o) {
      return typeof s == "number"
        ? s
        : (console.warn(
            "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
            s
          ),
          o[s]);
    }
    const r = {};
    if (e !== void 0)
      for (let s = 0, o = e.length; s < o; s++) {
        const a = e[s];
        (a.image === void 0 &&
          console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid),
          t[a.image] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined image", a.image));
        const l = t[a.image],
          u = l.data;
        let h;
        (Array.isArray(u)
          ? ((h = new Eh()), u.length === 6 && (h.needsUpdate = !0))
          : (u && u.data ? (h = new Lc()) : (h = new en()),
            u && (h.needsUpdate = !0)),
          (h.source = l),
          (h.uuid = a.uuid),
          a.name !== void 0 && (h.name = a.name),
          a.mapping !== void 0 && (h.mapping = i(a.mapping, EH)),
          a.channel !== void 0 && (h.channel = a.channel),
          a.offset !== void 0 && h.offset.fromArray(a.offset),
          a.repeat !== void 0 && h.repeat.fromArray(a.repeat),
          a.center !== void 0 && h.center.fromArray(a.center),
          a.rotation !== void 0 && (h.rotation = a.rotation),
          a.wrap !== void 0 &&
            ((h.wrapS = i(a.wrap[0], yC)), (h.wrapT = i(a.wrap[1], yC))),
          a.format !== void 0 && (h.format = a.format),
          a.internalFormat !== void 0 && (h.internalFormat = a.internalFormat),
          a.type !== void 0 && (h.type = a.type),
          a.encoding !== void 0 && (h.encoding = a.encoding),
          a.minFilter !== void 0 && (h.minFilter = i(a.minFilter, xC)),
          a.magFilter !== void 0 && (h.magFilter = i(a.magFilter, xC)),
          a.anisotropy !== void 0 && (h.anisotropy = a.anisotropy),
          a.flipY !== void 0 && (h.flipY = a.flipY),
          a.generateMipmaps !== void 0 &&
            (h.generateMipmaps = a.generateMipmaps),
          a.premultiplyAlpha !== void 0 &&
            (h.premultiplyAlpha = a.premultiplyAlpha),
          a.unpackAlignment !== void 0 &&
            (h.unpackAlignment = a.unpackAlignment),
          a.userData !== void 0 && (h.userData = a.userData),
          (r[a.uuid] = h));
      }
    return r;
  }
  parseObject(e, t, i, r, s) {
    let o;
    function a(p) {
      return (
        t[p] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined geometry", p),
        t[p]
      );
    }
    function l(p) {
      if (p !== void 0) {
        if (Array.isArray(p)) {
          const g = [];
          for (let y = 0, A = p.length; y < A; y++) {
            const _ = p[y];
            (i[_] === void 0 &&
              console.warn("THREE.ObjectLoader: Undefined material", _),
              g.push(i[_]));
          }
          return g;
        }
        return (
          i[p] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined material", p),
          i[p]
        );
      }
    }
    function u(p) {
      return (
        r[p] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined texture", p),
        r[p]
      );
    }
    let h, d;
    switch (e.type) {
      case "Scene":
        ((o = new Zm()),
          e.background !== void 0 &&
            (Number.isInteger(e.background)
              ? (o.background = new Ie(e.background))
              : (o.background = u(e.background))),
          e.environment !== void 0 && (o.environment = u(e.environment)),
          e.fog !== void 0 &&
            (e.fog.type === "Fog"
              ? (o.fog = new Gg(e.fog.color, e.fog.near, e.fog.far))
              : e.fog.type === "FogExp2" &&
                (o.fog = new zg(e.fog.color, e.fog.density))),
          e.backgroundBlurriness !== void 0 &&
            (o.backgroundBlurriness = e.backgroundBlurriness),
          e.backgroundIntensity !== void 0 &&
            (o.backgroundIntensity = e.backgroundIntensity));
        break;
      case "PerspectiveCamera":
        ((o = new Vt(e.fov, e.aspect, e.near, e.far)),
          e.focus !== void 0 && (o.focus = e.focus),
          e.zoom !== void 0 && (o.zoom = e.zoom),
          e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge),
          e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset),
          e.view !== void 0 && (o.view = Object.assign({}, e.view)));
        break;
      case "OrthographicCamera":
        ((o = new zr(e.left, e.right, e.top, e.bottom, e.near, e.far)),
          e.zoom !== void 0 && (o.zoom = e.zoom),
          e.view !== void 0 && (o.view = Object.assign({}, e.view)));
        break;
      case "AmbientLight":
        o = new TR(e.color, e.intensity);
        break;
      case "DirectionalLight":
        o = new bA(e.color, e.intensity);
        break;
      case "PointLight":
        o = new TA(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        o = new bR(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        o = new CA(
          e.color,
          e.intensity,
          e.distance,
          e.angle,
          e.penumbra,
          e.decay
        );
        break;
      case "HemisphereLight":
        o = new CR(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        o = new Jg().fromJSON(e);
        break;
      case "SkinnedMesh":
        ((h = a(e.geometry)),
          (d = l(e.material)),
          (o = new uA(h, d)),
          e.bindMode !== void 0 && (o.bindMode = e.bindMode),
          e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix),
          e.skeleton !== void 0 && (o.skeleton = e.skeleton));
        break;
      case "Mesh":
        ((h = a(e.geometry)), (d = l(e.material)), (o = new Bn(h, d)));
        break;
      case "InstancedMesh":
        ((h = a(e.geometry)), (d = l(e.material)));
        const p = e.count,
          g = e.instanceMatrix,
          y = e.instanceColor;
        ((o = new iR(h, d, p)),
          (o.instanceMatrix = new Kc(new Float32Array(g.array), 16)),
          y !== void 0 &&
            (o.instanceColor = new Kc(new Float32Array(y.array), y.itemSize)));
        break;
      case "LOD":
        o = new nR();
        break;
      case "Line":
        o = new Zs(a(e.geometry), l(e.material));
        break;
      case "LineLoop":
        o = new fA(a(e.geometry), l(e.material));
        break;
      case "LineSegments":
        o = new jr(a(e.geometry), l(e.material));
        break;
      case "PointCloud":
      case "Points":
        o = new hA(a(e.geometry), l(e.material));
        break;
      case "Sprite":
        o = new tR(l(e.material));
        break;
      case "Group":
        o = new Us();
        break;
      case "Bone":
        o = new Hg();
        break;
      default:
        o = new Pt();
    }
    if (
      ((o.uuid = e.uuid),
      e.name !== void 0 && (o.name = e.name),
      e.matrix !== void 0
        ? (o.matrix.fromArray(e.matrix),
          e.matrixAutoUpdate !== void 0 &&
            (o.matrixAutoUpdate = e.matrixAutoUpdate),
          o.matrixAutoUpdate &&
            o.matrix.decompose(o.position, o.quaternion, o.scale))
        : (e.position !== void 0 && o.position.fromArray(e.position),
          e.rotation !== void 0 && o.rotation.fromArray(e.rotation),
          e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion),
          e.scale !== void 0 && o.scale.fromArray(e.scale)),
      e.up !== void 0 && o.up.fromArray(e.up),
      e.castShadow !== void 0 && (o.castShadow = e.castShadow),
      e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow),
      e.shadow &&
        (e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 &&
          (o.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 &&
          o.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 &&
          (o.shadow.camera = this.parseObject(e.shadow.camera))),
      e.visible !== void 0 && (o.visible = e.visible),
      e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled),
      e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder),
      e.userData !== void 0 && (o.userData = e.userData),
      e.layers !== void 0 && (o.layers.mask = e.layers),
      e.children !== void 0)
    ) {
      const p = e.children;
      for (let g = 0; g < p.length; g++)
        o.add(this.parseObject(p[g], t, i, r, s));
    }
    if (e.animations !== void 0) {
      const p = e.animations;
      for (let g = 0; g < p.length; g++) {
        const y = p[g];
        o.animations.push(s[y]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
      const p = e.levels;
      for (let g = 0; g < p.length; g++) {
        const y = p[g],
          A = o.getObjectByProperty("uuid", y.object);
        A !== void 0 && o.addLevel(A, y.distance, y.hysteresis);
      }
    }
    return o;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 &&
      e.traverse(function (i) {
        if (i.isSkinnedMesh === !0 && i.skeleton !== void 0) {
          const r = t[i.skeleton];
          r === void 0
            ? console.warn(
                "THREE.ObjectLoader: No skeleton found with UUID:",
                i.skeleton
              )
            : i.bind(r, i.bindMatrix);
        }
      });
  }
}
const EH = {
    UVMapping: Dg,
    CubeReflectionMapping: Xo,
    CubeRefractionMapping: Ko,
    EquirectangularReflectionMapping: qf,
    EquirectangularRefractionMapping: $f,
    CubeUVReflectionMapping: iu,
  },
  yC = {
    RepeatWrapping: Yo,
    ClampToEdgeWrapping: jn,
    MirroredRepeatWrapping: Hc,
  },
  xC = {
    NearestFilter: dn,
    NearestMipmapNearestFilter: eh,
    NearestMipmapLinearFilter: Bc,
    LinearFilter: rn,
    LinearMipmapNearestFilter: Fg,
    LinearMipmapLinearFilter: hs,
  };
class LR extends _i {
  constructor(e) {
    (super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > "u" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
      typeof fetch > "u" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" }));
  }
  setOptions(e) {
    return ((this.options = e), this);
  }
  load(e, t, i, r) {
    (e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e)));
    const s = this,
      o = ll.get(e);
    if (o !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          (t && t(o), s.manager.itemEnd(e));
        }, 0),
        o
      );
    const a = {};
    ((a.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (a.headers = this.requestHeader),
      fetch(e, a)
        .then(function (l) {
          return l.blob();
        })
        .then(function (l) {
          return createImageBitmap(
            l,
            Object.assign(s.options, { colorSpaceConversion: "none" })
          );
        })
        .then(function (l) {
          (ll.add(e, l), t && t(l), s.manager.itemEnd(e));
        })
        .catch(function (l) {
          (r && r(l), s.manager.itemError(e), s.manager.itemEnd(e));
        }),
      s.manager.itemStart(e));
  }
}
let Gp;
class PA {
  static getContext() {
    return (
      Gp === void 0 &&
        (Gp = new (window.AudioContext || window.webkitAudioContext)()),
      Gp
    );
  }
  static setContext(e) {
    Gp = e;
  }
}
class CH extends _i {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = new Qi(this.manager);
    (o.setResponseType("arraybuffer"),
      o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            const l = a.slice(0);
            PA.getContext().decodeAudioData(l, function (h) {
              t(h);
            });
          } catch (l) {
            (r ? r(l) : console.error(l), s.manager.itemError(e));
          }
        },
        i,
        r
      ));
  }
}
class TH extends Jg {
  constructor(e, t, i = 1) {
    (super(void 0, i), (this.isHemisphereLightProbe = !0));
    const r = new Ie().set(e),
      s = new Ie().set(t),
      o = new F(r.r, r.g, r.b),
      a = new F(s.r, s.g, s.b),
      l = Math.sqrt(Math.PI),
      u = l * Math.sqrt(0.75);
    (this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l),
      this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(u));
  }
}
class bH extends Jg {
  constructor(e, t = 1) {
    (super(void 0, t), (this.isAmbientLightProbe = !0));
    const i = new Ie().set(e);
    this.sh.coefficients[0]
      .set(i.r, i.g, i.b)
      .multiplyScalar(2 * Math.sqrt(Math.PI));
  }
}
const _C = new ot(),
  AC = new ot(),
  xa = new ot();
class PH {
  constructor() {
    ((this.type = "StereoCamera"),
      (this.aspect = 1),
      (this.eyeSep = 0.064),
      (this.cameraL = new Vt()),
      this.cameraL.layers.enable(1),
      (this.cameraL.matrixAutoUpdate = !1),
      (this.cameraR = new Vt()),
      this.cameraR.layers.enable(2),
      (this.cameraR.matrixAutoUpdate = !1),
      (this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null,
      }));
  }
  update(e) {
    const t = this._cache;
    if (
      t.focus !== e.focus ||
      t.fov !== e.fov ||
      t.aspect !== e.aspect * this.aspect ||
      t.near !== e.near ||
      t.far !== e.far ||
      t.zoom !== e.zoom ||
      t.eyeSep !== this.eyeSep
    ) {
      ((t.focus = e.focus),
        (t.fov = e.fov),
        (t.aspect = e.aspect * this.aspect),
        (t.near = e.near),
        (t.far = e.far),
        (t.zoom = e.zoom),
        (t.eyeSep = this.eyeSep),
        xa.copy(e.projectionMatrix));
      const r = t.eyeSep / 2,
        s = (r * t.near) / t.focus,
        o = (t.near * Math.tan(Za * t.fov * 0.5)) / t.zoom;
      let a, l;
      ((AC.elements[12] = -r),
        (_C.elements[12] = r),
        (a = -o * t.aspect + s),
        (l = o * t.aspect + s),
        (xa.elements[0] = (2 * t.near) / (l - a)),
        (xa.elements[8] = (l + a) / (l - a)),
        this.cameraL.projectionMatrix.copy(xa),
        (a = -o * t.aspect - s),
        (l = o * t.aspect - s),
        (xa.elements[0] = (2 * t.near) / (l - a)),
        (xa.elements[8] = (l + a) / (l - a)),
        this.cameraR.projectionMatrix.copy(xa));
    }
    (this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(AC),
      this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(_C));
  }
}
class BA {
  constructor(e = !0) {
    ((this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1));
  }
  start() {
    ((this.startTime = MC()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0));
  }
  stop() {
    (this.getElapsedTime(), (this.running = !1), (this.autoStart = !1));
  }
  getElapsedTime() {
    return (this.getDelta(), this.elapsedTime);
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return (this.start(), 0);
    if (this.running) {
      const t = MC();
      ((e = (t - this.oldTime) / 1e3),
        (this.oldTime = t),
        (this.elapsedTime += e));
    }
    return e;
  }
}
function MC() {
  return (typeof performance > "u" ? Date : performance).now();
}
const _a = new F(),
  SC = new Kn(),
  BH = new F(),
  Aa = new F();
class RH extends Pt {
  constructor() {
    (super(),
      (this.type = "AudioListener"),
      (this.context = PA.getContext()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null),
      (this.timeDelta = 0),
      (this._clock = new BA()));
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return (
      this.filter !== null &&
        (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        (this.filter = null)),
      this
    );
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return (
      this.filter !== null
        ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination),
      (this.filter = e),
      this.gain.connect(this.filter),
      this.filter.connect(this.context.destination),
      this
    );
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01),
      this
    );
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener,
      i = this.up;
    if (
      ((this.timeDelta = this._clock.getDelta()),
      this.matrixWorld.decompose(_a, SC, BH),
      Aa.set(0, 0, -1).applyQuaternion(SC),
      t.positionX)
    ) {
      const r = this.context.currentTime + this.timeDelta;
      (t.positionX.linearRampToValueAtTime(_a.x, r),
        t.positionY.linearRampToValueAtTime(_a.y, r),
        t.positionZ.linearRampToValueAtTime(_a.z, r),
        t.forwardX.linearRampToValueAtTime(Aa.x, r),
        t.forwardY.linearRampToValueAtTime(Aa.y, r),
        t.forwardZ.linearRampToValueAtTime(Aa.z, r),
        t.upX.linearRampToValueAtTime(i.x, r),
        t.upY.linearRampToValueAtTime(i.y, r),
        t.upZ.linearRampToValueAtTime(i.z, r));
    } else
      (t.setPosition(_a.x, _a.y, _a.z),
        t.setOrientation(Aa.x, Aa.y, Aa.z, i.x, i.y, i.z));
  }
}
class IR extends Pt {
  constructor(e) {
    (super(),
      (this.type = "Audio"),
      (this.listener = e),
      (this.context = e.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(e.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = "empty"),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = []));
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "audioNode"),
      (this.source = e),
      this.connect(),
      this
    );
  }
  setMediaElementSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaNode"),
      (this.source = this.context.createMediaElementSource(e)),
      this.connect(),
      this
    );
  }
  setMediaStreamSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaStreamNode"),
      (this.source = this.context.createMediaStreamSource(e)),
      this.connect(),
      this
    );
  }
  setBuffer(e) {
    return (
      (this.buffer = e),
      (this.sourceType = "buffer"),
      this.autoplay && this.play(),
      this
    );
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return (
      (t.buffer = this.buffer),
      (t.loop = this.loop),
      (t.loopStart = this.loopStart),
      (t.loopEnd = this.loopEnd),
      (t.onended = this.onEnded.bind(this)),
      t.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = t),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    );
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      this.isPlaying === !0 &&
        ((this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) *
          this.playbackRate),
        this.loop === !0 &&
          (this._progress =
            this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1)),
      this
    );
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this._progress = 0),
      this.source !== null &&
        (this.source.stop(), (this.source.onended = null)),
      (this.isPlaying = !1),
      this
    );
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return ((this._connected = !0), this);
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].disconnect(this.filters[e]);
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else this.source.disconnect(this.getOutput());
    return ((this._connected = !1), this);
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return (
      e || (e = []),
      this._connected === !0
        ? (this.disconnect(), (this.filters = e.slice()), this.connect())
        : (this.filters = e.slice()),
      this
    );
  }
  setDetune(e) {
    if (((this.detune = e), this.source.detune !== void 0))
      return (
        this.isPlaying === !0 &&
          this.source.detune.setTargetAtTime(
            this.detune,
            this.context.currentTime,
            0.01
          ),
        this
      );
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.playbackRate = e),
      this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1
      ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
      : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.loop = e),
      this.isPlaying === !0 && (this.source.loop = this.loop),
      this
    );
  }
  setLoopStart(e) {
    return ((this.loopStart = e), this);
  }
  setLoopEnd(e) {
    return ((this.loopEnd = e), this);
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01),
      this
    );
  }
}
const Ma = new F(),
  wC = new Kn(),
  LH = new F(),
  Sa = new F();
class IH extends IR {
  constructor(e) {
    (super(e),
      (this.panner = this.context.createPanner()),
      (this.panner.panningModel = "HRTF"),
      this.panner.connect(this.gain));
  }
  disconnect() {
    (super.disconnect(), this.panner.disconnect(this.gain));
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return ((this.panner.refDistance = e), this);
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return ((this.panner.rolloffFactor = e), this);
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return ((this.panner.distanceModel = e), this);
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return ((this.panner.maxDistance = e), this);
  }
  setDirectionalCone(e, t, i) {
    return (
      (this.panner.coneInnerAngle = e),
      (this.panner.coneOuterAngle = t),
      (this.panner.coneOuterGain = i),
      this
    );
  }
  updateMatrixWorld(e) {
    if (
      (super.updateMatrixWorld(e),
      this.hasPlaybackControl === !0 && this.isPlaying === !1)
    )
      return;
    (this.matrixWorld.decompose(Ma, wC, LH),
      Sa.set(0, 0, 1).applyQuaternion(wC));
    const t = this.panner;
    if (t.positionX) {
      const i = this.context.currentTime + this.listener.timeDelta;
      (t.positionX.linearRampToValueAtTime(Ma.x, i),
        t.positionY.linearRampToValueAtTime(Ma.y, i),
        t.positionZ.linearRampToValueAtTime(Ma.z, i),
        t.orientationX.linearRampToValueAtTime(Sa.x, i),
        t.orientationY.linearRampToValueAtTime(Sa.y, i),
        t.orientationZ.linearRampToValueAtTime(Sa.z, i));
    } else
      (t.setPosition(Ma.x, Ma.y, Ma.z), t.setOrientation(Sa.x, Sa.y, Sa.z));
  }
}
class DH {
  constructor(e, t = 2048) {
    ((this.analyser = e.context.createAnalyser()),
      (this.analyser.fftSize = t),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      e.getOutput().connect(this.analyser));
  }
  getFrequencyData() {
    return (this.analyser.getByteFrequencyData(this.data), this.data);
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let i = 0; i < t.length; i++) e += t[i];
    return e / t.length;
  }
}
class DR {
  constructor(e, t, i) {
    ((this.binding = e), (this.valueSize = i));
    let r, s, o;
    switch (t) {
      case "quaternion":
        ((r = this._slerp),
          (s = this._slerpAdditive),
          (o = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(i * 6)),
          (this._workIndex = 5));
        break;
      case "string":
      case "bool":
        ((r = this._select),
          (s = this._select),
          (o = this._setAdditiveIdentityOther),
          (this.buffer = new Array(i * 5)));
        break;
      default:
        ((r = this._lerp),
          (s = this._lerpAdditive),
          (o = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(i * 5)));
    }
    ((this._mixBufferRegion = r),
      (this._mixBufferRegionAdditive = s),
      (this._setIdentity = o),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0));
  }
  accumulate(e, t) {
    const i = this.buffer,
      r = this.valueSize,
      s = e * r + r;
    let o = this.cumulativeWeight;
    if (o === 0) {
      for (let a = 0; a !== r; ++a) i[s + a] = i[a];
      o = t;
    } else {
      o += t;
      const a = t / o;
      this._mixBufferRegion(i, s, 0, a, r);
    }
    this.cumulativeWeight = o;
  }
  accumulateAdditive(e) {
    const t = this.buffer,
      i = this.valueSize,
      r = i * this._addIndex;
    (this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(t, r, 0, e, i),
      (this.cumulativeWeightAdditive += e));
  }
  apply(e) {
    const t = this.valueSize,
      i = this.buffer,
      r = e * t + t,
      s = this.cumulativeWeight,
      o = this.cumulativeWeightAdditive,
      a = this.binding;
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), s < 1)
    ) {
      const l = t * this._origIndex;
      this._mixBufferRegion(i, r, l, 1 - s, t);
    }
    o > 0 && this._mixBufferRegionAdditive(i, r, this._addIndex * t, 1, t);
    for (let l = t, u = t + t; l !== u; ++l)
      if (i[l] !== i[l + t]) {
        a.setValue(i, r);
        break;
      }
  }
  saveOriginalState() {
    const e = this.binding,
      t = this.buffer,
      i = this.valueSize,
      r = i * this._origIndex;
    e.getValue(t, r);
    for (let s = i, o = r; s !== o; ++s) t[s] = t[r + (s % i)];
    (this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0));
  }
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize,
      t = e + this.valueSize;
    for (let i = e; i < t; i++) this.buffer[i] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    (this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1));
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize,
      t = this._addIndex * this.valueSize;
    for (let i = 0; i < this.valueSize; i++)
      this.buffer[t + i] = this.buffer[e + i];
  }
  _select(e, t, i, r, s) {
    if (r >= 0.5) for (let o = 0; o !== s; ++o) e[t + o] = e[i + o];
  }
  _slerp(e, t, i, r) {
    Kn.slerpFlat(e, t, e, t, e, i, r);
  }
  _slerpAdditive(e, t, i, r, s) {
    const o = this._workIndex * s;
    (Kn.multiplyQuaternionsFlat(e, o, e, t, e, i),
      Kn.slerpFlat(e, t, e, t, e, o, r));
  }
  _lerp(e, t, i, r, s) {
    const o = 1 - r;
    for (let a = 0; a !== s; ++a) {
      const l = t + a;
      e[l] = e[l] * o + e[i + a] * r;
    }
  }
  _lerpAdditive(e, t, i, r, s) {
    for (let o = 0; o !== s; ++o) {
      const a = t + o;
      e[a] = e[a] + e[i + o] * r;
    }
  }
}
const RA = "\\[\\]\\.:\\/",
  FH = new RegExp("[" + RA + "]", "g"),
  LA = "[^" + RA + "]",
  NH = "[^" + RA.replace("\\.", "") + "]",
  kH = /((?:WC+[\/:])*)/.source.replace("WC", LA),
  OH = /(WCOD+)?/.source.replace("WCOD", NH),
  UH = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", LA),
  zH = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", LA),
  GH = new RegExp("^" + kH + OH + UH + zH + "$"),
  HH = ["material", "materials", "bones", "map"];
class VH {
  constructor(e, t, i) {
    const r = i || bt.parseTrackName(t);
    ((this._targetGroup = e), (this._bindings = e.subscribe_(t, r)));
  }
  getValue(e, t) {
    this.bind();
    const i = this._targetGroup.nCachedObjects_,
      r = this._bindings[i];
    r !== void 0 && r.getValue(e, t);
  }
  setValue(e, t) {
    const i = this._bindings;
    for (let r = this._targetGroup.nCachedObjects_, s = i.length; r !== s; ++r)
      i[r].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].unbind();
  }
}
class bt {
  constructor(e, t, i) {
    ((this.path = t),
      (this.parsedPath = i || bt.parseTrackName(t)),
      (this.node = bt.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound));
  }
  static create(e, t, i) {
    return e && e.isAnimationObjectGroup
      ? new bt.Composite(e, t, i)
      : new bt(e, t, i);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(FH, "");
  }
  static parseTrackName(e) {
    const t = GH.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const i = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      r = i.nodeName && i.nodeName.lastIndexOf(".");
    if (r !== void 0 && r !== -1) {
      const s = i.nodeName.substring(r + 1);
      HH.indexOf(s) !== -1 &&
        ((i.nodeName = i.nodeName.substring(0, r)), (i.objectName = s));
    }
    if (i.propertyName === null || i.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e
      );
    return i;
  }
  static findNode(e, t) {
    if (
      t === void 0 ||
      t === "" ||
      t === "." ||
      t === -1 ||
      t === e.name ||
      t === e.uuid
    )
      return e;
    if (e.skeleton) {
      const i = e.skeleton.getBoneByName(t);
      if (i !== void 0) return i;
    }
    if (e.children) {
      const i = function (s) {
          for (let o = 0; o < s.length; o++) {
            const a = s[o];
            if (a.name === t || a.uuid === t) return a;
            const l = i(a.children);
            if (l) return l;
          }
          return null;
        },
        r = i(e.children);
      if (r) return r;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) e[t++] = i[r];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    ((this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0));
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    ((this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0));
  }
  _setValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    ((this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0));
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    ((this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0));
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    (this.resolvedProperty.fromArray(e, t),
      (this.targetObject.needsUpdate = !0));
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    (this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0));
  }
  _getValue_unbound(e, t) {
    (this.bind(), this.getValue(e, t));
  }
  _setValue_unbound(e, t) {
    (this.bind(), this.setValue(e, t));
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath,
      i = t.objectName,
      r = t.propertyName;
    let s = t.propertyIndex;
    if (
      (e || ((e = bt.findNode(this.rootNode, t.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.error(
        "THREE.PropertyBinding: Trying to update node for track: " +
          this.path +
          " but it wasn't found."
      );
      return;
    }
    if (i) {
      let u = t.objectIndex;
      switch (i) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
            return;
          }
          e = e.skeleton.bones;
          for (let h = 0; h < e.length; h++)
            if (e[h].name === u) {
              u = h;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[i] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
            return;
          }
          e = e[i];
      }
      if (u !== void 0) {
        if (e[u] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e
          );
          return;
        }
        e = e[u];
      }
    }
    const o = e[r];
    if (o === void 0) {
      const u = t.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          u +
          "." +
          r +
          " but it wasn't found.",
        e
      );
      return;
    }
    let a = this.Versioning.None;
    ((this.targetObject = e),
      e.needsUpdate !== void 0
        ? (a = this.Versioning.NeedsUpdate)
        : e.matrixWorldNeedsUpdate !== void 0 &&
          (a = this.Versioning.MatrixWorldNeedsUpdate));
    let l = this.BindingType.Direct;
    if (s !== void 0) {
      if (r === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this
          );
          return;
        }
        e.morphTargetDictionary[s] !== void 0 &&
          (s = e.morphTargetDictionary[s]);
      }
      ((l = this.BindingType.ArrayElement),
        (this.resolvedProperty = o),
        (this.propertyIndex = s));
    } else
      o.fromArray !== void 0 && o.toArray !== void 0
        ? ((l = this.BindingType.HasFromToArray), (this.resolvedProperty = o))
        : Array.isArray(o)
          ? ((l = this.BindingType.EntireArray), (this.resolvedProperty = o))
          : (this.propertyName = r);
    ((this.getValue = this.GetterByBindingType[l]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[l][a]));
  }
  unbind() {
    ((this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound));
  }
}
bt.Composite = VH;
bt.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
bt.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
bt.prototype.GetterByBindingType = [
  bt.prototype._getValue_direct,
  bt.prototype._getValue_array,
  bt.prototype._getValue_arrayElement,
  bt.prototype._getValue_toArray,
];
bt.prototype.SetterByBindingTypeAndVersioning = [
  [
    bt.prototype._setValue_direct,
    bt.prototype._setValue_direct_setNeedsUpdate,
    bt.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    bt.prototype._setValue_array,
    bt.prototype._setValue_array_setNeedsUpdate,
    bt.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    bt.prototype._setValue_arrayElement,
    bt.prototype._setValue_arrayElement_setNeedsUpdate,
    bt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    bt.prototype._setValue_fromArray,
    bt.prototype._setValue_fromArray_setNeedsUpdate,
    bt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class WH {
  constructor() {
    ((this.isAnimationObjectGroup = !0),
      (this.uuid = Ki()),
      (this._objects = Array.prototype.slice.call(arguments)),
      (this.nCachedObjects_ = 0));
    const e = {};
    this._indicesByUUID = e;
    for (let i = 0, r = arguments.length; i !== r; ++i)
      e[arguments[i].uuid] = i;
    ((this._paths = []),
      (this._parsedPaths = []),
      (this._bindings = []),
      (this._bindingsIndicesByPath = {}));
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        },
      },
      get bindingsPerObject() {
        return t._bindings.length;
      },
    };
  }
  add() {
    const e = this._objects,
      t = this._indicesByUUID,
      i = this._paths,
      r = this._parsedPaths,
      s = this._bindings,
      o = s.length;
    let a,
      l = e.length,
      u = this.nCachedObjects_;
    for (let h = 0, d = arguments.length; h !== d; ++h) {
      const p = arguments[h],
        g = p.uuid;
      let y = t[g];
      if (y === void 0) {
        ((y = l++), (t[g] = y), e.push(p));
        for (let A = 0, _ = o; A !== _; ++A) s[A].push(new bt(p, i[A], r[A]));
      } else if (y < u) {
        a = e[y];
        const A = --u,
          _ = e[A];
        ((t[_.uuid] = y), (e[y] = _), (t[g] = A), (e[A] = p));
        for (let m = 0, x = o; m !== x; ++m) {
          const S = s[m],
            w = S[A];
          let C = S[y];
          ((S[y] = w), C === void 0 && (C = new bt(p, i[m], r[m])), (S[A] = C));
        }
      } else
        e[y] !== a &&
          console.error(
            "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
          );
    }
    this.nCachedObjects_ = u;
  }
  remove() {
    const e = this._objects,
      t = this._indicesByUUID,
      i = this._bindings,
      r = i.length;
    let s = this.nCachedObjects_;
    for (let o = 0, a = arguments.length; o !== a; ++o) {
      const l = arguments[o],
        u = l.uuid,
        h = t[u];
      if (h !== void 0 && h >= s) {
        const d = s++,
          p = e[d];
        ((t[p.uuid] = h), (e[h] = p), (t[u] = d), (e[d] = l));
        for (let g = 0, y = r; g !== y; ++g) {
          const A = i[g],
            _ = A[d],
            m = A[h];
          ((A[h] = _), (A[d] = m));
        }
      }
    }
    this.nCachedObjects_ = s;
  }
  uncache() {
    const e = this._objects,
      t = this._indicesByUUID,
      i = this._bindings,
      r = i.length;
    let s = this.nCachedObjects_,
      o = e.length;
    for (let a = 0, l = arguments.length; a !== l; ++a) {
      const u = arguments[a],
        h = u.uuid,
        d = t[h];
      if (d !== void 0)
        if ((delete t[h], d < s)) {
          const p = --s,
            g = e[p],
            y = --o,
            A = e[y];
          ((t[g.uuid] = d), (e[d] = g), (t[A.uuid] = p), (e[p] = A), e.pop());
          for (let _ = 0, m = r; _ !== m; ++_) {
            const x = i[_],
              S = x[p],
              w = x[y];
            ((x[d] = S), (x[p] = w), x.pop());
          }
        } else {
          const p = --o,
            g = e[p];
          (p > 0 && (t[g.uuid] = d), (e[d] = g), e.pop());
          for (let y = 0, A = r; y !== A; ++y) {
            const _ = i[y];
            ((_[d] = _[p]), _.pop());
          }
        }
    }
    this.nCachedObjects_ = s;
  }
  subscribe_(e, t) {
    const i = this._bindingsIndicesByPath;
    let r = i[e];
    const s = this._bindings;
    if (r !== void 0) return s[r];
    const o = this._paths,
      a = this._parsedPaths,
      l = this._objects,
      u = l.length,
      h = this.nCachedObjects_,
      d = new Array(u);
    ((r = s.length), (i[e] = r), o.push(e), a.push(t), s.push(d));
    for (let p = h, g = l.length; p !== g; ++p) {
      const y = l[p];
      d[p] = new bt(y, e, t);
    }
    return d;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath,
      i = t[e];
    if (i !== void 0) {
      const r = this._paths,
        s = this._parsedPaths,
        o = this._bindings,
        a = o.length - 1,
        l = o[a],
        u = e[a];
      ((t[u] = i),
        (o[i] = l),
        o.pop(),
        (s[i] = s[a]),
        s.pop(),
        (r[i] = r[a]),
        r.pop());
    }
  }
}
class FR {
  constructor(e, t, i = null, r = t.blendMode) {
    ((this._mixer = e),
      (this._clip = t),
      (this._localRoot = i),
      (this.blendMode = r));
    const s = t.tracks,
      o = s.length,
      a = new Array(o),
      l = { endingStart: Ga, endingEnd: Ga };
    for (let u = 0; u !== o; ++u) {
      const h = s[u].createInterpolant(null);
      ((a[u] = h), (h.settings = l));
    }
    ((this._interpolantSettings = l),
      (this._interpolants = a),
      (this._propertyBindings = new Array(o)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = LB),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0));
  }
  play() {
    return (this._mixer._activateAction(this), this);
  }
  stop() {
    return (this._mixer._deactivateAction(this), this.reset());
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    );
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return ((this._startTime = e), this);
  }
  setLoop(e, t) {
    return ((this.loop = e), (this.repetitions = t), this);
  }
  setEffectiveWeight(e) {
    return (
      (this.weight = e),
      (this._effectiveWeight = this.enabled ? e : 0),
      this.stopFading()
    );
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, i) {
    if ((e.fadeOut(t), this.fadeIn(t), i)) {
      const r = this._clip.duration,
        s = e._clip.duration,
        o = s / r,
        a = r / s;
      (e.warp(1, o, t), this.warp(a, 1, t));
    }
    return this;
  }
  crossFadeTo(e, t, i) {
    return e.crossFadeFrom(this, t, i);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return (
      e !== null &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  setEffectiveTimeScale(e) {
    return (
      (this.timeScale = e),
      (this._effectiveTimeScale = this.paused ? 0 : e),
      this.stopWarping()
    );
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return ((this.timeScale = this._clip.duration / e), this.stopWarping());
  }
  syncWith(e) {
    return (
      (this.time = e.time),
      (this.timeScale = e.timeScale),
      this.stopWarping()
    );
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, i) {
    const r = this._mixer,
      s = r.time,
      o = this.timeScale;
    let a = this._timeScaleInterpolant;
    a === null &&
      ((a = r._lendControlInterpolant()), (this._timeScaleInterpolant = a));
    const l = a.parameterPositions,
      u = a.sampleValues;
    return ((l[0] = s), (l[1] = s + i), (u[0] = e / o), (u[1] = t / o), this);
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return (
      e !== null &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, t, i, r) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const s = this._startTime;
    if (s !== null) {
      const l = (e - s) * i;
      l < 0 || i === 0 ? (t = 0) : ((this._startTime = null), (t = i * l));
    }
    t *= this._updateTimeScale(e);
    const o = this._updateTime(t),
      a = this._updateWeight(e);
    if (a > 0) {
      const l = this._interpolants,
        u = this._propertyBindings;
      switch (this.blendMode) {
        case K1:
          for (let h = 0, d = l.length; h !== d; ++h)
            (l[h].evaluate(o), u[h].accumulateAdditive(a));
          break;
        case Ng:
        default:
          for (let h = 0, d = l.length; h !== d; ++h)
            (l[h].evaluate(o), u[h].accumulate(r, a));
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const i = this._weightInterpolant;
      if (i !== null) {
        const r = i.evaluate(e)[0];
        ((t *= r),
          e > i.parameterPositions[1] &&
            (this.stopFading(), r === 0 && (this.enabled = !1)));
      }
    }
    return ((this._effectiveWeight = t), t);
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const i = this._timeScaleInterpolant;
      if (i !== null) {
        const r = i.evaluate(e)[0];
        ((t *= r),
          e > i.parameterPositions[1] &&
            (this.stopWarping(),
            t === 0 ? (this.paused = !0) : (this.timeScale = t)));
      }
    }
    return ((this._effectiveTimeScale = t), t);
  }
  _updateTime(e) {
    const t = this._clip.duration,
      i = this.loop;
    let r = this.time + e,
      s = this._loopCount;
    const o = i === IB;
    if (e === 0) return s === -1 ? r : o && (s & 1) === 1 ? t - r : r;
    if (i === RB) {
      s === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      e: {
        if (r >= t) r = t;
        else if (r < 0) r = 0;
        else {
          this.time = r;
          break e;
        }
        (this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = r),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e < 0 ? -1 : 1,
          }));
      }
    } else {
      if (
        (s === -1 &&
          (e >= 0
            ? ((s = 0), this._setEndings(!0, this.repetitions === 0, o))
            : this._setEndings(this.repetitions === 0, !0, o)),
        r >= t || r < 0)
      ) {
        const a = Math.floor(r / t);
        ((r -= t * a), (s += Math.abs(a)));
        const l = this.repetitions - s;
        if (l <= 0)
          (this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (r = e > 0 ? t : 0),
            (this.time = r),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: e > 0 ? 1 : -1,
            }));
        else {
          if (l === 1) {
            const u = e < 0;
            this._setEndings(u, !u, o);
          } else this._setEndings(!1, !1, o);
          ((this._loopCount = s),
            (this.time = r),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: a,
            }));
        }
      } else this.time = r;
      if (o && (s & 1) === 1) return t - r;
    }
    return r;
  }
  _setEndings(e, t, i) {
    const r = this._interpolantSettings;
    i
      ? ((r.endingStart = Ha), (r.endingEnd = Ha))
      : (e
          ? (r.endingStart = this.zeroSlopeAtStart ? Ha : Ga)
          : (r.endingStart = th),
        t ? (r.endingEnd = this.zeroSlopeAtEnd ? Ha : Ga) : (r.endingEnd = th));
  }
  _scheduleFading(e, t, i) {
    const r = this._mixer,
      s = r.time;
    let o = this._weightInterpolant;
    o === null &&
      ((o = r._lendControlInterpolant()), (this._weightInterpolant = o));
    const a = o.parameterPositions,
      l = o.sampleValues;
    return ((a[0] = s), (l[0] = t), (a[1] = s + e), (l[1] = i), this);
  }
}
const jH = new Float32Array(1);
class JH extends ps {
  constructor(e) {
    (super(),
      (this._root = e),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1));
  }
  _bindAction(e, t) {
    const i = e._localRoot || this._root,
      r = e._clip.tracks,
      s = r.length,
      o = e._propertyBindings,
      a = e._interpolants,
      l = i.uuid,
      u = this._bindingsByRootAndName;
    let h = u[l];
    h === void 0 && ((h = {}), (u[l] = h));
    for (let d = 0; d !== s; ++d) {
      const p = r[d],
        g = p.name;
      let y = h[g];
      if (y !== void 0) (++y.referenceCount, (o[d] = y));
      else {
        if (((y = o[d]), y !== void 0)) {
          y._cacheIndex === null &&
            (++y.referenceCount, this._addInactiveBinding(y, l, g));
          continue;
        }
        const A = t && t._propertyBindings[d].binding.parsedPath;
        ((y = new DR(bt.create(i, g, A), p.ValueTypeName, p.getValueSize())),
          ++y.referenceCount,
          this._addInactiveBinding(y, l, g),
          (o[d] = y));
      }
      a[d].resultBuffer = y.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const i = (e._localRoot || this._root).uuid,
          r = e._clip.uuid,
          s = this._actionsByClip[r];
        (this._bindAction(e, s && s.knownActions[0]),
          this._addInactiveAction(e, r, i));
      }
      const t = e._propertyBindings;
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i];
        s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i];
        --s.useCount === 0 &&
          (s.restoreOriginalState(), this._takeBackBinding(s));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    ((this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0));
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        },
      },
    };
  }
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, i) {
    const r = this._actions,
      s = this._actionsByClip;
    let o = s[t];
    if (o === void 0)
      ((o = { knownActions: [e], actionByRoot: {} }),
        (e._byClipCacheIndex = 0),
        (s[t] = o));
    else {
      const a = o.knownActions;
      ((e._byClipCacheIndex = a.length), a.push(e));
    }
    ((e._cacheIndex = r.length), r.push(e), (o.actionByRoot[i] = e));
  }
  _removeInactiveAction(e) {
    const t = this._actions,
      i = t[t.length - 1],
      r = e._cacheIndex;
    ((i._cacheIndex = r), (t[r] = i), t.pop(), (e._cacheIndex = null));
    const s = e._clip.uuid,
      o = this._actionsByClip,
      a = o[s],
      l = a.knownActions,
      u = l[l.length - 1],
      h = e._byClipCacheIndex;
    ((u._byClipCacheIndex = h),
      (l[h] = u),
      l.pop(),
      (e._byClipCacheIndex = null));
    const d = a.actionByRoot,
      p = (e._localRoot || this._root).uuid;
    (delete d[p],
      l.length === 0 && delete o[s],
      this._removeInactiveBindingsForAction(e));
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let i = 0, r = t.length; i !== r; ++i) {
      const s = t[i];
      --s.referenceCount === 0 && this._removeInactiveBinding(s);
    }
  }
  _lendAction(e) {
    const t = this._actions,
      i = e._cacheIndex,
      r = this._nActiveActions++,
      s = t[r];
    ((e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s));
  }
  _takeBackAction(e) {
    const t = this._actions,
      i = e._cacheIndex,
      r = --this._nActiveActions,
      s = t[r];
    ((e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s));
  }
  _addInactiveBinding(e, t, i) {
    const r = this._bindingsByRootAndName,
      s = this._bindings;
    let o = r[t];
    (o === void 0 && ((o = {}), (r[t] = o)),
      (o[i] = e),
      (e._cacheIndex = s.length),
      s.push(e));
  }
  _removeInactiveBinding(e) {
    const t = this._bindings,
      i = e.binding,
      r = i.rootNode.uuid,
      s = i.path,
      o = this._bindingsByRootAndName,
      a = o[r],
      l = t[t.length - 1],
      u = e._cacheIndex;
    ((l._cacheIndex = u),
      (t[u] = l),
      t.pop(),
      delete a[s],
      Object.keys(a).length === 0 && delete o[r]);
  }
  _lendBinding(e) {
    const t = this._bindings,
      i = e._cacheIndex,
      r = this._nActiveBindings++,
      s = t[r];
    ((e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s));
  }
  _takeBackBinding(e) {
    const t = this._bindings,
      i = e._cacheIndex,
      r = --this._nActiveBindings,
      s = t[r];
    ((e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s));
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants,
      t = this._nActiveControlInterpolants++;
    let i = e[t];
    return (
      i === void 0 &&
        ((i = new MA(new Float32Array(2), new Float32Array(2), 1, jH)),
        (i.__cacheIndex = t),
        (e[t] = i)),
      i
    );
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants,
      i = e.__cacheIndex,
      r = --this._nActiveControlInterpolants,
      s = t[r];
    ((e.__cacheIndex = r), (t[r] = e), (s.__cacheIndex = i), (t[i] = s));
  }
  clipAction(e, t, i) {
    const r = t || this._root,
      s = r.uuid;
    let o = typeof e == "string" ? Zc.findByName(r, e) : e;
    const a = o !== null ? o.uuid : e,
      l = this._actionsByClip[a];
    let u = null;
    if (
      (i === void 0 && (o !== null ? (i = o.blendMode) : (i = Ng)),
      l !== void 0)
    ) {
      const d = l.actionByRoot[s];
      if (d !== void 0 && d.blendMode === i) return d;
      ((u = l.knownActions[0]), o === null && (o = u._clip));
    }
    if (o === null) return null;
    const h = new FR(this, o, t, i);
    return (this._bindAction(h, u), this._addInactiveAction(h, a, s), h);
  }
  existingAction(e, t) {
    const i = t || this._root,
      r = i.uuid,
      s = typeof e == "string" ? Zc.findByName(i, e) : e,
      o = s ? s.uuid : e,
      a = this._actionsByClip[o];
    return (a !== void 0 && a.actionByRoot[r]) || null;
  }
  stopAllAction() {
    const e = this._actions,
      t = this._nActiveActions;
    for (let i = t - 1; i >= 0; --i) e[i].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const t = this._actions,
      i = this._nActiveActions,
      r = (this.time += e),
      s = Math.sign(e),
      o = (this._accuIndex ^= 1);
    for (let u = 0; u !== i; ++u) t[u]._update(r, e, s, o);
    const a = this._bindings,
      l = this._nActiveBindings;
    for (let u = 0; u !== l; ++u) a[u].apply(o);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const t = this._actions,
      i = e.uuid,
      r = this._actionsByClip,
      s = r[i];
    if (s !== void 0) {
      const o = s.knownActions;
      for (let a = 0, l = o.length; a !== l; ++a) {
        const u = o[a];
        this._deactivateAction(u);
        const h = u._cacheIndex,
          d = t[t.length - 1];
        ((u._cacheIndex = null),
          (u._byClipCacheIndex = null),
          (d._cacheIndex = h),
          (t[h] = d),
          t.pop(),
          this._removeInactiveBindingsForAction(u));
      }
      delete r[i];
    }
  }
  uncacheRoot(e) {
    const t = e.uuid,
      i = this._actionsByClip;
    for (const o in i) {
      const a = i[o].actionByRoot,
        l = a[t];
      l !== void 0 &&
        (this._deactivateAction(l), this._removeInactiveAction(l));
    }
    const r = this._bindingsByRootAndName,
      s = r[t];
    if (s !== void 0)
      for (const o in s) {
        const a = s[o];
        (a.restoreOriginalState(), this._removeInactiveBinding(a));
      }
  }
  uncacheAction(e, t) {
    const i = this.existingAction(e, t);
    i !== null && (this._deactivateAction(i), this._removeInactiveAction(i));
  }
}
class IA {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new IA(
      this.value.clone === void 0 ? this.value : this.value.clone()
    );
  }
}
let XH = 0;
class KH extends ps {
  constructor() {
    (super(),
      (this.isUniformsGroup = !0),
      Object.defineProperty(this, "id", { value: XH++ }),
      (this.name = ""),
      (this.usage = nh),
      (this.uniforms = []));
  }
  add(e) {
    return (this.uniforms.push(e), this);
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return (t !== -1 && this.uniforms.splice(t, 1), this);
  }
  setName(e) {
    return ((this.name = e), this);
  }
  setUsage(e) {
    return ((this.usage = e), this);
  }
  dispose() {
    return (this.dispatchEvent({ type: "dispose" }), this);
  }
  copy(e) {
    ((this.name = e.name), (this.usage = e.usage));
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let i = 0, r = t.length; i < r; i++) this.uniforms.push(t[i].clone());
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class YH extends Ch {
  constructor(e, t, i = 1) {
    (super(e, t),
      (this.isInstancedInterleavedBuffer = !0),
      (this.meshPerAttribute = i));
  }
  copy(e) {
    return (super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this);
  }
  clone(e) {
    const t = super.clone(e);
    return ((t.meshPerAttribute = this.meshPerAttribute), t);
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.isInstancedInterleavedBuffer = !0),
      (t.meshPerAttribute = this.meshPerAttribute),
      t
    );
  }
}
class QH {
  constructor(e, t, i, r, s) {
    ((this.isGLBufferAttribute = !0),
      (this.name = ""),
      (this.buffer = e),
      (this.type = t),
      (this.itemSize = i),
      (this.elementSize = r),
      (this.count = s),
      (this.version = 0));
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return ((this.buffer = e), this);
  }
  setType(e, t) {
    return ((this.type = e), (this.elementSize = t), this);
  }
  setItemSize(e) {
    return ((this.itemSize = e), this);
  }
  setCount(e) {
    return ((this.count = e), this);
  }
}
class NR {
  constructor(e, t, i = 0, r = 1 / 0) {
    ((this.ray = new Sh(e, t)),
      (this.near = i),
      (this.far = r),
      (this.camera = null),
      (this.layers = new qa()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      }));
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(t)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = t))
      : t.isOrthographicCamera
        ? (this.ray.origin
            .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
            .unproject(t),
          this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
          (this.camera = t))
        : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  intersectObject(e, t = !0, i = []) {
    return (__(e, this, i, t), i.sort(EC), i);
  }
  intersectObjects(e, t = !0, i = []) {
    for (let r = 0, s = e.length; r < s; r++) __(e[r], this, i, t);
    return (i.sort(EC), i);
  }
}
function EC(n, e) {
  return n.distance - e.distance;
}
function __(n, e, t, i) {
  if ((n.layers.test(e.layers) && n.raycast(e, t), i === !0)) {
    const r = n.children;
    for (let s = 0, o = r.length; s < o; s++) __(r[s], e, t, !0);
  }
}
class A_ {
  constructor(e = 1, t = 0, i = 0) {
    return ((this.radius = e), (this.phi = t), (this.theta = i), this);
  }
  set(e, t, i) {
    return ((this.radius = e), (this.phi = t), (this.theta = i), this);
  }
  copy(e) {
    return (
      (this.radius = e.radius),
      (this.phi = e.phi),
      (this.theta = e.theta),
      this
    );
  }
  makeSafe() {
    return (
      (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))),
      this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, i) {
    return (
      (this.radius = Math.sqrt(e * e + t * t + i * i)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, i)),
          (this.phi = Math.acos(pn(t / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class ZH {
  constructor(e = 1, t = 0, i = 0) {
    return ((this.radius = e), (this.theta = t), (this.y = i), this);
  }
  set(e, t, i) {
    return ((this.radius = e), (this.theta = t), (this.y = i), this);
  }
  copy(e) {
    return (
      (this.radius = e.radius),
      (this.theta = e.theta),
      (this.y = e.y),
      this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, i) {
    return (
      (this.radius = Math.sqrt(e * e + i * i)),
      (this.theta = Math.atan2(e, i)),
      (this.y = t),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const CC = new ve();
class qH {
  constructor(e = new ve(1 / 0, 1 / 0), t = new ve(-1 / 0, -1 / 0)) {
    ((this.isBox2 = !0), (this.min = e), (this.max = t));
  }
  set(e, t) {
    return (this.min.copy(e), this.max.copy(t), this);
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = CC.copy(t).multiplyScalar(0.5);
    return (this.min.copy(e).sub(i), this.max.copy(e).add(i), this);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.min.copy(e.min), this.max.copy(e.max), this);
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    );
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return (this.min.min(e), this.max.max(e), this);
  }
  expandByVector(e) {
    return (this.min.sub(e), this.max.add(e), this);
  }
  expandByScalar(e) {
    return (this.min.addScalar(-e), this.max.addScalar(e), this);
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y
    );
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, CC).distanceTo(e);
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return (this.min.min(e.min), this.max.max(e.max), this);
  }
  translate(e) {
    return (this.min.add(e), this.max.add(e), this);
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const TC = new F(),
  Hp = new F();
class $H {
  constructor(e = new F(), t = new F()) {
    ((this.start = e), (this.end = t));
  }
  set(e, t) {
    return (this.start.copy(e), this.end.copy(t), this);
  }
  copy(e) {
    return (this.start.copy(e.start), this.end.copy(e.end), this);
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    (TC.subVectors(e, this.start), Hp.subVectors(this.end, this.start));
    const i = Hp.dot(Hp);
    let s = Hp.dot(TC) / i;
    return (t && (s = pn(s, 0, 1)), s);
  }
  closestPointToPoint(e, t, i) {
    const r = this.closestPointToPointParameter(e, t);
    return this.delta(i).multiplyScalar(r).add(this.start);
  }
  applyMatrix4(e) {
    return (this.start.applyMatrix4(e), this.end.applyMatrix4(e), this);
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const bC = new F();
class e5 extends Pt {
  constructor(e, t) {
    (super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = t),
      (this.type = "SpotLightHelper"));
    const i = new ft(),
      r = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 0, -1, 1,
      ];
    for (let o = 0, a = 1, l = 32; o < l; o++, a++) {
      const u = (o / l) * Math.PI * 2,
        h = (a / l) * Math.PI * 2;
      r.push(Math.cos(u), Math.sin(u), 1, Math.cos(h), Math.sin(h), 1);
    }
    i.setAttribute("position", new Ve(r, 3));
    const s = new li({ fog: !1, toneMapped: !1 });
    ((this.cone = new jr(i, s)), this.add(this.cone), this.update());
  }
  dispose() {
    (this.cone.geometry.dispose(), this.cone.material.dispose());
  }
  update() {
    (this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1));
    const e = this.light.distance ? this.light.distance : 1e3,
      t = e * Math.tan(this.light.angle);
    (this.cone.scale.set(t, t, e),
      bC.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt(bC),
      this.color !== void 0
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color));
  }
}
const yo = new F(),
  Vp = new ot(),
  dy = new ot();
class t5 extends jr {
  constructor(e) {
    const t = kR(e),
      i = new ft(),
      r = [],
      s = [],
      o = new Ie(0, 0, 1),
      a = new Ie(0, 1, 0);
    for (let u = 0; u < t.length; u++) {
      const h = t[u];
      h.parent &&
        h.parent.isBone &&
        (r.push(0, 0, 0),
        r.push(0, 0, 0),
        s.push(o.r, o.g, o.b),
        s.push(a.r, a.g, a.b));
    }
    (i.setAttribute("position", new Ve(r, 3)),
      i.setAttribute("color", new Ve(s, 3)));
    const l = new li({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0,
    });
    (super(i, l),
      (this.isSkeletonHelper = !0),
      (this.type = "SkeletonHelper"),
      (this.root = e),
      (this.bones = t),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1));
  }
  updateMatrixWorld(e) {
    const t = this.bones,
      i = this.geometry,
      r = i.getAttribute("position");
    dy.copy(this.root.matrixWorld).invert();
    for (let s = 0, o = 0; s < t.length; s++) {
      const a = t[s];
      a.parent &&
        a.parent.isBone &&
        (Vp.multiplyMatrices(dy, a.matrixWorld),
        yo.setFromMatrixPosition(Vp),
        r.setXYZ(o, yo.x, yo.y, yo.z),
        Vp.multiplyMatrices(dy, a.parent.matrixWorld),
        yo.setFromMatrixPosition(Vp),
        r.setXYZ(o + 1, yo.x, yo.y, yo.z),
        (o += 2));
    }
    ((i.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(e));
  }
  dispose() {
    (this.geometry.dispose(), this.material.dispose());
  }
}
function kR(n) {
  const e = [];
  n.isBone === !0 && e.push(n);
  for (let t = 0; t < n.children.length; t++)
    e.push.apply(e, kR(n.children[t]));
  return e;
}
class n5 extends Bn {
  constructor(e, t, i) {
    const r = new lu(t, 4, 2),
      s = new Ji({ wireframe: !0, fog: !1, toneMapped: !1 });
    (super(r, s),
      (this.light = e),
      (this.color = i),
      (this.type = "PointLightHelper"),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update());
  }
  dispose() {
    (this.geometry.dispose(), this.material.dispose());
  }
  update() {
    (this.light.updateWorldMatrix(!0, !1),
      this.color !== void 0
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color));
  }
}
const i5 = new F(),
  PC = new Ie(),
  BC = new Ie();
class r5 extends Pt {
  constructor(e, t, i) {
    (super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = i),
      (this.type = "HemisphereLightHelper"));
    const r = new au(t);
    (r.rotateY(Math.PI * 0.5),
      (this.material = new Ji({ wireframe: !0, fog: !1, toneMapped: !1 })),
      this.color === void 0 && (this.material.vertexColors = !0));
    const s = r.getAttribute("position"),
      o = new Float32Array(s.count * 3);
    (r.setAttribute("color", new Dt(o, 3)),
      this.add(new Bn(r, this.material)),
      this.update());
  }
  dispose() {
    (this.children[0].geometry.dispose(), this.children[0].material.dispose());
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0) this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      (PC.copy(this.light.color), BC.copy(this.light.groundColor));
      for (let i = 0, r = t.count; i < r; i++) {
        const s = i < r / 2 ? PC : BC;
        t.setXYZ(i, s.r, s.g, s.b);
      }
      t.needsUpdate = !0;
    }
    (this.light.updateWorldMatrix(!0, !1),
      e.lookAt(i5.setFromMatrixPosition(this.light.matrixWorld).negate()));
  }
}
class s5 extends jr {
  constructor(e = 10, t = 10, i = 4473924, r = 8947848) {
    ((i = new Ie(i)), (r = new Ie(r)));
    const s = t / 2,
      o = e / t,
      a = e / 2,
      l = [],
      u = [];
    for (let p = 0, g = 0, y = -a; p <= t; p++, y += o) {
      (l.push(-a, 0, y, a, 0, y), l.push(y, 0, -a, y, 0, a));
      const A = p === s ? i : r;
      (A.toArray(u, g),
        (g += 3),
        A.toArray(u, g),
        (g += 3),
        A.toArray(u, g),
        (g += 3),
        A.toArray(u, g),
        (g += 3));
    }
    const h = new ft();
    (h.setAttribute("position", new Ve(l, 3)),
      h.setAttribute("color", new Ve(u, 3)));
    const d = new li({ vertexColors: !0, toneMapped: !1 });
    (super(h, d), (this.type = "GridHelper"));
  }
  dispose() {
    (this.geometry.dispose(), this.material.dispose());
  }
}
class o5 extends jr {
  constructor(e = 10, t = 16, i = 8, r = 64, s = 4473924, o = 8947848) {
    ((s = new Ie(s)), (o = new Ie(o)));
    const a = [],
      l = [];
    if (t > 1)
      for (let d = 0; d < t; d++) {
        const p = (d / t) * (Math.PI * 2),
          g = Math.sin(p) * e,
          y = Math.cos(p) * e;
        (a.push(0, 0, 0), a.push(g, 0, y));
        const A = d & 1 ? s : o;
        (l.push(A.r, A.g, A.b), l.push(A.r, A.g, A.b));
      }
    for (let d = 0; d < i; d++) {
      const p = d & 1 ? s : o,
        g = e - (e / i) * d;
      for (let y = 0; y < r; y++) {
        let A = (y / r) * (Math.PI * 2),
          _ = Math.sin(A) * g,
          m = Math.cos(A) * g;
        (a.push(_, 0, m),
          l.push(p.r, p.g, p.b),
          (A = ((y + 1) / r) * (Math.PI * 2)),
          (_ = Math.sin(A) * g),
          (m = Math.cos(A) * g),
          a.push(_, 0, m),
          l.push(p.r, p.g, p.b));
      }
    }
    const u = new ft();
    (u.setAttribute("position", new Ve(a, 3)),
      u.setAttribute("color", new Ve(l, 3)));
    const h = new li({ vertexColors: !0, toneMapped: !1 });
    (super(u, h), (this.type = "PolarGridHelper"));
  }
  dispose() {
    (this.geometry.dispose(), this.material.dispose());
  }
}
const RC = new F(),
  Wp = new F(),
  LC = new F();
class a5 extends Pt {
  constructor(e, t, i) {
    (super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = i),
      (this.type = "DirectionalLightHelper"),
      t === void 0 && (t = 1));
    let r = new ft();
    r.setAttribute(
      "position",
      new Ve([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)
    );
    const s = new li({ fog: !1, toneMapped: !1 });
    ((this.lightPlane = new Zs(r, s)),
      this.add(this.lightPlane),
      (r = new ft()),
      r.setAttribute("position", new Ve([0, 0, 0, 0, 0, 1], 3)),
      (this.targetLine = new Zs(r, s)),
      this.add(this.targetLine),
      this.update());
  }
  dispose() {
    (this.lightPlane.geometry.dispose(),
      this.lightPlane.material.dispose(),
      this.targetLine.geometry.dispose(),
      this.targetLine.material.dispose());
  }
  update() {
    (this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      RC.setFromMatrixPosition(this.light.matrixWorld),
      Wp.setFromMatrixPosition(this.light.target.matrixWorld),
      LC.subVectors(Wp, RC),
      this.lightPlane.lookAt(Wp),
      this.color !== void 0
        ? (this.lightPlane.material.color.set(this.color),
          this.targetLine.material.color.set(this.color))
        : (this.lightPlane.material.color.copy(this.light.color),
          this.targetLine.material.color.copy(this.light.color)),
      this.targetLine.lookAt(Wp),
      (this.targetLine.scale.z = LC.length()));
  }
}
const jp = new F(),
  fn = new wh();
class l5 extends jr {
  constructor(e) {
    const t = new ft(),
      i = new li({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
      r = [],
      s = [],
      o = {};
    (a("n1", "n2"),
      a("n2", "n4"),
      a("n4", "n3"),
      a("n3", "n1"),
      a("f1", "f2"),
      a("f2", "f4"),
      a("f4", "f3"),
      a("f3", "f1"),
      a("n1", "f1"),
      a("n2", "f2"),
      a("n3", "f3"),
      a("n4", "f4"),
      a("p", "n1"),
      a("p", "n2"),
      a("p", "n3"),
      a("p", "n4"),
      a("u1", "u2"),
      a("u2", "u3"),
      a("u3", "u1"),
      a("c", "t"),
      a("p", "c"),
      a("cn1", "cn2"),
      a("cn3", "cn4"),
      a("cf1", "cf2"),
      a("cf3", "cf4"));
    function a(y, A) {
      (l(y), l(A));
    }
    function l(y) {
      (r.push(0, 0, 0),
        s.push(0, 0, 0),
        o[y] === void 0 && (o[y] = []),
        o[y].push(r.length / 3 - 1));
    }
    (t.setAttribute("position", new Ve(r, 3)),
      t.setAttribute("color", new Ve(s, 3)),
      super(t, i),
      (this.type = "CameraHelper"),
      (this.camera = e),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = o),
      this.update());
    const u = new Ie(16755200),
      h = new Ie(16711680),
      d = new Ie(43775),
      p = new Ie(16777215),
      g = new Ie(3355443);
    this.setColors(u, h, d, p, g);
  }
  setColors(e, t, i, r, s) {
    const a = this.geometry.getAttribute("color");
    (a.setXYZ(0, e.r, e.g, e.b),
      a.setXYZ(1, e.r, e.g, e.b),
      a.setXYZ(2, e.r, e.g, e.b),
      a.setXYZ(3, e.r, e.g, e.b),
      a.setXYZ(4, e.r, e.g, e.b),
      a.setXYZ(5, e.r, e.g, e.b),
      a.setXYZ(6, e.r, e.g, e.b),
      a.setXYZ(7, e.r, e.g, e.b),
      a.setXYZ(8, e.r, e.g, e.b),
      a.setXYZ(9, e.r, e.g, e.b),
      a.setXYZ(10, e.r, e.g, e.b),
      a.setXYZ(11, e.r, e.g, e.b),
      a.setXYZ(12, e.r, e.g, e.b),
      a.setXYZ(13, e.r, e.g, e.b),
      a.setXYZ(14, e.r, e.g, e.b),
      a.setXYZ(15, e.r, e.g, e.b),
      a.setXYZ(16, e.r, e.g, e.b),
      a.setXYZ(17, e.r, e.g, e.b),
      a.setXYZ(18, e.r, e.g, e.b),
      a.setXYZ(19, e.r, e.g, e.b),
      a.setXYZ(20, e.r, e.g, e.b),
      a.setXYZ(21, e.r, e.g, e.b),
      a.setXYZ(22, e.r, e.g, e.b),
      a.setXYZ(23, e.r, e.g, e.b),
      a.setXYZ(24, t.r, t.g, t.b),
      a.setXYZ(25, t.r, t.g, t.b),
      a.setXYZ(26, t.r, t.g, t.b),
      a.setXYZ(27, t.r, t.g, t.b),
      a.setXYZ(28, t.r, t.g, t.b),
      a.setXYZ(29, t.r, t.g, t.b),
      a.setXYZ(30, t.r, t.g, t.b),
      a.setXYZ(31, t.r, t.g, t.b),
      a.setXYZ(32, i.r, i.g, i.b),
      a.setXYZ(33, i.r, i.g, i.b),
      a.setXYZ(34, i.r, i.g, i.b),
      a.setXYZ(35, i.r, i.g, i.b),
      a.setXYZ(36, i.r, i.g, i.b),
      a.setXYZ(37, i.r, i.g, i.b),
      a.setXYZ(38, r.r, r.g, r.b),
      a.setXYZ(39, r.r, r.g, r.b),
      a.setXYZ(40, s.r, s.g, s.b),
      a.setXYZ(41, s.r, s.g, s.b),
      a.setXYZ(42, s.r, s.g, s.b),
      a.setXYZ(43, s.r, s.g, s.b),
      a.setXYZ(44, s.r, s.g, s.b),
      a.setXYZ(45, s.r, s.g, s.b),
      a.setXYZ(46, s.r, s.g, s.b),
      a.setXYZ(47, s.r, s.g, s.b),
      a.setXYZ(48, s.r, s.g, s.b),
      a.setXYZ(49, s.r, s.g, s.b),
      (a.needsUpdate = !0));
  }
  update() {
    const e = this.geometry,
      t = this.pointMap,
      i = 1,
      r = 1;
    (fn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
      gn("c", t, e, fn, 0, 0, -1),
      gn("t", t, e, fn, 0, 0, 1),
      gn("n1", t, e, fn, -i, -r, -1),
      gn("n2", t, e, fn, i, -r, -1),
      gn("n3", t, e, fn, -i, r, -1),
      gn("n4", t, e, fn, i, r, -1),
      gn("f1", t, e, fn, -i, -r, 1),
      gn("f2", t, e, fn, i, -r, 1),
      gn("f3", t, e, fn, -i, r, 1),
      gn("f4", t, e, fn, i, r, 1),
      gn("u1", t, e, fn, i * 0.7, r * 1.1, -1),
      gn("u2", t, e, fn, -i * 0.7, r * 1.1, -1),
      gn("u3", t, e, fn, 0, r * 2, -1),
      gn("cf1", t, e, fn, -i, 0, 1),
      gn("cf2", t, e, fn, i, 0, 1),
      gn("cf3", t, e, fn, 0, -r, 1),
      gn("cf4", t, e, fn, 0, r, 1),
      gn("cn1", t, e, fn, -i, 0, -1),
      gn("cn2", t, e, fn, i, 0, -1),
      gn("cn3", t, e, fn, 0, -r, -1),
      gn("cn4", t, e, fn, 0, r, -1),
      (e.getAttribute("position").needsUpdate = !0));
  }
  dispose() {
    (this.geometry.dispose(), this.material.dispose());
  }
}
function gn(n, e, t, i, r, s, o) {
  jp.set(r, s, o).unproject(i);
  const a = e[n];
  if (a !== void 0) {
    const l = t.getAttribute("position");
    for (let u = 0, h = a.length; u < h; u++) l.setXYZ(a[u], jp.x, jp.y, jp.z);
  }
}
const Jp = new Vr();
class c5 extends jr {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      r = new Float32Array(8 * 3),
      s = new ft();
    (s.setIndex(new Dt(i, 1)),
      s.setAttribute("position", new Dt(r, 3)),
      super(s, new li({ color: t, toneMapped: !1 })),
      (this.object = e),
      (this.type = "BoxHelper"),
      (this.matrixAutoUpdate = !1),
      this.update());
  }
  update(e) {
    if (
      (e !== void 0 &&
        console.warn("THREE.BoxHelper: .update() has no longer arguments."),
      this.object !== void 0 && Jp.setFromObject(this.object),
      Jp.isEmpty())
    )
      return;
    const t = Jp.min,
      i = Jp.max,
      r = this.geometry.attributes.position,
      s = r.array;
    ((s[0] = i.x),
      (s[1] = i.y),
      (s[2] = i.z),
      (s[3] = t.x),
      (s[4] = i.y),
      (s[5] = i.z),
      (s[6] = t.x),
      (s[7] = t.y),
      (s[8] = i.z),
      (s[9] = i.x),
      (s[10] = t.y),
      (s[11] = i.z),
      (s[12] = i.x),
      (s[13] = i.y),
      (s[14] = t.z),
      (s[15] = t.x),
      (s[16] = i.y),
      (s[17] = t.z),
      (s[18] = t.x),
      (s[19] = t.y),
      (s[20] = t.z),
      (s[21] = i.x),
      (s[22] = t.y),
      (s[23] = t.z),
      (r.needsUpdate = !0),
      this.geometry.computeBoundingSphere());
  }
  setFromObject(e) {
    return ((this.object = e), this.update(), this);
  }
  copy(e, t) {
    return (super.copy(e, t), (this.object = e.object), this);
  }
  dispose() {
    (this.geometry.dispose(), this.material.dispose());
  }
}
class u5 extends jr {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      r = [
        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1,
        1, -1, -1,
      ],
      s = new ft();
    (s.setIndex(new Dt(i, 1)),
      s.setAttribute("position", new Ve(r, 3)),
      super(s, new li({ color: t, toneMapped: !1 })),
      (this.box = e),
      (this.type = "Box3Helper"),
      this.geometry.computeBoundingSphere());
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() ||
      (t.getCenter(this.position),
      t.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(e));
  }
  dispose() {
    (this.geometry.dispose(), this.material.dispose());
  }
}
class f5 extends Zs {
  constructor(e, t = 1, i = 16776960) {
    const r = i,
      s = [
        1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0,
        1, 1, 0,
      ],
      o = new ft();
    (o.setAttribute("position", new Ve(s, 3)),
      o.computeBoundingSphere(),
      super(o, new li({ color: r, toneMapped: !1 })),
      (this.type = "PlaneHelper"),
      (this.plane = e),
      (this.size = t));
    const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
      l = new ft();
    (l.setAttribute("position", new Ve(a, 3)),
      l.computeBoundingSphere(),
      this.add(
        new Bn(
          l,
          new Ji({
            color: r,
            opacity: 0.2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1,
          })
        )
      ));
  }
  updateMatrixWorld(e) {
    (this.position.set(0, 0, 0),
      this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
      this.lookAt(this.plane.normal),
      this.translateZ(-this.plane.constant),
      super.updateMatrixWorld(e));
  }
  dispose() {
    (this.geometry.dispose(),
      this.material.dispose(),
      this.children[0].geometry.dispose(),
      this.children[0].material.dispose());
  }
}
const IC = new F();
let Xp, py;
class h5 extends Pt {
  constructor(
    e = new F(0, 0, 1),
    t = new F(0, 0, 0),
    i = 1,
    r = 16776960,
    s = i * 0.2,
    o = s * 0.2
  ) {
    (super(),
      (this.type = "ArrowHelper"),
      Xp === void 0 &&
        ((Xp = new ft()),
        Xp.setAttribute("position", new Ve([0, 0, 0, 0, 1, 0], 3)),
        (py = new dl(0, 0.5, 1, 5, 1)),
        py.translate(0, -0.5, 0)),
      this.position.copy(t),
      (this.line = new Zs(Xp, new li({ color: r, toneMapped: !1 }))),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new Bn(py, new Ji({ color: r, toneMapped: !1 }))),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(e),
      this.setLength(i, s, o));
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
      IC.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(IC, t);
    }
  }
  setLength(e, t = e * 0.2, i = t * 0.2) {
    (this.line.scale.set(1, Math.max(1e-4, e - t), 1),
      this.line.updateMatrix(),
      this.cone.scale.set(i, t, i),
      (this.cone.position.y = e),
      this.cone.updateMatrix());
  }
  setColor(e) {
    (this.line.material.color.set(e), this.cone.material.color.set(e));
  }
  copy(e) {
    return (
      super.copy(e, !1),
      this.line.copy(e.line),
      this.cone.copy(e.cone),
      this
    );
  }
  dispose() {
    (this.line.geometry.dispose(),
      this.line.material.dispose(),
      this.cone.geometry.dispose(),
      this.cone.material.dispose());
  }
}
class d5 extends jr {
  constructor(e = 1) {
    const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
      i = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
      r = new ft();
    (r.setAttribute("position", new Ve(t, 3)),
      r.setAttribute("color", new Ve(i, 3)));
    const s = new li({ vertexColors: !0, toneMapped: !1 });
    (super(r, s), (this.type = "AxesHelper"));
  }
  setColors(e, t, i) {
    const r = new Ie(),
      s = this.geometry.attributes.color.array;
    return (
      r.set(e),
      r.toArray(s, 0),
      r.toArray(s, 3),
      r.set(t),
      r.toArray(s, 6),
      r.toArray(s, 9),
      r.set(i),
      r.toArray(s, 12),
      r.toArray(s, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    );
  }
  dispose() {
    (this.geometry.dispose(), this.material.dispose());
  }
}
class p5 {
  constructor() {
    ((this.type = "ShapePath"),
      (this.color = new Ie()),
      (this.subPaths = []),
      (this.currentPath = null));
  }
  moveTo(e, t) {
    return (
      (this.currentPath = new rh()),
      this.subPaths.push(this.currentPath),
      this.currentPath.moveTo(e, t),
      this
    );
  }
  lineTo(e, t) {
    return (this.currentPath.lineTo(e, t), this);
  }
  quadraticCurveTo(e, t, i, r) {
    return (this.currentPath.quadraticCurveTo(e, t, i, r), this);
  }
  bezierCurveTo(e, t, i, r, s, o) {
    return (this.currentPath.bezierCurveTo(e, t, i, r, s, o), this);
  }
  splineThru(e) {
    return (this.currentPath.splineThru(e), this);
  }
  toShapes(e) {
    function t(m) {
      const x = [];
      for (let S = 0, w = m.length; S < w; S++) {
        const C = m[S],
          P = new $a();
        ((P.curves = C.curves), x.push(P));
      }
      return x;
    }
    function i(m, x) {
      const S = x.length;
      let w = !1;
      for (let C = S - 1, P = 0; P < S; C = P++) {
        let R = x[C],
          B = x[P],
          b = B.x - R.x,
          L = B.y - R.y;
        if (Math.abs(L) > Number.EPSILON) {
          if (
            (L < 0 && ((R = x[P]), (b = -b), (B = x[C]), (L = -L)),
            m.y < R.y || m.y > B.y)
          )
            continue;
          if (m.y === R.y) {
            if (m.x === R.x) return !0;
          } else {
            const U = L * (m.x - R.x) - b * (m.y - R.y);
            if (U === 0) return !0;
            if (U < 0) continue;
            w = !w;
          }
        } else {
          if (m.y !== R.y) continue;
          if ((B.x <= m.x && m.x <= R.x) || (R.x <= m.x && m.x <= B.x))
            return !0;
        }
      }
      return w;
    }
    const r = ls.isClockWise,
      s = this.subPaths;
    if (s.length === 0) return [];
    let o, a, l;
    const u = [];
    if (s.length === 1)
      return ((a = s[0]), (l = new $a()), (l.curves = a.curves), u.push(l), u);
    let h = !r(s[0].getPoints());
    h = e ? !h : h;
    const d = [],
      p = [];
    let g = [],
      y = 0,
      A;
    ((p[y] = void 0), (g[y] = []));
    for (let m = 0, x = s.length; m < x; m++)
      ((a = s[m]),
        (A = a.getPoints()),
        (o = r(A)),
        (o = e ? !o : o),
        o
          ? (!h && p[y] && y++,
            (p[y] = { s: new $a(), p: A }),
            (p[y].s.curves = a.curves),
            h && y++,
            (g[y] = []))
          : g[y].push({ h: a, p: A[0] }));
    if (!p[0]) return t(s);
    if (p.length > 1) {
      let m = !1,
        x = 0;
      for (let S = 0, w = p.length; S < w; S++) d[S] = [];
      for (let S = 0, w = p.length; S < w; S++) {
        const C = g[S];
        for (let P = 0; P < C.length; P++) {
          const R = C[P];
          let B = !0;
          for (let b = 0; b < p.length; b++)
            i(R.p, p[b].p) &&
              (S !== b && x++, B ? ((B = !1), d[b].push(R)) : (m = !0));
          B && d[S].push(R);
        }
      }
      x > 0 && m === !1 && (g = d);
    }
    let _;
    for (let m = 0, x = p.length; m < x; m++) {
      ((l = p[m].s), u.push(l), (_ = g[m]));
      for (let S = 0, w = _.length; S < w; S++) l.holes.push(_[S].h);
    }
    return u;
  }
}
class m5 extends na {
  constructor(e, t, i, r, s, o) {
    (console.warn(
      "THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry."
    ),
      super(e, t, i, r, s, o));
  }
}
class g5 extends Ph {
  constructor(e, t, i, r) {
    (console.warn(
      "THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry."
    ),
      super(e, t, i, r));
  }
}
class v5 extends Bh {
  constructor(e, t, i, r) {
    (console.warn(
      "THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry."
    ),
      super(e, t, i, r));
  }
}
class y5 extends Rh {
  constructor(e, t, i, r, s, o, a) {
    (console.warn(
      "THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry."
    ),
      super(e, t, i, r, s, o, a));
  }
}
class x5 extends dl {
  constructor(e, t, i, r, s, o, a, l) {
    (console.warn(
      "THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry."
    ),
      super(e, t, i, r, s, o, a, l));
  }
}
class _5 extends Lh {
  constructor(e, t) {
    (console.warn(
      "THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry."
    ),
      super(e, t));
  }
}
class A5 extends Ih {
  constructor(e, t) {
    (console.warn(
      "THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry."
    ),
      super(e, t));
  }
}
class M5 extends Dh {
  constructor(e, t) {
    (console.warn(
      "THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry."
    ),
      super(e, t));
  }
}
class S5 extends ou {
  constructor(e, t, i, r) {
    (console.warn(
      "THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry."
    ),
      super(e, t, i, r));
  }
}
class w5 extends au {
  constructor(e, t) {
    (console.warn(
      "THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry."
    ),
      super(e, t));
  }
}
class E5 extends ru {
  constructor(e, t, i, r) {
    (console.warn(
      "THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry."
    ),
      super(e, t, i, r));
  }
}
class C5 extends to {
  constructor(e, t, i, r) {
    (console.warn(
      "THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry."
    ),
      super(e, t, i, r));
  }
}
class T5 extends Fh {
  constructor(e, t, i, r, s, o) {
    (console.warn(
      "THREE.RingBufferGeometry has been renamed to THREE.RingGeometry."
    ),
      super(e, t, i, r, s, o));
  }
}
class b5 extends Nh {
  constructor(e, t) {
    (console.warn(
      "THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry."
    ),
      super(e, t));
  }
}
class P5 extends lu {
  constructor(e, t, i, r, s, o, a) {
    (console.warn(
      "THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry."
    ),
      super(e, t, i, r, s, o, a));
  }
}
class B5 extends kh {
  constructor(e, t) {
    (console.warn(
      "THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry."
    ),
      super(e, t));
  }
}
class R5 extends Oh {
  constructor(e, t, i, r, s) {
    (console.warn(
      "THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry."
    ),
      super(e, t, i, r, s));
  }
}
class L5 extends Uh {
  constructor(e, t, i, r, s, o) {
    (console.warn(
      "THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry."
    ),
      super(e, t, i, r, s, o));
  }
}
class I5 extends zh {
  constructor(e, t, i, r, s) {
    (console.warn(
      "THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry."
    ),
      super(e, t, i, r, s));
  }
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: Lg } })
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = Lg));
const D5 = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      ACESFilmicToneMapping: J1,
      AddEquation: Da,
      AddOperation: fB,
      AdditiveAnimationBlendMode: K1,
      AdditiveBlending: Ox,
      AlphaFormat: AB,
      AlwaysDepth: rB,
      AlwaysStencilFunc: OB,
      AmbientLight: TR,
      AmbientLightProbe: bH,
      AnimationAction: FR,
      AnimationClip: Zc,
      AnimationLoader: vH,
      AnimationMixer: JH,
      AnimationObjectGroup: WH,
      AnimationUtils: dH,
      ArcCurve: rR,
      ArrayCamera: ZB,
      ArrowHelper: h5,
      Audio: IR,
      AudioAnalyser: DH,
      AudioContext: PA,
      AudioListener: RH,
      AudioLoader: CH,
      AxesHelper: d5,
      BackSide: vi,
      BasicDepthPacking: FB,
      BasicShadowMap: W2,
      Bone: Hg,
      BooleanKeyframeTrack: pl,
      Box2: qH,
      Box3: Vr,
      Box3Helper: u5,
      BoxBufferGeometry: m5,
      BoxGeometry: na,
      BoxHelper: c5,
      BufferAttribute: Dt,
      BufferGeometry: ft,
      BufferGeometryLoader: RR,
      ByteType: gB,
      Cache: ll,
      Camera: wh,
      CameraHelper: l5,
      CanvasTexture: kG,
      CapsuleBufferGeometry: g5,
      CapsuleGeometry: Ph,
      CatmullRomCurve3: sR,
      CineonToneMapping: pB,
      CircleBufferGeometry: v5,
      CircleGeometry: Bh,
      ClampToEdgeWrapping: jn,
      Clock: BA,
      Color: Ie,
      ColorKeyframeTrack: SA,
      ColorManagement: Ei,
      CompressedArrayTexture: NG,
      CompressedTexture: dA,
      CompressedTextureLoader: yH,
      ConeBufferGeometry: y5,
      ConeGeometry: Rh,
      CubeCamera: iA,
      CubeReflectionMapping: Xo,
      CubeRefractionMapping: Ko,
      CubeTexture: Eh,
      CubeTextureLoader: xH,
      CubeUVReflectionMapping: iu,
      CubicBezierCurve: mA,
      CubicBezierCurve3: oR,
      CubicInterpolant: SR,
      CullFaceBack: kx,
      CullFaceFront: V2,
      CullFaceFrontBack: kN,
      CullFaceNone: H2,
      Curve: Jr,
      CurvePath: lR,
      CustomBlending: j2,
      CustomToneMapping: mB,
      CylinderBufferGeometry: x5,
      CylinderGeometry: dl,
      Cylindrical: ZH,
      Data3DTexture: eA,
      DataArrayTexture: kg,
      DataTexture: Lc,
      DataTextureLoader: _H,
      DataUtils: Jk,
      DecrementStencilOp: KN,
      DecrementWrapStencilOp: QN,
      DefaultLoadingManager: _c,
      DepthFormat: Ho,
      DepthStencilFormat: sl,
      DepthTexture: qB,
      DirectionalLight: bA,
      DirectionalLightHelper: a5,
      DiscreteInterpolant: wR,
      DisplayP3ColorSpace: Q1,
      DodecahedronBufferGeometry: _5,
      DodecahedronGeometry: Lh,
      DoubleSide: mr,
      DstAlphaFactor: q2,
      DstColorFactor: eB,
      DynamicCopyUsage: uk,
      DynamicDrawUsage: Qa,
      DynamicReadUsage: ak,
      EdgesGeometry: cR,
      EllipseCurve: Vg,
      EqualDepth: oB,
      EqualStencilFunc: ek,
      EquirectangularReflectionMapping: qf,
      EquirectangularRefractionMapping: $f,
      Euler: hl,
      EventDispatcher: ps,
      ExtrudeBufferGeometry: A5,
      ExtrudeGeometry: Ih,
      FileLoader: Qi,
      Float16BufferAttribute: qk,
      Float32BufferAttribute: Ve,
      Float64BufferAttribute: $k,
      FloatType: Os,
      Fog: Gg,
      FogExp2: zg,
      FramebufferTexture: FG,
      FrontSide: fs,
      Frustum: Og,
      GLBufferAttribute: QH,
      GLSL1: hk,
      GLSL3: h_,
      GreaterDepth: lB,
      GreaterEqualDepth: aB,
      GreaterEqualStencilFunc: rk,
      GreaterStencilFunc: nk,
      GridHelper: s5,
      Group: Us,
      HalfFloatType: Vc,
      HemisphereLight: CR,
      HemisphereLightHelper: r5,
      HemisphereLightProbe: TH,
      IcosahedronBufferGeometry: M5,
      IcosahedronGeometry: Dh,
      ImageBitmapLoader: LR,
      ImageLoader: lh,
      ImageUtils: $1,
      IncrementStencilOp: XN,
      IncrementWrapStencilOp: YN,
      InstancedBufferAttribute: Kc,
      InstancedBufferGeometry: BR,
      InstancedInterleavedBuffer: YH,
      InstancedMesh: iR,
      Int16BufferAttribute: Qk,
      Int32BufferAttribute: Zk,
      Int8BufferAttribute: Xk,
      IntType: yB,
      InterleavedBuffer: Ch,
      InterleavedBufferAttribute: Qo,
      Interpolant: uu,
      InterpolateDiscrete: Wc,
      InterpolateLinear: ol,
      InterpolateSmooth: _m,
      InvertStencilOp: ZN,
      KeepStencilOp: Am,
      KeyframeTrack: Xr,
      LOD: nR,
      LatheBufferGeometry: S5,
      LatheGeometry: ou,
      Layers: qa,
      LessDepth: sB,
      LessEqualDepth: Ym,
      LessEqualStencilFunc: tk,
      LessStencilFunc: $N,
      Light: ia,
      LightProbe: Jg,
      Line: Zs,
      Line3: $H,
      LineBasicMaterial: li,
      LineCurve: Wg,
      LineCurve3: aR,
      LineDashedMaterial: AR,
      LineLoop: fA,
      LineSegments: jr,
      LinearEncoding: Qs,
      LinearFilter: rn,
      LinearInterpolant: MA,
      LinearMipMapLinearFilter: HN,
      LinearMipMapNearestFilter: GN,
      LinearMipmapLinearFilter: hs,
      LinearMipmapNearestFilter: Fg,
      LinearSRGBColorSpace: jc,
      LinearToneMapping: hB,
      Loader: _i,
      LoaderUtils: cs,
      LoadingManager: wA,
      LoopOnce: RB,
      LoopPingPong: IB,
      LoopRepeat: LB,
      LuminanceAlphaFormat: SB,
      LuminanceFormat: MB,
      MOUSE: ba,
      Material: En,
      MaterialLoader: Xg,
      MathUtils: q1,
      Matrix3: wt,
      Matrix4: ot,
      MaxEquation: Hx,
      Mesh: Bn,
      MeshBasicMaterial: Ji,
      MeshDepthMaterial: oA,
      MeshDistanceMaterial: aA,
      MeshLambertMaterial: xR,
      MeshMatcapMaterial: _R,
      MeshNormalMaterial: yR,
      MeshPhongMaterial: gR,
      MeshPhysicalMaterial: no,
      MeshStandardMaterial: cu,
      MeshToonMaterial: vR,
      MinEquation: Gx,
      MirroredRepeatWrapping: Hc,
      MixOperation: uB,
      MultiplyBlending: zx,
      MultiplyOperation: Mh,
      NearestFilter: dn,
      NearestMipMapLinearFilter: zN,
      NearestMipMapNearestFilter: UN,
      NearestMipmapLinearFilter: Bc,
      NearestMipmapNearestFilter: eh,
      NeverDepth: iB,
      NeverStencilFunc: qN,
      NoBlending: Hs,
      NoColorSpace: WN,
      NoToneMapping: Ur,
      NormalAnimationBlendMode: Ng,
      NormalBlending: Ka,
      NotEqualDepth: cB,
      NotEqualStencilFunc: ik,
      NumberKeyframeTrack: Yc,
      Object3D: Pt,
      ObjectLoader: wH,
      ObjectSpaceNormalMap: kB,
      OctahedronBufferGeometry: w5,
      OctahedronGeometry: au,
      OneFactor: Y2,
      OneMinusDstAlphaFactor: $2,
      OneMinusDstColorFactor: tB,
      OneMinusSrcAlphaFactor: j1,
      OneMinusSrcColorFactor: Z2,
      OrthographicCamera: zr,
      PCFShadowMap: Ig,
      PCFSoftShadowMap: Sf,
      PMREMGenerator: p_,
      Path: rh,
      PerspectiveCamera: Vt,
      Plane: Eo,
      PlaneBufferGeometry: E5,
      PlaneGeometry: ru,
      PlaneHelper: f5,
      PointLight: TA,
      PointLightHelper: n5,
      Points: hA,
      PointsMaterial: bh,
      PolarGridHelper: o5,
      PolyhedronBufferGeometry: C5,
      PolyhedronGeometry: to,
      PositionalAudio: IH,
      PropertyBinding: bt,
      PropertyMixer: DR,
      QuadraticBezierCurve: gA,
      QuadraticBezierCurve3: vA,
      Quaternion: Kn,
      QuaternionKeyframeTrack: Zo,
      QuaternionLinearInterpolant: ER,
      RED_GREEN_RGTC2_Format: u_,
      RED_RGTC1_Format: BB,
      REVISION: Lg,
      RGBADepthPacking: NB,
      RGBAFormat: Pi,
      RGBAIntegerFormat: bB,
      RGBA_ASTC_10x10_Format: o_,
      RGBA_ASTC_10x5_Format: i_,
      RGBA_ASTC_10x6_Format: r_,
      RGBA_ASTC_10x8_Format: s_,
      RGBA_ASTC_12x10_Format: a_,
      RGBA_ASTC_12x12_Format: l_,
      RGBA_ASTC_4x4_Format: Yx,
      RGBA_ASTC_5x4_Format: Qx,
      RGBA_ASTC_5x5_Format: Zx,
      RGBA_ASTC_6x5_Format: qx,
      RGBA_ASTC_6x6_Format: $x,
      RGBA_ASTC_8x5_Format: e_,
      RGBA_ASTC_8x6_Format: t_,
      RGBA_ASTC_8x8_Format: n_,
      RGBA_BPTC_Format: xm,
      RGBA_ETC2_EAC_Format: Kx,
      RGBA_PVRTC_2BPPV1_Format: Jx,
      RGBA_PVRTC_4BPPV1_Format: jx,
      RGBA_S3TC_DXT1_Format: gm,
      RGBA_S3TC_DXT3_Format: vm,
      RGBA_S3TC_DXT5_Format: ym,
      RGB_ETC1_Format: PB,
      RGB_ETC2_Format: Xx,
      RGB_PVRTC_2BPPV1_Format: Wx,
      RGB_PVRTC_4BPPV1_Format: Vx,
      RGB_S3TC_DXT1_Format: mm,
      RGFormat: CB,
      RGIntegerFormat: TB,
      RawShaderMaterial: mR,
      Ray: Sh,
      Raycaster: NR,
      RectAreaLight: bR,
      RedFormat: wB,
      RedIntegerFormat: EB,
      ReinhardToneMapping: dB,
      RepeatWrapping: Yo,
      ReplaceStencilOp: JN,
      ReverseSubtractEquation: X2,
      RingBufferGeometry: T5,
      RingGeometry: Fh,
      SIGNED_RED_GREEN_RGTC2_Format: f_,
      SIGNED_RED_RGTC1_Format: c_,
      SRGBColorSpace: Dr,
      Scene: Zm,
      ShaderChunk: gt,
      ShaderLib: Nr,
      ShaderMaterial: ds,
      ShadowMaterial: pR,
      Shape: $a,
      ShapeBufferGeometry: b5,
      ShapeGeometry: Nh,
      ShapePath: p5,
      ShapeUtils: ls,
      ShortType: vB,
      Skeleton: Th,
      SkeletonHelper: t5,
      SkinnedMesh: uA,
      Source: Va,
      Sphere: Wr,
      SphereBufferGeometry: P5,
      SphereGeometry: lu,
      Spherical: A_,
      SphericalHarmonics3: PR,
      SplineCurve: yA,
      SpotLight: CA,
      SpotLightHelper: e5,
      Sprite: tR,
      SpriteMaterial: cA,
      SrcAlphaFactor: W1,
      SrcAlphaSaturateFactor: nB,
      SrcColorFactor: Q2,
      StaticCopyUsage: ck,
      StaticDrawUsage: nh,
      StaticReadUsage: ok,
      StereoCamera: PH,
      StreamCopyUsage: fk,
      StreamDrawUsage: sk,
      StreamReadUsage: lk,
      StringKeyframeTrack: ml,
      SubtractEquation: J2,
      SubtractiveBlending: Ux,
      TOUCH: Pa,
      TangentSpaceNormalMap: eo,
      TetrahedronBufferGeometry: B5,
      TetrahedronGeometry: kh,
      Texture: en,
      TextureLoader: Gh,
      TorusBufferGeometry: R5,
      TorusGeometry: Oh,
      TorusKnotBufferGeometry: L5,
      TorusKnotGeometry: Uh,
      Triangle: bi,
      TriangleFanDrawMode: Y1,
      TriangleStripDrawMode: DB,
      TrianglesDrawMode: VN,
      TubeBufferGeometry: I5,
      TubeGeometry: zh,
      TwoPassDoubleSide: ON,
      UVMapping: Dg,
      Uint16BufferAttribute: tA,
      Uint32BufferAttribute: nA,
      Uint8BufferAttribute: Kk,
      Uint8ClampedBufferAttribute: Yk,
      Uniform: IA,
      UniformsGroup: KH,
      UniformsLib: De,
      UniformsUtils: WB,
      UnsignedByteType: Ys,
      UnsignedInt248Type: Ya,
      UnsignedIntType: Ro,
      UnsignedShort4444Type: xB,
      UnsignedShort5551Type: _B,
      UnsignedShortType: X1,
      VSMShadowMap: za,
      Vector2: ve,
      Vector3: F,
      Vector4: kt,
      VectorKeyframeTrack: Qc,
      VideoTexture: DG,
      WebGL1Renderer: $B,
      WebGL3DRenderTarget: Fk,
      WebGLArrayRenderTarget: Dk,
      WebGLCubeRenderTarget: rA,
      WebGLMultipleRenderTargets: Nk,
      WebGLRenderTarget: Hr,
      WebGLRenderer: lA,
      WebGLUtils: QB,
      WireframeGeometry: dR,
      WrapAroundEnding: th,
      ZeroCurvatureEnding: Ga,
      ZeroFactor: K2,
      ZeroSlopeEnding: Ha,
      ZeroStencilOp: jN,
      _SRGBAFormat: Qm,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
var Lo = {},
  F5 = {
    get exports() {
      return Lo;
    },
    set exports(n) {
      Lo = n;
    },
  },
  gl = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ gl.ConcurrentRoot = 1;
gl.ContinuousEventPriority = 4;
gl.DefaultEventPriority = 16;
gl.DiscreteEventPriority = 1;
gl.IdleEventPriority = 536870912;
gl.LegacyRoot = 0;
(function (n) {
  n.exports = gl;
})(F5);
function N5(n) {
  let e;
  const t = new Set(),
    i = (u, h) => {
      const d = typeof u == "function" ? u(e) : u;
      if (d !== e) {
        const p = e;
        ((e = h ? d : Object.assign({}, e, d)), t.forEach((g) => g(e, p)));
      }
    },
    r = () => e,
    s = (u, h = r, d = Object.is) => {
      console.warn(
        "[DEPRECATED] Please use `subscribeWithSelector` middleware"
      );
      let p = h(e);
      function g() {
        const y = h(e);
        if (!d(p, y)) {
          const A = p;
          u((p = y), A);
        }
      }
      return (t.add(g), () => t.delete(g));
    },
    l = {
      setState: i,
      getState: r,
      subscribe: (u, h, d) =>
        h || d ? s(u, h, d) : (t.add(u), () => t.delete(u)),
      destroy: () => t.clear(),
    };
  return ((e = n(i, r, l)), l);
}
const k5 =
    typeof window > "u" ||
    !window.navigator ||
    /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
  DC = k5 ? H.useEffect : H.useLayoutEffect;
function OR(n) {
  const e = typeof n == "function" ? N5(n) : n,
    t = (i = e.getState, r = Object.is) => {
      const [, s] = H.useReducer((_) => _ + 1, 0),
        o = e.getState(),
        a = H.useRef(o),
        l = H.useRef(i),
        u = H.useRef(r),
        h = H.useRef(!1),
        d = H.useRef();
      d.current === void 0 && (d.current = i(o));
      let p,
        g = !1;
      ((a.current !== o || l.current !== i || u.current !== r || h.current) &&
        ((p = i(o)), (g = !r(d.current, p))),
        DC(() => {
          (g && (d.current = p),
            (a.current = o),
            (l.current = i),
            (u.current = r),
            (h.current = !1));
        }));
      const y = H.useRef(o);
      DC(() => {
        const _ = () => {
            try {
              const x = e.getState(),
                S = l.current(x);
              u.current(d.current, S) ||
                ((a.current = x), (d.current = S), s());
            } catch {
              ((h.current = !0), s());
            }
          },
          m = e.subscribe(_);
        return (e.getState() !== y.current && _(), m);
      }, []);
      const A = g ? p : d.current;
      return (H.useDebugValue(A), A);
    };
  return (
    Object.assign(t, e),
    (t[Symbol.iterator] = function () {
      console.warn(
        "[useStore, api] = create() is deprecated and will be removed in v4"
      );
      const i = [t, e];
      return {
        next() {
          const r = i.length <= 0;
          return { value: i.shift(), done: r };
        },
      };
    }),
    t
  );
}
var M_ = {},
  O5 = {
    get exports() {
      return M_;
    },
    set exports(n) {
      M_ = n;
    },
  },
  qm = {},
  U5 = {
    get exports() {
      return qm;
    },
    set exports(n) {
      qm = n;
    },
  },
  my = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var FC;
function z5() {
  return (
    FC ||
      ((FC = 1),
      (function (n) {
        function e(I, G) {
          var z = I.length;
          I.push(G);
          e: for (; 0 < z; ) {
            var q = (z - 1) >>> 1,
              Q = I[q];
            if (0 < r(Q, G)) ((I[q] = G), (I[z] = Q), (z = q));
            else break e;
          }
        }
        function t(I) {
          return I.length === 0 ? null : I[0];
        }
        function i(I) {
          if (I.length === 0) return null;
          var G = I[0],
            z = I.pop();
          if (z !== G) {
            I[0] = z;
            e: for (var q = 0, Q = I.length, ee = Q >>> 1; q < ee; ) {
              var ne = 2 * (q + 1) - 1,
                Ee = I[ne],
                Ae = ne + 1,
                $ = I[Ae];
              if (0 > r(Ee, z))
                Ae < Q && 0 > r($, Ee)
                  ? ((I[q] = $), (I[Ae] = z), (q = Ae))
                  : ((I[q] = Ee), (I[ne] = z), (q = ne));
              else if (Ae < Q && 0 > r($, z))
                ((I[q] = $), (I[Ae] = z), (q = Ae));
              else break e;
            }
          }
          return G;
        }
        function r(I, G) {
          var z = I.sortIndex - G.sortIndex;
          return z !== 0 ? z : I.id - G.id;
        }
        if (
          typeof performance == "object" &&
          typeof performance.now == "function"
        ) {
          var s = performance;
          n.unstable_now = function () {
            return s.now();
          };
        } else {
          var o = Date,
            a = o.now();
          n.unstable_now = function () {
            return o.now() - a;
          };
        }
        var l = [],
          u = [],
          h = 1,
          d = null,
          p = 3,
          g = !1,
          y = !1,
          A = !1,
          _ = typeof setTimeout == "function" ? setTimeout : null,
          m = typeof clearTimeout == "function" ? clearTimeout : null,
          x = typeof setImmediate < "u" ? setImmediate : null;
        typeof navigator < "u" &&
          navigator.scheduling !== void 0 &&
          navigator.scheduling.isInputPending !== void 0 &&
          navigator.scheduling.isInputPending.bind(navigator.scheduling);
        function S(I) {
          for (var G = t(u); G !== null; ) {
            if (G.callback === null) i(u);
            else if (G.startTime <= I)
              (i(u), (G.sortIndex = G.expirationTime), e(l, G));
            else break;
            G = t(u);
          }
        }
        function w(I) {
          if (((A = !1), S(I), !y))
            if (t(l) !== null) ((y = !0), oe(C));
            else {
              var G = t(u);
              G !== null && ae(w, G.startTime - I);
            }
        }
        function C(I, G) {
          ((y = !1), A && ((A = !1), m(B), (B = -1)), (g = !0));
          var z = p;
          try {
            for (
              S(G), d = t(l);
              d !== null && (!(d.expirationTime > G) || (I && !U()));

            ) {
              var q = d.callback;
              if (typeof q == "function") {
                ((d.callback = null), (p = d.priorityLevel));
                var Q = q(d.expirationTime <= G);
                ((G = n.unstable_now()),
                  typeof Q == "function"
                    ? (d.callback = Q)
                    : d === t(l) && i(l),
                  S(G));
              } else i(l);
              d = t(l);
            }
            if (d !== null) var ee = !0;
            else {
              var ne = t(u);
              (ne !== null && ae(w, ne.startTime - G), (ee = !1));
            }
            return ee;
          } finally {
            ((d = null), (p = z), (g = !1));
          }
        }
        var P = !1,
          R = null,
          B = -1,
          b = 5,
          L = -1;
        function U() {
          return !(n.unstable_now() - L < b);
        }
        function J() {
          if (R !== null) {
            var I = n.unstable_now();
            L = I;
            var G = !0;
            try {
              G = R(!0, I);
            } finally {
              G ? V() : ((P = !1), (R = null));
            }
          } else P = !1;
        }
        var V;
        if (typeof x == "function")
          V = function () {
            x(J);
          };
        else if (typeof MessageChannel < "u") {
          var j = new MessageChannel(),
            X = j.port2;
          ((j.port1.onmessage = J),
            (V = function () {
              X.postMessage(null);
            }));
        } else
          V = function () {
            _(J, 0);
          };
        function oe(I) {
          ((R = I), P || ((P = !0), V()));
        }
        function ae(I, G) {
          B = _(function () {
            I(n.unstable_now());
          }, G);
        }
        ((n.unstable_IdlePriority = 5),
          (n.unstable_ImmediatePriority = 1),
          (n.unstable_LowPriority = 4),
          (n.unstable_NormalPriority = 3),
          (n.unstable_Profiling = null),
          (n.unstable_UserBlockingPriority = 2),
          (n.unstable_cancelCallback = function (I) {
            I.callback = null;
          }),
          (n.unstable_continueExecution = function () {
            y || g || ((y = !0), oe(C));
          }),
          (n.unstable_forceFrameRate = function (I) {
            0 > I || 125 < I
              ? console.error(
                  "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
                )
              : (b = 0 < I ? Math.floor(1e3 / I) : 5);
          }),
          (n.unstable_getCurrentPriorityLevel = function () {
            return p;
          }),
          (n.unstable_getFirstCallbackNode = function () {
            return t(l);
          }),
          (n.unstable_next = function (I) {
            switch (p) {
              case 1:
              case 2:
              case 3:
                var G = 3;
                break;
              default:
                G = p;
            }
            var z = p;
            p = G;
            try {
              return I();
            } finally {
              p = z;
            }
          }),
          (n.unstable_pauseExecution = function () {}),
          (n.unstable_requestPaint = function () {}),
          (n.unstable_runWithPriority = function (I, G) {
            switch (I) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                I = 3;
            }
            var z = p;
            p = I;
            try {
              return G();
            } finally {
              p = z;
            }
          }),
          (n.unstable_scheduleCallback = function (I, G, z) {
            var q = n.unstable_now();
            switch (
              (typeof z == "object" && z !== null
                ? ((z = z.delay),
                  (z = typeof z == "number" && 0 < z ? q + z : q))
                : (z = q),
              I)
            ) {
              case 1:
                var Q = -1;
                break;
              case 2:
                Q = 250;
                break;
              case 5:
                Q = 1073741823;
                break;
              case 4:
                Q = 1e4;
                break;
              default:
                Q = 5e3;
            }
            return (
              (Q = z + Q),
              (I = {
                id: h++,
                callback: G,
                priorityLevel: I,
                startTime: z,
                expirationTime: Q,
                sortIndex: -1,
              }),
              z > q
                ? ((I.sortIndex = z),
                  e(u, I),
                  t(l) === null &&
                    I === t(u) &&
                    (A ? (m(B), (B = -1)) : (A = !0), ae(w, z - q)))
                : ((I.sortIndex = Q), e(l, I), y || g || ((y = !0), oe(C))),
              I
            );
          }),
          (n.unstable_shouldYield = U),
          (n.unstable_wrapCallback = function (I) {
            var G = p;
            return function () {
              var z = p;
              p = G;
              try {
                return I.apply(this, arguments);
              } finally {
                p = z;
              }
            };
          }));
      })(my)),
    my
  );
}
var NC;
function G5() {
  return (
    NC ||
      ((NC = 1),
      (function (n) {
        n.exports = z5();
      })(U5)),
    qm
  );
}
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var H5 = function (e) {
  var t = {},
    i = H,
    r = G5(),
    s = Object.assign;
  function o(c) {
    for (
      var f = "https://reactjs.org/docs/error-decoder.html?invariant=" + c,
        v = 1;
      v < arguments.length;
      v++
    )
      f += "&args[]=" + encodeURIComponent(arguments[v]);
    return (
      "Minified React error #" +
      c +
      "; visit " +
      f +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  var a = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    l = Symbol.for("react.element"),
    u = Symbol.for("react.portal"),
    h = Symbol.for("react.fragment"),
    d = Symbol.for("react.strict_mode"),
    p = Symbol.for("react.profiler"),
    g = Symbol.for("react.provider"),
    y = Symbol.for("react.context"),
    A = Symbol.for("react.forward_ref"),
    _ = Symbol.for("react.suspense"),
    m = Symbol.for("react.suspense_list"),
    x = Symbol.for("react.memo"),
    S = Symbol.for("react.lazy"),
    w = Symbol.for("react.offscreen"),
    C = Symbol.iterator;
  function P(c) {
    return c === null || typeof c != "object"
      ? null
      : ((c = (C && c[C]) || c["@@iterator"]),
        typeof c == "function" ? c : null);
  }
  function R(c) {
    if (c == null) return null;
    if (typeof c == "function") return c.displayName || c.name || null;
    if (typeof c == "string") return c;
    switch (c) {
      case h:
        return "Fragment";
      case u:
        return "Portal";
      case p:
        return "Profiler";
      case d:
        return "StrictMode";
      case _:
        return "Suspense";
      case m:
        return "SuspenseList";
    }
    if (typeof c == "object")
      switch (c.$$typeof) {
        case y:
          return (c.displayName || "Context") + ".Consumer";
        case g:
          return (c._context.displayName || "Context") + ".Provider";
        case A:
          var f = c.render;
          return (
            (c = c.displayName),
            c ||
              ((c = f.displayName || f.name || ""),
              (c = c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef")),
            c
          );
        case x:
          return (
            (f = c.displayName || null),
            f !== null ? f : R(c.type) || "Memo"
          );
        case S:
          ((f = c._payload), (c = c._init));
          try {
            return R(c(f));
          } catch {}
      }
    return null;
  }
  function B(c) {
    var f = c.type;
    switch (c.tag) {
      case 24:
        return "Cache";
      case 9:
        return (f.displayName || "Context") + ".Consumer";
      case 10:
        return (f._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return (
          (c = f.render),
          (c = c.displayName || c.name || ""),
          f.displayName || (c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef")
        );
      case 7:
        return "Fragment";
      case 5:
        return f;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return R(f);
      case 8:
        return f === d ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof f == "function") return f.displayName || f.name || null;
        if (typeof f == "string") return f;
    }
    return null;
  }
  function b(c) {
    var f = c,
      v = c;
    if (c.alternate) for (; f.return; ) f = f.return;
    else {
      c = f;
      do ((f = c), f.flags & 4098 && (v = f.return), (c = f.return));
      while (c);
    }
    return f.tag === 3 ? v : null;
  }
  function L(c) {
    if (b(c) !== c) throw Error(o(188));
  }
  function U(c) {
    var f = c.alternate;
    if (!f) {
      if (((f = b(c)), f === null)) throw Error(o(188));
      return f !== c ? null : c;
    }
    for (var v = c, M = f; ; ) {
      var E = v.return;
      if (E === null) break;
      var T = E.alternate;
      if (T === null) {
        if (((M = E.return), M !== null)) {
          v = M;
          continue;
        }
        break;
      }
      if (E.child === T.child) {
        for (T = E.child; T; ) {
          if (T === v) return (L(E), c);
          if (T === M) return (L(E), f);
          T = T.sibling;
        }
        throw Error(o(188));
      }
      if (v.return !== M.return) ((v = E), (M = T));
      else {
        for (var k = !1, Y = E.child; Y; ) {
          if (Y === v) {
            ((k = !0), (v = E), (M = T));
            break;
          }
          if (Y === M) {
            ((k = !0), (M = E), (v = T));
            break;
          }
          Y = Y.sibling;
        }
        if (!k) {
          for (Y = T.child; Y; ) {
            if (Y === v) {
              ((k = !0), (v = T), (M = E));
              break;
            }
            if (Y === M) {
              ((k = !0), (M = T), (v = E));
              break;
            }
            Y = Y.sibling;
          }
          if (!k) throw Error(o(189));
        }
      }
      if (v.alternate !== M) throw Error(o(190));
    }
    if (v.tag !== 3) throw Error(o(188));
    return v.stateNode.current === v ? c : f;
  }
  function J(c) {
    return ((c = U(c)), c !== null ? V(c) : null);
  }
  function V(c) {
    if (c.tag === 5 || c.tag === 6) return c;
    for (c = c.child; c !== null; ) {
      var f = V(c);
      if (f !== null) return f;
      c = c.sibling;
    }
    return null;
  }
  function j(c) {
    if (c.tag === 5 || c.tag === 6) return c;
    for (c = c.child; c !== null; ) {
      if (c.tag !== 4) {
        var f = j(c);
        if (f !== null) return f;
      }
      c = c.sibling;
    }
    return null;
  }
  var X = Array.isArray,
    oe = e.getPublicInstance,
    ae = e.getRootHostContext,
    I = e.getChildHostContext,
    G = e.prepareForCommit,
    z = e.resetAfterCommit,
    q = e.createInstance,
    Q = e.appendInitialChild,
    ee = e.finalizeInitialChildren,
    ne = e.prepareUpdate,
    Ee = e.shouldSetTextContent,
    Ae = e.createTextInstance,
    $ = e.scheduleTimeout,
    Je = e.cancelTimeout,
    Xe = e.noTimeout,
    xe = e.isPrimaryRenderer,
    Se = e.supportsMutation,
    ge = e.supportsPersistence,
    se = e.supportsHydration,
    _e = e.getInstanceFromNode,
    Ne = e.preparePortalMount,
    Le = e.getCurrentEventPriority,
    We = e.detachDeletedInstance,
    Ke = e.supportsMicrotasks,
    je = e.scheduleMicrotask,
    nt = e.supportsTestSelectors,
    At = e.findFiberRoot,
    O = e.getBoundingRect,
    D = e.getTextContent,
    le = e.isHiddenSubtree,
    Ce = e.matchAccessibilityRole,
    Te = e.setFocusIfFocusable,
    Re = e.setupIntersectionObserver,
    et = e.appendChild,
    Ue = e.appendChildToContainer,
    pe = e.commitTextUpdate,
    He = e.commitMount,
    W = e.commitUpdate,
    de = e.insertBefore,
    Me = e.insertInContainerBefore,
    Pe = e.removeChild,
    qe = e.removeChildFromContainer,
    ht = e.resetTextContent,
    Ut = e.hideInstance,
    K = e.hideTextInstance,
    fe = e.unhideInstance,
    we = e.unhideTextInstance,
    Oe = e.clearContainer,
    Qe = e.cloneInstance,
    zt = e.createContainerChildSet,
    Wt = e.appendChildToContainerChildSet,
    In = e.finalizeContainerChildren,
    Ar = e.replaceContainerChildren,
    Qt = e.cloneHiddenInstance,
    ci = e.cloneHiddenTextInstance,
    er = e.canHydrateInstance,
    _l = e.canHydrateTextInstance,
    Kh = e.canHydrateSuspenseInstance,
    Yh = e.isSuspenseInstancePending,
    pu = e.isSuspenseInstanceFallback,
    s0 = e.registerSuspenseInstanceRetry,
    N = e.getNextHydratableSibling,
    re = e.getFirstHydratableChild,
    me = e.getFirstHydratableChildWithinContainer,
    te = e.getFirstHydratableChildWithinSuspenseInstance,
    ye = e.hydrateInstance,
    $e = e.hydrateTextInstance,
    st = e.hydrateSuspenseInstance,
    at = e.getNextHydratableInstanceAfterSuspenseInstance,
    dt = e.commitHydratedContainer,
    yt = e.commitHydratedSuspenseInstance,
    xt = e.clearSuspenseBoundary,
    Mt = e.clearSuspenseBoundaryFromContainer,
    Ft = e.shouldDeleteUnhydratedTailInstances,
    Gn = e.didNotMatchHydratedContainerTextInstance,
    Fi = e.didNotMatchHydratedTextInstance,
    Mr;
  function jt(c) {
    if (Mr === void 0)
      try {
        throw Error();
      } catch (v) {
        var f = v.stack.trim().match(/\n( *(at )?)/);
        Mr = (f && f[1]) || "";
      }
    return (
      `
` +
      Mr +
      c
    );
  }
  var St = !1;
  function oa(c, f) {
    if (!c || St) return "";
    St = !0;
    var v = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (f)
        if (
          ((f = function () {
            throw Error();
          }),
          Object.defineProperty(f.prototype, "props", {
            set: function () {
              throw Error();
            },
          }),
          typeof Reflect == "object" && Reflect.construct)
        ) {
          try {
            Reflect.construct(f, []);
          } catch (Be) {
            var M = Be;
          }
          Reflect.construct(c, [], f);
        } else {
          try {
            f.call();
          } catch (Be) {
            M = Be;
          }
          c.call(f.prototype);
        }
      else {
        try {
          throw Error();
        } catch (Be) {
          M = Be;
        }
        c();
      }
    } catch (Be) {
      if (Be && M && typeof Be.stack == "string") {
        for (
          var E = Be.stack.split(`
`),
            T = M.stack.split(`
`),
            k = E.length - 1,
            Y = T.length - 1;
          1 <= k && 0 <= Y && E[k] !== T[Y];

        )
          Y--;
        for (; 1 <= k && 0 <= Y; k--, Y--)
          if (E[k] !== T[Y]) {
            if (k !== 1 || Y !== 1)
              do
                if ((k--, Y--, 0 > Y || E[k] !== T[Y])) {
                  var he =
                    `
` + E[k].replace(" at new ", " at ");
                  return (
                    c.displayName &&
                      he.includes("<anonymous>") &&
                      (he = he.replace("<anonymous>", c.displayName)),
                    he
                  );
                }
              while (1 <= k && 0 <= Y);
            break;
          }
      }
    } finally {
      ((St = !1), (Error.prepareStackTrace = v));
    }
    return (c = c ? c.displayName || c.name : "") ? jt(c) : "";
  }
  var yn = Object.prototype.hasOwnProperty,
    Sr = [],
    ms = -1;
  function Ai(c) {
    return { current: c };
  }
  function Nt(c) {
    0 > ms || ((c.current = Sr[ms]), (Sr[ms] = null), ms--);
  }
  function pt(c, f) {
    (ms++, (Sr[ms] = c.current), (c.current = f));
  }
  var Qn = {},
    xn = Ai(Qn),
    Gt = Ai(!1),
    wr = Qn;
  function io(c, f) {
    var v = c.type.contextTypes;
    if (!v) return Qn;
    var M = c.stateNode;
    if (M && M.__reactInternalMemoizedUnmaskedChildContext === f)
      return M.__reactInternalMemoizedMaskedChildContext;
    var E = {},
      T;
    for (T in v) E[T] = f[T];
    return (
      M &&
        ((c = c.stateNode),
        (c.__reactInternalMemoizedUnmaskedChildContext = f),
        (c.__reactInternalMemoizedMaskedChildContext = E)),
      E
    );
  }
  function Hn(c) {
    return ((c = c.childContextTypes), c != null);
  }
  function Qh() {
    (Nt(Gt), Nt(xn));
  }
  function dM(c, f, v) {
    if (xn.current !== Qn) throw Error(o(168));
    (pt(xn, f), pt(Gt, v));
  }
  function pM(c, f, v) {
    var M = c.stateNode;
    if (((f = f.childContextTypes), typeof M.getChildContext != "function"))
      return v;
    M = M.getChildContext();
    for (var E in M) if (!(E in f)) throw Error(o(108, B(c) || "Unknown", E));
    return s({}, v, M);
  }
  function Zh(c) {
    return (
      (c =
        ((c = c.stateNode) && c.__reactInternalMemoizedMergedChildContext) ||
        Qn),
      (wr = xn.current),
      pt(xn, c),
      pt(Gt, Gt.current),
      !0
    );
  }
  function mM(c, f, v) {
    var M = c.stateNode;
    if (!M) throw Error(o(169));
    (v
      ? ((c = pM(c, f, wr)),
        (M.__reactInternalMemoizedMergedChildContext = c),
        Nt(Gt),
        Nt(xn),
        pt(xn, c))
      : Nt(Gt),
      pt(Gt, v));
  }
  var Er = Math.clz32 ? Math.clz32 : VL,
    GL = Math.log,
    HL = Math.LN2;
  function VL(c) {
    return ((c >>>= 0), c === 0 ? 32 : (31 - ((GL(c) / HL) | 0)) | 0);
  }
  var qh = 64,
    $h = 4194304;
  function mu(c) {
    switch (c & -c) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return c & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return c & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return c;
    }
  }
  function ed(c, f) {
    var v = c.pendingLanes;
    if (v === 0) return 0;
    var M = 0,
      E = c.suspendedLanes,
      T = c.pingedLanes,
      k = v & 268435455;
    if (k !== 0) {
      var Y = k & ~E;
      Y !== 0 ? (M = mu(Y)) : ((T &= k), T !== 0 && (M = mu(T)));
    } else ((k = v & ~E), k !== 0 ? (M = mu(k)) : T !== 0 && (M = mu(T)));
    if (M === 0) return 0;
    if (
      f !== 0 &&
      f !== M &&
      !(f & E) &&
      ((E = M & -M), (T = f & -f), E >= T || (E === 16 && (T & 4194240) !== 0))
    )
      return f;
    if ((M & 4 && (M |= v & 16), (f = c.entangledLanes), f !== 0))
      for (c = c.entanglements, f &= M; 0 < f; )
        ((v = 31 - Er(f)), (E = 1 << v), (M |= c[v]), (f &= ~E));
    return M;
  }
  function WL(c, f) {
    switch (c) {
      case 1:
      case 2:
      case 4:
        return f + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return f + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function jL(c, f) {
    for (
      var v = c.suspendedLanes,
        M = c.pingedLanes,
        E = c.expirationTimes,
        T = c.pendingLanes;
      0 < T;

    ) {
      var k = 31 - Er(T),
        Y = 1 << k,
        he = E[k];
      (he === -1
        ? (!(Y & v) || Y & M) && (E[k] = WL(Y, f))
        : he <= f && (c.expiredLanes |= Y),
        (T &= ~Y));
    }
  }
  function o0(c) {
    return (
      (c = c.pendingLanes & -1073741825),
      c !== 0 ? c : c & 1073741824 ? 1073741824 : 0
    );
  }
  function a0(c) {
    for (var f = [], v = 0; 31 > v; v++) f.push(c);
    return f;
  }
  function gu(c, f, v) {
    ((c.pendingLanes |= f),
      f !== 536870912 && ((c.suspendedLanes = 0), (c.pingedLanes = 0)),
      (c = c.eventTimes),
      (f = 31 - Er(f)),
      (c[f] = v));
  }
  function JL(c, f) {
    var v = c.pendingLanes & ~f;
    ((c.pendingLanes = f),
      (c.suspendedLanes = 0),
      (c.pingedLanes = 0),
      (c.expiredLanes &= f),
      (c.mutableReadLanes &= f),
      (c.entangledLanes &= f),
      (f = c.entanglements));
    var M = c.eventTimes;
    for (c = c.expirationTimes; 0 < v; ) {
      var E = 31 - Er(v),
        T = 1 << E;
      ((f[E] = 0), (M[E] = -1), (c[E] = -1), (v &= ~T));
    }
  }
  function l0(c, f) {
    var v = (c.entangledLanes |= f);
    for (c = c.entanglements; v; ) {
      var M = 31 - Er(v),
        E = 1 << M;
      ((E & f) | (c[M] & f) && (c[M] |= f), (v &= ~E));
    }
  }
  var Rt = 0;
  function gM(c) {
    return (
      (c &= -c),
      1 < c ? (4 < c ? (c & 268435455 ? 16 : 536870912) : 4) : 1
    );
  }
  var c0 = r.unstable_scheduleCallback,
    vM = r.unstable_cancelCallback,
    XL = r.unstable_shouldYield,
    KL = r.unstable_requestPaint,
    Dn = r.unstable_now,
    u0 = r.unstable_ImmediatePriority,
    YL = r.unstable_UserBlockingPriority,
    f0 = r.unstable_NormalPriority,
    QL = r.unstable_IdlePriority,
    td = null,
    Kr = null;
  function ZL(c) {
    if (Kr && typeof Kr.onCommitFiberRoot == "function")
      try {
        Kr.onCommitFiberRoot(td, c, void 0, (c.current.flags & 128) === 128);
      } catch {}
  }
  function qL(c, f) {
    return (c === f && (c !== 0 || 1 / c === 1 / f)) || (c !== c && f !== f);
  }
  var Yr = typeof Object.is == "function" ? Object.is : qL,
    gs = null,
    nd = !1,
    h0 = !1;
  function yM(c) {
    gs === null ? (gs = [c]) : gs.push(c);
  }
  function $L(c) {
    ((nd = !0), yM(c));
  }
  function Qr() {
    if (!h0 && gs !== null) {
      h0 = !0;
      var c = 0,
        f = Rt;
      try {
        var v = gs;
        for (Rt = 1; c < v.length; c++) {
          var M = v[c];
          do M = M(!0);
          while (M !== null);
        }
        ((gs = null), (nd = !1));
      } catch (E) {
        throw (gs !== null && (gs = gs.slice(c + 1)), c0(u0, Qr), E);
      } finally {
        ((Rt = f), (h0 = !1));
      }
    }
    return null;
  }
  var eI = a.ReactCurrentBatchConfig;
  function id(c, f) {
    if (Yr(c, f)) return !0;
    if (
      typeof c != "object" ||
      c === null ||
      typeof f != "object" ||
      f === null
    )
      return !1;
    var v = Object.keys(c),
      M = Object.keys(f);
    if (v.length !== M.length) return !1;
    for (M = 0; M < v.length; M++) {
      var E = v[M];
      if (!yn.call(f, E) || !Yr(c[E], f[E])) return !1;
    }
    return !0;
  }
  function tI(c) {
    switch (c.tag) {
      case 5:
        return jt(c.type);
      case 16:
        return jt("Lazy");
      case 13:
        return jt("Suspense");
      case 19:
        return jt("SuspenseList");
      case 0:
      case 2:
      case 15:
        return ((c = oa(c.type, !1)), c);
      case 11:
        return ((c = oa(c.type.render, !1)), c);
      case 1:
        return ((c = oa(c.type, !0)), c);
      default:
        return "";
    }
  }
  function Cr(c, f) {
    if (c && c.defaultProps) {
      ((f = s({}, f)), (c = c.defaultProps));
      for (var v in c) f[v] === void 0 && (f[v] = c[v]);
      return f;
    }
    return f;
  }
  var rd = Ai(null),
    sd = null,
    Al = null,
    d0 = null;
  function p0() {
    d0 = Al = sd = null;
  }
  function xM(c, f, v) {
    xe
      ? (pt(rd, f._currentValue), (f._currentValue = v))
      : (pt(rd, f._currentValue2), (f._currentValue2 = v));
  }
  function m0(c) {
    var f = rd.current;
    (Nt(rd), xe ? (c._currentValue = f) : (c._currentValue2 = f));
  }
  function g0(c, f, v) {
    for (; c !== null; ) {
      var M = c.alternate;
      if (
        ((c.childLanes & f) !== f
          ? ((c.childLanes |= f), M !== null && (M.childLanes |= f))
          : M !== null && (M.childLanes & f) !== f && (M.childLanes |= f),
        c === v)
      )
        break;
      c = c.return;
    }
  }
  function Ml(c, f) {
    ((sd = c),
      (d0 = Al = null),
      (c = c.dependencies),
      c !== null &&
        c.firstContext !== null &&
        (c.lanes & f && (Oi = !0), (c.firstContext = null)));
  }
  function tr(c) {
    var f = xe ? c._currentValue : c._currentValue2;
    if (d0 !== c)
      if (((c = { context: c, memoizedValue: f, next: null }), Al === null)) {
        if (sd === null) throw Error(o(308));
        ((Al = c), (sd.dependencies = { lanes: 0, firstContext: c }));
      } else Al = Al.next = c;
    return f;
  }
  var Zr = null,
    ro = !1;
  function v0(c) {
    c.updateQueue = {
      baseState: c.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, interleaved: null, lanes: 0 },
      effects: null,
    };
  }
  function _M(c, f) {
    ((c = c.updateQueue),
      f.updateQueue === c &&
        (f.updateQueue = {
          baseState: c.baseState,
          firstBaseUpdate: c.firstBaseUpdate,
          lastBaseUpdate: c.lastBaseUpdate,
          shared: c.shared,
          effects: c.effects,
        }));
  }
  function vs(c, f) {
    return {
      eventTime: c,
      lane: f,
      tag: 0,
      payload: null,
      callback: null,
      next: null,
    };
  }
  function so(c, f) {
    var v = c.updateQueue;
    v !== null &&
      ((v = v.shared),
      _n !== null && c.mode & 1 && !(_t & 2)
        ? ((c = v.interleaved),
          c === null
            ? ((f.next = f), Zr === null ? (Zr = [v]) : Zr.push(v))
            : ((f.next = c.next), (c.next = f)),
          (v.interleaved = f))
        : ((c = v.pending),
          c === null ? (f.next = f) : ((f.next = c.next), (c.next = f)),
          (v.pending = f)));
  }
  function od(c, f, v) {
    if (
      ((f = f.updateQueue), f !== null && ((f = f.shared), (v & 4194240) !== 0))
    ) {
      var M = f.lanes;
      ((M &= c.pendingLanes), (v |= M), (f.lanes = v), l0(c, v));
    }
  }
  function AM(c, f) {
    var v = c.updateQueue,
      M = c.alternate;
    if (M !== null && ((M = M.updateQueue), v === M)) {
      var E = null,
        T = null;
      if (((v = v.firstBaseUpdate), v !== null)) {
        do {
          var k = {
            eventTime: v.eventTime,
            lane: v.lane,
            tag: v.tag,
            payload: v.payload,
            callback: v.callback,
            next: null,
          };
          (T === null ? (E = T = k) : (T = T.next = k), (v = v.next));
        } while (v !== null);
        T === null ? (E = T = f) : (T = T.next = f);
      } else E = T = f;
      ((v = {
        baseState: M.baseState,
        firstBaseUpdate: E,
        lastBaseUpdate: T,
        shared: M.shared,
        effects: M.effects,
      }),
        (c.updateQueue = v));
      return;
    }
    ((c = v.lastBaseUpdate),
      c === null ? (v.firstBaseUpdate = f) : (c.next = f),
      (v.lastBaseUpdate = f));
  }
  function ad(c, f, v, M) {
    var E = c.updateQueue;
    ro = !1;
    var T = E.firstBaseUpdate,
      k = E.lastBaseUpdate,
      Y = E.shared.pending;
    if (Y !== null) {
      E.shared.pending = null;
      var he = Y,
        Be = he.next;
      ((he.next = null), k === null ? (T = Be) : (k.next = Be), (k = he));
      var Ge = c.alternate;
      Ge !== null &&
        ((Ge = Ge.updateQueue),
        (Y = Ge.lastBaseUpdate),
        Y !== k &&
          (Y === null ? (Ge.firstBaseUpdate = Be) : (Y.next = Be),
          (Ge.lastBaseUpdate = he)));
    }
    if (T !== null) {
      var lt = E.baseState;
      ((k = 0), (Ge = Be = he = null), (Y = T));
      do {
        var tt = Y.lane,
          Ht = Y.eventTime;
        if ((M & tt) === tt) {
          Ge !== null &&
            (Ge = Ge.next =
              {
                eventTime: Ht,
                lane: 0,
                tag: Y.tag,
                payload: Y.payload,
                callback: Y.callback,
                next: null,
              });
          e: {
            var Ze = c,
              ei = Y;
            switch (((tt = f), (Ht = v), ei.tag)) {
              case 1:
                if (((Ze = ei.payload), typeof Ze == "function")) {
                  lt = Ze.call(Ht, lt, tt);
                  break e;
                }
                lt = Ze;
                break e;
              case 3:
                Ze.flags = (Ze.flags & -65537) | 128;
              case 0:
                if (
                  ((Ze = ei.payload),
                  (tt = typeof Ze == "function" ? Ze.call(Ht, lt, tt) : Ze),
                  tt == null)
                )
                  break e;
                lt = s({}, lt, tt);
                break e;
              case 2:
                ro = !0;
            }
          }
          Y.callback !== null &&
            Y.lane !== 0 &&
            ((c.flags |= 64),
            (tt = E.effects),
            tt === null ? (E.effects = [Y]) : tt.push(Y));
        } else
          ((Ht = {
            eventTime: Ht,
            lane: tt,
            tag: Y.tag,
            payload: Y.payload,
            callback: Y.callback,
            next: null,
          }),
            Ge === null ? ((Be = Ge = Ht), (he = lt)) : (Ge = Ge.next = Ht),
            (k |= tt));
        if (((Y = Y.next), Y === null)) {
          if (((Y = E.shared.pending), Y === null)) break;
          ((tt = Y),
            (Y = tt.next),
            (tt.next = null),
            (E.lastBaseUpdate = tt),
            (E.shared.pending = null));
        }
      } while (1);
      if (
        (Ge === null && (he = lt),
        (E.baseState = he),
        (E.firstBaseUpdate = Be),
        (E.lastBaseUpdate = Ge),
        (f = E.shared.interleaved),
        f !== null)
      ) {
        E = f;
        do ((k |= E.lane), (E = E.next));
        while (E !== f);
      } else T === null && (E.shared.lanes = 0);
      ((Rl |= k), (c.lanes = k), (c.memoizedState = lt));
    }
  }
  function MM(c, f, v) {
    if (((c = f.effects), (f.effects = null), c !== null))
      for (f = 0; f < c.length; f++) {
        var M = c[f],
          E = M.callback;
        if (E !== null) {
          if (((M.callback = null), (M = v), typeof E != "function"))
            throw Error(o(191, E));
          E.call(M);
        }
      }
  }
  var SM = new i.Component().refs;
  function y0(c, f, v, M) {
    ((f = c.memoizedState),
      (v = v(M, f)),
      (v = v == null ? f : s({}, f, v)),
      (c.memoizedState = v),
      c.lanes === 0 && (c.updateQueue.baseState = v));
  }
  var ld = {
    isMounted: function (c) {
      return (c = c._reactInternals) ? b(c) === c : !1;
    },
    enqueueSetState: function (c, f, v) {
      c = c._reactInternals;
      var M = fi(),
        E = lo(c),
        T = vs(M, E);
      ((T.payload = f),
        v != null && (T.callback = v),
        so(c, T),
        (f = or(c, E, M)),
        f !== null && od(f, c, E));
    },
    enqueueReplaceState: function (c, f, v) {
      c = c._reactInternals;
      var M = fi(),
        E = lo(c),
        T = vs(M, E);
      ((T.tag = 1),
        (T.payload = f),
        v != null && (T.callback = v),
        so(c, T),
        (f = or(c, E, M)),
        f !== null && od(f, c, E));
    },
    enqueueForceUpdate: function (c, f) {
      c = c._reactInternals;
      var v = fi(),
        M = lo(c),
        E = vs(v, M);
      ((E.tag = 2),
        f != null && (E.callback = f),
        so(c, E),
        (f = or(c, M, v)),
        f !== null && od(f, c, M));
    },
  };
  function wM(c, f, v, M, E, T, k) {
    return (
      (c = c.stateNode),
      typeof c.shouldComponentUpdate == "function"
        ? c.shouldComponentUpdate(M, T, k)
        : f.prototype && f.prototype.isPureReactComponent
          ? !id(v, M) || !id(E, T)
          : !0
    );
  }
  function EM(c, f, v) {
    var M = !1,
      E = Qn,
      T = f.contextType;
    return (
      typeof T == "object" && T !== null
        ? (T = tr(T))
        : ((E = Hn(f) ? wr : xn.current),
          (M = f.contextTypes),
          (T = (M = M != null) ? io(c, E) : Qn)),
      (f = new f(v, T)),
      (c.memoizedState =
        f.state !== null && f.state !== void 0 ? f.state : null),
      (f.updater = ld),
      (c.stateNode = f),
      (f._reactInternals = c),
      M &&
        ((c = c.stateNode),
        (c.__reactInternalMemoizedUnmaskedChildContext = E),
        (c.__reactInternalMemoizedMaskedChildContext = T)),
      f
    );
  }
  function CM(c, f, v, M) {
    ((c = f.state),
      typeof f.componentWillReceiveProps == "function" &&
        f.componentWillReceiveProps(v, M),
      typeof f.UNSAFE_componentWillReceiveProps == "function" &&
        f.UNSAFE_componentWillReceiveProps(v, M),
      f.state !== c && ld.enqueueReplaceState(f, f.state, null));
  }
  function x0(c, f, v, M) {
    var E = c.stateNode;
    ((E.props = v), (E.state = c.memoizedState), (E.refs = SM), v0(c));
    var T = f.contextType;
    (typeof T == "object" && T !== null
      ? (E.context = tr(T))
      : ((T = Hn(f) ? wr : xn.current), (E.context = io(c, T))),
      (E.state = c.memoizedState),
      (T = f.getDerivedStateFromProps),
      typeof T == "function" && (y0(c, f, T, v), (E.state = c.memoizedState)),
      typeof f.getDerivedStateFromProps == "function" ||
        typeof E.getSnapshotBeforeUpdate == "function" ||
        (typeof E.UNSAFE_componentWillMount != "function" &&
          typeof E.componentWillMount != "function") ||
        ((f = E.state),
        typeof E.componentWillMount == "function" && E.componentWillMount(),
        typeof E.UNSAFE_componentWillMount == "function" &&
          E.UNSAFE_componentWillMount(),
        f !== E.state && ld.enqueueReplaceState(E, E.state, null),
        ad(c, v, E, M),
        (E.state = c.memoizedState)),
      typeof E.componentDidMount == "function" && (c.flags |= 4194308));
  }
  var Sl = [],
    wl = 0,
    cd = null,
    ud = 0,
    nr = [],
    ir = 0,
    aa = null,
    ys = 1,
    xs = "";
  function la(c, f) {
    ((Sl[wl++] = ud), (Sl[wl++] = cd), (cd = c), (ud = f));
  }
  function TM(c, f, v) {
    ((nr[ir++] = ys), (nr[ir++] = xs), (nr[ir++] = aa), (aa = c));
    var M = ys;
    c = xs;
    var E = 32 - Er(M) - 1;
    ((M &= ~(1 << E)), (v += 1));
    var T = 32 - Er(f) + E;
    if (30 < T) {
      var k = E - (E % 5);
      ((T = (M & ((1 << k) - 1)).toString(32)),
        (M >>= k),
        (E -= k),
        (ys = (1 << (32 - Er(f) + E)) | (v << E) | M),
        (xs = T + c));
    } else ((ys = (1 << T) | (v << E) | M), (xs = c));
  }
  function _0(c) {
    c.return !== null && (la(c, 1), TM(c, 1, 0));
  }
  function A0(c) {
    for (; c === cd; )
      ((cd = Sl[--wl]), (Sl[wl] = null), (ud = Sl[--wl]), (Sl[wl] = null));
    for (; c === aa; )
      ((aa = nr[--ir]),
        (nr[ir] = null),
        (xs = nr[--ir]),
        (nr[ir] = null),
        (ys = nr[--ir]),
        (nr[ir] = null));
  }
  var Ni = null,
    ki = null,
    Zt = !1,
    vu = !1,
    Tr = null;
  function bM(c, f) {
    var v = ar(5, null, null, 0);
    ((v.elementType = "DELETED"),
      (v.stateNode = f),
      (v.return = c),
      (f = c.deletions),
      f === null ? ((c.deletions = [v]), (c.flags |= 16)) : f.push(v));
  }
  function PM(c, f) {
    switch (c.tag) {
      case 5:
        return (
          (f = er(f, c.type, c.pendingProps)),
          f !== null ? ((c.stateNode = f), (Ni = c), (ki = re(f)), !0) : !1
        );
      case 6:
        return (
          (f = _l(f, c.pendingProps)),
          f !== null ? ((c.stateNode = f), (Ni = c), (ki = null), !0) : !1
        );
      case 13:
        if (((f = Kh(f)), f !== null)) {
          var v = aa !== null ? { id: ys, overflow: xs } : null;
          return (
            (c.memoizedState = {
              dehydrated: f,
              treeContext: v,
              retryLane: 1073741824,
            }),
            (v = ar(18, null, null, 0)),
            (v.stateNode = f),
            (v.return = c),
            (c.child = v),
            (Ni = c),
            (ki = null),
            !0
          );
        }
        return !1;
      default:
        return !1;
    }
  }
  function M0(c) {
    return (c.mode & 1) !== 0 && (c.flags & 128) === 0;
  }
  function S0(c) {
    if (Zt) {
      var f = ki;
      if (f) {
        var v = f;
        if (!PM(c, f)) {
          if (M0(c)) throw Error(o(418));
          f = N(v);
          var M = Ni;
          f && PM(c, f)
            ? bM(M, v)
            : ((c.flags = (c.flags & -4097) | 2), (Zt = !1), (Ni = c));
        }
      } else {
        if (M0(c)) throw Error(o(418));
        ((c.flags = (c.flags & -4097) | 2), (Zt = !1), (Ni = c));
      }
    }
  }
  function BM(c) {
    for (
      c = c.return;
      c !== null && c.tag !== 5 && c.tag !== 3 && c.tag !== 13;

    )
      c = c.return;
    Ni = c;
  }
  function yu(c) {
    if (!se || c !== Ni) return !1;
    if (!Zt) return (BM(c), (Zt = !0), !1);
    if (
      c.tag !== 3 &&
      (c.tag !== 5 || (Ft(c.type) && !Ee(c.type, c.memoizedProps)))
    ) {
      var f = ki;
      if (f) {
        if (M0(c)) {
          for (c = ki; c; ) c = N(c);
          throw Error(o(418));
        }
        for (; f; ) (bM(c, f), (f = N(f)));
      }
    }
    if ((BM(c), c.tag === 13)) {
      if (!se) throw Error(o(316));
      if (((c = c.memoizedState), (c = c !== null ? c.dehydrated : null), !c))
        throw Error(o(317));
      ki = at(c);
    } else ki = Ni ? N(c.stateNode) : null;
    return !0;
  }
  function El() {
    se && ((ki = Ni = null), (vu = Zt = !1));
  }
  function w0(c) {
    Tr === null ? (Tr = [c]) : Tr.push(c);
  }
  function xu(c, f, v) {
    if (
      ((c = v.ref),
      c !== null && typeof c != "function" && typeof c != "object")
    ) {
      if (v._owner) {
        if (((v = v._owner), v)) {
          if (v.tag !== 1) throw Error(o(309));
          var M = v.stateNode;
        }
        if (!M) throw Error(o(147, c));
        var E = M,
          T = "" + c;
        return f !== null &&
          f.ref !== null &&
          typeof f.ref == "function" &&
          f.ref._stringRef === T
          ? f.ref
          : ((f = function (k) {
              var Y = E.refs;
              (Y === SM && (Y = E.refs = {}),
                k === null ? delete Y[T] : (Y[T] = k));
            }),
            (f._stringRef = T),
            f);
      }
      if (typeof c != "string") throw Error(o(284));
      if (!v._owner) throw Error(o(290, c));
    }
    return c;
  }
  function fd(c, f) {
    throw (
      (c = Object.prototype.toString.call(f)),
      Error(
        o(
          31,
          c === "[object Object]"
            ? "object with keys {" + Object.keys(f).join(", ") + "}"
            : c
        )
      )
    );
  }
  function RM(c) {
    var f = c._init;
    return f(c._payload);
  }
  function LM(c) {
    function f(ie, Z) {
      if (c) {
        var ue = ie.deletions;
        ue === null ? ((ie.deletions = [Z]), (ie.flags |= 16)) : ue.push(Z);
      }
    }
    function v(ie, Z) {
      if (!c) return null;
      for (; Z !== null; ) (f(ie, Z), (Z = Z.sibling));
      return null;
    }
    function M(ie, Z) {
      for (ie = new Map(); Z !== null; )
        (Z.key !== null ? ie.set(Z.key, Z) : ie.set(Z.index, Z),
          (Z = Z.sibling));
      return ie;
    }
    function E(ie, Z) {
      return ((ie = uo(ie, Z)), (ie.index = 0), (ie.sibling = null), ie);
    }
    function T(ie, Z, ue) {
      return (
        (ie.index = ue),
        c
          ? ((ue = ie.alternate),
            ue !== null
              ? ((ue = ue.index), ue < Z ? ((ie.flags |= 2), Z) : ue)
              : ((ie.flags |= 2), Z))
          : ((ie.flags |= 1048576), Z)
      );
    }
    function k(ie) {
      return (c && ie.alternate === null && (ie.flags |= 2), ie);
    }
    function Y(ie, Z, ue, ke) {
      return Z === null || Z.tag !== 6
        ? ((Z = av(ue, ie.mode, ke)), (Z.return = ie), Z)
        : ((Z = E(Z, ue)), (Z.return = ie), Z);
    }
    function he(ie, Z, ue, ke) {
      var Ye = ue.type;
      return Ye === h
        ? Ge(ie, Z, ue.props.children, ke, ue.key)
        : Z !== null &&
            (Z.elementType === Ye ||
              (typeof Ye == "object" &&
                Ye !== null &&
                Ye.$$typeof === S &&
                RM(Ye) === Z.type))
          ? ((ke = E(Z, ue.props)),
            (ke.ref = xu(ie, Z, ue)),
            (ke.return = ie),
            ke)
          : ((ke = Hd(ue.type, ue.key, ue.props, null, ie.mode, ke)),
            (ke.ref = xu(ie, Z, ue)),
            (ke.return = ie),
            ke);
    }
    function Be(ie, Z, ue, ke) {
      return Z === null ||
        Z.tag !== 4 ||
        Z.stateNode.containerInfo !== ue.containerInfo ||
        Z.stateNode.implementation !== ue.implementation
        ? ((Z = lv(ue, ie.mode, ke)), (Z.return = ie), Z)
        : ((Z = E(Z, ue.children || [])), (Z.return = ie), Z);
    }
    function Ge(ie, Z, ue, ke, Ye) {
      return Z === null || Z.tag !== 7
        ? ((Z = ma(ue, ie.mode, ke, Ye)), (Z.return = ie), Z)
        : ((Z = E(Z, ue)), (Z.return = ie), Z);
    }
    function lt(ie, Z, ue) {
      if ((typeof Z == "string" && Z !== "") || typeof Z == "number")
        return ((Z = av("" + Z, ie.mode, ue)), (Z.return = ie), Z);
      if (typeof Z == "object" && Z !== null) {
        switch (Z.$$typeof) {
          case l:
            return (
              (ue = Hd(Z.type, Z.key, Z.props, null, ie.mode, ue)),
              (ue.ref = xu(ie, null, Z)),
              (ue.return = ie),
              ue
            );
          case u:
            return ((Z = lv(Z, ie.mode, ue)), (Z.return = ie), Z);
          case S:
            var ke = Z._init;
            return lt(ie, ke(Z._payload), ue);
        }
        if (X(Z) || P(Z))
          return ((Z = ma(Z, ie.mode, ue, null)), (Z.return = ie), Z);
        fd(ie, Z);
      }
      return null;
    }
    function tt(ie, Z, ue, ke) {
      var Ye = Z !== null ? Z.key : null;
      if ((typeof ue == "string" && ue !== "") || typeof ue == "number")
        return Ye !== null ? null : Y(ie, Z, "" + ue, ke);
      if (typeof ue == "object" && ue !== null) {
        switch (ue.$$typeof) {
          case l:
            return ue.key === Ye ? he(ie, Z, ue, ke) : null;
          case u:
            return ue.key === Ye ? Be(ie, Z, ue, ke) : null;
          case S:
            return ((Ye = ue._init), tt(ie, Z, Ye(ue._payload), ke));
        }
        if (X(ue) || P(ue)) return Ye !== null ? null : Ge(ie, Z, ue, ke, null);
        fd(ie, ue);
      }
      return null;
    }
    function Ht(ie, Z, ue, ke, Ye) {
      if ((typeof ke == "string" && ke !== "") || typeof ke == "number")
        return ((ie = ie.get(ue) || null), Y(Z, ie, "" + ke, Ye));
      if (typeof ke == "object" && ke !== null) {
        switch (ke.$$typeof) {
          case l:
            return (
              (ie = ie.get(ke.key === null ? ue : ke.key) || null),
              he(Z, ie, ke, Ye)
            );
          case u:
            return (
              (ie = ie.get(ke.key === null ? ue : ke.key) || null),
              Be(Z, ie, ke, Ye)
            );
          case S:
            var mt = ke._init;
            return Ht(ie, Z, ue, mt(ke._payload), Ye);
        }
        if (X(ke) || P(ke))
          return ((ie = ie.get(ue) || null), Ge(Z, ie, ke, Ye, null));
        fd(Z, ke);
      }
      return null;
    }
    function Ze(ie, Z, ue, ke) {
      for (
        var Ye = null, mt = null, ct = Z, Lt = (Z = 0), Nn = null;
        ct !== null && Lt < ue.length;
        Lt++
      ) {
        ct.index > Lt ? ((Nn = ct), (ct = null)) : (Nn = ct.sibling);
        var It = tt(ie, ct, ue[Lt], ke);
        if (It === null) {
          ct === null && (ct = Nn);
          break;
        }
        (c && ct && It.alternate === null && f(ie, ct),
          (Z = T(It, Z, Lt)),
          mt === null ? (Ye = It) : (mt.sibling = It),
          (mt = It),
          (ct = Nn));
      }
      if (Lt === ue.length) return (v(ie, ct), Zt && la(ie, Lt), Ye);
      if (ct === null) {
        for (; Lt < ue.length; Lt++)
          ((ct = lt(ie, ue[Lt], ke)),
            ct !== null &&
              ((Z = T(ct, Z, Lt)),
              mt === null ? (Ye = ct) : (mt.sibling = ct),
              (mt = ct)));
        return (Zt && la(ie, Lt), Ye);
      }
      for (ct = M(ie, ct); Lt < ue.length; Lt++)
        ((Nn = Ht(ct, ie, Lt, ue[Lt], ke)),
          Nn !== null &&
            (c &&
              Nn.alternate !== null &&
              ct.delete(Nn.key === null ? Lt : Nn.key),
            (Z = T(Nn, Z, Lt)),
            mt === null ? (Ye = Nn) : (mt.sibling = Nn),
            (mt = Nn)));
      return (
        c &&
          ct.forEach(function (fo) {
            return f(ie, fo);
          }),
        Zt && la(ie, Lt),
        Ye
      );
    }
    function ei(ie, Z, ue, ke) {
      var Ye = P(ue);
      if (typeof Ye != "function") throw Error(o(150));
      if (((ue = Ye.call(ue)), ue == null)) throw Error(o(151));
      for (
        var mt = (Ye = null), ct = Z, Lt = (Z = 0), Nn = null, It = ue.next();
        ct !== null && !It.done;
        Lt++, It = ue.next()
      ) {
        ct.index > Lt ? ((Nn = ct), (ct = null)) : (Nn = ct.sibling);
        var fo = tt(ie, ct, It.value, ke);
        if (fo === null) {
          ct === null && (ct = Nn);
          break;
        }
        (c && ct && fo.alternate === null && f(ie, ct),
          (Z = T(fo, Z, Lt)),
          mt === null ? (Ye = fo) : (mt.sibling = fo),
          (mt = fo),
          (ct = Nn));
      }
      if (It.done) return (v(ie, ct), Zt && la(ie, Lt), Ye);
      if (ct === null) {
        for (; !It.done; Lt++, It = ue.next())
          ((It = lt(ie, It.value, ke)),
            It !== null &&
              ((Z = T(It, Z, Lt)),
              mt === null ? (Ye = It) : (mt.sibling = It),
              (mt = It)));
        return (Zt && la(ie, Lt), Ye);
      }
      for (ct = M(ie, ct); !It.done; Lt++, It = ue.next())
        ((It = Ht(ct, ie, Lt, It.value, ke)),
          It !== null &&
            (c &&
              It.alternate !== null &&
              ct.delete(It.key === null ? Lt : It.key),
            (Z = T(It, Z, Lt)),
            mt === null ? (Ye = It) : (mt.sibling = It),
            (mt = It)));
      return (
        c &&
          ct.forEach(function (RI) {
            return f(ie, RI);
          }),
        Zt && la(ie, Lt),
        Ye
      );
    }
    function lr(ie, Z, ue, ke) {
      if (
        (typeof ue == "object" &&
          ue !== null &&
          ue.type === h &&
          ue.key === null &&
          (ue = ue.props.children),
        typeof ue == "object" && ue !== null)
      ) {
        switch (ue.$$typeof) {
          case l:
            e: {
              for (var Ye = ue.key, mt = Z; mt !== null; ) {
                if (mt.key === Ye) {
                  if (((Ye = ue.type), Ye === h)) {
                    if (mt.tag === 7) {
                      (v(ie, mt.sibling),
                        (Z = E(mt, ue.props.children)),
                        (Z.return = ie),
                        (ie = Z));
                      break e;
                    }
                  } else if (
                    mt.elementType === Ye ||
                    (typeof Ye == "object" &&
                      Ye !== null &&
                      Ye.$$typeof === S &&
                      RM(Ye) === mt.type)
                  ) {
                    (v(ie, mt.sibling),
                      (Z = E(mt, ue.props)),
                      (Z.ref = xu(ie, mt, ue)),
                      (Z.return = ie),
                      (ie = Z));
                    break e;
                  }
                  v(ie, mt);
                  break;
                } else f(ie, mt);
                mt = mt.sibling;
              }
              ue.type === h
                ? ((Z = ma(ue.props.children, ie.mode, ke, ue.key)),
                  (Z.return = ie),
                  (ie = Z))
                : ((ke = Hd(ue.type, ue.key, ue.props, null, ie.mode, ke)),
                  (ke.ref = xu(ie, Z, ue)),
                  (ke.return = ie),
                  (ie = ke));
            }
            return k(ie);
          case u:
            e: {
              for (mt = ue.key; Z !== null; ) {
                if (Z.key === mt)
                  if (
                    Z.tag === 4 &&
                    Z.stateNode.containerInfo === ue.containerInfo &&
                    Z.stateNode.implementation === ue.implementation
                  ) {
                    (v(ie, Z.sibling),
                      (Z = E(Z, ue.children || [])),
                      (Z.return = ie),
                      (ie = Z));
                    break e;
                  } else {
                    v(ie, Z);
                    break;
                  }
                else f(ie, Z);
                Z = Z.sibling;
              }
              ((Z = lv(ue, ie.mode, ke)), (Z.return = ie), (ie = Z));
            }
            return k(ie);
          case S:
            return ((mt = ue._init), lr(ie, Z, mt(ue._payload), ke));
        }
        if (X(ue)) return Ze(ie, Z, ue, ke);
        if (P(ue)) return ei(ie, Z, ue, ke);
        fd(ie, ue);
      }
      return (typeof ue == "string" && ue !== "") || typeof ue == "number"
        ? ((ue = "" + ue),
          Z !== null && Z.tag === 6
            ? (v(ie, Z.sibling), (Z = E(Z, ue)), (Z.return = ie), (ie = Z))
            : (v(ie, Z), (Z = av(ue, ie.mode, ke)), (Z.return = ie), (ie = Z)),
          k(ie))
        : v(ie, Z);
    }
    return lr;
  }
  var Cl = LM(!0),
    IM = LM(!1),
    _u = {},
    rr = Ai(_u),
    Au = Ai(_u),
    Tl = Ai(_u);
  function qr(c) {
    if (c === _u) throw Error(o(174));
    return c;
  }
  function E0(c, f) {
    (pt(Tl, f), pt(Au, c), pt(rr, _u), (c = ae(f)), Nt(rr), pt(rr, c));
  }
  function bl() {
    (Nt(rr), Nt(Au), Nt(Tl));
  }
  function DM(c) {
    var f = qr(Tl.current),
      v = qr(rr.current);
    ((f = I(v, c.type, f)), v !== f && (pt(Au, c), pt(rr, f)));
  }
  function C0(c) {
    Au.current === c && (Nt(rr), Nt(Au));
  }
  var tn = Ai(0);
  function hd(c) {
    for (var f = c; f !== null; ) {
      if (f.tag === 13) {
        var v = f.memoizedState;
        if (v !== null && ((v = v.dehydrated), v === null || Yh(v) || pu(v)))
          return f;
      } else if (f.tag === 19 && f.memoizedProps.revealOrder !== void 0) {
        if (f.flags & 128) return f;
      } else if (f.child !== null) {
        ((f.child.return = f), (f = f.child));
        continue;
      }
      if (f === c) break;
      for (; f.sibling === null; ) {
        if (f.return === null || f.return === c) return null;
        f = f.return;
      }
      ((f.sibling.return = f.return), (f = f.sibling));
    }
    return null;
  }
  var T0 = [];
  function b0() {
    for (var c = 0; c < T0.length; c++) {
      var f = T0[c];
      xe
        ? (f._workInProgressVersionPrimary = null)
        : (f._workInProgressVersionSecondary = null);
    }
    T0.length = 0;
  }
  var dd = a.ReactCurrentDispatcher,
    sr = a.ReactCurrentBatchConfig,
    Pl = 0,
    un = null,
    Zn = null,
    Fn = null,
    pd = !1,
    Mu = !1,
    Su = 0,
    nI = 0;
  function qn() {
    throw Error(o(321));
  }
  function P0(c, f) {
    if (f === null) return !1;
    for (var v = 0; v < f.length && v < c.length; v++)
      if (!Yr(c[v], f[v])) return !1;
    return !0;
  }
  function B0(c, f, v, M, E, T) {
    if (
      ((Pl = T),
      (un = f),
      (f.memoizedState = null),
      (f.updateQueue = null),
      (f.lanes = 0),
      (dd.current = c === null || c.memoizedState === null ? oI : aI),
      (c = v(M, E)),
      Mu)
    ) {
      T = 0;
      do {
        if (((Mu = !1), (Su = 0), 25 <= T)) throw Error(o(301));
        ((T += 1),
          (Fn = Zn = null),
          (f.updateQueue = null),
          (dd.current = lI),
          (c = v(M, E)));
      } while (Mu);
    }
    if (
      ((dd.current = xd),
      (f = Zn !== null && Zn.next !== null),
      (Pl = 0),
      (Fn = Zn = un = null),
      (pd = !1),
      f)
    )
      throw Error(o(300));
    return c;
  }
  function R0() {
    var c = Su !== 0;
    return ((Su = 0), c);
  }
  function _s() {
    var c = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null,
    };
    return (Fn === null ? (un.memoizedState = Fn = c) : (Fn = Fn.next = c), Fn);
  }
  function $r() {
    if (Zn === null) {
      var c = un.alternate;
      c = c !== null ? c.memoizedState : null;
    } else c = Zn.next;
    var f = Fn === null ? un.memoizedState : Fn.next;
    if (f !== null) ((Fn = f), (Zn = c));
    else {
      if (c === null) throw Error(o(310));
      ((Zn = c),
        (c = {
          memoizedState: Zn.memoizedState,
          baseState: Zn.baseState,
          baseQueue: Zn.baseQueue,
          queue: Zn.queue,
          next: null,
        }),
        Fn === null ? (un.memoizedState = Fn = c) : (Fn = Fn.next = c));
    }
    return Fn;
  }
  function ca(c, f) {
    return typeof f == "function" ? f(c) : f;
  }
  function md(c) {
    var f = $r(),
      v = f.queue;
    if (v === null) throw Error(o(311));
    v.lastRenderedReducer = c;
    var M = Zn,
      E = M.baseQueue,
      T = v.pending;
    if (T !== null) {
      if (E !== null) {
        var k = E.next;
        ((E.next = T.next), (T.next = k));
      }
      ((M.baseQueue = E = T), (v.pending = null));
    }
    if (E !== null) {
      ((T = E.next), (M = M.baseState));
      var Y = (k = null),
        he = null,
        Be = T;
      do {
        var Ge = Be.lane;
        if ((Pl & Ge) === Ge)
          (he !== null &&
            (he = he.next =
              {
                lane: 0,
                action: Be.action,
                hasEagerState: Be.hasEagerState,
                eagerState: Be.eagerState,
                next: null,
              }),
            (M = Be.hasEagerState ? Be.eagerState : c(M, Be.action)));
        else {
          var lt = {
            lane: Ge,
            action: Be.action,
            hasEagerState: Be.hasEagerState,
            eagerState: Be.eagerState,
            next: null,
          };
          (he === null ? ((Y = he = lt), (k = M)) : (he = he.next = lt),
            (un.lanes |= Ge),
            (Rl |= Ge));
        }
        Be = Be.next;
      } while (Be !== null && Be !== T);
      (he === null ? (k = M) : (he.next = Y),
        Yr(M, f.memoizedState) || (Oi = !0),
        (f.memoizedState = M),
        (f.baseState = k),
        (f.baseQueue = he),
        (v.lastRenderedState = M));
    }
    if (((c = v.interleaved), c !== null)) {
      E = c;
      do ((T = E.lane), (un.lanes |= T), (Rl |= T), (E = E.next));
      while (E !== c);
    } else E === null && (v.lanes = 0);
    return [f.memoizedState, v.dispatch];
  }
  function gd(c) {
    var f = $r(),
      v = f.queue;
    if (v === null) throw Error(o(311));
    v.lastRenderedReducer = c;
    var M = v.dispatch,
      E = v.pending,
      T = f.memoizedState;
    if (E !== null) {
      v.pending = null;
      var k = (E = E.next);
      do ((T = c(T, k.action)), (k = k.next));
      while (k !== E);
      (Yr(T, f.memoizedState) || (Oi = !0),
        (f.memoizedState = T),
        f.baseQueue === null && (f.baseState = T),
        (v.lastRenderedState = T));
    }
    return [T, M];
  }
  function FM() {}
  function NM(c, f) {
    var v = un,
      M = $r(),
      E = f(),
      T = !Yr(M.memoizedState, E);
    if (
      (T && ((M.memoizedState = E), (Oi = !0)),
      (M = M.queue),
      Eu(UM.bind(null, v, M, c), [c]),
      M.getSnapshot !== f || T || (Fn !== null && Fn.memoizedState.tag & 1))
    ) {
      if (
        ((v.flags |= 2048),
        wu(9, OM.bind(null, v, M, E, f), void 0, null),
        _n === null)
      )
        throw Error(o(349));
      Pl & 30 || kM(v, f, E);
    }
    return E;
  }
  function kM(c, f, v) {
    ((c.flags |= 16384),
      (c = { getSnapshot: f, value: v }),
      (f = un.updateQueue),
      f === null
        ? ((f = { lastEffect: null, stores: null }),
          (un.updateQueue = f),
          (f.stores = [c]))
        : ((v = f.stores), v === null ? (f.stores = [c]) : v.push(c)));
  }
  function OM(c, f, v, M) {
    ((f.value = v), (f.getSnapshot = M), zM(f) && or(c, 1, -1));
  }
  function UM(c, f, v) {
    return v(function () {
      zM(f) && or(c, 1, -1);
    });
  }
  function zM(c) {
    var f = c.getSnapshot;
    c = c.value;
    try {
      var v = f();
      return !Yr(c, v);
    } catch {
      return !0;
    }
  }
  function L0(c) {
    var f = _s();
    return (
      typeof c == "function" && (c = c()),
      (f.memoizedState = f.baseState = c),
      (c = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: ca,
        lastRenderedState: c,
      }),
      (f.queue = c),
      (c = c.dispatch = sI.bind(null, un, c)),
      [f.memoizedState, c]
    );
  }
  function wu(c, f, v, M) {
    return (
      (c = { tag: c, create: f, destroy: v, deps: M, next: null }),
      (f = un.updateQueue),
      f === null
        ? ((f = { lastEffect: null, stores: null }),
          (un.updateQueue = f),
          (f.lastEffect = c.next = c))
        : ((v = f.lastEffect),
          v === null
            ? (f.lastEffect = c.next = c)
            : ((M = v.next), (v.next = c), (c.next = M), (f.lastEffect = c))),
      c
    );
  }
  function GM() {
    return $r().memoizedState;
  }
  function vd(c, f, v, M) {
    var E = _s();
    ((un.flags |= c),
      (E.memoizedState = wu(1 | f, v, void 0, M === void 0 ? null : M)));
  }
  function yd(c, f, v, M) {
    var E = $r();
    M = M === void 0 ? null : M;
    var T = void 0;
    if (Zn !== null) {
      var k = Zn.memoizedState;
      if (((T = k.destroy), M !== null && P0(M, k.deps))) {
        E.memoizedState = wu(f, v, T, M);
        return;
      }
    }
    ((un.flags |= c), (E.memoizedState = wu(1 | f, v, T, M)));
  }
  function I0(c, f) {
    return vd(8390656, 8, c, f);
  }
  function Eu(c, f) {
    return yd(2048, 8, c, f);
  }
  function HM(c, f) {
    return yd(4, 2, c, f);
  }
  function VM(c, f) {
    return yd(4, 4, c, f);
  }
  function WM(c, f) {
    if (typeof f == "function")
      return (
        (c = c()),
        f(c),
        function () {
          f(null);
        }
      );
    if (f != null)
      return (
        (c = c()),
        (f.current = c),
        function () {
          f.current = null;
        }
      );
  }
  function jM(c, f, v) {
    return (
      (v = v != null ? v.concat([c]) : null),
      yd(4, 4, WM.bind(null, f, c), v)
    );
  }
  function D0() {}
  function JM(c, f) {
    var v = $r();
    f = f === void 0 ? null : f;
    var M = v.memoizedState;
    return M !== null && f !== null && P0(f, M[1])
      ? M[0]
      : ((v.memoizedState = [c, f]), c);
  }
  function XM(c, f) {
    var v = $r();
    f = f === void 0 ? null : f;
    var M = v.memoizedState;
    return M !== null && f !== null && P0(f, M[1])
      ? M[0]
      : ((c = c()), (v.memoizedState = [c, f]), c);
  }
  function iI(c, f) {
    var v = Rt;
    ((Rt = v !== 0 && 4 > v ? v : 4), c(!0));
    var M = sr.transition;
    sr.transition = {};
    try {
      (c(!1), f());
    } finally {
      ((Rt = v), (sr.transition = M));
    }
  }
  function KM() {
    return $r().memoizedState;
  }
  function rI(c, f, v) {
    var M = lo(c);
    ((v = {
      lane: M,
      action: v,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
      YM(c)
        ? QM(f, v)
        : (ZM(c, f, v),
          (v = fi()),
          (c = or(c, M, v)),
          c !== null && qM(c, f, M)));
  }
  function sI(c, f, v) {
    var M = lo(c),
      E = {
        lane: M,
        action: v,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      };
    if (YM(c)) QM(f, E);
    else {
      ZM(c, f, E);
      var T = c.alternate;
      if (
        c.lanes === 0 &&
        (T === null || T.lanes === 0) &&
        ((T = f.lastRenderedReducer), T !== null)
      )
        try {
          var k = f.lastRenderedState,
            Y = T(k, v);
          if (((E.hasEagerState = !0), (E.eagerState = Y), Yr(Y, k))) return;
        } catch {
        } finally {
        }
      ((v = fi()), (c = or(c, M, v)), c !== null && qM(c, f, M));
    }
  }
  function YM(c) {
    var f = c.alternate;
    return c === un || (f !== null && f === un);
  }
  function QM(c, f) {
    Mu = pd = !0;
    var v = c.pending;
    (v === null ? (f.next = f) : ((f.next = v.next), (v.next = f)),
      (c.pending = f));
  }
  function ZM(c, f, v) {
    _n !== null && c.mode & 1 && !(_t & 2)
      ? ((c = f.interleaved),
        c === null
          ? ((v.next = v), Zr === null ? (Zr = [f]) : Zr.push(f))
          : ((v.next = c.next), (c.next = v)),
        (f.interleaved = v))
      : ((c = f.pending),
        c === null ? (v.next = v) : ((v.next = c.next), (c.next = v)),
        (f.pending = v));
  }
  function qM(c, f, v) {
    if (v & 4194240) {
      var M = f.lanes;
      ((M &= c.pendingLanes), (v |= M), (f.lanes = v), l0(c, v));
    }
  }
  var xd = {
      readContext: tr,
      useCallback: qn,
      useContext: qn,
      useEffect: qn,
      useImperativeHandle: qn,
      useInsertionEffect: qn,
      useLayoutEffect: qn,
      useMemo: qn,
      useReducer: qn,
      useRef: qn,
      useState: qn,
      useDebugValue: qn,
      useDeferredValue: qn,
      useTransition: qn,
      useMutableSource: qn,
      useSyncExternalStore: qn,
      useId: qn,
      unstable_isNewReconciler: !1,
    },
    oI = {
      readContext: tr,
      useCallback: function (c, f) {
        return ((_s().memoizedState = [c, f === void 0 ? null : f]), c);
      },
      useContext: tr,
      useEffect: I0,
      useImperativeHandle: function (c, f, v) {
        return (
          (v = v != null ? v.concat([c]) : null),
          vd(4194308, 4, WM.bind(null, f, c), v)
        );
      },
      useLayoutEffect: function (c, f) {
        return vd(4194308, 4, c, f);
      },
      useInsertionEffect: function (c, f) {
        return vd(4, 2, c, f);
      },
      useMemo: function (c, f) {
        var v = _s();
        return (
          (f = f === void 0 ? null : f),
          (c = c()),
          (v.memoizedState = [c, f]),
          c
        );
      },
      useReducer: function (c, f, v) {
        var M = _s();
        return (
          (f = v !== void 0 ? v(f) : f),
          (M.memoizedState = M.baseState = f),
          (c = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: c,
            lastRenderedState: f,
          }),
          (M.queue = c),
          (c = c.dispatch = rI.bind(null, un, c)),
          [M.memoizedState, c]
        );
      },
      useRef: function (c) {
        var f = _s();
        return ((c = { current: c }), (f.memoizedState = c));
      },
      useState: L0,
      useDebugValue: D0,
      useDeferredValue: function (c) {
        var f = L0(c),
          v = f[0],
          M = f[1];
        return (
          I0(
            function () {
              var E = sr.transition;
              sr.transition = {};
              try {
                M(c);
              } finally {
                sr.transition = E;
              }
            },
            [c]
          ),
          v
        );
      },
      useTransition: function () {
        var c = L0(!1),
          f = c[0];
        return ((c = iI.bind(null, c[1])), (_s().memoizedState = c), [f, c]);
      },
      useMutableSource: function () {},
      useSyncExternalStore: function (c, f, v) {
        var M = un,
          E = _s();
        if (Zt) {
          if (v === void 0) throw Error(o(407));
          v = v();
        } else {
          if (((v = f()), _n === null)) throw Error(o(349));
          Pl & 30 || kM(M, f, v);
        }
        E.memoizedState = v;
        var T = { value: v, getSnapshot: f };
        return (
          (E.queue = T),
          I0(UM.bind(null, M, T, c), [c]),
          (M.flags |= 2048),
          wu(9, OM.bind(null, M, T, v, f), void 0, null),
          v
        );
      },
      useId: function () {
        var c = _s(),
          f = _n.identifierPrefix;
        if (Zt) {
          var v = xs,
            M = ys;
          ((v = (M & ~(1 << (32 - Er(M) - 1))).toString(32) + v),
            (f = ":" + f + "R" + v),
            (v = Su++),
            0 < v && (f += "H" + v.toString(32)),
            (f += ":"));
        } else ((v = nI++), (f = ":" + f + "r" + v.toString(32) + ":"));
        return (c.memoizedState = f);
      },
      unstable_isNewReconciler: !1,
    },
    aI = {
      readContext: tr,
      useCallback: JM,
      useContext: tr,
      useEffect: Eu,
      useImperativeHandle: jM,
      useInsertionEffect: HM,
      useLayoutEffect: VM,
      useMemo: XM,
      useReducer: md,
      useRef: GM,
      useState: function () {
        return md(ca);
      },
      useDebugValue: D0,
      useDeferredValue: function (c) {
        var f = md(ca),
          v = f[0],
          M = f[1];
        return (
          Eu(
            function () {
              var E = sr.transition;
              sr.transition = {};
              try {
                M(c);
              } finally {
                sr.transition = E;
              }
            },
            [c]
          ),
          v
        );
      },
      useTransition: function () {
        var c = md(ca)[0],
          f = $r().memoizedState;
        return [c, f];
      },
      useMutableSource: FM,
      useSyncExternalStore: NM,
      useId: KM,
      unstable_isNewReconciler: !1,
    },
    lI = {
      readContext: tr,
      useCallback: JM,
      useContext: tr,
      useEffect: Eu,
      useImperativeHandle: jM,
      useInsertionEffect: HM,
      useLayoutEffect: VM,
      useMemo: XM,
      useReducer: gd,
      useRef: GM,
      useState: function () {
        return gd(ca);
      },
      useDebugValue: D0,
      useDeferredValue: function (c) {
        var f = gd(ca),
          v = f[0],
          M = f[1];
        return (
          Eu(
            function () {
              var E = sr.transition;
              sr.transition = {};
              try {
                M(c);
              } finally {
                sr.transition = E;
              }
            },
            [c]
          ),
          v
        );
      },
      useTransition: function () {
        var c = gd(ca)[0],
          f = $r().memoizedState;
        return [c, f];
      },
      useMutableSource: FM,
      useSyncExternalStore: NM,
      useId: KM,
      unstable_isNewReconciler: !1,
    };
  function F0(c, f) {
    try {
      var v = "",
        M = f;
      do ((v += tI(M)), (M = M.return));
      while (M);
      var E = v;
    } catch (T) {
      E =
        `
Error generating stack: ` +
        T.message +
        `
` +
        T.stack;
    }
    return { value: c, source: f, stack: E };
  }
  function N0(c, f) {
    try {
      console.error(f.value);
    } catch (v) {
      setTimeout(function () {
        throw v;
      });
    }
  }
  var cI = typeof WeakMap == "function" ? WeakMap : Map;
  function $M(c, f, v) {
    ((v = vs(-1, v)), (v.tag = 3), (v.payload = { element: null }));
    var M = f.value;
    return (
      (v.callback = function () {
        (Fd || ((Fd = !0), (ev = M)), N0(c, f));
      }),
      v
    );
  }
  function eS(c, f, v) {
    ((v = vs(-1, v)), (v.tag = 3));
    var M = c.type.getDerivedStateFromError;
    if (typeof M == "function") {
      var E = f.value;
      ((v.payload = function () {
        return M(E);
      }),
        (v.callback = function () {
          N0(c, f);
        }));
    }
    var T = c.stateNode;
    return (
      T !== null &&
        typeof T.componentDidCatch == "function" &&
        (v.callback = function () {
          (N0(c, f),
            typeof M != "function" &&
              (oo === null ? (oo = new Set([this])) : oo.add(this)));
          var k = f.stack;
          this.componentDidCatch(f.value, {
            componentStack: k !== null ? k : "",
          });
        }),
      v
    );
  }
  function tS(c, f, v) {
    var M = c.pingCache;
    if (M === null) {
      M = c.pingCache = new cI();
      var E = new Set();
      M.set(f, E);
    } else ((E = M.get(f)), E === void 0 && ((E = new Set()), M.set(f, E)));
    E.has(v) || (E.add(v), (c = SI.bind(null, c, f, v)), f.then(c, c));
  }
  function nS(c) {
    do {
      var f;
      if (
        ((f = c.tag === 13) &&
          ((f = c.memoizedState),
          (f = f !== null ? f.dehydrated !== null : !0)),
        f)
      )
        return c;
      c = c.return;
    } while (c !== null);
    return null;
  }
  function iS(c, f, v, M, E) {
    return c.mode & 1
      ? ((c.flags |= 65536), (c.lanes = E), c)
      : (c === f
          ? (c.flags |= 65536)
          : ((c.flags |= 128),
            (v.flags |= 131072),
            (v.flags &= -52805),
            v.tag === 1 &&
              (v.alternate === null
                ? (v.tag = 17)
                : ((f = vs(-1, 1)), (f.tag = 2), so(v, f))),
            (v.lanes |= 1)),
        c);
  }
  function es(c) {
    c.flags |= 4;
  }
  function rS(c, f) {
    if (c !== null && c.child === f.child) return !0;
    if (f.flags & 16) return !1;
    for (c = f.child; c !== null; ) {
      if (c.flags & 12854 || c.subtreeFlags & 12854) return !1;
      c = c.sibling;
    }
    return !0;
  }
  var Cu, Tu, _d, Ad;
  if (Se)
    ((Cu = function (c, f) {
      for (var v = f.child; v !== null; ) {
        if (v.tag === 5 || v.tag === 6) Q(c, v.stateNode);
        else if (v.tag !== 4 && v.child !== null) {
          ((v.child.return = v), (v = v.child));
          continue;
        }
        if (v === f) break;
        for (; v.sibling === null; ) {
          if (v.return === null || v.return === f) return;
          v = v.return;
        }
        ((v.sibling.return = v.return), (v = v.sibling));
      }
    }),
      (Tu = function () {}),
      (_d = function (c, f, v, M, E) {
        if (((c = c.memoizedProps), c !== M)) {
          var T = f.stateNode,
            k = qr(rr.current);
          ((v = ne(T, v, c, M, E, k)), (f.updateQueue = v) && es(f));
        }
      }),
      (Ad = function (c, f, v, M) {
        v !== M && es(f);
      }));
  else if (ge) {
    Cu = function (c, f, v, M) {
      for (var E = f.child; E !== null; ) {
        if (E.tag === 5) {
          var T = E.stateNode;
          (v && M && (T = Qt(T, E.type, E.memoizedProps, E)), Q(c, T));
        } else if (E.tag === 6)
          ((T = E.stateNode),
            v && M && (T = ci(T, E.memoizedProps, E)),
            Q(c, T));
        else if (E.tag !== 4) {
          if (E.tag === 22 && E.memoizedState !== null)
            ((T = E.child), T !== null && (T.return = E), Cu(c, E, !0, !0));
          else if (E.child !== null) {
            ((E.child.return = E), (E = E.child));
            continue;
          }
        }
        if (E === f) break;
        for (; E.sibling === null; ) {
          if (E.return === null || E.return === f) return;
          E = E.return;
        }
        ((E.sibling.return = E.return), (E = E.sibling));
      }
    };
    var sS = function (c, f, v, M) {
      for (var E = f.child; E !== null; ) {
        if (E.tag === 5) {
          var T = E.stateNode;
          (v && M && (T = Qt(T, E.type, E.memoizedProps, E)), Wt(c, T));
        } else if (E.tag === 6)
          ((T = E.stateNode),
            v && M && (T = ci(T, E.memoizedProps, E)),
            Wt(c, T));
        else if (E.tag !== 4) {
          if (E.tag === 22 && E.memoizedState !== null)
            ((T = E.child), T !== null && (T.return = E), sS(c, E, !0, !0));
          else if (E.child !== null) {
            ((E.child.return = E), (E = E.child));
            continue;
          }
        }
        if (E === f) break;
        for (; E.sibling === null; ) {
          if (E.return === null || E.return === f) return;
          E = E.return;
        }
        ((E.sibling.return = E.return), (E = E.sibling));
      }
    };
    ((Tu = function (c, f) {
      var v = f.stateNode;
      if (!rS(c, f)) {
        c = v.containerInfo;
        var M = zt(c);
        (sS(M, f, !1, !1), (v.pendingChildren = M), es(f), In(c, M));
      }
    }),
      (_d = function (c, f, v, M, E) {
        var T = c.stateNode,
          k = c.memoizedProps;
        if ((c = rS(c, f)) && k === M) f.stateNode = T;
        else {
          var Y = f.stateNode,
            he = qr(rr.current),
            Be = null;
          (k !== M && (Be = ne(Y, v, k, M, E, he)),
            c && Be === null
              ? (f.stateNode = T)
              : ((T = Qe(T, Be, v, k, M, f, c, Y)),
                ee(T, v, M, E, he) && es(f),
                (f.stateNode = T),
                c ? es(f) : Cu(T, f, !1, !1)));
        }
      }),
      (Ad = function (c, f, v, M) {
        v !== M
          ? ((c = qr(Tl.current)),
            (v = qr(rr.current)),
            (f.stateNode = Ae(M, c, v, f)),
            es(f))
          : (f.stateNode = c.stateNode);
      }));
  } else ((Tu = function () {}), (_d = function () {}), (Ad = function () {}));
  function bu(c, f) {
    if (!Zt)
      switch (c.tailMode) {
        case "hidden":
          f = c.tail;
          for (var v = null; f !== null; )
            (f.alternate !== null && (v = f), (f = f.sibling));
          v === null ? (c.tail = null) : (v.sibling = null);
          break;
        case "collapsed":
          v = c.tail;
          for (var M = null; v !== null; )
            (v.alternate !== null && (M = v), (v = v.sibling));
          M === null
            ? f || c.tail === null
              ? (c.tail = null)
              : (c.tail.sibling = null)
            : (M.sibling = null);
      }
  }
  function $n(c) {
    var f = c.alternate !== null && c.alternate.child === c.child,
      v = 0,
      M = 0;
    if (f)
      for (var E = c.child; E !== null; )
        ((v |= E.lanes | E.childLanes),
          (M |= E.subtreeFlags & 14680064),
          (M |= E.flags & 14680064),
          (E.return = c),
          (E = E.sibling));
    else
      for (E = c.child; E !== null; )
        ((v |= E.lanes | E.childLanes),
          (M |= E.subtreeFlags),
          (M |= E.flags),
          (E.return = c),
          (E = E.sibling));
    return ((c.subtreeFlags |= M), (c.childLanes = v), f);
  }
  function uI(c, f, v) {
    var M = f.pendingProps;
    switch ((A0(f), f.tag)) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return ($n(f), null);
      case 1:
        return (Hn(f.type) && Qh(), $n(f), null);
      case 3:
        return (
          (M = f.stateNode),
          bl(),
          Nt(Gt),
          Nt(xn),
          b0(),
          M.pendingContext &&
            ((M.context = M.pendingContext), (M.pendingContext = null)),
          (c === null || c.child === null) &&
            (yu(f)
              ? es(f)
              : c === null ||
                (c.memoizedState.isDehydrated && !(f.flags & 256)) ||
                ((f.flags |= 1024), Tr !== null && (iv(Tr), (Tr = null)))),
          Tu(c, f),
          $n(f),
          null
        );
      case 5:
        (C0(f), (v = qr(Tl.current)));
        var E = f.type;
        if (c !== null && f.stateNode != null)
          (_d(c, f, E, M, v),
            c.ref !== f.ref && ((f.flags |= 512), (f.flags |= 2097152)));
        else {
          if (!M) {
            if (f.stateNode === null) throw Error(o(166));
            return ($n(f), null);
          }
          if (((c = qr(rr.current)), yu(f))) {
            if (!se) throw Error(o(175));
            ((c = ye(f.stateNode, f.type, f.memoizedProps, v, c, f, !vu)),
              (f.updateQueue = c),
              c !== null && es(f));
          } else {
            var T = q(E, M, v, c, f);
            (Cu(T, f, !1, !1), (f.stateNode = T), ee(T, E, M, v, c) && es(f));
          }
          f.ref !== null && ((f.flags |= 512), (f.flags |= 2097152));
        }
        return ($n(f), null);
      case 6:
        if (c && f.stateNode != null) Ad(c, f, c.memoizedProps, M);
        else {
          if (typeof M != "string" && f.stateNode === null) throw Error(o(166));
          if (((c = qr(Tl.current)), (v = qr(rr.current)), yu(f))) {
            if (!se) throw Error(o(176));
            if (
              ((c = f.stateNode),
              (M = f.memoizedProps),
              (v = $e(c, M, f, !vu)) && ((E = Ni), E !== null))
            )
              switch (((T = (E.mode & 1) !== 0), E.tag)) {
                case 3:
                  Gn(E.stateNode.containerInfo, c, M, T);
                  break;
                case 5:
                  Fi(E.type, E.memoizedProps, E.stateNode, c, M, T);
              }
            v && es(f);
          } else f.stateNode = Ae(M, c, v, f);
        }
        return ($n(f), null);
      case 13:
        if (
          (Nt(tn),
          (M = f.memoizedState),
          Zt && ki !== null && f.mode & 1 && !(f.flags & 128))
        ) {
          for (c = ki; c; ) c = N(c);
          return (El(), (f.flags |= 98560), f);
        }
        if (M !== null && M.dehydrated !== null) {
          if (((M = yu(f)), c === null)) {
            if (!M) throw Error(o(318));
            if (!se) throw Error(o(344));
            if (
              ((c = f.memoizedState),
              (c = c !== null ? c.dehydrated : null),
              !c)
            )
              throw Error(o(317));
            st(c, f);
          } else
            (El(),
              !(f.flags & 128) && (f.memoizedState = null),
              (f.flags |= 4));
          return ($n(f), null);
        }
        return (
          Tr !== null && (iv(Tr), (Tr = null)),
          f.flags & 128
            ? ((f.lanes = v), f)
            : ((M = M !== null),
              (v = !1),
              c === null ? yu(f) : (v = c.memoizedState !== null),
              M &&
                !v &&
                ((f.child.flags |= 8192),
                f.mode & 1 &&
                  (c === null || tn.current & 1 ? Cn === 0 && (Cn = 3) : sv())),
              f.updateQueue !== null && (f.flags |= 4),
              $n(f),
              null)
        );
      case 4:
        return (
          bl(),
          Tu(c, f),
          c === null && Ne(f.stateNode.containerInfo),
          $n(f),
          null
        );
      case 10:
        return (m0(f.type._context), $n(f), null);
      case 17:
        return (Hn(f.type) && Qh(), $n(f), null);
      case 19:
        if ((Nt(tn), (E = f.memoizedState), E === null)) return ($n(f), null);
        if (((M = (f.flags & 128) !== 0), (T = E.rendering), T === null))
          if (M) bu(E, !1);
          else {
            if (Cn !== 0 || (c !== null && c.flags & 128))
              for (c = f.child; c !== null; ) {
                if (((T = hd(c)), T !== null)) {
                  for (
                    f.flags |= 128,
                      bu(E, !1),
                      c = T.updateQueue,
                      c !== null && ((f.updateQueue = c), (f.flags |= 4)),
                      f.subtreeFlags = 0,
                      c = v,
                      M = f.child;
                    M !== null;

                  )
                    ((v = M),
                      (E = c),
                      (v.flags &= 14680066),
                      (T = v.alternate),
                      T === null
                        ? ((v.childLanes = 0),
                          (v.lanes = E),
                          (v.child = null),
                          (v.subtreeFlags = 0),
                          (v.memoizedProps = null),
                          (v.memoizedState = null),
                          (v.updateQueue = null),
                          (v.dependencies = null),
                          (v.stateNode = null))
                        : ((v.childLanes = T.childLanes),
                          (v.lanes = T.lanes),
                          (v.child = T.child),
                          (v.subtreeFlags = 0),
                          (v.deletions = null),
                          (v.memoizedProps = T.memoizedProps),
                          (v.memoizedState = T.memoizedState),
                          (v.updateQueue = T.updateQueue),
                          (v.type = T.type),
                          (E = T.dependencies),
                          (v.dependencies =
                            E === null
                              ? null
                              : {
                                  lanes: E.lanes,
                                  firstContext: E.firstContext,
                                })),
                      (M = M.sibling));
                  return (pt(tn, (tn.current & 1) | 2), f.child);
                }
                c = c.sibling;
              }
            E.tail !== null &&
              Dn() > $0 &&
              ((f.flags |= 128), (M = !0), bu(E, !1), (f.lanes = 4194304));
          }
        else {
          if (!M)
            if (((c = hd(T)), c !== null)) {
              if (
                ((f.flags |= 128),
                (M = !0),
                (c = c.updateQueue),
                c !== null && ((f.updateQueue = c), (f.flags |= 4)),
                bu(E, !0),
                E.tail === null &&
                  E.tailMode === "hidden" &&
                  !T.alternate &&
                  !Zt)
              )
                return ($n(f), null);
            } else
              2 * Dn() - E.renderingStartTime > $0 &&
                v !== 1073741824 &&
                ((f.flags |= 128), (M = !0), bu(E, !1), (f.lanes = 4194304));
          E.isBackwards
            ? ((T.sibling = f.child), (f.child = T))
            : ((c = E.last),
              c !== null ? (c.sibling = T) : (f.child = T),
              (E.last = T));
        }
        return E.tail !== null
          ? ((f = E.tail),
            (E.rendering = f),
            (E.tail = f.sibling),
            (E.renderingStartTime = Dn()),
            (f.sibling = null),
            (c = tn.current),
            pt(tn, M ? (c & 1) | 2 : c & 1),
            f)
          : ($n(f), null);
      case 22:
      case 23:
        return (
          rv(),
          (M = f.memoizedState !== null),
          c !== null && (c.memoizedState !== null) !== M && (f.flags |= 8192),
          M && f.mode & 1
            ? Ui & 1073741824 &&
              ($n(f), Se && f.subtreeFlags & 6 && (f.flags |= 8192))
            : $n(f),
          null
        );
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(o(156, f.tag));
  }
  var fI = a.ReactCurrentOwner,
    Oi = !1;
  function ui(c, f, v, M) {
    f.child = c === null ? IM(f, null, v, M) : Cl(f, c.child, v, M);
  }
  function oS(c, f, v, M, E) {
    v = v.render;
    var T = f.ref;
    return (
      Ml(f, E),
      (M = B0(c, f, v, M, T, E)),
      (v = R0()),
      c !== null && !Oi
        ? ((f.updateQueue = c.updateQueue),
          (f.flags &= -2053),
          (c.lanes &= ~E),
          As(c, f, E))
        : (Zt && v && _0(f), (f.flags |= 1), ui(c, f, M, E), f.child)
    );
  }
  function aS(c, f, v, M, E) {
    if (c === null) {
      var T = v.type;
      return typeof T == "function" &&
        !ov(T) &&
        T.defaultProps === void 0 &&
        v.compare === null &&
        v.defaultProps === void 0
        ? ((f.tag = 15), (f.type = T), lS(c, f, T, M, E))
        : ((c = Hd(v.type, null, M, f, f.mode, E)),
          (c.ref = f.ref),
          (c.return = f),
          (f.child = c));
    }
    if (((T = c.child), !(c.lanes & E))) {
      var k = T.memoizedProps;
      if (
        ((v = v.compare), (v = v !== null ? v : id), v(k, M) && c.ref === f.ref)
      )
        return As(c, f, E);
    }
    return (
      (f.flags |= 1),
      (c = uo(T, M)),
      (c.ref = f.ref),
      (c.return = f),
      (f.child = c)
    );
  }
  function lS(c, f, v, M, E) {
    if (c !== null && id(c.memoizedProps, M) && c.ref === f.ref)
      if (((Oi = !1), (c.lanes & E) !== 0)) c.flags & 131072 && (Oi = !0);
      else return ((f.lanes = c.lanes), As(c, f, E));
    return k0(c, f, v, M, E);
  }
  function cS(c, f, v) {
    var M = f.pendingProps,
      E = M.children,
      T = c !== null ? c.memoizedState : null;
    if (M.mode === "hidden")
      if (!(f.mode & 1))
        ((f.memoizedState = { baseLanes: 0, cachePool: null }),
          pt(Bl, Ui),
          (Ui |= v));
      else if (v & 1073741824)
        ((f.memoizedState = { baseLanes: 0, cachePool: null }),
          (M = T !== null ? T.baseLanes : v),
          pt(Bl, Ui),
          (Ui |= M));
      else
        return (
          (c = T !== null ? T.baseLanes | v : v),
          (f.lanes = f.childLanes = 1073741824),
          (f.memoizedState = { baseLanes: c, cachePool: null }),
          (f.updateQueue = null),
          pt(Bl, Ui),
          (Ui |= c),
          null
        );
    else
      (T !== null ? ((M = T.baseLanes | v), (f.memoizedState = null)) : (M = v),
        pt(Bl, Ui),
        (Ui |= M));
    return (ui(c, f, E, v), f.child);
  }
  function uS(c, f) {
    var v = f.ref;
    ((c === null && v !== null) || (c !== null && c.ref !== v)) &&
      ((f.flags |= 512), (f.flags |= 2097152));
  }
  function k0(c, f, v, M, E) {
    var T = Hn(v) ? wr : xn.current;
    return (
      (T = io(f, T)),
      Ml(f, E),
      (v = B0(c, f, v, M, T, E)),
      (M = R0()),
      c !== null && !Oi
        ? ((f.updateQueue = c.updateQueue),
          (f.flags &= -2053),
          (c.lanes &= ~E),
          As(c, f, E))
        : (Zt && M && _0(f), (f.flags |= 1), ui(c, f, v, E), f.child)
    );
  }
  function fS(c, f, v, M, E) {
    if (Hn(v)) {
      var T = !0;
      Zh(f);
    } else T = !1;
    if ((Ml(f, E), f.stateNode === null))
      (c !== null &&
        ((c.alternate = null), (f.alternate = null), (f.flags |= 2)),
        EM(f, v, M),
        x0(f, v, M, E),
        (M = !0));
    else if (c === null) {
      var k = f.stateNode,
        Y = f.memoizedProps;
      k.props = Y;
      var he = k.context,
        Be = v.contextType;
      typeof Be == "object" && Be !== null
        ? (Be = tr(Be))
        : ((Be = Hn(v) ? wr : xn.current), (Be = io(f, Be)));
      var Ge = v.getDerivedStateFromProps,
        lt =
          typeof Ge == "function" ||
          typeof k.getSnapshotBeforeUpdate == "function";
      (lt ||
        (typeof k.UNSAFE_componentWillReceiveProps != "function" &&
          typeof k.componentWillReceiveProps != "function") ||
        ((Y !== M || he !== Be) && CM(f, k, M, Be)),
        (ro = !1));
      var tt = f.memoizedState;
      ((k.state = tt),
        ad(f, M, k, E),
        (he = f.memoizedState),
        Y !== M || tt !== he || Gt.current || ro
          ? (typeof Ge == "function" &&
              (y0(f, v, Ge, M), (he = f.memoizedState)),
            (Y = ro || wM(f, v, Y, M, tt, he, Be))
              ? (lt ||
                  (typeof k.UNSAFE_componentWillMount != "function" &&
                    typeof k.componentWillMount != "function") ||
                  (typeof k.componentWillMount == "function" &&
                    k.componentWillMount(),
                  typeof k.UNSAFE_componentWillMount == "function" &&
                    k.UNSAFE_componentWillMount()),
                typeof k.componentDidMount == "function" &&
                  (f.flags |= 4194308))
              : (typeof k.componentDidMount == "function" &&
                  (f.flags |= 4194308),
                (f.memoizedProps = M),
                (f.memoizedState = he)),
            (k.props = M),
            (k.state = he),
            (k.context = Be),
            (M = Y))
          : (typeof k.componentDidMount == "function" && (f.flags |= 4194308),
            (M = !1)));
    } else {
      ((k = f.stateNode),
        _M(c, f),
        (Y = f.memoizedProps),
        (Be = f.type === f.elementType ? Y : Cr(f.type, Y)),
        (k.props = Be),
        (lt = f.pendingProps),
        (tt = k.context),
        (he = v.contextType),
        typeof he == "object" && he !== null
          ? (he = tr(he))
          : ((he = Hn(v) ? wr : xn.current), (he = io(f, he))));
      var Ht = v.getDerivedStateFromProps;
      ((Ge =
        typeof Ht == "function" ||
        typeof k.getSnapshotBeforeUpdate == "function") ||
        (typeof k.UNSAFE_componentWillReceiveProps != "function" &&
          typeof k.componentWillReceiveProps != "function") ||
        ((Y !== lt || tt !== he) && CM(f, k, M, he)),
        (ro = !1),
        (tt = f.memoizedState),
        (k.state = tt),
        ad(f, M, k, E));
      var Ze = f.memoizedState;
      Y !== lt || tt !== Ze || Gt.current || ro
        ? (typeof Ht == "function" && (y0(f, v, Ht, M), (Ze = f.memoizedState)),
          (Be = ro || wM(f, v, Be, M, tt, Ze, he) || !1)
            ? (Ge ||
                (typeof k.UNSAFE_componentWillUpdate != "function" &&
                  typeof k.componentWillUpdate != "function") ||
                (typeof k.componentWillUpdate == "function" &&
                  k.componentWillUpdate(M, Ze, he),
                typeof k.UNSAFE_componentWillUpdate == "function" &&
                  k.UNSAFE_componentWillUpdate(M, Ze, he)),
              typeof k.componentDidUpdate == "function" && (f.flags |= 4),
              typeof k.getSnapshotBeforeUpdate == "function" &&
                (f.flags |= 1024))
            : (typeof k.componentDidUpdate != "function" ||
                (Y === c.memoizedProps && tt === c.memoizedState) ||
                (f.flags |= 4),
              typeof k.getSnapshotBeforeUpdate != "function" ||
                (Y === c.memoizedProps && tt === c.memoizedState) ||
                (f.flags |= 1024),
              (f.memoizedProps = M),
              (f.memoizedState = Ze)),
          (k.props = M),
          (k.state = Ze),
          (k.context = he),
          (M = Be))
        : (typeof k.componentDidUpdate != "function" ||
            (Y === c.memoizedProps && tt === c.memoizedState) ||
            (f.flags |= 4),
          typeof k.getSnapshotBeforeUpdate != "function" ||
            (Y === c.memoizedProps && tt === c.memoizedState) ||
            (f.flags |= 1024),
          (M = !1));
    }
    return O0(c, f, v, M, T, E);
  }
  function O0(c, f, v, M, E, T) {
    uS(c, f);
    var k = (f.flags & 128) !== 0;
    if (!M && !k) return (E && mM(f, v, !1), As(c, f, T));
    ((M = f.stateNode), (fI.current = f));
    var Y =
      k && typeof v.getDerivedStateFromError != "function" ? null : M.render();
    return (
      (f.flags |= 1),
      c !== null && k
        ? ((f.child = Cl(f, c.child, null, T)), (f.child = Cl(f, null, Y, T)))
        : ui(c, f, Y, T),
      (f.memoizedState = M.state),
      E && mM(f, v, !0),
      f.child
    );
  }
  function hS(c) {
    var f = c.stateNode;
    (f.pendingContext
      ? dM(c, f.pendingContext, f.pendingContext !== f.context)
      : f.context && dM(c, f.context, !1),
      E0(c, f.containerInfo));
  }
  function dS(c, f, v, M, E) {
    return (El(), w0(E), (f.flags |= 256), ui(c, f, v, M), f.child);
  }
  var Md = { dehydrated: null, treeContext: null, retryLane: 0 };
  function Sd(c) {
    return { baseLanes: c, cachePool: null };
  }
  function pS(c, f, v) {
    var M = f.pendingProps,
      E = tn.current,
      T = !1,
      k = (f.flags & 128) !== 0,
      Y;
    if (
      ((Y = k) ||
        (Y = c !== null && c.memoizedState === null ? !1 : (E & 2) !== 0),
      Y
        ? ((T = !0), (f.flags &= -129))
        : (c === null || c.memoizedState !== null) && (E |= 1),
      pt(tn, E & 1),
      c === null)
    )
      return (
        S0(f),
        (c = f.memoizedState),
        c !== null && ((c = c.dehydrated), c !== null)
          ? (f.mode & 1
              ? pu(c)
                ? (f.lanes = 8)
                : (f.lanes = 1073741824)
              : (f.lanes = 1),
            null)
          : ((E = M.children),
            (c = M.fallback),
            T
              ? ((M = f.mode),
                (T = f.child),
                (E = { mode: "hidden", children: E }),
                !(M & 1) && T !== null
                  ? ((T.childLanes = 0), (T.pendingProps = E))
                  : (T = Vd(E, M, 0, null)),
                (c = ma(c, M, v, null)),
                (T.return = f),
                (c.return = f),
                (T.sibling = c),
                (f.child = T),
                (f.child.memoizedState = Sd(v)),
                (f.memoizedState = Md),
                c)
              : U0(f, E))
      );
    if (((E = c.memoizedState), E !== null)) {
      if (((Y = E.dehydrated), Y !== null)) {
        if (k)
          return f.flags & 256
            ? ((f.flags &= -257), wd(c, f, v, Error(o(422))))
            : f.memoizedState !== null
              ? ((f.child = c.child), (f.flags |= 128), null)
              : ((T = M.fallback),
                (E = f.mode),
                (M = Vd({ mode: "visible", children: M.children }, E, 0, null)),
                (T = ma(T, E, v, null)),
                (T.flags |= 2),
                (M.return = f),
                (T.return = f),
                (M.sibling = T),
                (f.child = M),
                f.mode & 1 && Cl(f, c.child, null, v),
                (f.child.memoizedState = Sd(v)),
                (f.memoizedState = Md),
                T);
        if (!(f.mode & 1)) f = wd(c, f, v, null);
        else if (pu(Y)) f = wd(c, f, v, Error(o(419)));
        else if (((M = (v & c.childLanes) !== 0), Oi || M)) {
          if (((M = _n), M !== null)) {
            switch (v & -v) {
              case 4:
                T = 2;
                break;
              case 16:
                T = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                T = 32;
                break;
              case 536870912:
                T = 268435456;
                break;
              default:
                T = 0;
            }
            ((M = T & (M.suspendedLanes | v) ? 0 : T),
              M !== 0 &&
                M !== E.retryLane &&
                ((E.retryLane = M), or(c, M, -1)));
          }
          (sv(), (f = wd(c, f, v, Error(o(421)))));
        } else
          Yh(Y)
            ? ((f.flags |= 128),
              (f.child = c.child),
              (f = wI.bind(null, c)),
              s0(Y, f),
              (f = null))
            : ((v = E.treeContext),
              se &&
                ((ki = te(Y)),
                (Ni = f),
                (Zt = !0),
                (Tr = null),
                (vu = !1),
                v !== null &&
                  ((nr[ir++] = ys),
                  (nr[ir++] = xs),
                  (nr[ir++] = aa),
                  (ys = v.id),
                  (xs = v.overflow),
                  (aa = f))),
              (f = U0(f, f.pendingProps.children)),
              (f.flags |= 4096));
        return f;
      }
      return T
        ? ((M = gS(c, f, M.children, M.fallback, v)),
          (T = f.child),
          (E = c.child.memoizedState),
          (T.memoizedState =
            E === null
              ? Sd(v)
              : { baseLanes: E.baseLanes | v, cachePool: null }),
          (T.childLanes = c.childLanes & ~v),
          (f.memoizedState = Md),
          M)
        : ((v = mS(c, f, M.children, v)), (f.memoizedState = null), v);
    }
    return T
      ? ((M = gS(c, f, M.children, M.fallback, v)),
        (T = f.child),
        (E = c.child.memoizedState),
        (T.memoizedState =
          E === null ? Sd(v) : { baseLanes: E.baseLanes | v, cachePool: null }),
        (T.childLanes = c.childLanes & ~v),
        (f.memoizedState = Md),
        M)
      : ((v = mS(c, f, M.children, v)), (f.memoizedState = null), v);
  }
  function U0(c, f) {
    return (
      (f = Vd({ mode: "visible", children: f }, c.mode, 0, null)),
      (f.return = c),
      (c.child = f)
    );
  }
  function mS(c, f, v, M) {
    var E = c.child;
    return (
      (c = E.sibling),
      (v = uo(E, { mode: "visible", children: v })),
      !(f.mode & 1) && (v.lanes = M),
      (v.return = f),
      (v.sibling = null),
      c !== null &&
        ((M = f.deletions),
        M === null ? ((f.deletions = [c]), (f.flags |= 16)) : M.push(c)),
      (f.child = v)
    );
  }
  function gS(c, f, v, M, E) {
    var T = f.mode;
    c = c.child;
    var k = c.sibling,
      Y = { mode: "hidden", children: v };
    return (
      !(T & 1) && f.child !== c
        ? ((v = f.child),
          (v.childLanes = 0),
          (v.pendingProps = Y),
          (f.deletions = null))
        : ((v = uo(c, Y)), (v.subtreeFlags = c.subtreeFlags & 14680064)),
      k !== null ? (M = uo(k, M)) : ((M = ma(M, T, E, null)), (M.flags |= 2)),
      (M.return = f),
      (v.return = f),
      (v.sibling = M),
      (f.child = v),
      M
    );
  }
  function wd(c, f, v, M) {
    return (
      M !== null && w0(M),
      Cl(f, c.child, null, v),
      (c = U0(f, f.pendingProps.children)),
      (c.flags |= 2),
      (f.memoizedState = null),
      c
    );
  }
  function vS(c, f, v) {
    c.lanes |= f;
    var M = c.alternate;
    (M !== null && (M.lanes |= f), g0(c.return, f, v));
  }
  function z0(c, f, v, M, E) {
    var T = c.memoizedState;
    T === null
      ? (c.memoizedState = {
          isBackwards: f,
          rendering: null,
          renderingStartTime: 0,
          last: M,
          tail: v,
          tailMode: E,
        })
      : ((T.isBackwards = f),
        (T.rendering = null),
        (T.renderingStartTime = 0),
        (T.last = M),
        (T.tail = v),
        (T.tailMode = E));
  }
  function yS(c, f, v) {
    var M = f.pendingProps,
      E = M.revealOrder,
      T = M.tail;
    if ((ui(c, f, M.children, v), (M = tn.current), M & 2))
      ((M = (M & 1) | 2), (f.flags |= 128));
    else {
      if (c !== null && c.flags & 128)
        e: for (c = f.child; c !== null; ) {
          if (c.tag === 13) c.memoizedState !== null && vS(c, v, f);
          else if (c.tag === 19) vS(c, v, f);
          else if (c.child !== null) {
            ((c.child.return = c), (c = c.child));
            continue;
          }
          if (c === f) break e;
          for (; c.sibling === null; ) {
            if (c.return === null || c.return === f) break e;
            c = c.return;
          }
          ((c.sibling.return = c.return), (c = c.sibling));
        }
      M &= 1;
    }
    if ((pt(tn, M), !(f.mode & 1))) f.memoizedState = null;
    else
      switch (E) {
        case "forwards":
          for (v = f.child, E = null; v !== null; )
            ((c = v.alternate),
              c !== null && hd(c) === null && (E = v),
              (v = v.sibling));
          ((v = E),
            v === null
              ? ((E = f.child), (f.child = null))
              : ((E = v.sibling), (v.sibling = null)),
            z0(f, !1, E, v, T));
          break;
        case "backwards":
          for (v = null, E = f.child, f.child = null; E !== null; ) {
            if (((c = E.alternate), c !== null && hd(c) === null)) {
              f.child = E;
              break;
            }
            ((c = E.sibling), (E.sibling = v), (v = E), (E = c));
          }
          z0(f, !0, v, null, T);
          break;
        case "together":
          z0(f, !1, null, null, void 0);
          break;
        default:
          f.memoizedState = null;
      }
    return f.child;
  }
  function As(c, f, v) {
    if (
      (c !== null && (f.dependencies = c.dependencies),
      (Rl |= f.lanes),
      !(v & f.childLanes))
    )
      return null;
    if (c !== null && f.child !== c.child) throw Error(o(153));
    if (f.child !== null) {
      for (
        c = f.child, v = uo(c, c.pendingProps), f.child = v, v.return = f;
        c.sibling !== null;

      )
        ((c = c.sibling),
          (v = v.sibling = uo(c, c.pendingProps)),
          (v.return = f));
      v.sibling = null;
    }
    return f.child;
  }
  function hI(c, f, v) {
    switch (f.tag) {
      case 3:
        (hS(f), El());
        break;
      case 5:
        DM(f);
        break;
      case 1:
        Hn(f.type) && Zh(f);
        break;
      case 4:
        E0(f, f.stateNode.containerInfo);
        break;
      case 10:
        xM(f, f.type._context, f.memoizedProps.value);
        break;
      case 13:
        var M = f.memoizedState;
        if (M !== null)
          return M.dehydrated !== null
            ? (pt(tn, tn.current & 1), (f.flags |= 128), null)
            : v & f.child.childLanes
              ? pS(c, f, v)
              : (pt(tn, tn.current & 1),
                (c = As(c, f, v)),
                c !== null ? c.sibling : null);
        pt(tn, tn.current & 1);
        break;
      case 19:
        if (((M = (v & f.childLanes) !== 0), c.flags & 128)) {
          if (M) return yS(c, f, v);
          f.flags |= 128;
        }
        var E = f.memoizedState;
        if (
          (E !== null &&
            ((E.rendering = null), (E.tail = null), (E.lastEffect = null)),
          pt(tn, tn.current),
          M)
        )
          break;
        return null;
      case 22:
      case 23:
        return ((f.lanes = 0), cS(c, f, v));
    }
    return As(c, f, v);
  }
  function dI(c, f) {
    switch ((A0(f), f.tag)) {
      case 1:
        return (
          Hn(f.type) && Qh(),
          (c = f.flags),
          c & 65536 ? ((f.flags = (c & -65537) | 128), f) : null
        );
      case 3:
        return (
          bl(),
          Nt(Gt),
          Nt(xn),
          b0(),
          (c = f.flags),
          c & 65536 && !(c & 128) ? ((f.flags = (c & -65537) | 128), f) : null
        );
      case 5:
        return (C0(f), null);
      case 13:
        if (
          (Nt(tn), (c = f.memoizedState), c !== null && c.dehydrated !== null)
        ) {
          if (f.alternate === null) throw Error(o(340));
          El();
        }
        return (
          (c = f.flags),
          c & 65536 ? ((f.flags = (c & -65537) | 128), f) : null
        );
      case 19:
        return (Nt(tn), null);
      case 4:
        return (bl(), null);
      case 10:
        return (m0(f.type._context), null);
      case 22:
      case 23:
        return (rv(), null);
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Ed = !1,
    ua = !1,
    pI = typeof WeakSet == "function" ? WeakSet : Set,
    Fe = null;
  function Cd(c, f) {
    var v = c.ref;
    if (v !== null)
      if (typeof v == "function")
        try {
          v(null);
        } catch (M) {
          wi(c, f, M);
        }
      else v.current = null;
  }
  function G0(c, f, v) {
    try {
      v();
    } catch (M) {
      wi(c, f, M);
    }
  }
  var xS = !1;
  function mI(c, f) {
    for (G(c.containerInfo), Fe = f; Fe !== null; )
      if (
        ((c = Fe), (f = c.child), (c.subtreeFlags & 1028) !== 0 && f !== null)
      )
        ((f.return = c), (Fe = f));
      else
        for (; Fe !== null; ) {
          c = Fe;
          try {
            var v = c.alternate;
            if (c.flags & 1024)
              switch (c.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (v !== null) {
                    var M = v.memoizedProps,
                      E = v.memoizedState,
                      T = c.stateNode,
                      k = T.getSnapshotBeforeUpdate(
                        c.elementType === c.type ? M : Cr(c.type, M),
                        E
                      );
                    T.__reactInternalSnapshotBeforeUpdate = k;
                  }
                  break;
                case 3:
                  Se && Oe(c.stateNode.containerInfo);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(o(163));
              }
          } catch (Y) {
            wi(c, c.return, Y);
          }
          if (((f = c.sibling), f !== null)) {
            ((f.return = c.return), (Fe = f));
            break;
          }
          Fe = c.return;
        }
    return ((v = xS), (xS = !1), v);
  }
  function fa(c, f, v) {
    var M = f.updateQueue;
    if (((M = M !== null ? M.lastEffect : null), M !== null)) {
      var E = (M = M.next);
      do {
        if ((E.tag & c) === c) {
          var T = E.destroy;
          ((E.destroy = void 0), T !== void 0 && G0(f, v, T));
        }
        E = E.next;
      } while (E !== M);
    }
  }
  function Pu(c, f) {
    if (
      ((f = f.updateQueue), (f = f !== null ? f.lastEffect : null), f !== null)
    ) {
      var v = (f = f.next);
      do {
        if ((v.tag & c) === c) {
          var M = v.create;
          v.destroy = M();
        }
        v = v.next;
      } while (v !== f);
    }
  }
  function H0(c) {
    var f = c.ref;
    if (f !== null) {
      var v = c.stateNode;
      switch (c.tag) {
        case 5:
          c = oe(v);
          break;
        default:
          c = v;
      }
      typeof f == "function" ? f(c) : (f.current = c);
    }
  }
  function _S(c, f, v) {
    if (Kr && typeof Kr.onCommitFiberUnmount == "function")
      try {
        Kr.onCommitFiberUnmount(td, f);
      } catch {}
    switch (f.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (
          ((c = f.updateQueue), c !== null && ((c = c.lastEffect), c !== null))
        ) {
          var M = (c = c.next);
          do {
            var E = M,
              T = E.destroy;
            ((E = E.tag),
              T !== void 0 && (E & 2 || E & 4) && G0(f, v, T),
              (M = M.next));
          } while (M !== c);
        }
        break;
      case 1:
        if (
          (Cd(f, v),
          (c = f.stateNode),
          typeof c.componentWillUnmount == "function")
        )
          try {
            ((c.props = f.memoizedProps),
              (c.state = f.memoizedState),
              c.componentWillUnmount());
          } catch (k) {
            wi(f, v, k);
          }
        break;
      case 5:
        Cd(f, v);
        break;
      case 4:
        Se
          ? CS(c, f, v)
          : ge &&
            ge &&
            ((f = f.stateNode.containerInfo), (v = zt(f)), Ar(f, v));
    }
  }
  function AS(c, f, v) {
    for (var M = f; ; )
      if ((_S(c, M, v), M.child === null || (Se && M.tag === 4))) {
        if (M === f) break;
        for (; M.sibling === null; ) {
          if (M.return === null || M.return === f) return;
          M = M.return;
        }
        ((M.sibling.return = M.return), (M = M.sibling));
      } else ((M.child.return = M), (M = M.child));
  }
  function MS(c) {
    var f = c.alternate;
    (f !== null && ((c.alternate = null), MS(f)),
      (c.child = null),
      (c.deletions = null),
      (c.sibling = null),
      c.tag === 5 && ((f = c.stateNode), f !== null && We(f)),
      (c.stateNode = null),
      (c.return = null),
      (c.dependencies = null),
      (c.memoizedProps = null),
      (c.memoizedState = null),
      (c.pendingProps = null),
      (c.stateNode = null),
      (c.updateQueue = null));
  }
  function SS(c) {
    return c.tag === 5 || c.tag === 3 || c.tag === 4;
  }
  function wS(c) {
    e: for (;;) {
      for (; c.sibling === null; ) {
        if (c.return === null || SS(c.return)) return null;
        c = c.return;
      }
      for (
        c.sibling.return = c.return, c = c.sibling;
        c.tag !== 5 && c.tag !== 6 && c.tag !== 18;

      ) {
        if (c.flags & 2 || c.child === null || c.tag === 4) continue e;
        ((c.child.return = c), (c = c.child));
      }
      if (!(c.flags & 2)) return c.stateNode;
    }
  }
  function ES(c) {
    if (Se) {
      e: {
        for (var f = c.return; f !== null; ) {
          if (SS(f)) break e;
          f = f.return;
        }
        throw Error(o(160));
      }
      var v = f;
      switch (v.tag) {
        case 5:
          ((f = v.stateNode),
            v.flags & 32 && (ht(f), (v.flags &= -33)),
            (v = wS(c)),
            W0(c, v, f));
          break;
        case 3:
        case 4:
          ((f = v.stateNode.containerInfo), (v = wS(c)), V0(c, v, f));
          break;
        default:
          throw Error(o(161));
      }
    }
  }
  function V0(c, f, v) {
    var M = c.tag;
    if (M === 5 || M === 6) ((c = c.stateNode), f ? Me(v, c, f) : Ue(v, c));
    else if (M !== 4 && ((c = c.child), c !== null))
      for (V0(c, f, v), c = c.sibling; c !== null; )
        (V0(c, f, v), (c = c.sibling));
  }
  function W0(c, f, v) {
    var M = c.tag;
    if (M === 5 || M === 6) ((c = c.stateNode), f ? de(v, c, f) : et(v, c));
    else if (M !== 4 && ((c = c.child), c !== null))
      for (W0(c, f, v), c = c.sibling; c !== null; )
        (W0(c, f, v), (c = c.sibling));
  }
  function CS(c, f, v) {
    for (var M = f, E = !1, T, k; ; ) {
      if (!E) {
        E = M.return;
        e: for (;;) {
          if (E === null) throw Error(o(160));
          switch (((T = E.stateNode), E.tag)) {
            case 5:
              k = !1;
              break e;
            case 3:
              ((T = T.containerInfo), (k = !0));
              break e;
            case 4:
              ((T = T.containerInfo), (k = !0));
              break e;
          }
          E = E.return;
        }
        E = !0;
      }
      if (M.tag === 5 || M.tag === 6)
        (AS(c, M, v), k ? qe(T, M.stateNode) : Pe(T, M.stateNode));
      else if (M.tag === 18) k ? Mt(T, M.stateNode) : xt(T, M.stateNode);
      else if (M.tag === 4) {
        if (M.child !== null) {
          ((T = M.stateNode.containerInfo),
            (k = !0),
            (M.child.return = M),
            (M = M.child));
          continue;
        }
      } else if ((_S(c, M, v), M.child !== null)) {
        ((M.child.return = M), (M = M.child));
        continue;
      }
      if (M === f) break;
      for (; M.sibling === null; ) {
        if (M.return === null || M.return === f) return;
        ((M = M.return), M.tag === 4 && (E = !1));
      }
      ((M.sibling.return = M.return), (M = M.sibling));
    }
  }
  function j0(c, f) {
    if (Se) {
      switch (f.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          (fa(3, f, f.return), Pu(3, f), fa(5, f, f.return));
          return;
        case 1:
          return;
        case 5:
          var v = f.stateNode;
          if (v != null) {
            var M = f.memoizedProps;
            c = c !== null ? c.memoizedProps : M;
            var E = f.type,
              T = f.updateQueue;
            ((f.updateQueue = null), T !== null && W(v, T, E, c, M, f));
          }
          return;
        case 6:
          if (f.stateNode === null) throw Error(o(162));
          ((v = f.memoizedProps),
            pe(f.stateNode, c !== null ? c.memoizedProps : v, v));
          return;
        case 3:
          se &&
            c !== null &&
            c.memoizedState.isDehydrated &&
            dt(f.stateNode.containerInfo);
          return;
        case 12:
          return;
        case 13:
          Td(f);
          return;
        case 19:
          Td(f);
          return;
        case 17:
          return;
      }
      throw Error(o(163));
    }
    switch (f.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        (fa(3, f, f.return), Pu(3, f), fa(5, f, f.return));
        return;
      case 12:
        return;
      case 13:
        Td(f);
        return;
      case 19:
        Td(f);
        return;
      case 3:
        se &&
          c !== null &&
          c.memoizedState.isDehydrated &&
          dt(f.stateNode.containerInfo);
        break;
      case 22:
      case 23:
        return;
    }
    e: if (ge) {
      switch (f.tag) {
        case 1:
        case 5:
        case 6:
          break e;
        case 3:
        case 4:
          ((f = f.stateNode), Ar(f.containerInfo, f.pendingChildren));
          break e;
      }
      throw Error(o(163));
    }
  }
  function Td(c) {
    var f = c.updateQueue;
    if (f !== null) {
      c.updateQueue = null;
      var v = c.stateNode;
      (v === null && (v = c.stateNode = new pI()),
        f.forEach(function (M) {
          var E = EI.bind(null, c, M);
          v.has(M) || (v.add(M), M.then(E, E));
        }));
    }
  }
  function gI(c, f) {
    for (Fe = f; Fe !== null; ) {
      f = Fe;
      var v = f.deletions;
      if (v !== null)
        for (var M = 0; M < v.length; M++) {
          var E = v[M];
          try {
            var T = c;
            Se ? CS(T, E, f) : AS(T, E, f);
            var k = E.alternate;
            (k !== null && (k.return = null), (E.return = null));
          } catch (Ye) {
            wi(E, f, Ye);
          }
        }
      if (((v = f.child), f.subtreeFlags & 12854 && v !== null))
        ((v.return = f), (Fe = v));
      else
        for (; Fe !== null; ) {
          f = Fe;
          try {
            var Y = f.flags;
            if ((Y & 32 && Se && ht(f.stateNode), Y & 512)) {
              var he = f.alternate;
              if (he !== null) {
                var Be = he.ref;
                Be !== null &&
                  (typeof Be == "function" ? Be(null) : (Be.current = null));
              }
            }
            if (Y & 8192)
              switch (f.tag) {
                case 13:
                  if (f.memoizedState !== null) {
                    var Ge = f.alternate;
                    (Ge === null || Ge.memoizedState === null) && (q0 = Dn());
                  }
                  break;
                case 22:
                  var lt = f.memoizedState !== null,
                    tt = f.alternate,
                    Ht = tt !== null && tt.memoizedState !== null;
                  if (((v = f), Se)) {
                    e: if (((M = v), (E = lt), (T = null), Se))
                      for (var Ze = M; ; ) {
                        if (Ze.tag === 5) {
                          if (T === null) {
                            T = Ze;
                            var ei = Ze.stateNode;
                            E ? Ut(ei) : fe(Ze.stateNode, Ze.memoizedProps);
                          }
                        } else if (Ze.tag === 6) {
                          if (T === null) {
                            var lr = Ze.stateNode;
                            E ? K(lr) : we(lr, Ze.memoizedProps);
                          }
                        } else if (
                          ((Ze.tag !== 22 && Ze.tag !== 23) ||
                            Ze.memoizedState === null ||
                            Ze === M) &&
                          Ze.child !== null
                        ) {
                          ((Ze.child.return = Ze), (Ze = Ze.child));
                          continue;
                        }
                        if (Ze === M) break;
                        for (; Ze.sibling === null; ) {
                          if (Ze.return === null || Ze.return === M) break e;
                          (T === Ze && (T = null), (Ze = Ze.return));
                        }
                        (T === Ze && (T = null),
                          (Ze.sibling.return = Ze.return),
                          (Ze = Ze.sibling));
                      }
                  }
                  if (lt && !Ht && v.mode & 1) {
                    Fe = v;
                    for (var ie = v.child; ie !== null; ) {
                      for (v = Fe = ie; Fe !== null; ) {
                        M = Fe;
                        var Z = M.child;
                        switch (M.tag) {
                          case 0:
                          case 11:
                          case 14:
                          case 15:
                            fa(4, M, M.return);
                            break;
                          case 1:
                            Cd(M, M.return);
                            var ue = M.stateNode;
                            if (typeof ue.componentWillUnmount == "function") {
                              var ke = M.return;
                              try {
                                ((ue.props = M.memoizedProps),
                                  (ue.state = M.memoizedState),
                                  ue.componentWillUnmount());
                              } catch (Ye) {
                                wi(M, ke, Ye);
                              }
                            }
                            break;
                          case 5:
                            Cd(M, M.return);
                            break;
                          case 22:
                            if (M.memoizedState !== null) {
                              PS(v);
                              continue;
                            }
                        }
                        Z !== null ? ((Z.return = M), (Fe = Z)) : PS(v);
                      }
                      ie = ie.sibling;
                    }
                  }
              }
            switch (Y & 4102) {
              case 2:
                (ES(f), (f.flags &= -3));
                break;
              case 6:
                (ES(f), (f.flags &= -3), j0(f.alternate, f));
                break;
              case 4096:
                f.flags &= -4097;
                break;
              case 4100:
                ((f.flags &= -4097), j0(f.alternate, f));
                break;
              case 4:
                j0(f.alternate, f);
            }
          } catch (Ye) {
            wi(f, f.return, Ye);
          }
          if (((v = f.sibling), v !== null)) {
            ((v.return = f.return), (Fe = v));
            break;
          }
          Fe = f.return;
        }
    }
  }
  function vI(c, f, v) {
    ((Fe = c), TS(c));
  }
  function TS(c, f, v) {
    for (var M = (c.mode & 1) !== 0; Fe !== null; ) {
      var E = Fe,
        T = E.child;
      if (E.tag === 22 && M) {
        var k = E.memoizedState !== null || Ed;
        if (!k) {
          var Y = E.alternate,
            he = (Y !== null && Y.memoizedState !== null) || ua;
          Y = Ed;
          var Be = ua;
          if (((Ed = k), (ua = he) && !Be))
            for (Fe = E; Fe !== null; )
              ((k = Fe),
                (he = k.child),
                k.tag === 22 && k.memoizedState !== null
                  ? BS(E)
                  : he !== null
                    ? ((he.return = k), (Fe = he))
                    : BS(E));
          for (; T !== null; ) ((Fe = T), TS(T), (T = T.sibling));
          ((Fe = E), (Ed = Y), (ua = Be));
        }
        bS(c);
      } else
        E.subtreeFlags & 8772 && T !== null
          ? ((T.return = E), (Fe = T))
          : bS(c);
    }
  }
  function bS(c) {
    for (; Fe !== null; ) {
      var f = Fe;
      if (f.flags & 8772) {
        var v = f.alternate;
        try {
          if (f.flags & 8772)
            switch (f.tag) {
              case 0:
              case 11:
              case 15:
                ua || Pu(5, f);
                break;
              case 1:
                var M = f.stateNode;
                if (f.flags & 4 && !ua)
                  if (v === null) M.componentDidMount();
                  else {
                    var E =
                      f.elementType === f.type
                        ? v.memoizedProps
                        : Cr(f.type, v.memoizedProps);
                    M.componentDidUpdate(
                      E,
                      v.memoizedState,
                      M.__reactInternalSnapshotBeforeUpdate
                    );
                  }
                var T = f.updateQueue;
                T !== null && MM(f, T, M);
                break;
              case 3:
                var k = f.updateQueue;
                if (k !== null) {
                  if (((v = null), f.child !== null))
                    switch (f.child.tag) {
                      case 5:
                        v = oe(f.child.stateNode);
                        break;
                      case 1:
                        v = f.child.stateNode;
                    }
                  MM(f, k, v);
                }
                break;
              case 5:
                var Y = f.stateNode;
                v === null && f.flags & 4 && He(Y, f.type, f.memoizedProps, f);
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (se && f.memoizedState === null) {
                  var he = f.alternate;
                  if (he !== null) {
                    var Be = he.memoizedState;
                    if (Be !== null) {
                      var Ge = Be.dehydrated;
                      Ge !== null && yt(Ge);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
                break;
              default:
                throw Error(o(163));
            }
          ua || (f.flags & 512 && H0(f));
        } catch (lt) {
          wi(f, f.return, lt);
        }
      }
      if (f === c) {
        Fe = null;
        break;
      }
      if (((v = f.sibling), v !== null)) {
        ((v.return = f.return), (Fe = v));
        break;
      }
      Fe = f.return;
    }
  }
  function PS(c) {
    for (; Fe !== null; ) {
      var f = Fe;
      if (f === c) {
        Fe = null;
        break;
      }
      var v = f.sibling;
      if (v !== null) {
        ((v.return = f.return), (Fe = v));
        break;
      }
      Fe = f.return;
    }
  }
  function BS(c) {
    for (; Fe !== null; ) {
      var f = Fe;
      try {
        switch (f.tag) {
          case 0:
          case 11:
          case 15:
            var v = f.return;
            try {
              Pu(4, f);
            } catch (he) {
              wi(f, v, he);
            }
            break;
          case 1:
            var M = f.stateNode;
            if (typeof M.componentDidMount == "function") {
              var E = f.return;
              try {
                M.componentDidMount();
              } catch (he) {
                wi(f, E, he);
              }
            }
            var T = f.return;
            try {
              H0(f);
            } catch (he) {
              wi(f, T, he);
            }
            break;
          case 5:
            var k = f.return;
            try {
              H0(f);
            } catch (he) {
              wi(f, k, he);
            }
        }
      } catch (he) {
        wi(f, f.return, he);
      }
      if (f === c) {
        Fe = null;
        break;
      }
      var Y = f.sibling;
      if (Y !== null) {
        ((Y.return = f.return), (Fe = Y));
        break;
      }
      Fe = f.return;
    }
  }
  var bd = 0,
    Pd = 1,
    Bd = 2,
    Rd = 3,
    Ld = 4;
  if (typeof Symbol == "function" && Symbol.for) {
    var Bu = Symbol.for;
    ((bd = Bu("selector.component")),
      (Pd = Bu("selector.has_pseudo_class")),
      (Bd = Bu("selector.role")),
      (Rd = Bu("selector.test_id")),
      (Ld = Bu("selector.text")));
  }
  function J0(c) {
    var f = _e(c);
    if (f != null) {
      if (typeof f.memoizedProps["data-testname"] != "string")
        throw Error(o(364));
      return f;
    }
    if (((c = At(c)), c === null)) throw Error(o(362));
    return c.stateNode.current;
  }
  function X0(c, f) {
    switch (f.$$typeof) {
      case bd:
        if (c.type === f.value) return !0;
        break;
      case Pd:
        e: {
          ((f = f.value), (c = [c, 0]));
          for (var v = 0; v < c.length; ) {
            var M = c[v++],
              E = c[v++],
              T = f[E];
            if (M.tag !== 5 || !le(M)) {
              for (; T != null && X0(M, T); ) (E++, (T = f[E]));
              if (E === f.length) {
                f = !0;
                break e;
              } else
                for (M = M.child; M !== null; ) (c.push(M, E), (M = M.sibling));
            }
          }
          f = !1;
        }
        return f;
      case Bd:
        if (c.tag === 5 && Ce(c.stateNode, f.value)) return !0;
        break;
      case Ld:
        if (
          (c.tag === 5 || c.tag === 6) &&
          ((c = D(c)), c !== null && 0 <= c.indexOf(f.value))
        )
          return !0;
        break;
      case Rd:
        if (
          c.tag === 5 &&
          ((c = c.memoizedProps["data-testname"]),
          typeof c == "string" && c.toLowerCase() === f.value.toLowerCase())
        )
          return !0;
        break;
      default:
        throw Error(o(365));
    }
    return !1;
  }
  function K0(c) {
    switch (c.$$typeof) {
      case bd:
        return "<" + (R(c.value) || "Unknown") + ">";
      case Pd:
        return ":has(" + (K0(c) || "") + ")";
      case Bd:
        return '[role="' + c.value + '"]';
      case Ld:
        return '"' + c.value + '"';
      case Rd:
        return '[data-testname="' + c.value + '"]';
      default:
        throw Error(o(365));
    }
  }
  function RS(c, f) {
    var v = [];
    c = [c, 0];
    for (var M = 0; M < c.length; ) {
      var E = c[M++],
        T = c[M++],
        k = f[T];
      if (E.tag !== 5 || !le(E)) {
        for (; k != null && X0(E, k); ) (T++, (k = f[T]));
        if (T === f.length) v.push(E);
        else for (E = E.child; E !== null; ) (c.push(E, T), (E = E.sibling));
      }
    }
    return v;
  }
  function Y0(c, f) {
    if (!nt) throw Error(o(363));
    ((c = J0(c)), (c = RS(c, f)), (f = []), (c = Array.from(c)));
    for (var v = 0; v < c.length; ) {
      var M = c[v++];
      if (M.tag === 5) le(M) || f.push(M.stateNode);
      else for (M = M.child; M !== null; ) (c.push(M), (M = M.sibling));
    }
    return f;
  }
  var yI = Math.ceil,
    Id = a.ReactCurrentDispatcher,
    Q0 = a.ReactCurrentOwner,
    mn = a.ReactCurrentBatchConfig,
    _t = 0,
    _n = null,
    An = null,
    Vn = 0,
    Ui = 0,
    Bl = Ai(0),
    Cn = 0,
    Ru = null,
    Rl = 0,
    Dd = 0,
    Z0 = 0,
    Lu = null,
    Mi = null,
    q0 = 0,
    $0 = 1 / 0;
  function Ll() {
    $0 = Dn() + 500;
  }
  var Fd = !1,
    ev = null,
    oo = null,
    Nd = !1,
    ao = null,
    kd = 0,
    Iu = 0,
    tv = null,
    Od = -1,
    Ud = 0;
  function fi() {
    return _t & 6 ? Dn() : Od !== -1 ? Od : (Od = Dn());
  }
  function lo(c) {
    return c.mode & 1
      ? _t & 2 && Vn !== 0
        ? Vn & -Vn
        : eI.transition !== null
          ? (Ud === 0 &&
              ((c = qh), (qh <<= 1), !(qh & 4194240) && (qh = 64), (Ud = c)),
            Ud)
          : ((c = Rt), c !== 0 ? c : Le())
      : 1;
  }
  function or(c, f, v) {
    if (50 < Iu) throw ((Iu = 0), (tv = null), Error(o(185)));
    var M = zd(c, f);
    return M === null
      ? null
      : (gu(M, f, v),
        (!(_t & 2) || M !== _n) &&
          (M === _n && (!(_t & 2) && (Dd |= f), Cn === 4 && co(M, Vn)),
          Si(M, v),
          f === 1 && _t === 0 && !(c.mode & 1) && (Ll(), nd && Qr())),
        M);
  }
  function zd(c, f) {
    c.lanes |= f;
    var v = c.alternate;
    for (v !== null && (v.lanes |= f), v = c, c = c.return; c !== null; )
      ((c.childLanes |= f),
        (v = c.alternate),
        v !== null && (v.childLanes |= f),
        (v = c),
        (c = c.return));
    return v.tag === 3 ? v.stateNode : null;
  }
  function Si(c, f) {
    var v = c.callbackNode;
    jL(c, f);
    var M = ed(c, c === _n ? Vn : 0);
    if (M === 0)
      (v !== null && vM(v), (c.callbackNode = null), (c.callbackPriority = 0));
    else if (((f = M & -M), c.callbackPriority !== f)) {
      if ((v != null && vM(v), f === 1))
        (c.tag === 0 ? $L(IS.bind(null, c)) : yM(IS.bind(null, c)),
          Ke
            ? je(function () {
                _t === 0 && Qr();
              })
            : c0(u0, Qr),
          (v = null));
      else {
        switch (gM(M)) {
          case 1:
            v = u0;
            break;
          case 4:
            v = YL;
            break;
          case 16:
            v = f0;
            break;
          case 536870912:
            v = QL;
            break;
          default:
            v = f0;
        }
        v = HS(v, LS.bind(null, c));
      }
      ((c.callbackPriority = f), (c.callbackNode = v));
    }
  }
  function LS(c, f) {
    if (((Od = -1), (Ud = 0), _t & 6)) throw Error(o(327));
    var v = c.callbackNode;
    if (pa() && c.callbackNode !== v) return null;
    var M = ed(c, c === _n ? Vn : 0);
    if (M === 0) return null;
    if (M & 30 || M & c.expiredLanes || f) f = Gd(c, M);
    else {
      f = M;
      var E = _t;
      _t |= 2;
      var T = NS();
      (_n !== c || Vn !== f) && (Ll(), ha(c, f));
      do
        try {
          AI();
          break;
        } catch (Y) {
          FS(c, Y);
        }
      while (1);
      (p0(),
        (Id.current = T),
        (_t = E),
        An !== null ? (f = 0) : ((_n = null), (Vn = 0), (f = Cn)));
    }
    if (f !== 0) {
      if (
        (f === 2 && ((E = o0(c)), E !== 0 && ((M = E), (f = nv(c, E)))),
        f === 1)
      )
        throw ((v = Ru), ha(c, 0), co(c, M), Si(c, Dn()), v);
      if (f === 6) co(c, M);
      else {
        if (
          ((E = c.current.alternate),
          !(M & 30) &&
            !xI(E) &&
            ((f = Gd(c, M)),
            f === 2 && ((T = o0(c)), T !== 0 && ((M = T), (f = nv(c, T)))),
            f === 1))
        )
          throw ((v = Ru), ha(c, 0), co(c, M), Si(c, Dn()), v);
        switch (((c.finishedWork = E), (c.finishedLanes = M), f)) {
          case 0:
          case 1:
            throw Error(o(345));
          case 2:
            da(c, Mi);
            break;
          case 3:
            if (
              (co(c, M),
              (M & 130023424) === M && ((f = q0 + 500 - Dn()), 10 < f))
            ) {
              if (ed(c, 0) !== 0) break;
              if (((E = c.suspendedLanes), (E & M) !== M)) {
                (fi(), (c.pingedLanes |= c.suspendedLanes & E));
                break;
              }
              c.timeoutHandle = $(da.bind(null, c, Mi), f);
              break;
            }
            da(c, Mi);
            break;
          case 4:
            if ((co(c, M), (M & 4194240) === M)) break;
            for (f = c.eventTimes, E = -1; 0 < M; ) {
              var k = 31 - Er(M);
              ((T = 1 << k), (k = f[k]), k > E && (E = k), (M &= ~T));
            }
            if (
              ((M = E),
              (M = Dn() - M),
              (M =
                (120 > M
                  ? 120
                  : 480 > M
                    ? 480
                    : 1080 > M
                      ? 1080
                      : 1920 > M
                        ? 1920
                        : 3e3 > M
                          ? 3e3
                          : 4320 > M
                            ? 4320
                            : 1960 * yI(M / 1960)) - M),
              10 < M)
            ) {
              c.timeoutHandle = $(da.bind(null, c, Mi), M);
              break;
            }
            da(c, Mi);
            break;
          case 5:
            da(c, Mi);
            break;
          default:
            throw Error(o(329));
        }
      }
    }
    return (Si(c, Dn()), c.callbackNode === v ? LS.bind(null, c) : null);
  }
  function nv(c, f) {
    var v = Lu;
    return (
      c.current.memoizedState.isDehydrated && (ha(c, f).flags |= 256),
      (c = Gd(c, f)),
      c !== 2 && ((f = Mi), (Mi = v), f !== null && iv(f)),
      c
    );
  }
  function iv(c) {
    Mi === null ? (Mi = c) : Mi.push.apply(Mi, c);
  }
  function xI(c) {
    for (var f = c; ; ) {
      if (f.flags & 16384) {
        var v = f.updateQueue;
        if (v !== null && ((v = v.stores), v !== null))
          for (var M = 0; M < v.length; M++) {
            var E = v[M],
              T = E.getSnapshot;
            E = E.value;
            try {
              if (!Yr(T(), E)) return !1;
            } catch {
              return !1;
            }
          }
      }
      if (((v = f.child), f.subtreeFlags & 16384 && v !== null))
        ((v.return = f), (f = v));
      else {
        if (f === c) break;
        for (; f.sibling === null; ) {
          if (f.return === null || f.return === c) return !0;
          f = f.return;
        }
        ((f.sibling.return = f.return), (f = f.sibling));
      }
    }
    return !0;
  }
  function co(c, f) {
    for (
      f &= ~Z0,
        f &= ~Dd,
        c.suspendedLanes |= f,
        c.pingedLanes &= ~f,
        c = c.expirationTimes;
      0 < f;

    ) {
      var v = 31 - Er(f),
        M = 1 << v;
      ((c[v] = -1), (f &= ~M));
    }
  }
  function IS(c) {
    if (_t & 6) throw Error(o(327));
    pa();
    var f = ed(c, 0);
    if (!(f & 1)) return (Si(c, Dn()), null);
    var v = Gd(c, f);
    if (c.tag !== 0 && v === 2) {
      var M = o0(c);
      M !== 0 && ((f = M), (v = nv(c, M)));
    }
    if (v === 1) throw ((v = Ru), ha(c, 0), co(c, f), Si(c, Dn()), v);
    if (v === 6) throw Error(o(345));
    return (
      (c.finishedWork = c.current.alternate),
      (c.finishedLanes = f),
      da(c, Mi),
      Si(c, Dn()),
      null
    );
  }
  function DS(c) {
    ao !== null && ao.tag === 0 && !(_t & 6) && pa();
    var f = _t;
    _t |= 1;
    var v = mn.transition,
      M = Rt;
    try {
      if (((mn.transition = null), (Rt = 1), c)) return c();
    } finally {
      ((Rt = M), (mn.transition = v), (_t = f), !(_t & 6) && Qr());
    }
  }
  function rv() {
    ((Ui = Bl.current), Nt(Bl));
  }
  function ha(c, f) {
    ((c.finishedWork = null), (c.finishedLanes = 0));
    var v = c.timeoutHandle;
    if ((v !== Xe && ((c.timeoutHandle = Xe), Je(v)), An !== null))
      for (v = An.return; v !== null; ) {
        var M = v;
        switch ((A0(M), M.tag)) {
          case 1:
            ((M = M.type.childContextTypes), M != null && Qh());
            break;
          case 3:
            (bl(), Nt(Gt), Nt(xn), b0());
            break;
          case 5:
            C0(M);
            break;
          case 4:
            bl();
            break;
          case 13:
            Nt(tn);
            break;
          case 19:
            Nt(tn);
            break;
          case 10:
            m0(M.type._context);
            break;
          case 22:
          case 23:
            rv();
        }
        v = v.return;
      }
    if (
      ((_n = c),
      (An = c = uo(c.current, null)),
      (Vn = Ui = f),
      (Cn = 0),
      (Ru = null),
      (Z0 = Dd = Rl = 0),
      (Mi = Lu = null),
      Zr !== null)
    ) {
      for (f = 0; f < Zr.length; f++)
        if (((v = Zr[f]), (M = v.interleaved), M !== null)) {
          v.interleaved = null;
          var E = M.next,
            T = v.pending;
          if (T !== null) {
            var k = T.next;
            ((T.next = E), (M.next = k));
          }
          v.pending = M;
        }
      Zr = null;
    }
    return c;
  }
  function FS(c, f) {
    do {
      var v = An;
      try {
        if ((p0(), (dd.current = xd), pd)) {
          for (var M = un.memoizedState; M !== null; ) {
            var E = M.queue;
            (E !== null && (E.pending = null), (M = M.next));
          }
          pd = !1;
        }
        if (
          ((Pl = 0),
          (Fn = Zn = un = null),
          (Mu = !1),
          (Su = 0),
          (Q0.current = null),
          v === null || v.return === null)
        ) {
          ((Cn = 1), (Ru = f), (An = null));
          break;
        }
        e: {
          var T = c,
            k = v.return,
            Y = v,
            he = f;
          if (
            ((f = Vn),
            (Y.flags |= 32768),
            he !== null &&
              typeof he == "object" &&
              typeof he.then == "function")
          ) {
            var Be = he,
              Ge = Y,
              lt = Ge.tag;
            if (!(Ge.mode & 1) && (lt === 0 || lt === 11 || lt === 15)) {
              var tt = Ge.alternate;
              tt
                ? ((Ge.updateQueue = tt.updateQueue),
                  (Ge.memoizedState = tt.memoizedState),
                  (Ge.lanes = tt.lanes))
                : ((Ge.updateQueue = null), (Ge.memoizedState = null));
            }
            var Ht = nS(k);
            if (Ht !== null) {
              ((Ht.flags &= -257),
                iS(Ht, k, Y, T, f),
                Ht.mode & 1 && tS(T, Be, f),
                (f = Ht),
                (he = Be));
              var Ze = f.updateQueue;
              if (Ze === null) {
                var ei = new Set();
                (ei.add(he), (f.updateQueue = ei));
              } else Ze.add(he);
              break e;
            } else {
              if (!(f & 1)) {
                (tS(T, Be, f), sv());
                break e;
              }
              he = Error(o(426));
            }
          } else if (Zt && Y.mode & 1) {
            var lr = nS(k);
            if (lr !== null) {
              (!(lr.flags & 65536) && (lr.flags |= 256),
                iS(lr, k, Y, T, f),
                w0(he));
              break e;
            }
          }
          ((T = he),
            Cn !== 4 && (Cn = 2),
            Lu === null ? (Lu = [T]) : Lu.push(T),
            (he = F0(he, Y)),
            (Y = k));
          do {
            switch (Y.tag) {
              case 3:
                ((Y.flags |= 65536), (f &= -f), (Y.lanes |= f));
                var ie = $M(Y, he, f);
                AM(Y, ie);
                break e;
              case 1:
                T = he;
                var Z = Y.type,
                  ue = Y.stateNode;
                if (
                  !(Y.flags & 128) &&
                  (typeof Z.getDerivedStateFromError == "function" ||
                    (ue !== null &&
                      typeof ue.componentDidCatch == "function" &&
                      (oo === null || !oo.has(ue))))
                ) {
                  ((Y.flags |= 65536), (f &= -f), (Y.lanes |= f));
                  var ke = eS(Y, T, f);
                  AM(Y, ke);
                  break e;
                }
            }
            Y = Y.return;
          } while (Y !== null);
        }
        OS(v);
      } catch (Ye) {
        ((f = Ye), An === v && v !== null && (An = v = v.return));
        continue;
      }
      break;
    } while (1);
  }
  function NS() {
    var c = Id.current;
    return ((Id.current = xd), c === null ? xd : c);
  }
  function sv() {
    ((Cn === 0 || Cn === 3 || Cn === 2) && (Cn = 4),
      _n === null || (!(Rl & 268435455) && !(Dd & 268435455)) || co(_n, Vn));
  }
  function Gd(c, f) {
    var v = _t;
    _t |= 2;
    var M = NS();
    (_n === c && Vn === f) || ha(c, f);
    do
      try {
        _I();
        break;
      } catch (E) {
        FS(c, E);
      }
    while (1);
    if ((p0(), (_t = v), (Id.current = M), An !== null)) throw Error(o(261));
    return ((_n = null), (Vn = 0), Cn);
  }
  function _I() {
    for (; An !== null; ) kS(An);
  }
  function AI() {
    for (; An !== null && !XL(); ) kS(An);
  }
  function kS(c) {
    var f = GS(c.alternate, c, Ui);
    ((c.memoizedProps = c.pendingProps),
      f === null ? OS(c) : (An = f),
      (Q0.current = null));
  }
  function OS(c) {
    var f = c;
    do {
      var v = f.alternate;
      if (((c = f.return), f.flags & 32768)) {
        if (((v = dI(v, f)), v !== null)) {
          ((v.flags &= 32767), (An = v));
          return;
        }
        if (c !== null)
          ((c.flags |= 32768), (c.subtreeFlags = 0), (c.deletions = null));
        else {
          ((Cn = 6), (An = null));
          return;
        }
      } else if (((v = uI(v, f, Ui)), v !== null)) {
        An = v;
        return;
      }
      if (((f = f.sibling), f !== null)) {
        An = f;
        return;
      }
      An = f = c;
    } while (f !== null);
    Cn === 0 && (Cn = 5);
  }
  function da(c, f) {
    var v = Rt,
      M = mn.transition;
    try {
      ((mn.transition = null), (Rt = 1), MI(c, f, v));
    } finally {
      ((mn.transition = M), (Rt = v));
    }
    return null;
  }
  function MI(c, f, v) {
    do pa();
    while (ao !== null);
    if (_t & 6) throw Error(o(327));
    var M = c.finishedWork,
      E = c.finishedLanes;
    if (M === null) return null;
    if (((c.finishedWork = null), (c.finishedLanes = 0), M === c.current))
      throw Error(o(177));
    ((c.callbackNode = null), (c.callbackPriority = 0));
    var T = M.lanes | M.childLanes;
    if (
      (JL(c, T),
      c === _n && ((An = _n = null), (Vn = 0)),
      (!(M.subtreeFlags & 2064) && !(M.flags & 2064)) ||
        Nd ||
        ((Nd = !0),
        HS(f0, function () {
          return (pa(), null);
        })),
      (T = (M.flags & 15990) !== 0),
      M.subtreeFlags & 15990 || T)
    ) {
      ((T = mn.transition), (mn.transition = null));
      var k = Rt;
      Rt = 1;
      var Y = _t;
      ((_t |= 4),
        (Q0.current = null),
        mI(c, M),
        gI(c, M),
        z(c.containerInfo),
        (c.current = M),
        vI(M),
        KL(),
        (_t = Y),
        (Rt = k),
        (mn.transition = T));
    } else c.current = M;
    if (
      (Nd && ((Nd = !1), (ao = c), (kd = E)),
      (T = c.pendingLanes),
      T === 0 && (oo = null),
      ZL(M.stateNode),
      Si(c, Dn()),
      f !== null)
    )
      for (v = c.onRecoverableError, M = 0; M < f.length; M++) v(f[M]);
    if (Fd) throw ((Fd = !1), (c = ev), (ev = null), c);
    return (
      kd & 1 && c.tag !== 0 && pa(),
      (T = c.pendingLanes),
      T & 1 ? (c === tv ? Iu++ : ((Iu = 0), (tv = c))) : (Iu = 0),
      Qr(),
      null
    );
  }
  function pa() {
    if (ao !== null) {
      var c = gM(kd),
        f = mn.transition,
        v = Rt;
      try {
        if (((mn.transition = null), (Rt = 16 > c ? 16 : c), ao === null))
          var M = !1;
        else {
          if (((c = ao), (ao = null), (kd = 0), _t & 6)) throw Error(o(331));
          var E = _t;
          for (_t |= 4, Fe = c.current; Fe !== null; ) {
            var T = Fe,
              k = T.child;
            if (Fe.flags & 16) {
              var Y = T.deletions;
              if (Y !== null) {
                for (var he = 0; he < Y.length; he++) {
                  var Be = Y[he];
                  for (Fe = Be; Fe !== null; ) {
                    var Ge = Fe;
                    switch (Ge.tag) {
                      case 0:
                      case 11:
                      case 15:
                        fa(8, Ge, T);
                    }
                    var lt = Ge.child;
                    if (lt !== null) ((lt.return = Ge), (Fe = lt));
                    else
                      for (; Fe !== null; ) {
                        Ge = Fe;
                        var tt = Ge.sibling,
                          Ht = Ge.return;
                        if ((MS(Ge), Ge === Be)) {
                          Fe = null;
                          break;
                        }
                        if (tt !== null) {
                          ((tt.return = Ht), (Fe = tt));
                          break;
                        }
                        Fe = Ht;
                      }
                  }
                }
                var Ze = T.alternate;
                if (Ze !== null) {
                  var ei = Ze.child;
                  if (ei !== null) {
                    Ze.child = null;
                    do {
                      var lr = ei.sibling;
                      ((ei.sibling = null), (ei = lr));
                    } while (ei !== null);
                  }
                }
                Fe = T;
              }
            }
            if (T.subtreeFlags & 2064 && k !== null) ((k.return = T), (Fe = k));
            else
              e: for (; Fe !== null; ) {
                if (((T = Fe), T.flags & 2048))
                  switch (T.tag) {
                    case 0:
                    case 11:
                    case 15:
                      fa(9, T, T.return);
                  }
                var ie = T.sibling;
                if (ie !== null) {
                  ((ie.return = T.return), (Fe = ie));
                  break e;
                }
                Fe = T.return;
              }
          }
          var Z = c.current;
          for (Fe = Z; Fe !== null; ) {
            k = Fe;
            var ue = k.child;
            if (k.subtreeFlags & 2064 && ue !== null)
              ((ue.return = k), (Fe = ue));
            else
              e: for (k = Z; Fe !== null; ) {
                if (((Y = Fe), Y.flags & 2048))
                  try {
                    switch (Y.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Pu(9, Y);
                    }
                  } catch (Ye) {
                    wi(Y, Y.return, Ye);
                  }
                if (Y === k) {
                  Fe = null;
                  break e;
                }
                var ke = Y.sibling;
                if (ke !== null) {
                  ((ke.return = Y.return), (Fe = ke));
                  break e;
                }
                Fe = Y.return;
              }
          }
          if (
            ((_t = E),
            Qr(),
            Kr && typeof Kr.onPostCommitFiberRoot == "function")
          )
            try {
              Kr.onPostCommitFiberRoot(td, c);
            } catch {}
          M = !0;
        }
        return M;
      } finally {
        ((Rt = v), (mn.transition = f));
      }
    }
    return !1;
  }
  function US(c, f, v) {
    ((f = F0(v, f)),
      (f = $M(c, f, 1)),
      so(c, f),
      (f = fi()),
      (c = zd(c, 1)),
      c !== null && (gu(c, 1, f), Si(c, f)));
  }
  function wi(c, f, v) {
    if (c.tag === 3) US(c, c, v);
    else
      for (; f !== null; ) {
        if (f.tag === 3) {
          US(f, c, v);
          break;
        } else if (f.tag === 1) {
          var M = f.stateNode;
          if (
            typeof f.type.getDerivedStateFromError == "function" ||
            (typeof M.componentDidCatch == "function" &&
              (oo === null || !oo.has(M)))
          ) {
            ((c = F0(v, c)),
              (c = eS(f, c, 1)),
              so(f, c),
              (c = fi()),
              (f = zd(f, 1)),
              f !== null && (gu(f, 1, c), Si(f, c)));
            break;
          }
        }
        f = f.return;
      }
  }
  function SI(c, f, v) {
    var M = c.pingCache;
    (M !== null && M.delete(f),
      (f = fi()),
      (c.pingedLanes |= c.suspendedLanes & v),
      _n === c &&
        (Vn & v) === v &&
        (Cn === 4 || (Cn === 3 && (Vn & 130023424) === Vn && 500 > Dn() - q0)
          ? ha(c, 0)
          : (Z0 |= v)),
      Si(c, f));
  }
  function zS(c, f) {
    f === 0 &&
      (c.mode & 1
        ? ((f = $h), ($h <<= 1), !($h & 130023424) && ($h = 4194304))
        : (f = 1));
    var v = fi();
    ((c = zd(c, f)), c !== null && (gu(c, f, v), Si(c, v)));
  }
  function wI(c) {
    var f = c.memoizedState,
      v = 0;
    (f !== null && (v = f.retryLane), zS(c, v));
  }
  function EI(c, f) {
    var v = 0;
    switch (c.tag) {
      case 13:
        var M = c.stateNode,
          E = c.memoizedState;
        E !== null && (v = E.retryLane);
        break;
      case 19:
        M = c.stateNode;
        break;
      default:
        throw Error(o(314));
    }
    (M !== null && M.delete(f), zS(c, v));
  }
  var GS;
  GS = function (c, f, v) {
    if (c !== null)
      if (c.memoizedProps !== f.pendingProps || Gt.current) Oi = !0;
      else {
        if (!(c.lanes & v) && !(f.flags & 128)) return ((Oi = !1), hI(c, f, v));
        Oi = !!(c.flags & 131072);
      }
    else ((Oi = !1), Zt && f.flags & 1048576 && TM(f, ud, f.index));
    switch (((f.lanes = 0), f.tag)) {
      case 2:
        var M = f.type;
        (c !== null &&
          ((c.alternate = null), (f.alternate = null), (f.flags |= 2)),
          (c = f.pendingProps));
        var E = io(f, xn.current);
        (Ml(f, v), (E = B0(null, f, M, c, E, v)));
        var T = R0();
        return (
          (f.flags |= 1),
          typeof E == "object" &&
          E !== null &&
          typeof E.render == "function" &&
          E.$$typeof === void 0
            ? ((f.tag = 1),
              (f.memoizedState = null),
              (f.updateQueue = null),
              Hn(M) ? ((T = !0), Zh(f)) : (T = !1),
              (f.memoizedState =
                E.state !== null && E.state !== void 0 ? E.state : null),
              v0(f),
              (E.updater = ld),
              (f.stateNode = E),
              (E._reactInternals = f),
              x0(f, M, c, v),
              (f = O0(null, f, M, !0, T, v)))
            : ((f.tag = 0), Zt && T && _0(f), ui(null, f, E, v), (f = f.child)),
          f
        );
      case 16:
        M = f.elementType;
        e: {
          switch (
            (c !== null &&
              ((c.alternate = null), (f.alternate = null), (f.flags |= 2)),
            (c = f.pendingProps),
            (E = M._init),
            (M = E(M._payload)),
            (f.type = M),
            (E = f.tag = TI(M)),
            (c = Cr(M, c)),
            E)
          ) {
            case 0:
              f = k0(null, f, M, c, v);
              break e;
            case 1:
              f = fS(null, f, M, c, v);
              break e;
            case 11:
              f = oS(null, f, M, c, v);
              break e;
            case 14:
              f = aS(null, f, M, Cr(M.type, c), v);
              break e;
          }
          throw Error(o(306, M, ""));
        }
        return f;
      case 0:
        return (
          (M = f.type),
          (E = f.pendingProps),
          (E = f.elementType === M ? E : Cr(M, E)),
          k0(c, f, M, E, v)
        );
      case 1:
        return (
          (M = f.type),
          (E = f.pendingProps),
          (E = f.elementType === M ? E : Cr(M, E)),
          fS(c, f, M, E, v)
        );
      case 3:
        e: {
          if ((hS(f), c === null)) throw Error(o(387));
          ((M = f.pendingProps),
            (T = f.memoizedState),
            (E = T.element),
            _M(c, f),
            ad(f, M, null, v));
          var k = f.memoizedState;
          if (((M = k.element), se && T.isDehydrated))
            if (
              ((T = {
                element: M,
                isDehydrated: !1,
                cache: k.cache,
                transitions: k.transitions,
              }),
              (f.updateQueue.baseState = T),
              (f.memoizedState = T),
              f.flags & 256)
            ) {
              ((E = Error(o(423))), (f = dS(c, f, M, v, E)));
              break e;
            } else if (M !== E) {
              ((E = Error(o(424))), (f = dS(c, f, M, v, E)));
              break e;
            } else
              for (
                se &&
                  ((ki = me(f.stateNode.containerInfo)),
                  (Ni = f),
                  (Zt = !0),
                  (Tr = null),
                  (vu = !1)),
                  v = IM(f, null, M, v),
                  f.child = v;
                v;

              )
                ((v.flags = (v.flags & -3) | 4096), (v = v.sibling));
          else {
            if ((El(), M === E)) {
              f = As(c, f, v);
              break e;
            }
            ui(c, f, M, v);
          }
          f = f.child;
        }
        return f;
      case 5:
        return (
          DM(f),
          c === null && S0(f),
          (M = f.type),
          (E = f.pendingProps),
          (T = c !== null ? c.memoizedProps : null),
          (k = E.children),
          Ee(M, E) ? (k = null) : T !== null && Ee(M, T) && (f.flags |= 32),
          uS(c, f),
          ui(c, f, k, v),
          f.child
        );
      case 6:
        return (c === null && S0(f), null);
      case 13:
        return pS(c, f, v);
      case 4:
        return (
          E0(f, f.stateNode.containerInfo),
          (M = f.pendingProps),
          c === null ? (f.child = Cl(f, null, M, v)) : ui(c, f, M, v),
          f.child
        );
      case 11:
        return (
          (M = f.type),
          (E = f.pendingProps),
          (E = f.elementType === M ? E : Cr(M, E)),
          oS(c, f, M, E, v)
        );
      case 7:
        return (ui(c, f, f.pendingProps, v), f.child);
      case 8:
        return (ui(c, f, f.pendingProps.children, v), f.child);
      case 12:
        return (ui(c, f, f.pendingProps.children, v), f.child);
      case 10:
        e: {
          if (
            ((M = f.type._context),
            (E = f.pendingProps),
            (T = f.memoizedProps),
            (k = E.value),
            xM(f, M, k),
            T !== null)
          )
            if (Yr(T.value, k)) {
              if (T.children === E.children && !Gt.current) {
                f = As(c, f, v);
                break e;
              }
            } else
              for (T = f.child, T !== null && (T.return = f); T !== null; ) {
                var Y = T.dependencies;
                if (Y !== null) {
                  k = T.child;
                  for (var he = Y.firstContext; he !== null; ) {
                    if (he.context === M) {
                      if (T.tag === 1) {
                        ((he = vs(-1, v & -v)), (he.tag = 2));
                        var Be = T.updateQueue;
                        if (Be !== null) {
                          Be = Be.shared;
                          var Ge = Be.pending;
                          (Ge === null
                            ? (he.next = he)
                            : ((he.next = Ge.next), (Ge.next = he)),
                            (Be.pending = he));
                        }
                      }
                      ((T.lanes |= v),
                        (he = T.alternate),
                        he !== null && (he.lanes |= v),
                        g0(T.return, v, f),
                        (Y.lanes |= v));
                      break;
                    }
                    he = he.next;
                  }
                } else if (T.tag === 10) k = T.type === f.type ? null : T.child;
                else if (T.tag === 18) {
                  if (((k = T.return), k === null)) throw Error(o(341));
                  ((k.lanes |= v),
                    (Y = k.alternate),
                    Y !== null && (Y.lanes |= v),
                    g0(k, v, f),
                    (k = T.sibling));
                } else k = T.child;
                if (k !== null) k.return = T;
                else
                  for (k = T; k !== null; ) {
                    if (k === f) {
                      k = null;
                      break;
                    }
                    if (((T = k.sibling), T !== null)) {
                      ((T.return = k.return), (k = T));
                      break;
                    }
                    k = k.return;
                  }
                T = k;
              }
          (ui(c, f, E.children, v), (f = f.child));
        }
        return f;
      case 9:
        return (
          (E = f.type),
          (M = f.pendingProps.children),
          Ml(f, v),
          (E = tr(E)),
          (M = M(E)),
          (f.flags |= 1),
          ui(c, f, M, v),
          f.child
        );
      case 14:
        return (
          (M = f.type),
          (E = Cr(M, f.pendingProps)),
          (E = Cr(M.type, E)),
          aS(c, f, M, E, v)
        );
      case 15:
        return lS(c, f, f.type, f.pendingProps, v);
      case 17:
        return (
          (M = f.type),
          (E = f.pendingProps),
          (E = f.elementType === M ? E : Cr(M, E)),
          c !== null &&
            ((c.alternate = null), (f.alternate = null), (f.flags |= 2)),
          (f.tag = 1),
          Hn(M) ? ((c = !0), Zh(f)) : (c = !1),
          Ml(f, v),
          EM(f, M, E),
          x0(f, M, E, v),
          O0(null, f, M, !0, c, v)
        );
      case 19:
        return yS(c, f, v);
      case 22:
        return cS(c, f, v);
    }
    throw Error(o(156, f.tag));
  };
  function HS(c, f) {
    return c0(c, f);
  }
  function CI(c, f, v, M) {
    ((this.tag = c),
      (this.key = v),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.ref = null),
      (this.pendingProps = f),
      (this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null),
      (this.mode = M),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null));
  }
  function ar(c, f, v, M) {
    return new CI(c, f, v, M);
  }
  function ov(c) {
    return ((c = c.prototype), !(!c || !c.isReactComponent));
  }
  function TI(c) {
    if (typeof c == "function") return ov(c) ? 1 : 0;
    if (c != null) {
      if (((c = c.$$typeof), c === A)) return 11;
      if (c === x) return 14;
    }
    return 2;
  }
  function uo(c, f) {
    var v = c.alternate;
    return (
      v === null
        ? ((v = ar(c.tag, f, c.key, c.mode)),
          (v.elementType = c.elementType),
          (v.type = c.type),
          (v.stateNode = c.stateNode),
          (v.alternate = c),
          (c.alternate = v))
        : ((v.pendingProps = f),
          (v.type = c.type),
          (v.flags = 0),
          (v.subtreeFlags = 0),
          (v.deletions = null)),
      (v.flags = c.flags & 14680064),
      (v.childLanes = c.childLanes),
      (v.lanes = c.lanes),
      (v.child = c.child),
      (v.memoizedProps = c.memoizedProps),
      (v.memoizedState = c.memoizedState),
      (v.updateQueue = c.updateQueue),
      (f = c.dependencies),
      (v.dependencies =
        f === null ? null : { lanes: f.lanes, firstContext: f.firstContext }),
      (v.sibling = c.sibling),
      (v.index = c.index),
      (v.ref = c.ref),
      v
    );
  }
  function Hd(c, f, v, M, E, T) {
    var k = 2;
    if (((M = c), typeof c == "function")) ov(c) && (k = 1);
    else if (typeof c == "string") k = 5;
    else
      e: switch (c) {
        case h:
          return ma(v.children, E, T, f);
        case d:
          ((k = 8), (E |= 8));
          break;
        case p:
          return (
            (c = ar(12, v, f, E | 2)),
            (c.elementType = p),
            (c.lanes = T),
            c
          );
        case _:
          return ((c = ar(13, v, f, E)), (c.elementType = _), (c.lanes = T), c);
        case m:
          return ((c = ar(19, v, f, E)), (c.elementType = m), (c.lanes = T), c);
        case w:
          return Vd(v, E, T, f);
        default:
          if (typeof c == "object" && c !== null)
            switch (c.$$typeof) {
              case g:
                k = 10;
                break e;
              case y:
                k = 9;
                break e;
              case A:
                k = 11;
                break e;
              case x:
                k = 14;
                break e;
              case S:
                ((k = 16), (M = null));
                break e;
            }
          throw Error(o(130, c == null ? c : typeof c, ""));
      }
    return (
      (f = ar(k, v, f, E)),
      (f.elementType = c),
      (f.type = M),
      (f.lanes = T),
      f
    );
  }
  function ma(c, f, v, M) {
    return ((c = ar(7, c, M, f)), (c.lanes = v), c);
  }
  function Vd(c, f, v, M) {
    return (
      (c = ar(22, c, M, f)),
      (c.elementType = w),
      (c.lanes = v),
      (c.stateNode = {}),
      c
    );
  }
  function av(c, f, v) {
    return ((c = ar(6, c, null, f)), (c.lanes = v), c);
  }
  function lv(c, f, v) {
    return (
      (f = ar(4, c.children !== null ? c.children : [], c.key, f)),
      (f.lanes = v),
      (f.stateNode = {
        containerInfo: c.containerInfo,
        pendingChildren: null,
        implementation: c.implementation,
      }),
      f
    );
  }
  function bI(c, f, v, M, E) {
    ((this.tag = f),
      (this.containerInfo = c),
      (this.finishedWork =
        this.pingCache =
        this.current =
        this.pendingChildren =
          null),
      (this.timeoutHandle = Xe),
      (this.callbackNode = this.pendingContext = this.context = null),
      (this.callbackPriority = 0),
      (this.eventTimes = a0(0)),
      (this.expirationTimes = a0(-1)),
      (this.entangledLanes =
        this.finishedLanes =
        this.mutableReadLanes =
        this.expiredLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = a0(0)),
      (this.identifierPrefix = M),
      (this.onRecoverableError = E),
      se && (this.mutableSourceEagerHydrationData = null));
  }
  function VS(c, f, v, M, E, T, k, Y, he) {
    return (
      (c = new bI(c, f, v, Y, he)),
      f === 1 ? ((f = 1), T === !0 && (f |= 8)) : (f = 0),
      (T = ar(3, null, null, f)),
      (c.current = T),
      (T.stateNode = c),
      (T.memoizedState = {
        element: M,
        isDehydrated: v,
        cache: null,
        transitions: null,
      }),
      v0(T),
      c
    );
  }
  function WS(c) {
    if (!c) return Qn;
    c = c._reactInternals;
    e: {
      if (b(c) !== c || c.tag !== 1) throw Error(o(170));
      var f = c;
      do {
        switch (f.tag) {
          case 3:
            f = f.stateNode.context;
            break e;
          case 1:
            if (Hn(f.type)) {
              f = f.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        f = f.return;
      } while (f !== null);
      throw Error(o(171));
    }
    if (c.tag === 1) {
      var v = c.type;
      if (Hn(v)) return pM(c, v, f);
    }
    return f;
  }
  function jS(c) {
    var f = c._reactInternals;
    if (f === void 0)
      throw typeof c.render == "function"
        ? Error(o(188))
        : ((c = Object.keys(c).join(",")), Error(o(268, c)));
    return ((c = J(f)), c === null ? null : c.stateNode);
  }
  function JS(c, f) {
    if (((c = c.memoizedState), c !== null && c.dehydrated !== null)) {
      var v = c.retryLane;
      c.retryLane = v !== 0 && v < f ? v : f;
    }
  }
  function cv(c, f) {
    (JS(c, f), (c = c.alternate) && JS(c, f));
  }
  function PI(c) {
    return ((c = J(c)), c === null ? null : c.stateNode);
  }
  function BI() {
    return null;
  }
  return (
    (t.attemptContinuousHydration = function (c) {
      if (c.tag === 13) {
        var f = fi();
        (or(c, 134217728, f), cv(c, 134217728));
      }
    }),
    (t.attemptHydrationAtCurrentPriority = function (c) {
      if (c.tag === 13) {
        var f = fi(),
          v = lo(c);
        (or(c, v, f), cv(c, v));
      }
    }),
    (t.attemptSynchronousHydration = function (c) {
      switch (c.tag) {
        case 3:
          var f = c.stateNode;
          if (f.current.memoizedState.isDehydrated) {
            var v = mu(f.pendingLanes);
            v !== 0 && (l0(f, v | 1), Si(f, Dn()), !(_t & 6) && (Ll(), Qr()));
          }
          break;
        case 13:
          var M = fi();
          (DS(function () {
            return or(c, 1, M);
          }),
            cv(c, 1));
      }
    }),
    (t.batchedUpdates = function (c, f) {
      var v = _t;
      _t |= 1;
      try {
        return c(f);
      } finally {
        ((_t = v), _t === 0 && (Ll(), nd && Qr()));
      }
    }),
    (t.createComponentSelector = function (c) {
      return { $$typeof: bd, value: c };
    }),
    (t.createContainer = function (c, f, v, M, E, T, k) {
      return VS(c, f, !1, null, v, M, E, T, k);
    }),
    (t.createHasPseudoClassSelector = function (c) {
      return { $$typeof: Pd, value: c };
    }),
    (t.createHydrationContainer = function (c, f, v, M, E, T, k, Y, he) {
      return (
        (c = VS(v, M, !0, c, E, T, k, Y, he)),
        (c.context = WS(null)),
        (v = c.current),
        (M = fi()),
        (E = lo(v)),
        (T = vs(M, E)),
        (T.callback = f ?? null),
        so(v, T),
        (c.current.lanes = E),
        gu(c, E, M),
        Si(c, M),
        c
      );
    }),
    (t.createPortal = function (c, f, v) {
      var M =
        3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return {
        $$typeof: u,
        key: M == null ? null : "" + M,
        children: c,
        containerInfo: f,
        implementation: v,
      };
    }),
    (t.createRoleSelector = function (c) {
      return { $$typeof: Bd, value: c };
    }),
    (t.createTestNameSelector = function (c) {
      return { $$typeof: Rd, value: c };
    }),
    (t.createTextSelector = function (c) {
      return { $$typeof: Ld, value: c };
    }),
    (t.deferredUpdates = function (c) {
      var f = Rt,
        v = mn.transition;
      try {
        return ((mn.transition = null), (Rt = 16), c());
      } finally {
        ((Rt = f), (mn.transition = v));
      }
    }),
    (t.discreteUpdates = function (c, f, v, M, E) {
      var T = Rt,
        k = mn.transition;
      try {
        return ((mn.transition = null), (Rt = 1), c(f, v, M, E));
      } finally {
        ((Rt = T), (mn.transition = k), _t === 0 && Ll());
      }
    }),
    (t.findAllNodes = Y0),
    (t.findBoundingRects = function (c, f) {
      if (!nt) throw Error(o(363));
      ((f = Y0(c, f)), (c = []));
      for (var v = 0; v < f.length; v++) c.push(O(f[v]));
      for (f = c.length - 1; 0 < f; f--) {
        v = c[f];
        for (
          var M = v.x, E = M + v.width, T = v.y, k = T + v.height, Y = f - 1;
          0 <= Y;
          Y--
        )
          if (f !== Y) {
            var he = c[Y],
              Be = he.x,
              Ge = Be + he.width,
              lt = he.y,
              tt = lt + he.height;
            if (M >= Be && T >= lt && E <= Ge && k <= tt) {
              c.splice(f, 1);
              break;
            } else if (M !== Be || v.width !== he.width || tt < T || lt > k) {
              if (!(T !== lt || v.height !== he.height || Ge < M || Be > E)) {
                (Be > M && ((he.width += Be - M), (he.x = M)),
                  Ge < E && (he.width = E - Be),
                  c.splice(f, 1));
                break;
              }
            } else {
              (lt > T && ((he.height += lt - T), (he.y = T)),
                tt < k && (he.height = k - lt),
                c.splice(f, 1));
              break;
            }
          }
      }
      return c;
    }),
    (t.findHostInstance = jS),
    (t.findHostInstanceWithNoPortals = function (c) {
      return (
        (c = U(c)),
        (c = c !== null ? j(c) : null),
        c === null ? null : c.stateNode
      );
    }),
    (t.findHostInstanceWithWarning = function (c) {
      return jS(c);
    }),
    (t.flushControlled = function (c) {
      var f = _t;
      _t |= 1;
      var v = mn.transition,
        M = Rt;
      try {
        ((mn.transition = null), (Rt = 1), c());
      } finally {
        ((Rt = M), (mn.transition = v), (_t = f), _t === 0 && (Ll(), Qr()));
      }
    }),
    (t.flushPassiveEffects = pa),
    (t.flushSync = DS),
    (t.focusWithin = function (c, f) {
      if (!nt) throw Error(o(363));
      for (c = J0(c), f = RS(c, f), f = Array.from(f), c = 0; c < f.length; ) {
        var v = f[c++];
        if (!le(v)) {
          if (v.tag === 5 && Te(v.stateNode)) return !0;
          for (v = v.child; v !== null; ) (f.push(v), (v = v.sibling));
        }
      }
      return !1;
    }),
    (t.getCurrentUpdatePriority = function () {
      return Rt;
    }),
    (t.getFindAllNodesFailureDescription = function (c, f) {
      if (!nt) throw Error(o(363));
      var v = 0,
        M = [];
      c = [J0(c), 0];
      for (var E = 0; E < c.length; ) {
        var T = c[E++],
          k = c[E++],
          Y = f[k];
        if (
          (T.tag !== 5 || !le(T)) &&
          (X0(T, Y) && (M.push(K0(Y)), k++, k > v && (v = k)), k < f.length)
        )
          for (T = T.child; T !== null; ) (c.push(T, k), (T = T.sibling));
      }
      if (v < f.length) {
        for (c = []; v < f.length; v++) c.push(K0(f[v]));
        return (
          `findAllNodes was able to match part of the selector:
  ` +
          (M.join(" > ") +
            `

No matching component was found for:
  `) +
          c.join(" > ")
        );
      }
      return null;
    }),
    (t.getPublicRootInstance = function (c) {
      if (((c = c.current), !c.child)) return null;
      switch (c.child.tag) {
        case 5:
          return oe(c.child.stateNode);
        default:
          return c.child.stateNode;
      }
    }),
    (t.injectIntoDevTools = function (c) {
      if (
        ((c = {
          bundleType: c.bundleType,
          version: c.version,
          rendererPackageName: c.rendererPackageName,
          rendererConfig: c.rendererConfig,
          overrideHookState: null,
          overrideHookStateDeletePath: null,
          overrideHookStateRenamePath: null,
          overrideProps: null,
          overridePropsDeletePath: null,
          overridePropsRenamePath: null,
          setErrorHandler: null,
          setSuspenseHandler: null,
          scheduleUpdate: null,
          currentDispatcherRef: a.ReactCurrentDispatcher,
          findHostInstanceByFiber: PI,
          findFiberByHostInstance: c.findFiberByHostInstance || BI,
          findHostInstancesForRefresh: null,
          scheduleRefresh: null,
          scheduleRoot: null,
          setRefreshHandler: null,
          getCurrentFiber: null,
          reconcilerVersion: "18.0.0-fc46dba67-20220329",
        }),
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
      )
        c = !1;
      else {
        var f = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (f.isDisabled || !f.supportsFiber) c = !0;
        else {
          try {
            ((td = f.inject(c)), (Kr = f));
          } catch {}
          c = !!f.checkDCE;
        }
      }
      return c;
    }),
    (t.isAlreadyRendering = function () {
      return !1;
    }),
    (t.observeVisibleRects = function (c, f, v, M) {
      if (!nt) throw Error(o(363));
      c = Y0(c, f);
      var E = Re(c, v, M).disconnect;
      return {
        disconnect: function () {
          E();
        },
      };
    }),
    (t.registerMutableSourceForHydration = function (c, f) {
      var v = f._getVersion;
      ((v = v(f._source)),
        c.mutableSourceEagerHydrationData == null
          ? (c.mutableSourceEagerHydrationData = [f, v])
          : c.mutableSourceEagerHydrationData.push(f, v));
    }),
    (t.runWithPriority = function (c, f) {
      var v = Rt;
      try {
        return ((Rt = c), f());
      } finally {
        Rt = v;
      }
    }),
    (t.shouldError = function () {
      return null;
    }),
    (t.shouldSuspend = function () {
      return !1;
    }),
    (t.updateContainer = function (c, f, v, M) {
      var E = f.current,
        T = fi(),
        k = lo(E);
      return (
        (v = WS(v)),
        f.context === null ? (f.context = v) : (f.pendingContext = v),
        (f = vs(T, k)),
        (f.payload = { element: c }),
        (M = M === void 0 ? null : M),
        M !== null && (f.callback = M),
        so(E, f),
        (c = or(E, k, T)),
        c !== null && od(c, E, k),
        k
      );
    }),
    t
  );
};
(function (n) {
  n.exports = H5;
})(O5);
const V5 = Cb(M_);
var $m = {},
  W5 = {
    get exports() {
      return $m;
    },
    set exports(n) {
      $m = n;
    },
  },
  UR = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (n) {
  function e(I, G) {
    var z = I.length;
    I.push(G);
    e: for (; 0 < z; ) {
      var q = (z - 1) >>> 1,
        Q = I[q];
      if (0 < r(Q, G)) ((I[q] = G), (I[z] = Q), (z = q));
      else break e;
    }
  }
  function t(I) {
    return I.length === 0 ? null : I[0];
  }
  function i(I) {
    if (I.length === 0) return null;
    var G = I[0],
      z = I.pop();
    if (z !== G) {
      I[0] = z;
      e: for (var q = 0, Q = I.length, ee = Q >>> 1; q < ee; ) {
        var ne = 2 * (q + 1) - 1,
          Ee = I[ne],
          Ae = ne + 1,
          $ = I[Ae];
        if (0 > r(Ee, z))
          Ae < Q && 0 > r($, Ee)
            ? ((I[q] = $), (I[Ae] = z), (q = Ae))
            : ((I[q] = Ee), (I[ne] = z), (q = ne));
        else if (Ae < Q && 0 > r($, z)) ((I[q] = $), (I[Ae] = z), (q = Ae));
        else break e;
      }
    }
    return G;
  }
  function r(I, G) {
    var z = I.sortIndex - G.sortIndex;
    return z !== 0 ? z : I.id - G.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    n.unstable_now = function () {
      return s.now();
    };
  } else {
    var o = Date,
      a = o.now();
    n.unstable_now = function () {
      return o.now() - a;
    };
  }
  var l = [],
    u = [],
    h = 1,
    d = null,
    p = 3,
    g = !1,
    y = !1,
    A = !1,
    _ = typeof setTimeout == "function" ? setTimeout : null,
    m = typeof clearTimeout == "function" ? clearTimeout : null,
    x = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function S(I) {
    for (var G = t(u); G !== null; ) {
      if (G.callback === null) i(u);
      else if (G.startTime <= I)
        (i(u), (G.sortIndex = G.expirationTime), e(l, G));
      else break;
      G = t(u);
    }
  }
  function w(I) {
    if (((A = !1), S(I), !y))
      if (t(l) !== null) ((y = !0), oe(C));
      else {
        var G = t(u);
        G !== null && ae(w, G.startTime - I);
      }
  }
  function C(I, G) {
    ((y = !1), A && ((A = !1), m(B), (B = -1)), (g = !0));
    var z = p;
    try {
      for (
        S(G), d = t(l);
        d !== null && (!(d.expirationTime > G) || (I && !U()));

      ) {
        var q = d.callback;
        if (typeof q == "function") {
          ((d.callback = null), (p = d.priorityLevel));
          var Q = q(d.expirationTime <= G);
          ((G = n.unstable_now()),
            typeof Q == "function" ? (d.callback = Q) : d === t(l) && i(l),
            S(G));
        } else i(l);
        d = t(l);
      }
      if (d !== null) var ee = !0;
      else {
        var ne = t(u);
        (ne !== null && ae(w, ne.startTime - G), (ee = !1));
      }
      return ee;
    } finally {
      ((d = null), (p = z), (g = !1));
    }
  }
  var P = !1,
    R = null,
    B = -1,
    b = 5,
    L = -1;
  function U() {
    return !(n.unstable_now() - L < b);
  }
  function J() {
    if (R !== null) {
      var I = n.unstable_now();
      L = I;
      var G = !0;
      try {
        G = R(!0, I);
      } finally {
        G ? V() : ((P = !1), (R = null));
      }
    } else P = !1;
  }
  var V;
  if (typeof x == "function")
    V = function () {
      x(J);
    };
  else if (typeof MessageChannel < "u") {
    var j = new MessageChannel(),
      X = j.port2;
    ((j.port1.onmessage = J),
      (V = function () {
        X.postMessage(null);
      }));
  } else
    V = function () {
      _(J, 0);
    };
  function oe(I) {
    ((R = I), P || ((P = !0), V()));
  }
  function ae(I, G) {
    B = _(function () {
      I(n.unstable_now());
    }, G);
  }
  ((n.unstable_IdlePriority = 5),
    (n.unstable_ImmediatePriority = 1),
    (n.unstable_LowPriority = 4),
    (n.unstable_NormalPriority = 3),
    (n.unstable_Profiling = null),
    (n.unstable_UserBlockingPriority = 2),
    (n.unstable_cancelCallback = function (I) {
      I.callback = null;
    }),
    (n.unstable_continueExecution = function () {
      y || g || ((y = !0), oe(C));
    }),
    (n.unstable_forceFrameRate = function (I) {
      0 > I || 125 < I
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (b = 0 < I ? Math.floor(1e3 / I) : 5);
    }),
    (n.unstable_getCurrentPriorityLevel = function () {
      return p;
    }),
    (n.unstable_getFirstCallbackNode = function () {
      return t(l);
    }),
    (n.unstable_next = function (I) {
      switch (p) {
        case 1:
        case 2:
        case 3:
          var G = 3;
          break;
        default:
          G = p;
      }
      var z = p;
      p = G;
      try {
        return I();
      } finally {
        p = z;
      }
    }),
    (n.unstable_pauseExecution = function () {}),
    (n.unstable_requestPaint = function () {}),
    (n.unstable_runWithPriority = function (I, G) {
      switch (I) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          I = 3;
      }
      var z = p;
      p = I;
      try {
        return G();
      } finally {
        p = z;
      }
    }),
    (n.unstable_scheduleCallback = function (I, G, z) {
      var q = n.unstable_now();
      switch (
        (typeof z == "object" && z !== null
          ? ((z = z.delay), (z = typeof z == "number" && 0 < z ? q + z : q))
          : (z = q),
        I)
      ) {
        case 1:
          var Q = -1;
          break;
        case 2:
          Q = 250;
          break;
        case 5:
          Q = 1073741823;
          break;
        case 4:
          Q = 1e4;
          break;
        default:
          Q = 5e3;
      }
      return (
        (Q = z + Q),
        (I = {
          id: h++,
          callback: G,
          priorityLevel: I,
          startTime: z,
          expirationTime: Q,
          sortIndex: -1,
        }),
        z > q
          ? ((I.sortIndex = z),
            e(u, I),
            t(l) === null &&
              I === t(u) &&
              (A ? (m(B), (B = -1)) : (A = !0), ae(w, z - q)))
          : ((I.sortIndex = Q), e(l, I), y || g || ((y = !0), oe(C))),
        I
      );
    }),
    (n.unstable_shouldYield = U),
    (n.unstable_wrapCallback = function (I) {
      var G = p;
      return function () {
        var z = p;
        p = G;
        try {
          return I.apply(this, arguments);
        } finally {
          p = z;
        }
      };
    }));
})(UR);
(function (n) {
  n.exports = UR;
})(W5);
function zR(n, e, t = (i, r) => i === r) {
  if (n === e) return !0;
  if (!n || !e) return !1;
  const i = n.length;
  if (e.length !== i) return !1;
  for (let r = 0; r < i; r++) if (!t(n[r], e[r])) return !1;
  return !0;
}
const Ds = [];
function GR(n, e, t = !1, i = {}) {
  for (const s of Ds)
    if (zR(e, s.keys, s.equal)) {
      if (t) return;
      if (Object.prototype.hasOwnProperty.call(s, "error")) throw s.error;
      if (Object.prototype.hasOwnProperty.call(s, "response"))
        return s.response;
      if (!t) throw s.promise;
    }
  const r = {
    keys: e,
    equal: i.equal,
    promise: n(...e)
      .then((s) => (r.response = s))
      .then(() => {
        i.lifespan &&
          i.lifespan > 0 &&
          setTimeout(() => {
            const s = Ds.indexOf(r);
            s !== -1 && Ds.splice(s, 1);
          }, i.lifespan);
      })
      .catch((s) => (r.error = s)),
  };
  if ((Ds.push(r), !t)) throw r.promise;
}
const j5 = (n, e, t) => GR(n, e, !1, t),
  J5 = (n, e, t) => void GR(n, e, !0, t),
  X5 = (n) => {
    if (n === void 0 || n.length === 0) Ds.splice(0, Ds.length);
    else {
      const e = Ds.find((t) => zR(n, t.keys, t.equal));
      if (e) {
        const t = Ds.indexOf(e);
        t !== -1 && Ds.splice(t, 1);
      }
    }
  },
  DA = {},
  K5 = (n) => void Object.assign(DA, n);
function Y5(n, e) {
  function t(h, { args: d = [], attach: p, ...g }, y) {
    let A = `${h[0].toUpperCase()}${h.slice(1)}`,
      _;
    if (h === "primitive") {
      if (g.object === void 0)
        throw new Error("R3F: Primitives without 'object' are invalid!");
      const m = g.object;
      _ = ic(m, { type: h, root: y, attach: p, primitive: !0 });
    } else {
      const m = DA[A];
      if (!m)
        throw new Error(
          `R3F: ${A} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`
        );
      if (!Array.isArray(d))
        throw new Error("R3F: The args prop must be an array!");
      _ = ic(new m(...d), {
        type: h,
        root: y,
        attach: p,
        memoizedProps: { args: d },
      });
    }
    return (
      _.__r3f.attach === void 0 &&
        (_ instanceof ft
          ? (_.__r3f.attach = "geometry")
          : _ instanceof En && (_.__r3f.attach = "material")),
      A !== "inject" && vy(_, g),
      _
    );
  }
  function i(h, d) {
    let p = !1;
    if (d) {
      var g, y;
      ((g = d.__r3f) != null && g.attach
        ? gy(h, d, d.__r3f.attach)
        : d.isObject3D && h.isObject3D && (h.add(d), (p = !0)),
        p || (y = h.__r3f) == null || y.objects.push(d),
        d.__r3f || ic(d, {}),
        (d.__r3f.parent = h),
        w_(d),
        rc(d));
    }
  }
  function r(h, d, p) {
    let g = !1;
    if (d) {
      var y, A;
      if ((y = d.__r3f) != null && y.attach) gy(h, d, d.__r3f.attach);
      else if (d.isObject3D && h.isObject3D) {
        ((d.parent = h), d.dispatchEvent({ type: "added" }));
        const _ = h.children.filter((x) => x !== d),
          m = _.indexOf(p);
        ((h.children = [..._.slice(0, m), d, ..._.slice(m)]), (g = !0));
      }
      (g || (A = h.__r3f) == null || A.objects.push(d),
        d.__r3f || ic(d, {}),
        (d.__r3f.parent = h),
        w_(d),
        rc(d));
    }
  }
  function s(h, d, p = !1) {
    h && [...h].forEach((g) => o(d, g, p));
  }
  function o(h, d, p) {
    if (d) {
      var g, y, A;
      if (
        (d.__r3f && (d.__r3f.parent = null),
        (g = h.__r3f) != null &&
          g.objects &&
          (h.__r3f.objects = h.__r3f.objects.filter((w) => w !== d)),
        (y = d.__r3f) != null && y.attach)
      )
        GC(h, d, d.__r3f.attach);
      else if (d.isObject3D && h.isObject3D) {
        var _;
        (h.remove(d), (_ = d.__r3f) != null && _.root && iV(d.__r3f.root, d));
      }
      const x = (A = d.__r3f) == null ? void 0 : A.primitive,
        S = p === void 0 ? d.dispose !== null && !x : p;
      if (!x) {
        var m;
        (s((m = d.__r3f) == null ? void 0 : m.objects, d, S),
          s(d.children, d, S));
      }
      (d.__r3f &&
        (delete d.__r3f.root,
        delete d.__r3f.objects,
        delete d.__r3f.handlers,
        delete d.__r3f.memoizedProps,
        x || delete d.__r3f),
        S &&
          d.dispose &&
          d.type !== "Scene" &&
          $m.unstable_scheduleCallback($m.unstable_IdlePriority, () => {
            try {
              d.dispose();
            } catch {}
          }),
        rc(h));
    }
  }
  function a(h, d, p, g) {
    var y;
    const A = (y = h.__r3f) == null ? void 0 : y.parent;
    if (!A) return;
    const _ = t(d, p, h.__r3f.root);
    if (h.children) {
      for (const m of h.children) m.__r3f && i(_, m);
      h.children = h.children.filter((m) => !m.__r3f);
    }
    (h.__r3f.objects.forEach((m) => i(_, m)),
      (h.__r3f.objects = []),
      h.__r3f.autoRemovedBeforeAppend || o(A, h),
      _.parent && (_.__r3f.autoRemovedBeforeAppend = !0),
      i(A, _),
      _.raycast &&
        _.__r3f.eventCount &&
        _.__r3f.root.getState().internal.interaction.push(_),
      [g, g.alternate].forEach((m) => {
        m !== null &&
          ((m.stateNode = _),
          m.ref &&
            (typeof m.ref == "function" ? m.ref(_) : (m.ref.current = _)));
      }));
  }
  const l = () =>
    console.warn(
      "Text is not allowed in the R3F tree! This could be stray whitespace or characters."
    );
  return {
    reconciler: V5({
      createInstance: t,
      removeChild: o,
      appendChild: i,
      appendInitialChild: i,
      insertBefore: r,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (h, d) => {
        if (!d) return;
        const p = h.getState().scene;
        p.__r3f && ((p.__r3f.root = h), i(p, d));
      },
      removeChildFromContainer: (h, d) => {
        d && o(h.getState().scene, d);
      },
      insertInContainerBefore: (h, d, p) => {
        if (!d || !p) return;
        const g = h.getState().scene;
        g.__r3f && r(g, d, p);
      },
      getRootHostContext: () => null,
      getChildHostContext: (h) => h,
      finalizeInitialChildren(h) {
        var d;
        return !!((d = h == null ? void 0 : h.__r3f) != null ? d : {}).handlers;
      },
      prepareUpdate(h, d, p, g) {
        if (h.__r3f.primitive && g.object && g.object !== h) return [!0];
        {
          const { args: y = [], children: A, ..._ } = g,
            { args: m = [], children: x, ...S } = p;
          if (!Array.isArray(y))
            throw new Error("R3F: the args prop must be an array!");
          if (y.some((C, P) => C !== m[P])) return [!0];
          const w = KR(h, _, S, !0);
          return w.changes.length ? [!1, w] : null;
        }
      },
      commitUpdate(h, [d, p], g, y, A, _) {
        d ? a(h, g, A, _) : vy(h, p);
      },
      commitMount(h, d, p, g) {
        var y;
        const A = (y = h.__r3f) != null ? y : {};
        h.raycast &&
          A.handlers &&
          A.eventCount &&
          h.__r3f.root.getState().internal.interaction.push(h);
      },
      getPublicInstance: (h) => h,
      prepareForCommit: () => null,
      preparePortalMount: (h) => ic(h.getState().scene),
      resetAfterCommit: () => {},
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(h) {
        var d;
        const { attach: p, parent: g } = (d = h.__r3f) != null ? d : {};
        (p && g && GC(g, h, p), h.isObject3D && (h.visible = !1), rc(h));
      },
      unhideInstance(h, d) {
        var p;
        const { attach: g, parent: y } = (p = h.__r3f) != null ? p : {};
        (g && y && gy(y, h, g),
          ((h.isObject3D && d.visible == null) || d.visible) &&
            (h.visible = !0),
          rc(h));
      },
      createTextInstance: l,
      hideTextInstance: l,
      unhideTextInstance: l,
      getCurrentEventPriority: () => (e ? e() : Lo.DefaultEventPriority),
      beforeActiveInstanceBlur: () => {},
      afterActiveInstanceBlur: () => {},
      detachDeletedInstance: () => {},
      now:
        typeof performance < "u" && Kt.fun(performance.now)
          ? performance.now
          : Kt.fun(Date.now)
            ? Date.now
            : () => 0,
      scheduleTimeout: Kt.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: Kt.fun(clearTimeout) ? clearTimeout : void 0,
    }),
    applyProps: vy,
  };
}
var kC, OC;
const HR = () => {
    var n;
    return (n = DA.ColorManagement) != null ? n : null;
  },
  VR = (n) => n && n.isOrthographicCamera,
  Q5 = (n) => n && n.hasOwnProperty("current"),
  Hh =
    typeof window < "u" &&
    (((kC = window.document) != null && kC.createElement) ||
      ((OC = window.navigator) == null ? void 0 : OC.product) === "ReactNative")
      ? H.useLayoutEffect
      : H.useEffect;
function WR(n) {
  const e = H.useRef(n);
  return (Hh(() => void (e.current = n), [n]), e);
}
function Z5({ set: n }) {
  return (Hh(() => (n(new Promise(() => null)), () => n(!1)), [n]), null);
}
class jR extends H.Component {
  constructor(...e) {
    (super(...e), (this.state = { error: !1 }));
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
jR.getDerivedStateFromError = () => ({ error: !0 });
const JR = "__default",
  UC = new Map(),
  q5 = (n) => n && !!n.memoized && !!n.changes;
function XR(n) {
  const e = typeof window < "u" ? window.devicePixelRatio : 1;
  return Array.isArray(n) ? Math.min(Math.max(n[0], e), n[1]) : n;
}
const qu = (n) => {
    var e;
    return (e = n.__r3f) == null ? void 0 : e.root.getState();
  },
  Kt = {
    obj: (n) => n === Object(n) && !Kt.arr(n) && typeof n != "function",
    fun: (n) => typeof n == "function",
    str: (n) => typeof n == "string",
    num: (n) => typeof n == "number",
    boo: (n) => typeof n == "boolean",
    und: (n) => n === void 0,
    arr: (n) => Array.isArray(n),
    equ(
      n,
      e,
      { arrays: t = "shallow", objects: i = "reference", strict: r = !0 } = {}
    ) {
      if (typeof n != typeof e || !!n != !!e) return !1;
      if (Kt.str(n) || Kt.num(n)) return n === e;
      const s = Kt.obj(n);
      if (s && i === "reference") return n === e;
      const o = Kt.arr(n);
      if (o && t === "reference") return n === e;
      if ((o || s) && n === e) return !0;
      let a;
      for (a in n) if (!(a in e)) return !1;
      if (s && t === "shallow" && i === "shallow") {
        for (a in r ? e : n)
          if (!Kt.equ(n[a], e[a], { strict: r, objects: "reference" }))
            return !1;
      } else for (a in r ? e : n) if (n[a] !== e[a]) return !1;
      if (Kt.und(a)) {
        if (
          (o && n.length === 0 && e.length === 0) ||
          (s && Object.keys(n).length === 0 && Object.keys(e).length === 0)
        )
          return !0;
        if (n !== e) return !1;
      }
      return !0;
    },
  };
function $5(n) {
  const e = { nodes: {}, materials: {} };
  return (
    n &&
      n.traverse((t) => {
        (t.name && (e.nodes[t.name] = t),
          t.material &&
            !e.materials[t.material.name] &&
            (e.materials[t.material.name] = t.material));
      }),
    e
  );
}
function eV(n) {
  n.dispose && n.type !== "Scene" && n.dispose();
  for (const e in n) (e.dispose == null || e.dispose(), delete n[e]);
}
function ic(n, e) {
  const t = n;
  return (
    ((e != null && e.primitive) || !t.__r3f) &&
      (t.__r3f = {
        type: "",
        root: null,
        previousAttach: null,
        memoizedProps: {},
        eventCount: 0,
        handlers: {},
        objects: [],
        parent: null,
        ...e,
      }),
    n
  );
}
function S_(n, e) {
  let t = n;
  if (e.includes("-")) {
    const i = e.split("-"),
      r = i.pop();
    return ((t = i.reduce((s, o) => s[o], n)), { target: t, key: r });
  } else return { target: t, key: e };
}
const zC = /-\d+$/;
function gy(n, e, t) {
  if (Kt.str(t)) {
    if (zC.test(t)) {
      const s = t.replace(zC, ""),
        { target: o, key: a } = S_(n, s);
      Array.isArray(o[a]) || (o[a] = []);
    }
    const { target: i, key: r } = S_(n, t);
    ((e.__r3f.previousAttach = i[r]), (i[r] = e));
  } else e.__r3f.previousAttach = t(n, e);
}
function GC(n, e, t) {
  var i, r;
  if (Kt.str(t)) {
    const { target: s, key: o } = S_(n, t),
      a = e.__r3f.previousAttach;
    a === void 0 ? delete s[o] : (s[o] = a);
  } else
    (i = e.__r3f) == null || i.previousAttach == null || i.previousAttach(n, e);
  (r = e.__r3f) == null || delete r.previousAttach;
}
function KR(
  n,
  { children: e, key: t, ref: i, ...r },
  { children: s, key: o, ref: a, ...l } = {},
  u = !1
) {
  var h;
  const d = (h = n == null ? void 0 : n.__r3f) != null ? h : {},
    p = Object.entries(r),
    g = [];
  if (u) {
    const A = Object.keys(l);
    for (let _ = 0; _ < A.length; _++)
      r.hasOwnProperty(A[_]) || p.unshift([A[_], JR + "remove"]);
  }
  p.forEach(([A, _]) => {
    var m;
    if (
      ((m = n.__r3f) != null && m.primitive && A === "object") ||
      Kt.equ(_, l[A])
    )
      return;
    if (/^on(LostPointer|Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(A))
      return g.push([A, _, !0, []]);
    let x = [];
    (A.includes("-") && (x = A.split("-")), g.push([A, _, !1, x]));
    for (const S in r) {
      const w = r[S];
      S.startsWith(`${A}-`) && g.push([S, w, !1, S.split("-")]);
    }
  });
  const y = { ...r };
  return (
    d.memoizedProps && d.memoizedProps.args && (y.args = d.memoizedProps.args),
    d.memoizedProps &&
      d.memoizedProps.attach &&
      (y.attach = d.memoizedProps.attach),
    { memoized: y, changes: g }
  );
}
function vy(n, e) {
  var t, i, r;
  const s = (t = n.__r3f) != null ? t : {},
    o = s.root,
    a =
      (i = o == null || o.getState == null ? void 0 : o.getState()) != null
        ? i
        : {},
    { memoized: l, changes: u } = q5(e) ? e : KR(n, e),
    h = s.eventCount;
  n.__r3f && (n.__r3f.memoizedProps = l);
  for (let p = 0; p < u.length; p++) {
    let [g, y, A, _] = u[p],
      m = n,
      x = m[g];
    if (_.length && ((x = _.reduce((S, w) => S[w], n)), !(x && x.set))) {
      const [S, ...w] = _.reverse();
      ((m = w.reverse().reduce((C, P) => C[P], n)), (g = S));
    }
    if (y === JR + "remove")
      if (m.constructor) {
        let S = UC.get(m.constructor);
        (S || ((S = new m.constructor()), UC.set(m.constructor, S)),
          (y = S[g]));
      } else y = 0;
    if (A)
      (y ? (s.handlers[g] = y) : delete s.handlers[g],
        (s.eventCount = Object.keys(s.handlers).length));
    else if (x && x.set && (x.copy || x instanceof qa)) {
      if (Array.isArray(y)) x.fromArray ? x.fromArray(y) : x.set(...y);
      else if (x.copy && y && y.constructor && x.constructor === y.constructor)
        x.copy(y);
      else if (y !== void 0) {
        const S = x instanceof Ie;
        (!S && x.setScalar
          ? x.setScalar(y)
          : x instanceof qa && y instanceof qa
            ? (x.mask = y.mask)
            : x.set(y),
          !HR() && !a.linear && S && x.convertSRGBToLinear());
      }
    } else
      ((m[g] = y),
        !a.linear &&
          m[g] instanceof en &&
          m[g].format === Pi &&
          m[g].type === Ys &&
          (m[g].encoding = Tt));
    rc(n);
  }
  if (s.parent && a.internal && n.raycast && h !== s.eventCount) {
    const p = a.internal.interaction.indexOf(n);
    (p > -1 && a.internal.interaction.splice(p, 1),
      s.eventCount && a.internal.interaction.push(n));
  }
  return (
    !(u.length === 1 && u[0][0] === "onUpdate") &&
      u.length &&
      (r = n.__r3f) != null &&
      r.parent &&
      w_(n),
    n
  );
}
function rc(n) {
  var e, t;
  const i =
    (e = n.__r3f) == null || (t = e.root) == null || t.getState == null
      ? void 0
      : t.getState();
  i && i.internal.frames === 0 && i.invalidate();
}
function w_(n) {
  n.onUpdate == null || n.onUpdate(n);
}
function tV(n, e) {
  n.manual ||
    (VR(n)
      ? ((n.left = e.width / -2),
        (n.right = e.width / 2),
        (n.top = e.height / 2),
        (n.bottom = e.height / -2))
      : (n.aspect = e.width / e.height),
    n.updateProjectionMatrix(),
    n.updateMatrixWorld());
}
function Kp(n) {
  return (n.eventObject || n.object).uuid + "/" + n.index + n.instanceId;
}
function nV() {
  var n;
  const e = (typeof self < "u" && self) || (typeof window < "u" && window);
  if (!e) return Lo.DefaultEventPriority;
  switch ((n = e.event) == null ? void 0 : n.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return Lo.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return Lo.ContinuousEventPriority;
    default:
      return Lo.DefaultEventPriority;
  }
}
function YR(n, e, t, i) {
  const r = t.get(e);
  r &&
    (t.delete(e),
    t.size === 0 && (n.delete(i), r.target.releasePointerCapture(i)));
}
function iV(n, e) {
  const { internal: t } = n.getState();
  ((t.interaction = t.interaction.filter((i) => i !== e)),
    (t.initialHits = t.initialHits.filter((i) => i !== e)),
    t.hovered.forEach((i, r) => {
      (i.eventObject === e || i.object === e) && t.hovered.delete(r);
    }),
    t.capturedMap.forEach((i, r) => {
      YR(t.capturedMap, e, i, r);
    }));
}
function rV(n) {
  function e(l) {
    const { internal: u } = n.getState(),
      h = l.offsetX - u.initialClick[0],
      d = l.offsetY - u.initialClick[1];
    return Math.round(Math.sqrt(h * h + d * d));
  }
  function t(l) {
    return l.filter((u) =>
      ["Move", "Over", "Enter", "Out", "Leave"].some((h) => {
        var d;
        return (d = u.__r3f) == null ? void 0 : d.handlers["onPointer" + h];
      })
    );
  }
  function i(l, u) {
    const h = n.getState(),
      d = new Set(),
      p = [],
      g = u ? u(h.internal.interaction) : h.internal.interaction;
    for (let m = 0; m < g.length; m++) {
      const x = qu(g[m]);
      x && (x.raycaster.camera = void 0);
    }
    h.previousRoot || h.events.compute == null || h.events.compute(l, h);
    function y(m) {
      const x = qu(m);
      if (!x || !x.events.enabled || x.raycaster.camera === null) return [];
      if (x.raycaster.camera === void 0) {
        var S;
        (x.events.compute == null ||
          x.events.compute(
            l,
            x,
            (S = x.previousRoot) == null ? void 0 : S.getState()
          ),
          x.raycaster.camera === void 0 && (x.raycaster.camera = null));
      }
      return x.raycaster.camera ? x.raycaster.intersectObject(m, !0) : [];
    }
    let A = g
      .flatMap(y)
      .sort((m, x) => {
        const S = qu(m.object),
          w = qu(x.object);
        return !S || !w
          ? m.distance - x.distance
          : w.events.priority - S.events.priority || m.distance - x.distance;
      })
      .filter((m) => {
        const x = Kp(m);
        return d.has(x) ? !1 : (d.add(x), !0);
      });
    h.events.filter && (A = h.events.filter(A, h));
    for (const m of A) {
      let x = m.object;
      for (; x; ) {
        var _;
        ((_ = x.__r3f) != null &&
          _.eventCount &&
          p.push({ ...m, eventObject: x }),
          (x = x.parent));
      }
    }
    if ("pointerId" in l && h.internal.capturedMap.has(l.pointerId))
      for (let m of h.internal.capturedMap.get(l.pointerId).values())
        d.has(Kp(m.intersection)) || p.push(m.intersection);
    return p;
  }
  function r(l, u, h, d) {
    const p = n.getState();
    if (l.length) {
      const g = { stopped: !1 };
      for (const y of l) {
        const A = qu(y.object) || p,
          { raycaster: _, pointer: m, camera: x, internal: S } = A,
          w = new F(m.x, m.y, 0).unproject(x),
          C = (L) => {
            var U, J;
            return (U =
              (J = S.capturedMap.get(L)) == null
                ? void 0
                : J.has(y.eventObject)) != null
              ? U
              : !1;
          },
          P = (L) => {
            const U = { intersection: y, target: u.target };
            (S.capturedMap.has(L)
              ? S.capturedMap.get(L).set(y.eventObject, U)
              : S.capturedMap.set(L, new Map([[y.eventObject, U]])),
              u.target.setPointerCapture(L));
          },
          R = (L) => {
            const U = S.capturedMap.get(L);
            U && YR(S.capturedMap, y.eventObject, U, L);
          };
        let B = {};
        for (let L in u) {
          let U = u[L];
          typeof U != "function" && (B[L] = U);
        }
        let b = {
          ...y,
          ...B,
          pointer: m,
          intersections: l,
          stopped: g.stopped,
          delta: h,
          unprojectedPoint: w,
          ray: _.ray,
          camera: x,
          stopPropagation() {
            const L = "pointerId" in u && S.capturedMap.get(u.pointerId);
            if (
              (!L || L.has(y.eventObject)) &&
              ((b.stopped = g.stopped = !0),
              S.hovered.size &&
                Array.from(S.hovered.values()).find(
                  (U) => U.eventObject === y.eventObject
                ))
            ) {
              const U = l.slice(0, l.indexOf(y));
              s([...U, y]);
            }
          },
          target: {
            hasPointerCapture: C,
            setPointerCapture: P,
            releasePointerCapture: R,
          },
          currentTarget: {
            hasPointerCapture: C,
            setPointerCapture: P,
            releasePointerCapture: R,
          },
          nativeEvent: u,
        };
        if ((d(b), g.stopped === !0)) break;
      }
    }
    return l;
  }
  function s(l) {
    const { internal: u } = n.getState();
    for (const h of u.hovered.values())
      if (
        !l.length ||
        !l.find(
          (d) =>
            d.object === h.object &&
            d.index === h.index &&
            d.instanceId === h.instanceId
        )
      ) {
        const p = h.eventObject.__r3f,
          g = p == null ? void 0 : p.handlers;
        if ((u.hovered.delete(Kp(h)), p != null && p.eventCount)) {
          const y = { ...h, intersections: l };
          (g.onPointerOut == null || g.onPointerOut(y),
            g.onPointerLeave == null || g.onPointerLeave(y));
        }
      }
  }
  function o(l, u) {
    for (let h = 0; h < u.length; h++) {
      const d = u[h].__r3f;
      d == null ||
        d.handlers.onPointerMissed == null ||
        d.handlers.onPointerMissed(l);
    }
  }
  function a(l) {
    switch (l) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => s([]);
    }
    return function (h) {
      const { onPointerMissed: d, internal: p } = n.getState();
      p.lastEvent.current = h;
      const g = l === "onPointerMove",
        y = l === "onLostPointerCapture",
        A = l === "onClick" || l === "onContextMenu" || l === "onDoubleClick",
        m = i(h, g ? t : void 0),
        x = A ? e(h) : 0;
      (l === "onPointerDown" &&
        ((p.initialClick = [h.offsetX, h.offsetY]),
        (p.initialHits = m.map((w) => w.eventObject))),
        A && !m.length && x <= 2 && (o(h, p.interaction), d && d(h)),
        g && s(m));
      function S(w) {
        const C = w.eventObject,
          P = C.__r3f,
          R = P == null ? void 0 : P.handlers;
        if (P != null && P.eventCount)
          if (g) {
            if (
              R.onPointerOver ||
              R.onPointerEnter ||
              R.onPointerOut ||
              R.onPointerLeave
            ) {
              const B = Kp(w),
                b = p.hovered.get(B);
              b
                ? b.stopped && w.stopPropagation()
                : (p.hovered.set(B, w),
                  R.onPointerOver == null || R.onPointerOver(w),
                  R.onPointerEnter == null || R.onPointerEnter(w));
            }
            R.onPointerMove == null || R.onPointerMove(w);
          } else if (y) {
            const { internal: B } = n.getState();
            "pointerId" in h &&
              B.capturedMap.has(h.pointerId) &&
              requestAnimationFrame(() => {
                B.capturedMap.has(h.pointerId) &&
                  (B.capturedMap.delete(h.pointerId),
                  s([]),
                  R.onLostPointerCapture == null || R.onLostPointerCapture(w));
              });
          } else {
            const B = R[l];
            B
              ? (!A || p.initialHits.includes(C)) &&
                (o(
                  h,
                  p.interaction.filter((b) => !p.initialHits.includes(b))
                ),
                B(w))
              : A &&
                p.initialHits.includes(C) &&
                o(
                  h,
                  p.interaction.filter((b) => !p.initialHits.includes(b))
                );
          }
      }
      r(m, h, x, S);
    };
  }
  return { handlePointer: a };
}
const QR = (n) => !!(n != null && n.render),
  ZR = H.createContext(null),
  sV = (n, e) => {
    const t = OR((a, l) => {
        const u = new F(),
          h = new F(),
          d = new F();
        function p(m = l().camera, x = h, S = l().size) {
          const { width: w, height: C, top: P, left: R } = S,
            B = w / C;
          x instanceof F ? d.copy(x) : d.set(...x);
          const b = m.getWorldPosition(u).distanceTo(d);
          if (VR(m))
            return {
              width: w / m.zoom,
              height: C / m.zoom,
              top: P,
              left: R,
              factor: 1,
              distance: b,
              aspect: B,
            };
          {
            const L = (m.fov * Math.PI) / 180,
              U = 2 * Math.tan(L / 2) * b,
              J = U * (w / C);
            return {
              width: J,
              height: U,
              top: P,
              left: R,
              factor: w / J,
              distance: b,
              aspect: B,
            };
          }
        }
        let g;
        const y = (m) =>
            a((x) => ({ performance: { ...x.performance, current: m } })),
          A = new ve();
        return {
          set: a,
          get: l,
          gl: null,
          camera: null,
          raycaster: null,
          events: { priority: 1, enabled: !0, connected: !1 },
          xr: null,
          scene: null,
          invalidate: (m = 1) => n(l(), m),
          advance: (m, x) => e(m, x, l()),
          legacy: !1,
          linear: !1,
          flat: !1,
          controls: null,
          clock: new BA(),
          pointer: A,
          mouse: A,
          frameloop: "always",
          onPointerMissed: void 0,
          performance: {
            current: 1,
            min: 0.5,
            max: 1,
            debounce: 200,
            regress: () => {
              const m = l();
              (g && clearTimeout(g),
                m.performance.current !== m.performance.min &&
                  y(m.performance.min),
                (g = setTimeout(
                  () => y(l().performance.max),
                  m.performance.debounce
                )));
            },
          },
          size: { width: 0, height: 0, top: 0, left: 0, updateStyle: !1 },
          viewport: {
            initialDpr: 0,
            dpr: 0,
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            aspect: 0,
            distance: 0,
            factor: 0,
            getCurrentViewport: p,
          },
          setEvents: (m) => a((x) => ({ ...x, events: { ...x.events, ...m } })),
          setSize: (m, x, S, w, C) => {
            const P = l().camera,
              R = {
                width: m,
                height: x,
                top: w || 0,
                left: C || 0,
                updateStyle: S,
              };
            a((B) => ({ size: R, viewport: { ...B.viewport, ...p(P, h, R) } }));
          },
          setDpr: (m) =>
            a((x) => {
              const S = XR(m);
              return {
                viewport: {
                  ...x.viewport,
                  dpr: S,
                  initialDpr: x.viewport.initialDpr || S,
                },
              };
            }),
          setFrameloop: (m = "always") => {
            const x = l().clock;
            (x.stop(),
              (x.elapsedTime = 0),
              m !== "never" && (x.start(), (x.elapsedTime = 0)),
              a(() => ({ frameloop: m })));
          },
          previousRoot: void 0,
          internal: {
            active: !1,
            priority: 0,
            frames: 0,
            lastEvent: H.createRef(),
            interaction: [],
            hovered: new Map(),
            subscribers: [],
            initialClick: [0, 0],
            initialHits: [],
            capturedMap: new Map(),
            subscribe: (m, x, S) => {
              const w = l().internal;
              return (
                (w.priority = w.priority + (x > 0 ? 1 : 0)),
                w.subscribers.push({ ref: m, priority: x, store: S }),
                (w.subscribers = w.subscribers.sort(
                  (C, P) => C.priority - P.priority
                )),
                () => {
                  const C = l().internal;
                  C != null &&
                    C.subscribers &&
                    ((C.priority = C.priority - (x > 0 ? 1 : 0)),
                    (C.subscribers = C.subscribers.filter((P) => P.ref !== m)));
                }
              );
            },
          },
        };
      }),
      i = t.getState();
    let r = i.size,
      s = i.viewport.dpr,
      o = i.camera;
    return (
      t.subscribe(() => {
        const { camera: a, size: l, viewport: u, gl: h, set: d } = t.getState();
        if (l !== r || u.dpr !== s) {
          var p;
          ((r = l), (s = u.dpr), tV(a, l), h.setPixelRatio(u.dpr));
          const g =
            (p = l.updateStyle) != null
              ? p
              : typeof HTMLCanvasElement < "u" &&
                h.domElement instanceof HTMLCanvasElement;
          h.setSize(l.width, l.height, g);
        }
        a !== o &&
          ((o = a),
          d((g) => ({
            viewport: { ...g.viewport, ...g.viewport.getCurrentViewport(a) },
          })));
      }),
      t.subscribe((a) => n(a)),
      t
    );
  };
let Yp,
  oV = new Set(),
  aV = new Set(),
  lV = new Set();
function yy(n, e) {
  if (n.size) for (const { callback: t } of n.values()) t(e);
}
function $u(n, e) {
  switch (n) {
    case "before":
      return yy(oV, e);
    case "after":
      return yy(aV, e);
    case "tail":
      return yy(lV, e);
  }
}
let xy, _y;
function Ay(n, e, t) {
  let i = e.clock.getDelta();
  for (
    e.frameloop === "never" &&
      typeof n == "number" &&
      ((i = n - e.clock.elapsedTime),
      (e.clock.oldTime = e.clock.elapsedTime),
      (e.clock.elapsedTime = n)),
      xy = e.internal.subscribers,
      Yp = 0;
    Yp < xy.length;
    Yp++
  )
    ((_y = xy[Yp]), _y.ref.current(_y.store.getState(), i, t));
  return (
    !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    (e.internal.frames = Math.max(0, e.internal.frames - 1)),
    e.frameloop === "always" ? 1 : e.internal.frames
  );
}
function cV(n) {
  let e = !1,
    t,
    i,
    r;
  function s(l) {
    ((i = requestAnimationFrame(s)), (e = !0), (t = 0), $u("before", l));
    for (const h of n.values()) {
      var u;
      ((r = h.store.getState()),
        r.internal.active &&
          (r.frameloop === "always" || r.internal.frames > 0) &&
          !((u = r.gl.xr) != null && u.isPresenting) &&
          (t += Ay(l, r)));
    }
    if (($u("after", l), t === 0))
      return ($u("tail", l), (e = !1), cancelAnimationFrame(i));
  }
  function o(l, u = 1) {
    var h;
    if (!l) return n.forEach((d) => o(d.store.getState()), u);
    ((h = l.gl.xr) != null && h.isPresenting) ||
      !l.internal.active ||
      l.frameloop === "never" ||
      ((l.internal.frames = Math.min(60, l.internal.frames + u)),
      e || ((e = !0), requestAnimationFrame(s)));
  }
  function a(l, u = !0, h, d) {
    if ((u && $u("before", l), h)) Ay(l, h, d);
    else for (const p of n.values()) Ay(l, p.store.getState());
    u && $u("after", l);
  }
  return { loop: s, invalidate: o, advance: a };
}
function qR() {
  const n = H.useContext(ZR);
  if (!n)
    throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return n;
}
function Vi(n = (t) => t, e) {
  return qR()(n, e);
}
function fu(n, e = 0) {
  const t = qR(),
    i = t.getState().internal.subscribe,
    r = WR(n);
  return (Hh(() => i(r, e, t), [e, i, t]), null);
}
function $R(n, e) {
  return function (t, ...i) {
    const r = new t();
    return (
      n && n(r),
      Promise.all(
        i.map(
          (s) =>
            new Promise((o, a) =>
              r.load(
                s,
                (l) => {
                  (l.scene && Object.assign(l, $5(l.scene)), o(l));
                },
                e,
                (l) => a(new Error(`Could not load ${s}: ${l.message})`))
              )
            )
        )
      )
    );
  };
}
function ra(n, e, t, i) {
  const r = Array.isArray(e) ? e : [e],
    s = j5($R(t, i), [n, ...r], { equal: Kt.equ });
  return Array.isArray(e) ? s : s[0];
}
ra.preload = function (n, e, t) {
  const i = Array.isArray(e) ? e : [e];
  return J5($R(t), [n, ...i]);
};
ra.clear = function (n, e) {
  const t = Array.isArray(e) ? e : [e];
  return X5([n, ...t]);
};
const qc = new Map(),
  { invalidate: HC, advance: VC } = cV(qc),
  { reconciler: eg, applyProps: Fs } = Y5(qc, nV),
  nc = { objects: "shallow", strict: !1 },
  uV = (n, e) => {
    const t = typeof n == "function" ? n(e) : n;
    return QR(t)
      ? t
      : new lA({
          powerPreference: "high-performance",
          canvas: e,
          antialias: !0,
          alpha: !0,
          ...n,
        });
  };
function fV(n, e) {
  if (e) return e;
  if (
    typeof HTMLCanvasElement < "u" &&
    n instanceof HTMLCanvasElement &&
    n.parentElement
  ) {
    const {
      width: t,
      height: i,
      top: r,
      left: s,
    } = n.parentElement.getBoundingClientRect();
    return { width: t, height: i, top: r, left: s };
  } else if (typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas)
    return { width: n.width, height: n.height, top: 0, left: 0 };
  return { width: 0, height: 0, top: 0, left: 0 };
}
function hV(n) {
  const e = qc.get(n),
    t = e == null ? void 0 : e.fiber,
    i = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const r = typeof reportError == "function" ? reportError : console.error,
    s = i || sV(HC, VC),
    o =
      t ||
      eg.createContainer(s, Lo.ConcurrentRoot, null, !1, null, "", r, null);
  e || qc.set(n, { fiber: o, store: s });
  let a,
    l = !1,
    u;
  return {
    configure(h = {}) {
      let {
          gl: d,
          size: p,
          scene: g,
          events: y,
          onCreated: A,
          shadows: _ = !1,
          linear: m = !1,
          flat: x = !1,
          legacy: S = !1,
          orthographic: w = !1,
          frameloop: C = "always",
          dpr: P = [1, 2],
          performance: R,
          raycaster: B,
          camera: b,
          onPointerMissed: L,
        } = h,
        U = s.getState(),
        J = U.gl;
      U.gl || U.set({ gl: (J = uV(d, n)) });
      let V = U.raycaster;
      V || U.set({ raycaster: (V = new NR()) });
      const { params: j, ...X } = B || {};
      if (
        (Kt.equ(X, V, nc) || Fs(V, { ...X }),
        Kt.equ(j, V.params, nc) || Fs(V, { params: { ...V.params, ...j } }),
        !U.camera || (U.camera === u && !Kt.equ(u, b, nc)))
      ) {
        u = b;
        const q = b instanceof wh,
          Q = q
            ? b
            : w
              ? new zr(0, 0, 0, 0, 0.1, 1e3)
              : new Vt(75, 0, 0.1, 1e3);
        (q ||
          ((Q.position.z = 5),
          b && Fs(Q, b),
          !U.camera && !(b != null && b.rotation) && Q.lookAt(0, 0, 0)),
          U.set({ camera: Q }));
      }
      if (!U.scene) {
        let q;
        (g instanceof Zm ? (q = g) : ((q = new Zm()), g && Fs(q, g)),
          U.set({ scene: ic(q) }));
      }
      if (!U.xr) {
        const q = (ne, Ee) => {
            const Ae = s.getState();
            Ae.frameloop !== "never" && VC(ne, !0, Ae, Ee);
          },
          Q = () => {
            const ne = s.getState();
            ((ne.gl.xr.enabled = ne.gl.xr.isPresenting),
              ne.gl.xr.setAnimationLoop(ne.gl.xr.isPresenting ? q : null),
              ne.gl.xr.isPresenting || HC(ne));
          },
          ee = {
            connect() {
              const ne = s.getState().gl;
              (ne.xr.addEventListener("sessionstart", Q),
                ne.xr.addEventListener("sessionend", Q));
            },
            disconnect() {
              const ne = s.getState().gl;
              (ne.xr.removeEventListener("sessionstart", Q),
                ne.xr.removeEventListener("sessionend", Q));
            },
          };
        (J.xr && ee.connect(), U.set({ xr: ee }));
      }
      if (J.shadowMap) {
        const q = J.shadowMap.enabled,
          Q = J.shadowMap.type;
        if (((J.shadowMap.enabled = !!_), Kt.boo(_))) J.shadowMap.type = Sf;
        else if (Kt.str(_)) {
          var oe;
          const ee = { basic: W2, percentage: Ig, soft: Sf, variance: za };
          J.shadowMap.type = (oe = ee[_]) != null ? oe : Sf;
        } else Kt.obj(_) && Object.assign(J.shadowMap, _);
        (q !== J.shadowMap.enabled || Q !== J.shadowMap.type) &&
          (J.shadowMap.needsUpdate = !0);
      }
      const ae = HR();
      ae &&
        ("enabled" in ae
          ? (ae.enabled = !S)
          : "legacyMode" in ae && (ae.legacyMode = S));
      const I = m ? Qs : Tt,
        G = x ? Ur : J1;
      (J.outputEncoding !== I && (J.outputEncoding = I),
        J.toneMapping !== G && (J.toneMapping = G),
        U.legacy !== S && U.set(() => ({ legacy: S })),
        U.linear !== m && U.set(() => ({ linear: m })),
        U.flat !== x && U.set(() => ({ flat: x })),
        d && !Kt.fun(d) && !QR(d) && !Kt.equ(d, J, nc) && Fs(J, d),
        y && !U.events.handlers && U.set({ events: y(s) }));
      const z = fV(n, p);
      return (
        Kt.equ(z, U.size, nc) ||
          U.setSize(z.width, z.height, z.updateStyle, z.top, z.left),
        P && U.viewport.dpr !== XR(P) && U.setDpr(P),
        U.frameloop !== C && U.setFrameloop(C),
        U.onPointerMissed || U.set({ onPointerMissed: L }),
        R &&
          !Kt.equ(R, U.performance, nc) &&
          U.set((q) => ({ performance: { ...q.performance, ...R } })),
        (a = A),
        (l = !0),
        this
      );
    },
    render(h) {
      return (
        l || this.configure(),
        eg.updateContainer(
          H.createElement(dV, {
            store: s,
            children: h,
            onCreated: a,
            rootElement: n,
          }),
          o,
          null,
          () => {}
        ),
        s
      );
    },
    unmount() {
      e3(n);
    },
  };
}
function dV({ store: n, children: e, onCreated: t, rootElement: i }) {
  return (
    Hh(() => {
      const r = n.getState();
      (r.set((s) => ({ internal: { ...s.internal, active: !0 } })),
        t && t(r),
        n.getState().events.connected ||
          r.events.connect == null ||
          r.events.connect(i));
    }, []),
    H.createElement(ZR.Provider, { value: n }, e)
  );
}
function e3(n, e) {
  const t = qc.get(n),
    i = t == null ? void 0 : t.fiber;
  if (i) {
    const r = t == null ? void 0 : t.store.getState();
    (r && (r.internal.active = !1),
      eg.updateContainer(null, i, null, () => {
        r &&
          setTimeout(() => {
            try {
              var s, o, a, l;
              (r.events.disconnect == null || r.events.disconnect(),
                (s = r.gl) == null ||
                  (o = s.renderLists) == null ||
                  o.dispose == null ||
                  o.dispose(),
                (a = r.gl) == null ||
                  a.forceContextLoss == null ||
                  a.forceContextLoss(),
                (l = r.gl) != null && l.xr && r.xr.disconnect(),
                eV(r),
                qc.delete(n),
                e && e(n));
            } catch {}
          }, 500);
      }));
  }
}
eg.injectIntoDevTools({
  bundleType: 0,
  rendererPackageName: "@react-three/fiber",
  version: H.version,
});
function _r() {
  return (
    (_r = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
              Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
          }
          return n;
        }),
    _r.apply(this, arguments)
  );
}
function E_(n, e, t) {
  var i, r, s, o, a;
  e == null && (e = 100);
  function l() {
    var h = Date.now() - o;
    h < e && h >= 0
      ? (i = setTimeout(l, e - h))
      : ((i = null), t || ((a = n.apply(s, r)), (s = r = null)));
  }
  var u = function () {
    ((s = this), (r = arguments), (o = Date.now()));
    var h = t && !i;
    return (
      i || (i = setTimeout(l, e)),
      h && ((a = n.apply(s, r)), (s = r = null)),
      a
    );
  };
  return (
    (u.clear = function () {
      i && (clearTimeout(i), (i = null));
    }),
    (u.flush = function () {
      i && ((a = n.apply(s, r)), (s = r = null), clearTimeout(i), (i = null));
    }),
    u
  );
}
E_.debounce = E_;
var WC = E_;
function pV(n) {
  let {
    debounce: e,
    scroll: t,
    polyfill: i,
    offsetSize: r,
  } = n === void 0 ? { debounce: 0, scroll: !1, offsetSize: !1 } : n;
  const s = i || (typeof window > "u" ? class {} : window.ResizeObserver);
  if (!s)
    throw new Error(
      "This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills"
    );
  const [o, a] = H.useState({
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      bottom: 0,
      right: 0,
      x: 0,
      y: 0,
    }),
    l = H.useRef({
      element: null,
      scrollContainers: null,
      resizeObserver: null,
      lastBounds: o,
    }),
    u = e ? (typeof e == "number" ? e : e.scroll) : null,
    h = e ? (typeof e == "number" ? e : e.resize) : null,
    d = H.useRef(!1);
  H.useEffect(() => ((d.current = !0), () => void (d.current = !1)));
  const [p, g, y] = H.useMemo(() => {
    const x = () => {
      if (!l.current.element) return;
      const {
          left: S,
          top: w,
          width: C,
          height: P,
          bottom: R,
          right: B,
          x: b,
          y: L,
        } = l.current.element.getBoundingClientRect(),
        U = {
          left: S,
          top: w,
          width: C,
          height: P,
          bottom: R,
          right: B,
          x: b,
          y: L,
        };
      (l.current.element instanceof HTMLElement &&
        r &&
        ((U.height = l.current.element.offsetHeight),
        (U.width = l.current.element.offsetWidth)),
        Object.freeze(U),
        d.current &&
          !yV(l.current.lastBounds, U) &&
          a((l.current.lastBounds = U)));
    };
    return [x, h ? WC(x, h) : x, u ? WC(x, u) : x];
  }, [a, r, u, h]);
  function A() {
    (l.current.scrollContainers &&
      (l.current.scrollContainers.forEach((x) =>
        x.removeEventListener("scroll", y, !0)
      ),
      (l.current.scrollContainers = null)),
      l.current.resizeObserver &&
        (l.current.resizeObserver.disconnect(),
        (l.current.resizeObserver = null)));
  }
  function _() {
    l.current.element &&
      ((l.current.resizeObserver = new s(y)),
      l.current.resizeObserver.observe(l.current.element),
      t &&
        l.current.scrollContainers &&
        l.current.scrollContainers.forEach((x) =>
          x.addEventListener("scroll", y, { capture: !0, passive: !0 })
        ));
  }
  const m = (x) => {
    !x ||
      x === l.current.element ||
      (A(), (l.current.element = x), (l.current.scrollContainers = t3(x)), _());
  };
  return (
    gV(y, !!t),
    mV(g),
    H.useEffect(() => {
      (A(), _());
    }, [t, y, g]),
    H.useEffect(() => A, []),
    [m, o, p]
  );
}
function mV(n) {
  H.useEffect(() => {
    const e = n;
    return (
      window.addEventListener("resize", e),
      () => void window.removeEventListener("resize", e)
    );
  }, [n]);
}
function gV(n, e) {
  H.useEffect(() => {
    if (e) {
      const t = n;
      return (
        window.addEventListener("scroll", t, { capture: !0, passive: !0 }),
        () => void window.removeEventListener("scroll", t, !0)
      );
    }
  }, [n, e]);
}
function t3(n) {
  const e = [];
  if (!n || n === document.body) return e;
  const {
    overflow: t,
    overflowX: i,
    overflowY: r,
  } = window.getComputedStyle(n);
  return (
    [t, i, r].some((s) => s === "auto" || s === "scroll") && e.push(n),
    [...e, ...t3(n.parentElement)]
  );
}
const vV = ["x", "y", "top", "bottom", "left", "right", "width", "height"],
  yV = (n, e) => vV.every((t) => n[t] === e[t]);
var xV = Object.defineProperty,
  _V = Object.defineProperties,
  AV = Object.getOwnPropertyDescriptors,
  jC = Object.getOwnPropertySymbols,
  MV = Object.prototype.hasOwnProperty,
  SV = Object.prototype.propertyIsEnumerable,
  JC = (n, e, t) =>
    e in n
      ? xV(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t),
  XC = (n, e) => {
    for (var t in e || (e = {})) MV.call(e, t) && JC(n, t, e[t]);
    if (jC) for (var t of jC(e)) SV.call(e, t) && JC(n, t, e[t]);
    return n;
  },
  wV = (n, e) => _V(n, AV(e));
function n3(n, e, t) {
  if (!n) return;
  if (t(n) === !0) return n;
  let i = e ? n.return : n.child;
  for (; i; ) {
    const r = n3(i, e, t);
    if (r) return r;
    i = e ? null : i.sibling;
  }
}
function i3(n) {
  try {
    return Object.defineProperties(n, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {},
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {},
      },
    });
  } catch {
    return n;
  }
}
const FA = i3(H.createContext(null));
class r3 extends H.Component {
  render() {
    return H.createElement(
      FA.Provider,
      { value: this._reactInternals },
      this.props.children
    );
  }
}
const { ReactCurrentOwner: KC, ReactCurrentDispatcher: YC } =
  H.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
function EV() {
  const n = H.useContext(FA);
  if (n === null)
    throw new Error(
      "its-fine: useFiber must be called within a <FiberProvider />!"
    );
  const e = H.useId();
  return H.useMemo(() => {
    var i;
    return (i = KC == null ? void 0 : KC.current) != null
      ? i
      : n3(n, !1, (r) => {
          let s = r.memoizedState;
          for (; s; ) {
            if (s.memoizedState === e) return !0;
            s = s.next;
          }
        });
  }, [n, e]);
}
function CV() {
  var n, e;
  const t = EV(),
    [i] = H.useState(() => new Map());
  i.clear();
  let r = t;
  for (; r; ) {
    const s = (n = r.type) == null ? void 0 : n._context;
    (s &&
      s !== FA &&
      !i.has(s) &&
      i.set(
        s,
        (e = YC == null ? void 0 : YC.current) == null
          ? void 0
          : e.readContext(i3(s))
      ),
      (r = r.return));
  }
  return i;
}
function TV() {
  const n = CV();
  return H.useMemo(
    () =>
      Array.from(n.keys()).reduce(
        (e, t) => (i) =>
          H.createElement(
            e,
            null,
            H.createElement(t.Provider, wV(XC({}, i), { value: n.get(t) }))
          ),
        (e) => H.createElement(r3, XC({}, e))
      ),
    [n]
  );
}
const My = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0],
};
function bV(n) {
  const { handlePointer: e } = rV(n);
  return {
    priority: 1,
    enabled: !0,
    compute(t, i, r) {
      (i.pointer.set(
        (t.offsetX / i.size.width) * 2 - 1,
        -(t.offsetY / i.size.height) * 2 + 1
      ),
        i.raycaster.setFromCamera(i.pointer, i.camera));
    },
    connected: void 0,
    handlers: Object.keys(My).reduce((t, i) => ({ ...t, [i]: e(i) }), {}),
    update: () => {
      var t;
      const { events: i, internal: r } = n.getState();
      (t = r.lastEvent) != null &&
        t.current &&
        i.handlers &&
        i.handlers.onPointerMove(r.lastEvent.current);
    },
    connect: (t) => {
      var i;
      const { set: r, events: s } = n.getState();
      (s.disconnect == null || s.disconnect(),
        r((o) => ({ events: { ...o.events, connected: t } })),
        Object.entries((i = s.handlers) != null ? i : []).forEach(([o, a]) => {
          const [l, u] = My[o];
          t.addEventListener(l, a, { passive: u });
        }));
    },
    disconnect: () => {
      const { set: t, events: i } = n.getState();
      if (i.connected) {
        var r;
        (Object.entries((r = i.handlers) != null ? r : []).forEach(([s, o]) => {
          if (i && i.connected instanceof HTMLElement) {
            const [a] = My[s];
            i.connected.removeEventListener(a, o);
          }
        }),
          t((s) => ({ events: { ...s.events, connected: void 0 } })));
      }
    },
  };
}
const PV = H.forwardRef(function (
    {
      children: e,
      fallback: t,
      resize: i,
      style: r,
      gl: s,
      events: o = bV,
      eventSource: a,
      eventPrefix: l,
      shadows: u,
      linear: h,
      flat: d,
      legacy: p,
      orthographic: g,
      frameloop: y,
      dpr: A,
      performance: _,
      raycaster: m,
      camera: x,
      onPointerMissed: S,
      onCreated: w,
      ...C
    },
    P
  ) {
    H.useMemo(() => K5(D5), []);
    const R = TV(),
      [B, b] = pV({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...i }),
      L = H.useRef(null),
      U = H.useRef(null);
    H.useImperativeHandle(P, () => L.current);
    const J = WR(S),
      [V, j] = H.useState(!1),
      [X, oe] = H.useState(!1);
    if (V) throw V;
    if (X) throw X;
    const ae = H.useRef(null);
    (Hh(() => {
      const G = L.current;
      b.width > 0 &&
        b.height > 0 &&
        G &&
        (ae.current || (ae.current = hV(G)),
        ae.current.configure({
          gl: s,
          events: o,
          shadows: u,
          linear: h,
          flat: d,
          legacy: p,
          orthographic: g,
          frameloop: y,
          dpr: A,
          performance: _,
          raycaster: m,
          camera: x,
          size: b,
          onPointerMissed: (...z) =>
            J.current == null ? void 0 : J.current(...z),
          onCreated: (z) => {
            (z.events.connect == null ||
              z.events.connect(a ? (Q5(a) ? a.current : a) : U.current),
              l &&
                z.setEvents({
                  compute: (q, Q) => {
                    const ee = q[l + "X"],
                      ne = q[l + "Y"];
                    (Q.pointer.set(
                      (ee / Q.size.width) * 2 - 1,
                      -(ne / Q.size.height) * 2 + 1
                    ),
                      Q.raycaster.setFromCamera(Q.pointer, Q.camera));
                  },
                }),
              w == null || w(z));
          },
        }),
        ae.current.render(
          H.createElement(
            R,
            null,
            H.createElement(
              jR,
              { set: oe },
              H.createElement(
                H.Suspense,
                { fallback: H.createElement(Z5, { set: j }) },
                e
              )
            )
          )
        ));
    }),
      H.useEffect(() => {
        const G = L.current;
        if (G) return () => e3(G);
      }, []));
    const I = a ? "none" : "auto";
    return H.createElement(
      "div",
      _r(
        {
          ref: U,
          style: {
            position: "relative",
            width: "100%",
            height: "100%",
            overflow: "hidden",
            pointerEvents: I,
            ...r,
          },
        },
        C
      ),
      H.createElement(
        "div",
        { ref: B, style: { width: "100%", height: "100%" } },
        H.createElement("canvas", { ref: L, style: { display: "block" } }, t)
      )
    );
  }),
  NA = H.forwardRef(function (e, t) {
    return H.createElement(
      r3,
      null,
      H.createElement(PV, _r({}, e, { ref: t }))
    );
  }),
  Vh = new F(),
  kA = new F(),
  BV = new F();
function RV(n, e, t) {
  const i = Vh.setFromMatrixPosition(n.matrixWorld);
  i.project(e);
  const r = t.width / 2,
    s = t.height / 2;
  return [i.x * r + r, -(i.y * s) + s];
}
function LV(n, e) {
  const t = Vh.setFromMatrixPosition(n.matrixWorld),
    i = kA.setFromMatrixPosition(e.matrixWorld),
    r = t.sub(i),
    s = e.getWorldDirection(BV);
  return r.angleTo(s) > Math.PI / 2;
}
function IV(n, e, t, i) {
  const r = Vh.setFromMatrixPosition(n.matrixWorld),
    s = r.clone();
  (s.project(e), t.setFromCamera(s, e));
  const o = t.intersectObjects(i, !0);
  if (o.length) {
    const a = o[0].distance;
    return r.distanceTo(t.ray.origin) < a;
  }
  return !0;
}
function DV(n, e) {
  if (e instanceof zr) return e.zoom;
  if (e instanceof Vt) {
    const t = Vh.setFromMatrixPosition(n.matrixWorld),
      i = kA.setFromMatrixPosition(e.matrixWorld),
      r = (e.fov * Math.PI) / 180,
      s = t.distanceTo(i);
    return 1 / (2 * Math.tan(r / 2) * s);
  } else return 1;
}
function FV(n, e, t) {
  if (e instanceof Vt || e instanceof zr) {
    const i = Vh.setFromMatrixPosition(n.matrixWorld),
      r = kA.setFromMatrixPosition(e.matrixWorld),
      s = i.distanceTo(r),
      o = (t[1] - t[0]) / (e.far - e.near),
      a = t[1] - o * e.far;
    return Math.round(o * s + a);
  }
}
const C_ = (n) => (Math.abs(n) < 1e-10 ? 0 : n);
function s3(n, e, t = "") {
  let i = "matrix3d(";
  for (let r = 0; r !== 16; r++)
    i += C_(e[r] * n.elements[r]) + (r !== 15 ? "," : ")");
  return t + i;
}
const NV = (
    (n) => (e) =>
      s3(e, n)
  )([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]),
  kV = (
    (n) => (e, t) =>
      s3(e, n(t), "translate(-50%,-50%)")
  )((n) => [
    1 / n,
    1 / n,
    1 / n,
    1,
    -1 / n,
    -1 / n,
    -1 / n,
    -1,
    1 / n,
    1 / n,
    1 / n,
    1,
    1,
    1,
    1,
    1,
  ]);
function OV(n) {
  return n && typeof n == "object" && "current" in n;
}
const UV = H.forwardRef(
  (
    {
      children: n,
      eps: e = 0.001,
      style: t,
      className: i,
      prepend: r,
      center: s,
      fullscreen: o,
      portal: a,
      distanceFactor: l,
      sprite: u = !1,
      transform: h = !1,
      occlude: d,
      onOcclude: p,
      castShadow: g,
      receiveShadow: y,
      material: A,
      geometry: _,
      zIndexRange: m = [16777271, 0],
      calculatePosition: x = RV,
      as: S = "div",
      wrapperClass: w,
      pointerEvents: C = "auto",
      ...P
    },
    R
  ) => {
    const {
        gl: B,
        camera: b,
        scene: L,
        size: U,
        raycaster: J,
        events: V,
        viewport: j,
      } = Vi(),
      [X] = H.useState(() => document.createElement(S)),
      oe = H.useRef(),
      ae = H.useRef(null),
      I = H.useRef(0),
      G = H.useRef([0, 0]),
      z = H.useRef(null),
      q = H.useRef(null),
      Q =
        (a == null ? void 0 : a.current) ||
        V.connected ||
        B.domElement.parentNode,
      ee = H.useRef(null),
      ne = H.useRef(!1),
      Ee = H.useMemo(
        () =>
          (d && d !== "blending") || (Array.isArray(d) && d.length && OV(d[0])),
        [d]
      );
    (H.useLayoutEffect(() => {
      const xe = B.domElement;
      d && d === "blending"
        ? ((xe.style.zIndex = `${Math.floor(m[0] / 2)}`),
          (xe.style.position = "absolute"),
          (xe.style.pointerEvents = "none"))
        : ((xe.style.zIndex = null),
          (xe.style.position = null),
          (xe.style.pointerEvents = null));
    }, [d]),
      H.useLayoutEffect(() => {
        if (ae.current) {
          const xe = (oe.current = F2(X));
          if ((L.updateMatrixWorld(), h))
            X.style.cssText =
              "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";
          else {
            const Se = x(ae.current, b, U);
            X.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${Se[0]}px,${Se[1]}px,0);transform-origin:0 0;`;
          }
          return (
            Q && (r ? Q.prepend(X) : Q.appendChild(X)),
            () => {
              (Q && Q.removeChild(X), xe.unmount());
            }
          );
        }
      }, [Q, h]),
      H.useLayoutEffect(() => {
        w && (X.className = w);
      }, [w]));
    const Ae = H.useMemo(
        () =>
          h
            ? {
                position: "absolute",
                top: 0,
                left: 0,
                width: U.width,
                height: U.height,
                transformStyle: "preserve-3d",
                pointerEvents: "none",
              }
            : {
                position: "absolute",
                transform: s ? "translate3d(-50%,-50%,0)" : "none",
                ...(o && {
                  top: -U.height / 2,
                  left: -U.width / 2,
                  width: U.width,
                  height: U.height,
                }),
                ...t,
              },
        [t, s, o, U, h]
      ),
      $ = H.useMemo(() => ({ position: "absolute", pointerEvents: C }), [C]);
    H.useLayoutEffect(() => {
      if (((ne.current = !1), h)) {
        var xe;
        (xe = oe.current) == null ||
          xe.render(
            H.createElement(
              "div",
              { ref: z, style: Ae },
              H.createElement(
                "div",
                { ref: q, style: $ },
                H.createElement("div", {
                  ref: R,
                  className: i,
                  style: t,
                  children: n,
                })
              )
            )
          );
      } else {
        var Se;
        (Se = oe.current) == null ||
          Se.render(
            H.createElement("div", {
              ref: R,
              style: Ae,
              className: i,
              children: n,
            })
          );
      }
    });
    const Je = H.useRef(!0);
    fu((xe) => {
      if (ae.current) {
        (b.updateMatrixWorld(), ae.current.updateWorldMatrix(!0, !1));
        const Se = h ? G.current : x(ae.current, b, U);
        if (
          h ||
          Math.abs(I.current - b.zoom) > e ||
          Math.abs(G.current[0] - Se[0]) > e ||
          Math.abs(G.current[1] - Se[1]) > e
        ) {
          const ge = LV(ae.current, b);
          let se = !1;
          Ee &&
            (d !== "blending"
              ? (se = [L])
              : Array.isArray(d) && (se = d.map((We) => We.current)));
          const _e = Je.current;
          if (se) {
            const We = IV(ae.current, b, J, se);
            Je.current = We && !ge;
          } else Je.current = !ge;
          _e !== Je.current &&
            (p
              ? p(!Je.current)
              : (X.style.display = Je.current ? "block" : "none"));
          const Ne = Math.floor(m[0] / 2),
            Le = d ? (Ee ? [m[0], Ne] : [Ne - 1, 0]) : m;
          if (((X.style.zIndex = `${FV(ae.current, b, Le)}`), h)) {
            const [We, Ke] = [U.width / 2, U.height / 2],
              je = b.projectionMatrix.elements[5] * Ke,
              {
                isOrthographicCamera: nt,
                top: At,
                left: O,
                bottom: D,
                right: le,
              } = b,
              Ce = NV(b.matrixWorldInverse),
              Te = nt
                ? `scale(${je})translate(${C_(-(le + O) / 2)}px,${C_((At + D) / 2)}px)`
                : `translateZ(${je}px)`;
            let Re = ae.current.matrixWorld;
            (u &&
              ((Re = b.matrixWorldInverse
                .clone()
                .transpose()
                .copyPosition(Re)
                .scale(ae.current.scale)),
              (Re.elements[3] = Re.elements[7] = Re.elements[11] = 0),
              (Re.elements[15] = 1)),
              (X.style.width = U.width + "px"),
              (X.style.height = U.height + "px"),
              (X.style.perspective = nt ? "" : `${je}px`),
              z.current &&
                q.current &&
                ((z.current.style.transform = `${Te}${Ce}translate(${We}px,${Ke}px)`),
                (q.current.style.transform = kV(Re, 1 / ((l || 10) / 400)))));
          } else {
            const We = l === void 0 ? 1 : DV(ae.current, b) * l;
            X.style.transform = `translate3d(${Se[0]}px,${Se[1]}px,0) scale(${We})`;
          }
          ((G.current = Se), (I.current = b.zoom));
        }
      }
      if (!Ee && ee.current && !ne.current)
        if (h) {
          if (z.current) {
            const Se = z.current.children[0];
            if (Se != null && Se.clientWidth && Se != null && Se.clientHeight) {
              const { isOrthographicCamera: ge } = b;
              if (ge || _)
                P.scale &&
                  (Array.isArray(P.scale)
                    ? P.scale instanceof F
                      ? ee.current.scale.copy(P.scale.clone().divideScalar(1))
                      : ee.current.scale.set(
                          1 / P.scale[0],
                          1 / P.scale[1],
                          1 / P.scale[2]
                        )
                    : ee.current.scale.setScalar(1 / P.scale));
              else {
                const se = (l || 10) / 400,
                  _e = Se.clientWidth * se,
                  Ne = Se.clientHeight * se;
                ee.current.scale.set(_e, Ne, 1);
              }
              ne.current = !0;
            }
          }
        } else {
          const Se = X.children[0];
          if (Se != null && Se.clientWidth && Se != null && Se.clientHeight) {
            const ge = 1 / j.factor,
              se = Se.clientWidth * ge,
              _e = Se.clientHeight * ge;
            (ee.current.scale.set(se, _e, 1), (ne.current = !0));
          }
          ee.current.lookAt(xe.camera.position);
        }
    });
    const Xe = H.useMemo(
      () => ({
        vertexShader: h
          ? void 0
          : `
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,
        fragmentShader: `
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `,
      }),
      [h]
    );
    return H.createElement(
      "group",
      _r({}, P, { ref: ae }),
      d &&
        !Ee &&
        H.createElement(
          "mesh",
          { castShadow: g, receiveShadow: y, ref: ee },
          _ || H.createElement("planeGeometry", null),
          A ||
            H.createElement("shaderMaterial", {
              side: mr,
              vertexShader: Xe.vertexShader,
              fragmentShader: Xe.fragmentShader,
            })
        )
    );
  }
);
let ef = 0;
const zV = OR(
  (n) => (
    (_c.onStart = (e, t, i) => {
      n({
        active: !0,
        item: e,
        loaded: t,
        total: i,
        progress: ((t - ef) / (i - ef)) * 100,
      });
    }),
    (_c.onLoad = () => {
      n({ active: !1 });
    }),
    (_c.onError = (e) => n((t) => ({ errors: [...t.errors, e] }))),
    (_c.onProgress = (e, t, i) => {
      (t === i && (ef = i),
        n({
          active: !0,
          item: e,
          loaded: t,
          total: i,
          progress: ((t - ef) / (i - ef)) * 100 || 100,
        }));
    }),
    { errors: [], active: !1, progress: 0, item: "", loaded: 0, total: 0 }
  )
);
function OA(n) {
  return function (e) {
    n.forEach(function (t) {
      typeof t == "function" ? t(e) : t != null && (t.current = e);
    });
  };
}
function Ic(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  );
}
function QC(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(n);
    (e &&
      (i = i.filter(function (r) {
        return Object.getOwnPropertyDescriptor(n, r).enumerable;
      })),
      t.push.apply(t, i));
  }
  return t;
}
function ZC(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? QC(Object(t), !0).forEach(function (i) {
          Ic(n, i, t[i]);
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
        : QC(Object(t)).forEach(function (i) {
            Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(t, i));
          });
  }
  return n;
}
new ve();
new ve();
function o3(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
var ur = function n(e, t, i) {
    var r = this;
    (o3(this, n),
      Ic(this, "dot2", function (s, o) {
        return r.x * s + r.y * o;
      }),
      Ic(this, "dot3", function (s, o, a) {
        return r.x * s + r.y * o + r.z * a;
      }),
      (this.x = e),
      (this.y = t),
      (this.z = i));
  },
  GV = [
    new ur(1, 1, 0),
    new ur(-1, 1, 0),
    new ur(1, -1, 0),
    new ur(-1, -1, 0),
    new ur(1, 0, 1),
    new ur(-1, 0, 1),
    new ur(1, 0, -1),
    new ur(-1, 0, -1),
    new ur(0, 1, 1),
    new ur(0, -1, 1),
    new ur(0, 1, -1),
    new ur(0, -1, -1),
  ],
  qC = [
    151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140,
    36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120,
    234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,
    88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71,
    134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133,
    230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161,
    1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130,
    116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250,
    124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227,
    47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44,
    154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98,
    108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34,
    242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14,
    239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121,
    50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243,
    141, 128, 195, 78, 66, 215, 61, 156, 180,
  ],
  $C = new Array(512),
  eT = new Array(512),
  HV = function (e) {
    (e > 0 && e < 1 && (e *= 65536),
      (e = Math.floor(e)),
      e < 256 && (e |= e << 8));
    for (var t = 0; t < 256; t++) {
      var i;
      (t & 1 ? (i = qC[t] ^ (e & 255)) : (i = qC[t] ^ ((e >> 8) & 255)),
        ($C[t] = $C[t + 256] = i),
        (eT[t] = eT[t + 256] = GV[i % 12]));
    }
  };
HV(0);
function VV(n) {
  if (typeof n == "number") n = Math.abs(n);
  else if (typeof n == "string") {
    var e = n;
    n = 0;
    for (var t = 0; t < e.length; t++)
      n = (n + (t + 1) * (e.charCodeAt(t) % 96)) % 2147483647;
  }
  return (n === 0 && (n = 311), n);
}
function tT(n) {
  var e = VV(n);
  return function () {
    var t = (e * 48271) % 2147483647;
    return ((e = t), t / 2147483647);
  };
}
var WV = function n(e) {
    var t = this;
    (o3(this, n),
      Ic(this, "seed", 0),
      Ic(this, "init", function (i) {
        ((t.seed = i), (t.value = tT(i)));
      }),
      Ic(this, "value", tT(this.seed)),
      this.init(e));
  },
  jV = new WV(Math.random()),
  JV = { radius: 1, center: [0, 0, 0] };
function XV(n, e) {
  for (
    var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : jV,
      i = ZC(ZC({}, JV), e),
      r = i.radius,
      s = i.center,
      o = 0;
    o < n.length;
    o += 3
  ) {
    var a = Math.pow(t.value(), 0.3333333333333333),
      l = t.value() * 2 - 1,
      u = t.value() * 2 - 1,
      h = t.value() * 2 - 1,
      d = Math.sqrt(l * l + u * u + h * h);
    ((l = (a * l) / d),
      (u = (a * u) / d),
      (h = (a * h) / d),
      (n[o] = l * r + s[0]),
      (n[o + 1] = u * r + s[1]),
      (n[o + 2] = h * r + s[2]));
  }
  return n;
}
function ch(n) {
  return (
    (ch =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (e) {
            return typeof e;
          }
        : function (e) {
            return e &&
              typeof Symbol == "function" &&
              e.constructor === Symbol &&
              e !== Symbol.prototype
              ? "symbol"
              : typeof e;
          }),
    ch(n)
  );
}
function KV(n, e) {
  if (ch(n) !== "object" || n === null) return n;
  var t = n[Symbol.toPrimitive];
  if (t !== void 0) {
    var i = t.call(n, e || "default");
    if (ch(i) !== "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(n);
}
function YV(n) {
  var e = KV(n, "string");
  return ch(e) === "symbol" ? e : String(e);
}
function ut(n, e, t) {
  return (
    (e = YV(e)),
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  );
}
const nT = (n, e) => ((n % e) + e) % e;
let QV = class extends ps {
  constructor(e, t) {
    (super(),
      ut(this, "object", void 0),
      ut(this, "domElement", void 0),
      ut(this, "enabled", !0),
      ut(this, "target", new F()),
      ut(this, "minDistance", 0),
      ut(this, "maxDistance", 1 / 0),
      ut(this, "minZoom", 0),
      ut(this, "maxZoom", 1 / 0),
      ut(this, "minPolarAngle", 0),
      ut(this, "maxPolarAngle", Math.PI),
      ut(this, "minAzimuthAngle", -1 / 0),
      ut(this, "maxAzimuthAngle", 1 / 0),
      ut(this, "enableDamping", !1),
      ut(this, "dampingFactor", 0.05),
      ut(this, "enableZoom", !0),
      ut(this, "zoomSpeed", 1),
      ut(this, "enableRotate", !0),
      ut(this, "rotateSpeed", 1),
      ut(this, "enablePan", !0),
      ut(this, "panSpeed", 1),
      ut(this, "screenSpacePanning", !0),
      ut(this, "keyPanSpeed", 7),
      ut(this, "autoRotate", !1),
      ut(this, "autoRotateSpeed", 2),
      ut(this, "reverseOrbit", !1),
      ut(this, "keys", {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown",
      }),
      ut(this, "mouseButtons", {
        LEFT: ba.ROTATE,
        MIDDLE: ba.DOLLY,
        RIGHT: ba.PAN,
      }),
      ut(this, "touches", { ONE: Pa.ROTATE, TWO: Pa.DOLLY_PAN }),
      ut(this, "target0", void 0),
      ut(this, "position0", void 0),
      ut(this, "zoom0", void 0),
      ut(this, "_domElementKeyEvents", null),
      ut(this, "getPolarAngle", void 0),
      ut(this, "getAzimuthalAngle", void 0),
      ut(this, "setPolarAngle", void 0),
      ut(this, "setAzimuthalAngle", void 0),
      ut(this, "getDistance", void 0),
      ut(this, "listenToKeyEvents", void 0),
      ut(this, "saveState", void 0),
      ut(this, "reset", void 0),
      ut(this, "update", void 0),
      ut(this, "connect", void 0),
      ut(this, "dispose", void 0),
      (this.object = e),
      (this.domElement = t),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object instanceof Vt ? this.object.zoom : 1),
      (this.getPolarAngle = () => h.phi),
      (this.getAzimuthalAngle = () => h.theta),
      (this.setPolarAngle = (W) => {
        let de = nT(W, 2 * Math.PI),
          Me = h.phi;
        (Me < 0 && (Me += 2 * Math.PI), de < 0 && (de += 2 * Math.PI));
        let Pe = Math.abs(de - Me);
        (2 * Math.PI - Pe < Pe &&
          (de < Me ? (de += 2 * Math.PI) : (Me += 2 * Math.PI)),
          (d.phi = de - Me),
          i.update());
      }),
      (this.setAzimuthalAngle = (W) => {
        let de = nT(W, 2 * Math.PI),
          Me = h.theta;
        (Me < 0 && (Me += 2 * Math.PI), de < 0 && (de += 2 * Math.PI));
        let Pe = Math.abs(de - Me);
        (2 * Math.PI - Pe < Pe &&
          (de < Me ? (de += 2 * Math.PI) : (Me += 2 * Math.PI)),
          (d.theta = de - Me),
          i.update());
      }),
      (this.getDistance = () => i.object.position.distanceTo(i.target)),
      (this.listenToKeyEvents = (W) => {
        (W.addEventListener("keydown", le), (this._domElementKeyEvents = W));
      }),
      (this.saveState = () => {
        (i.target0.copy(i.target),
          i.position0.copy(i.object.position),
          (i.zoom0 = i.object instanceof Vt ? i.object.zoom : 1));
      }),
      (this.reset = () => {
        (i.target.copy(i.target0),
          i.object.position.copy(i.position0),
          i.object instanceof Vt &&
            ((i.object.zoom = i.zoom0), i.object.updateProjectionMatrix()),
          i.dispatchEvent(r),
          i.update(),
          (l = a.NONE));
      }),
      (this.update = (() => {
        const W = new F(),
          de = new Kn().setFromUnitVectors(e.up, new F(0, 1, 0)),
          Me = de.clone().invert(),
          Pe = new F(),
          qe = new Kn(),
          ht = 2 * Math.PI;
        return function () {
          const K = i.object.position;
          (W.copy(K).sub(i.target),
            W.applyQuaternion(de),
            h.setFromVector3(W),
            i.autoRotate && l === a.NONE && J(L()),
            i.enableDamping
              ? ((h.theta += d.theta * i.dampingFactor),
                (h.phi += d.phi * i.dampingFactor))
              : ((h.theta += d.theta), (h.phi += d.phi)));
          let fe = i.minAzimuthAngle,
            we = i.maxAzimuthAngle;
          return (
            isFinite(fe) &&
              isFinite(we) &&
              (fe < -Math.PI ? (fe += ht) : fe > Math.PI && (fe -= ht),
              we < -Math.PI ? (we += ht) : we > Math.PI && (we -= ht),
              fe <= we
                ? (h.theta = Math.max(fe, Math.min(we, h.theta)))
                : (h.theta =
                    h.theta > (fe + we) / 2
                      ? Math.max(fe, h.theta)
                      : Math.min(we, h.theta))),
            (h.phi = Math.max(
              i.minPolarAngle,
              Math.min(i.maxPolarAngle, h.phi)
            )),
            h.makeSafe(),
            (h.radius *= p),
            (h.radius = Math.max(
              i.minDistance,
              Math.min(i.maxDistance, h.radius)
            )),
            i.enableDamping === !0
              ? i.target.addScaledVector(g, i.dampingFactor)
              : i.target.add(g),
            W.setFromSpherical(h),
            W.applyQuaternion(Me),
            K.copy(i.target).add(W),
            i.object.lookAt(i.target),
            i.enableDamping === !0
              ? ((d.theta *= 1 - i.dampingFactor),
                (d.phi *= 1 - i.dampingFactor),
                g.multiplyScalar(1 - i.dampingFactor))
              : (d.set(0, 0, 0), g.set(0, 0, 0)),
            (p = 1),
            y ||
            Pe.distanceToSquared(i.object.position) > u ||
            8 * (1 - qe.dot(i.object.quaternion)) > u
              ? (i.dispatchEvent(r),
                Pe.copy(i.object.position),
                qe.copy(i.object.quaternion),
                (y = !1),
                !0)
              : !1
          );
        };
      })()),
      (this.connect = (W) => {
        (W === document &&
          console.error(
            'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
          ),
          (i.domElement = W),
          (i.domElement.style.touchAction = "none"),
          i.domElement.addEventListener("contextmenu", Re),
          i.domElement.addEventListener("pointerdown", We),
          i.domElement.addEventListener("pointercancel", nt),
          i.domElement.addEventListener("wheel", D));
      }),
      (this.dispose = () => {
        var W, de, Me, Pe, qe, ht;
        ((W = i.domElement) === null ||
          W === void 0 ||
          W.removeEventListener("contextmenu", Re),
          (de = i.domElement) === null ||
            de === void 0 ||
            de.removeEventListener("pointerdown", We),
          (Me = i.domElement) === null ||
            Me === void 0 ||
            Me.removeEventListener("pointercancel", nt),
          (Pe = i.domElement) === null ||
            Pe === void 0 ||
            Pe.removeEventListener("wheel", D),
          (qe = i.domElement) === null ||
            qe === void 0 ||
            qe.ownerDocument.removeEventListener("pointermove", Ke),
          (ht = i.domElement) === null ||
            ht === void 0 ||
            ht.ownerDocument.removeEventListener("pointerup", je),
          i._domElementKeyEvents !== null &&
            i._domElementKeyEvents.removeEventListener("keydown", le));
      }));
    const i = this,
      r = { type: "change" },
      s = { type: "start" },
      o = { type: "end" },
      a = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      };
    let l = a.NONE;
    const u = 1e-6,
      h = new A_(),
      d = new A_();
    let p = 1;
    const g = new F();
    let y = !1;
    const A = new ve(),
      _ = new ve(),
      m = new ve(),
      x = new ve(),
      S = new ve(),
      w = new ve(),
      C = new ve(),
      P = new ve(),
      R = new ve(),
      B = [],
      b = {};
    function L() {
      return ((2 * Math.PI) / 60 / 60) * i.autoRotateSpeed;
    }
    function U() {
      return Math.pow(0.95, i.zoomSpeed);
    }
    function J(W) {
      i.reverseOrbit ? (d.theta += W) : (d.theta -= W);
    }
    function V(W) {
      i.reverseOrbit ? (d.phi += W) : (d.phi -= W);
    }
    const j = (() => {
        const W = new F();
        return function (Me, Pe) {
          (W.setFromMatrixColumn(Pe, 0), W.multiplyScalar(-Me), g.add(W));
        };
      })(),
      X = (() => {
        const W = new F();
        return function (Me, Pe) {
          (i.screenSpacePanning === !0
            ? W.setFromMatrixColumn(Pe, 1)
            : (W.setFromMatrixColumn(Pe, 0), W.crossVectors(i.object.up, W)),
            W.multiplyScalar(Me),
            g.add(W));
        };
      })(),
      oe = (() => {
        const W = new F();
        return function (Me, Pe) {
          const qe = i.domElement;
          if (qe && i.object instanceof Vt && i.object.isPerspectiveCamera) {
            const ht = i.object.position;
            W.copy(ht).sub(i.target);
            let Ut = W.length();
            ((Ut *= Math.tan(((i.object.fov / 2) * Math.PI) / 180)),
              j((2 * Me * Ut) / qe.clientHeight, i.object.matrix),
              X((2 * Pe * Ut) / qe.clientHeight, i.object.matrix));
          } else
            qe && i.object instanceof zr && i.object.isOrthographicCamera
              ? (j(
                  (Me * (i.object.right - i.object.left)) /
                    i.object.zoom /
                    qe.clientWidth,
                  i.object.matrix
                ),
                X(
                  (Pe * (i.object.top - i.object.bottom)) /
                    i.object.zoom /
                    qe.clientHeight,
                  i.object.matrix
                ))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                ),
                (i.enablePan = !1));
        };
      })();
    function ae(W) {
      i.object instanceof Vt && i.object.isPerspectiveCamera
        ? (p /= W)
        : i.object instanceof zr && i.object.isOrthographicCamera
          ? ((i.object.zoom = Math.max(
              i.minZoom,
              Math.min(i.maxZoom, i.object.zoom * W)
            )),
            i.object.updateProjectionMatrix(),
            (y = !0))
          : (console.warn(
              "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
            ),
            (i.enableZoom = !1));
    }
    function I(W) {
      i.object instanceof Vt && i.object.isPerspectiveCamera
        ? (p *= W)
        : i.object instanceof zr && i.object.isOrthographicCamera
          ? ((i.object.zoom = Math.max(
              i.minZoom,
              Math.min(i.maxZoom, i.object.zoom / W)
            )),
            i.object.updateProjectionMatrix(),
            (y = !0))
          : (console.warn(
              "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
            ),
            (i.enableZoom = !1));
    }
    function G(W) {
      A.set(W.clientX, W.clientY);
    }
    function z(W) {
      C.set(W.clientX, W.clientY);
    }
    function q(W) {
      x.set(W.clientX, W.clientY);
    }
    function Q(W) {
      (_.set(W.clientX, W.clientY),
        m.subVectors(_, A).multiplyScalar(i.rotateSpeed));
      const de = i.domElement;
      (de &&
        (J((2 * Math.PI * m.x) / de.clientHeight),
        V((2 * Math.PI * m.y) / de.clientHeight)),
        A.copy(_),
        i.update());
    }
    function ee(W) {
      (P.set(W.clientX, W.clientY),
        R.subVectors(P, C),
        R.y > 0 ? ae(U()) : R.y < 0 && I(U()),
        C.copy(P),
        i.update());
    }
    function ne(W) {
      (S.set(W.clientX, W.clientY),
        w.subVectors(S, x).multiplyScalar(i.panSpeed),
        oe(w.x, w.y),
        x.copy(S),
        i.update());
    }
    function Ee(W) {
      (W.deltaY < 0 ? I(U()) : W.deltaY > 0 && ae(U()), i.update());
    }
    function Ae(W) {
      let de = !1;
      switch (W.code) {
        case i.keys.UP:
          (oe(0, i.keyPanSpeed), (de = !0));
          break;
        case i.keys.BOTTOM:
          (oe(0, -i.keyPanSpeed), (de = !0));
          break;
        case i.keys.LEFT:
          (oe(i.keyPanSpeed, 0), (de = !0));
          break;
        case i.keys.RIGHT:
          (oe(-i.keyPanSpeed, 0), (de = !0));
          break;
      }
      de && (W.preventDefault(), i.update());
    }
    function $() {
      if (B.length == 1) A.set(B[0].pageX, B[0].pageY);
      else {
        const W = 0.5 * (B[0].pageX + B[1].pageX),
          de = 0.5 * (B[0].pageY + B[1].pageY);
        A.set(W, de);
      }
    }
    function Je() {
      if (B.length == 1) x.set(B[0].pageX, B[0].pageY);
      else {
        const W = 0.5 * (B[0].pageX + B[1].pageX),
          de = 0.5 * (B[0].pageY + B[1].pageY);
        x.set(W, de);
      }
    }
    function Xe() {
      const W = B[0].pageX - B[1].pageX,
        de = B[0].pageY - B[1].pageY,
        Me = Math.sqrt(W * W + de * de);
      C.set(0, Me);
    }
    function xe() {
      (i.enableZoom && Xe(), i.enablePan && Je());
    }
    function Se() {
      (i.enableZoom && Xe(), i.enableRotate && $());
    }
    function ge(W) {
      if (B.length == 1) _.set(W.pageX, W.pageY);
      else {
        const Me = He(W),
          Pe = 0.5 * (W.pageX + Me.x),
          qe = 0.5 * (W.pageY + Me.y);
        _.set(Pe, qe);
      }
      m.subVectors(_, A).multiplyScalar(i.rotateSpeed);
      const de = i.domElement;
      (de &&
        (J((2 * Math.PI * m.x) / de.clientHeight),
        V((2 * Math.PI * m.y) / de.clientHeight)),
        A.copy(_));
    }
    function se(W) {
      if (B.length == 1) S.set(W.pageX, W.pageY);
      else {
        const de = He(W),
          Me = 0.5 * (W.pageX + de.x),
          Pe = 0.5 * (W.pageY + de.y);
        S.set(Me, Pe);
      }
      (w.subVectors(S, x).multiplyScalar(i.panSpeed), oe(w.x, w.y), x.copy(S));
    }
    function _e(W) {
      const de = He(W),
        Me = W.pageX - de.x,
        Pe = W.pageY - de.y,
        qe = Math.sqrt(Me * Me + Pe * Pe);
      (P.set(0, qe),
        R.set(0, Math.pow(P.y / C.y, i.zoomSpeed)),
        ae(R.y),
        C.copy(P));
    }
    function Ne(W) {
      (i.enableZoom && _e(W), i.enablePan && se(W));
    }
    function Le(W) {
      (i.enableZoom && _e(W), i.enableRotate && ge(W));
    }
    function We(W) {
      if (i.enabled !== !1) {
        if (B.length === 0) {
          var de, Me;
          ((de = i.domElement) === null ||
            de === void 0 ||
            de.ownerDocument.addEventListener("pointermove", Ke),
            (Me = i.domElement) === null ||
              Me === void 0 ||
              Me.ownerDocument.addEventListener("pointerup", je));
        }
        (et(W), W.pointerType === "touch" ? Ce(W) : At(W));
      }
    }
    function Ke(W) {
      i.enabled !== !1 && (W.pointerType === "touch" ? Te(W) : O(W));
    }
    function je(W) {
      if ((Ue(W), B.length === 0)) {
        var de, Me, Pe;
        ((de = i.domElement) === null ||
          de === void 0 ||
          de.releasePointerCapture(W.pointerId),
          (Me = i.domElement) === null ||
            Me === void 0 ||
            Me.ownerDocument.removeEventListener("pointermove", Ke),
          (Pe = i.domElement) === null ||
            Pe === void 0 ||
            Pe.ownerDocument.removeEventListener("pointerup", je));
      }
      (i.dispatchEvent(o), (l = a.NONE));
    }
    function nt(W) {
      Ue(W);
    }
    function At(W) {
      let de;
      switch (W.button) {
        case 0:
          de = i.mouseButtons.LEFT;
          break;
        case 1:
          de = i.mouseButtons.MIDDLE;
          break;
        case 2:
          de = i.mouseButtons.RIGHT;
          break;
        default:
          de = -1;
      }
      switch (de) {
        case ba.DOLLY:
          if (i.enableZoom === !1) return;
          (z(W), (l = a.DOLLY));
          break;
        case ba.ROTATE:
          if (W.ctrlKey || W.metaKey || W.shiftKey) {
            if (i.enablePan === !1) return;
            (q(W), (l = a.PAN));
          } else {
            if (i.enableRotate === !1) return;
            (G(W), (l = a.ROTATE));
          }
          break;
        case ba.PAN:
          if (W.ctrlKey || W.metaKey || W.shiftKey) {
            if (i.enableRotate === !1) return;
            (G(W), (l = a.ROTATE));
          } else {
            if (i.enablePan === !1) return;
            (q(W), (l = a.PAN));
          }
          break;
        default:
          l = a.NONE;
      }
      l !== a.NONE && i.dispatchEvent(s);
    }
    function O(W) {
      if (i.enabled !== !1)
        switch (l) {
          case a.ROTATE:
            if (i.enableRotate === !1) return;
            Q(W);
            break;
          case a.DOLLY:
            if (i.enableZoom === !1) return;
            ee(W);
            break;
          case a.PAN:
            if (i.enablePan === !1) return;
            ne(W);
            break;
        }
    }
    function D(W) {
      i.enabled === !1 ||
        i.enableZoom === !1 ||
        (l !== a.NONE && l !== a.ROTATE) ||
        (W.preventDefault(), i.dispatchEvent(s), Ee(W), i.dispatchEvent(o));
    }
    function le(W) {
      i.enabled === !1 || i.enablePan === !1 || Ae(W);
    }
    function Ce(W) {
      switch ((pe(W), B.length)) {
        case 1:
          switch (i.touches.ONE) {
            case Pa.ROTATE:
              if (i.enableRotate === !1) return;
              ($(), (l = a.TOUCH_ROTATE));
              break;
            case Pa.PAN:
              if (i.enablePan === !1) return;
              (Je(), (l = a.TOUCH_PAN));
              break;
            default:
              l = a.NONE;
          }
          break;
        case 2:
          switch (i.touches.TWO) {
            case Pa.DOLLY_PAN:
              if (i.enableZoom === !1 && i.enablePan === !1) return;
              (xe(), (l = a.TOUCH_DOLLY_PAN));
              break;
            case Pa.DOLLY_ROTATE:
              if (i.enableZoom === !1 && i.enableRotate === !1) return;
              (Se(), (l = a.TOUCH_DOLLY_ROTATE));
              break;
            default:
              l = a.NONE;
          }
          break;
        default:
          l = a.NONE;
      }
      l !== a.NONE && i.dispatchEvent(s);
    }
    function Te(W) {
      switch ((pe(W), l)) {
        case a.TOUCH_ROTATE:
          if (i.enableRotate === !1) return;
          (ge(W), i.update());
          break;
        case a.TOUCH_PAN:
          if (i.enablePan === !1) return;
          (se(W), i.update());
          break;
        case a.TOUCH_DOLLY_PAN:
          if (i.enableZoom === !1 && i.enablePan === !1) return;
          (Ne(W), i.update());
          break;
        case a.TOUCH_DOLLY_ROTATE:
          if (i.enableZoom === !1 && i.enableRotate === !1) return;
          (Le(W), i.update());
          break;
        default:
          l = a.NONE;
      }
    }
    function Re(W) {
      i.enabled !== !1 && W.preventDefault();
    }
    function et(W) {
      B.push(W);
    }
    function Ue(W) {
      delete b[W.pointerId];
      for (let de = 0; de < B.length; de++)
        if (B[de].pointerId == W.pointerId) {
          B.splice(de, 1);
          return;
        }
    }
    function pe(W) {
      let de = b[W.pointerId];
      (de === void 0 && ((de = new ve()), (b[W.pointerId] = de)),
        de.set(W.pageX, W.pageY));
    }
    function He(W) {
      const de = W.pointerId === B[0].pointerId ? B[1] : B[0];
      return b[de.pointerId];
    }
    (t !== void 0 && this.connect(t), this.update());
  }
};
class UA extends _i {
  constructor(e) {
    (super(e),
      (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (t) {
        return new t9(t);
      }),
      this.register(function (t) {
        return new l9(t);
      }),
      this.register(function (t) {
        return new c9(t);
      }),
      this.register(function (t) {
        return new i9(t);
      }),
      this.register(function (t) {
        return new r9(t);
      }),
      this.register(function (t) {
        return new s9(t);
      }),
      this.register(function (t) {
        return new o9(t);
      }),
      this.register(function (t) {
        return new e9(t);
      }),
      this.register(function (t) {
        return new a9(t);
      }),
      this.register(function (t) {
        return new n9(t);
      }),
      this.register(function (t) {
        return new qV(t);
      }),
      this.register(function (t) {
        return new u9(t);
      }));
  }
  load(e, t, i, r) {
    const s = this;
    let o;
    (this.resourcePath !== ""
      ? (o = this.resourcePath)
      : this.path !== ""
        ? (o = this.path)
        : (o = cs.extractUrlBase(e)),
      this.manager.itemStart(e));
    const a = function (u) {
        (r ? r(u) : console.error(u),
          s.manager.itemError(e),
          s.manager.itemEnd(e));
      },
      l = new Qi(this.manager);
    (l.setPath(this.path),
      l.setResponseType("arraybuffer"),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(this.withCredentials),
      l.load(
        e,
        function (u) {
          try {
            s.parse(
              u,
              o,
              function (h) {
                (t(h), s.manager.itemEnd(e));
              },
              a
            );
          } catch (h) {
            a(h);
          }
        },
        i,
        a
      ));
  }
  setDRACOLoader(e) {
    return ((this.dracoLoader = e), this);
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(e) {
    return ((this.ktx2Loader = e), this);
  }
  setMeshoptDecoder(e) {
    return ((this.meshoptDecoder = e), this);
  }
  register(e) {
    return (
      this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
      this
    );
  }
  unregister(e) {
    return (
      this.pluginCallbacks.indexOf(e) !== -1 &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
      this
    );
  }
  parse(e, t, i, r) {
    let s;
    const o = {},
      a = {};
    if (typeof e == "string") s = e;
    else if (cs.decodeText(new Uint8Array(e, 0, 4)) === a3) {
      try {
        o[Et.KHR_BINARY_GLTF] = new f9(e);
      } catch (d) {
        r && r(d);
        return;
      }
      s = o[Et.KHR_BINARY_GLTF].content;
    } else s = cs.decodeText(new Uint8Array(e));
    const l = JSON.parse(s);
    if (l.asset === void 0 || l.asset.version[0] < 2) {
      r &&
        r(
          new Error(
            "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
          )
        );
      return;
    }
    const u = new w9(l, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
    });
    u.fileLoader.setRequestHeader(this.requestHeader);
    for (let h = 0; h < this.pluginCallbacks.length; h++) {
      const d = this.pluginCallbacks[h](u);
      ((a[d.name] = d), (o[d.name] = !0));
    }
    if (l.extensionsUsed)
      for (let h = 0; h < l.extensionsUsed.length; ++h) {
        const d = l.extensionsUsed[h],
          p = l.extensionsRequired || [];
        switch (d) {
          case Et.KHR_MATERIALS_UNLIT:
            o[d] = new $V();
            break;
          case Et.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
            o[d] = new p9();
            break;
          case Et.KHR_DRACO_MESH_COMPRESSION:
            o[d] = new h9(l, this.dracoLoader);
            break;
          case Et.KHR_TEXTURE_TRANSFORM:
            o[d] = new d9();
            break;
          case Et.KHR_MESH_QUANTIZATION:
            o[d] = new m9();
            break;
          default:
            p.indexOf(d) >= 0 &&
              a[d] === void 0 &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + d + '".');
        }
      }
    (u.setExtensions(o), u.setPlugins(a), u.parse(i, r));
  }
  parseAsync(e, t) {
    const i = this;
    return new Promise(function (r, s) {
      i.parse(e, t, r, s);
    });
  }
}
function ZV() {
  let n = {};
  return {
    get: function (e) {
      return n[e];
    },
    add: function (e, t) {
      n[e] = t;
    },
    remove: function (e) {
      delete n[e];
    },
    removeAll: function () {
      n = {};
    },
  };
}
const Et = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
};
class qV {
  constructor(e) {
    ((this.parser = e),
      (this.name = Et.KHR_LIGHTS_PUNCTUAL),
      (this.cache = { refs: {}, uses: {} }));
  }
  _markDefs() {
    const e = this.parser,
      t = this.parser.json.nodes || [];
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      s.extensions &&
        s.extensions[this.name] &&
        s.extensions[this.name].light !== void 0 &&
        e._addNodeRef(this.cache, s.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser,
      i = "light:" + e;
    let r = t.cache.get(i);
    if (r) return r;
    const s = t.json,
      l = (((s.extensions && s.extensions[this.name]) || {}).lights || [])[e];
    let u;
    const h = new Ie(16777215);
    l.color !== void 0 && h.fromArray(l.color);
    const d = l.range !== void 0 ? l.range : 0;
    switch (l.type) {
      case "directional":
        ((u = new bA(h)), u.target.position.set(0, 0, -1), u.add(u.target));
        break;
      case "point":
        ((u = new TA(h)), (u.distance = d));
        break;
      case "spot":
        ((u = new CA(h)),
          (u.distance = d),
          (l.spot = l.spot || {}),
          (l.spot.innerConeAngle =
            l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0),
          (l.spot.outerConeAngle =
            l.spot.outerConeAngle !== void 0
              ? l.spot.outerConeAngle
              : Math.PI / 4),
          (u.angle = l.spot.outerConeAngle),
          (u.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle),
          u.target.position.set(0, 0, -1),
          u.add(u.target));
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type);
    }
    return (
      u.position.set(0, 0, 0),
      (u.decay = 2),
      l.intensity !== void 0 && (u.intensity = l.intensity),
      (u.name = t.createUniqueName(l.name || "light_" + e)),
      (r = Promise.resolve(u)),
      t.cache.add(i, r),
      r
    );
  }
  createNodeAttachment(e) {
    const t = this,
      i = this.parser,
      s = i.json.nodes[e],
      a = ((s.extensions && s.extensions[this.name]) || {}).light;
    return a === void 0
      ? null
      : this._loadLight(a).then(function (l) {
          return i._getNodeRef(t.cache, a, l);
        });
  }
}
class $V {
  constructor() {
    this.name = Et.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return Ji;
  }
  extendParams(e, t, i) {
    const r = [];
    ((e.color = new Ie(1, 1, 1)), (e.opacity = 1));
    const s = t.pbrMetallicRoughness;
    if (s) {
      if (Array.isArray(s.baseColorFactor)) {
        const o = s.baseColorFactor;
        (e.color.fromArray(o), (e.opacity = o[3]));
      }
      s.baseColorTexture !== void 0 &&
        r.push(i.assignTexture(e, "map", s.baseColorTexture, Tt));
    }
    return Promise.all(r);
  }
}
class e9 {
  constructor(e) {
    ((this.parser = e), (this.name = Et.KHR_MATERIALS_EMISSIVE_STRENGTH));
  }
  extendMaterialParams(e, t) {
    const r = this.parser.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = r.extensions[this.name].emissiveStrength;
    return (s !== void 0 && (t.emissiveIntensity = s), Promise.resolve());
  }
}
class t9 {
  constructor(e) {
    ((this.parser = e), (this.name = Et.KHR_MATERIALS_CLEARCOAT));
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : no;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    if (
      (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor),
      o.clearcoatTexture !== void 0 &&
        s.push(i.assignTexture(t, "clearcoatMap", o.clearcoatTexture)),
      o.clearcoatRoughnessFactor !== void 0 &&
        (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
      o.clearcoatRoughnessTexture !== void 0 &&
        s.push(
          i.assignTexture(
            t,
            "clearcoatRoughnessMap",
            o.clearcoatRoughnessTexture
          )
        ),
      o.clearcoatNormalTexture !== void 0 &&
        (s.push(
          i.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)
        ),
        o.clearcoatNormalTexture.scale !== void 0))
    ) {
      const a = o.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new ve(a, a);
    }
    return Promise.all(s);
  }
}
class n9 {
  constructor(e) {
    ((this.parser = e), (this.name = Et.KHR_MATERIALS_IRIDESCENCE));
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : no;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    return (
      o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor),
      o.iridescenceTexture !== void 0 &&
        s.push(i.assignTexture(t, "iridescenceMap", o.iridescenceTexture)),
      o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor),
      t.iridescenceThicknessRange === void 0 &&
        (t.iridescenceThicknessRange = [100, 400]),
      o.iridescenceThicknessMinimum !== void 0 &&
        (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum),
      o.iridescenceThicknessMaximum !== void 0 &&
        (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum),
      o.iridescenceThicknessTexture !== void 0 &&
        s.push(
          i.assignTexture(
            t,
            "iridescenceThicknessMap",
            o.iridescenceThicknessTexture
          )
        ),
      Promise.all(s)
    );
  }
}
class i9 {
  constructor(e) {
    ((this.parser = e), (this.name = Et.KHR_MATERIALS_SHEEN));
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : no;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [];
    ((t.sheenColor = new Ie(0, 0, 0)), (t.sheenRoughness = 0), (t.sheen = 1));
    const o = r.extensions[this.name];
    return (
      o.sheenColorFactor !== void 0 &&
        t.sheenColor.fromArray(o.sheenColorFactor),
      o.sheenRoughnessFactor !== void 0 &&
        (t.sheenRoughness = o.sheenRoughnessFactor),
      o.sheenColorTexture !== void 0 &&
        s.push(i.assignTexture(t, "sheenColorMap", o.sheenColorTexture, Tt)),
      o.sheenRoughnessTexture !== void 0 &&
        s.push(
          i.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)
        ),
      Promise.all(s)
    );
  }
}
class r9 {
  constructor(e) {
    ((this.parser = e), (this.name = Et.KHR_MATERIALS_TRANSMISSION));
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : no;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    return (
      o.transmissionFactor !== void 0 &&
        (t.transmission = o.transmissionFactor),
      o.transmissionTexture !== void 0 &&
        s.push(i.assignTexture(t, "transmissionMap", o.transmissionTexture)),
      Promise.all(s)
    );
  }
}
class s9 {
  constructor(e) {
    ((this.parser = e), (this.name = Et.KHR_MATERIALS_VOLUME));
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : no;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    ((t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0),
      o.thicknessTexture !== void 0 &&
        s.push(i.assignTexture(t, "thicknessMap", o.thicknessTexture)),
      (t.attenuationDistance = o.attenuationDistance || 1 / 0));
    const a = o.attenuationColor || [1, 1, 1];
    return ((t.attenuationColor = new Ie(a[0], a[1], a[2])), Promise.all(s));
  }
}
class o9 {
  constructor(e) {
    ((this.parser = e), (this.name = Et.KHR_MATERIALS_IOR));
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : no;
  }
  extendMaterialParams(e, t) {
    const r = this.parser.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = r.extensions[this.name];
    return ((t.ior = s.ior !== void 0 ? s.ior : 1.5), Promise.resolve());
  }
}
class a9 {
  constructor(e) {
    ((this.parser = e), (this.name = Et.KHR_MATERIALS_SPECULAR));
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : no;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    ((t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1),
      o.specularTexture !== void 0 &&
        s.push(i.assignTexture(t, "specularIntensityMap", o.specularTexture)));
    const a = o.specularColorFactor || [1, 1, 1];
    return (
      (t.specularColor = new Ie(a[0], a[1], a[2])),
      o.specularColorTexture !== void 0 &&
        s.push(
          i.assignTexture(t, "specularColorMap", o.specularColorTexture, Tt)
        ),
      Promise.all(s)
    );
  }
}
class l9 {
  constructor(e) {
    ((this.parser = e), (this.name = Et.KHR_TEXTURE_BASISU));
  }
  loadTexture(e) {
    const t = this.parser,
      i = t.json,
      r = i.textures[e];
    if (!r.extensions || !r.extensions[this.name]) return null;
    const s = r.extensions[this.name],
      o = t.options.ktx2Loader;
    if (!o) {
      if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error(
          "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
        );
      return null;
    }
    return t.loadTextureImage(e, s.source, o);
  }
}
class c9 {
  constructor(e) {
    ((this.parser = e),
      (this.name = Et.EXT_TEXTURE_WEBP),
      (this.isSupported = null));
  }
  loadTexture(e) {
    const t = this.name,
      i = this.parser,
      r = i.json,
      s = r.textures[e];
    if (!s.extensions || !s.extensions[t]) return null;
    const o = s.extensions[t],
      a = r.images[o.source];
    let l = i.textureLoader;
    if (a.uri) {
      const u = i.options.manager.getHandler(a.uri);
      u !== null && (l = u);
    }
    return this.detectSupport().then(function (u) {
      if (u) return i.loadTextureImage(e, o.source, l);
      if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          "THREE.GLTFLoader: WebP required by asset but unsupported."
        );
      return i.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          ((t.src =
            "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
            (t.onload = t.onerror =
              function () {
                e(t.height === 1);
              }));
        })),
      this.isSupported
    );
  }
}
class u9 {
  constructor(e) {
    ((this.name = Et.EXT_MESHOPT_COMPRESSION), (this.parser = e));
  }
  loadBufferView(e) {
    const t = this.parser.json,
      i = t.bufferViews[e];
    if (i.extensions && i.extensions[this.name]) {
      const r = i.extensions[this.name],
        s = this.parser.getDependency("buffer", r.buffer),
        o = this.parser.options.meshoptDecoder;
      if (!o || !o.supported) {
        if (
          t.extensionsRequired &&
          t.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
          );
        return null;
      }
      return s.then(function (a) {
        const l = r.byteOffset || 0,
          u = r.byteLength || 0,
          h = r.count,
          d = r.byteStride,
          p = new Uint8Array(a, l, u);
        return o.decodeGltfBufferAsync
          ? o
              .decodeGltfBufferAsync(h, d, p, r.mode, r.filter)
              .then(function (g) {
                return g.buffer;
              })
          : o.ready.then(function () {
              const g = new ArrayBuffer(h * d);
              return (
                o.decodeGltfBuffer(
                  new Uint8Array(g),
                  h,
                  d,
                  p,
                  r.mode,
                  r.filter
                ),
                g
              );
            });
      });
    } else return null;
  }
}
const a3 = "glTF",
  tf = 12,
  iT = { JSON: 1313821514, BIN: 5130562 };
class f9 {
  constructor(e) {
    ((this.name = Et.KHR_BINARY_GLTF),
      (this.content = null),
      (this.body = null));
    const t = new DataView(e, 0, tf);
    if (
      ((this.header = {
        magic: cs.decodeText(new Uint8Array(e.slice(0, 4))),
        version: t.getUint32(4, !0),
        length: t.getUint32(8, !0),
      }),
      this.header.magic !== a3)
    )
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const i = this.header.length - tf,
      r = new DataView(e, tf);
    let s = 0;
    for (; s < i; ) {
      const o = r.getUint32(s, !0);
      s += 4;
      const a = r.getUint32(s, !0);
      if (((s += 4), a === iT.JSON)) {
        const l = new Uint8Array(e, tf + s, o);
        this.content = cs.decodeText(l);
      } else if (a === iT.BIN) {
        const l = tf + s;
        this.body = e.slice(l, l + o);
      }
      s += o;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class h9 {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    ((this.name = Et.KHR_DRACO_MESH_COMPRESSION),
      (this.json = e),
      (this.dracoLoader = t),
      this.dracoLoader.preload());
  }
  decodePrimitive(e, t) {
    const i = this.json,
      r = this.dracoLoader,
      s = e.extensions[this.name].bufferView,
      o = e.extensions[this.name].attributes,
      a = {},
      l = {},
      u = {};
    for (const h in o) {
      const d = b_[h] || h.toLowerCase();
      a[d] = o[h];
    }
    for (const h in e.attributes) {
      const d = b_[h] || h.toLowerCase();
      if (o[h] !== void 0) {
        const p = i.accessors[e.attributes[h]],
          g = uh[p.componentType];
        ((u[d] = g.name), (l[d] = p.normalized === !0));
      }
    }
    return t.getDependency("bufferView", s).then(function (h) {
      return new Promise(function (d) {
        r.decodeDracoFile(
          h,
          function (p) {
            for (const g in p.attributes) {
              const y = p.attributes[g],
                A = l[g];
              A !== void 0 && (y.normalized = A);
            }
            d(p);
          },
          a,
          u
        );
      });
    });
  }
}
class d9 {
  constructor() {
    this.name = Et.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (
      t.texCoord !== void 0 &&
        console.warn(
          'THREE.GLTFLoader: Custom UV sets in "' +
            this.name +
            '" extension not yet supported.'
        ),
      (t.offset === void 0 && t.rotation === void 0 && t.scale === void 0) ||
        ((e = e.clone()),
        t.offset !== void 0 && e.offset.fromArray(t.offset),
        t.rotation !== void 0 && (e.rotation = t.rotation),
        t.scale !== void 0 && e.repeat.fromArray(t.scale),
        (e.needsUpdate = !0)),
      e
    );
  }
}
class T_ extends cu {
  constructor(e) {
    (super(), (this.isGLTFSpecularGlossinessMaterial = !0));
    const t = [
        "#ifdef USE_SPECULARMAP",
        "	uniform sampler2D specularMap;",
        "#endif",
      ].join(`
`),
      i = [
        "#ifdef USE_GLOSSINESSMAP",
        "	uniform sampler2D glossinessMap;",
        "#endif",
      ].join(`
`),
      r = [
        "vec3 specularFactor = specular;",
        "#ifdef USE_SPECULARMAP",
        "	vec4 texelSpecular = texture2D( specularMap, vUv );",
        "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
        "	specularFactor *= texelSpecular.rgb;",
        "#endif",
      ].join(`
`),
      s = [
        "float glossinessFactor = glossiness;",
        "#ifdef USE_GLOSSINESSMAP",
        "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );",
        "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
        "	glossinessFactor *= texelGlossiness.a;",
        "#endif",
      ].join(`
`),
      o = [
        "PhysicalMaterial material;",
        "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
        "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
        "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
        "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
        "material.roughness += geometryRoughness;",
        "material.roughness = min( material.roughness, 1.0 );",
        "material.specularColor = specularFactor;",
      ].join(`
`),
      a = {
        specular: { value: new Ie().setHex(16777215) },
        glossiness: { value: 1 },
        specularMap: { value: null },
        glossinessMap: { value: null },
      };
    ((this._extraUniforms = a),
      (this.onBeforeCompile = function (l) {
        for (const u in a) l.uniforms[u] = a[u];
        l.fragmentShader = l.fragmentShader
          .replace("uniform float roughness;", "uniform vec3 specular;")
          .replace("uniform float metalness;", "uniform float glossiness;")
          .replace("#include <roughnessmap_pars_fragment>", t)
          .replace("#include <metalnessmap_pars_fragment>", i)
          .replace("#include <roughnessmap_fragment>", r)
          .replace("#include <metalnessmap_fragment>", s)
          .replace("#include <lights_physical_fragment>", o);
      }),
      Object.defineProperties(this, {
        specular: {
          get: function () {
            return a.specular.value;
          },
          set: function (l) {
            a.specular.value = l;
          },
        },
        specularMap: {
          get: function () {
            return a.specularMap.value;
          },
          set: function (l) {
            ((a.specularMap.value = l),
              l
                ? (this.defines.USE_SPECULARMAP = "")
                : delete this.defines.USE_SPECULARMAP);
          },
        },
        glossiness: {
          get: function () {
            return a.glossiness.value;
          },
          set: function (l) {
            a.glossiness.value = l;
          },
        },
        glossinessMap: {
          get: function () {
            return a.glossinessMap.value;
          },
          set: function (l) {
            ((a.glossinessMap.value = l),
              l
                ? ((this.defines.USE_GLOSSINESSMAP = ""),
                  (this.defines.USE_UV = ""))
                : (delete this.defines.USE_GLOSSINESSMAP,
                  delete this.defines.USE_UV));
          },
        },
      }),
      delete this.metalness,
      delete this.roughness,
      delete this.metalnessMap,
      delete this.roughnessMap,
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.specularMap = e.specularMap),
      this.specular.copy(e.specular),
      (this.glossinessMap = e.glossinessMap),
      (this.glossiness = e.glossiness),
      delete this.metalness,
      delete this.roughness,
      delete this.metalnessMap,
      delete this.roughnessMap,
      this
    );
  }
}
class p9 {
  constructor() {
    ((this.name = Et.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS),
      (this.specularGlossinessParams = [
        "color",
        "map",
        "lightMap",
        "lightMapIntensity",
        "aoMap",
        "aoMapIntensity",
        "emissive",
        "emissiveIntensity",
        "emissiveMap",
        "bumpMap",
        "bumpScale",
        "normalMap",
        "normalMapType",
        "displacementMap",
        "displacementScale",
        "displacementBias",
        "specularMap",
        "specular",
        "glossinessMap",
        "glossiness",
        "alphaMap",
        "envMap",
        "envMapIntensity",
        "refractionRatio",
      ]));
  }
  getMaterialType() {
    return T_;
  }
  extendParams(e, t, i) {
    const r = t.extensions[this.name];
    ((e.color = new Ie(1, 1, 1)), (e.opacity = 1));
    const s = [];
    if (Array.isArray(r.diffuseFactor)) {
      const o = r.diffuseFactor;
      (e.color.fromArray(o), (e.opacity = o[3]));
    }
    if (
      (r.diffuseTexture !== void 0 &&
        s.push(i.assignTexture(e, "map", r.diffuseTexture, Tt)),
      (e.emissive = new Ie(0, 0, 0)),
      (e.glossiness = r.glossinessFactor !== void 0 ? r.glossinessFactor : 1),
      (e.specular = new Ie(1, 1, 1)),
      Array.isArray(r.specularFactor) && e.specular.fromArray(r.specularFactor),
      r.specularGlossinessTexture !== void 0)
    ) {
      const o = r.specularGlossinessTexture;
      (s.push(i.assignTexture(e, "glossinessMap", o)),
        s.push(i.assignTexture(e, "specularMap", o, Tt)));
    }
    return Promise.all(s);
  }
  createMaterial(e) {
    const t = new T_(e);
    return (
      (t.fog = !0),
      (t.color = e.color),
      (t.map = e.map === void 0 ? null : e.map),
      (t.lightMap = null),
      (t.lightMapIntensity = 1),
      (t.aoMap = e.aoMap === void 0 ? null : e.aoMap),
      (t.aoMapIntensity = 1),
      (t.emissive = e.emissive),
      (t.emissiveIntensity =
        e.emissiveIntensity === void 0 ? 1 : e.emissiveIntensity),
      (t.emissiveMap = e.emissiveMap === void 0 ? null : e.emissiveMap),
      (t.bumpMap = e.bumpMap === void 0 ? null : e.bumpMap),
      (t.bumpScale = 1),
      (t.normalMap = e.normalMap === void 0 ? null : e.normalMap),
      (t.normalMapType = eo),
      e.normalScale && (t.normalScale = e.normalScale),
      (t.displacementMap = null),
      (t.displacementScale = 1),
      (t.displacementBias = 0),
      (t.specularMap = e.specularMap === void 0 ? null : e.specularMap),
      (t.specular = e.specular),
      (t.glossinessMap = e.glossinessMap === void 0 ? null : e.glossinessMap),
      (t.glossiness = e.glossiness),
      (t.alphaMap = null),
      (t.envMap = e.envMap === void 0 ? null : e.envMap),
      (t.envMapIntensity = 1),
      (t.refractionRatio = 0.98),
      t
    );
  }
}
class m9 {
  constructor() {
    this.name = Et.KHR_MESH_QUANTIZATION;
  }
}
class l3 extends uu {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      i = this.sampleValues,
      r = this.valueSize,
      s = e * r * 3 + r;
    for (let o = 0; o !== r; o++) t[o] = i[s + o];
    return t;
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = a * 2,
      u = a * 3,
      h = r - t,
      d = (i - t) / h,
      p = d * d,
      g = p * d,
      y = e * u,
      A = y - u,
      _ = -2 * g + 3 * p,
      m = g - p,
      x = 1 - _,
      S = m - p + d;
    for (let w = 0; w !== a; w++) {
      const C = o[A + w + a],
        P = o[A + w + l] * h,
        R = o[y + w + a],
        B = o[y + w] * h;
      s[w] = x * C + S * P + _ * R + m * B;
    }
    return s;
  }
}
const g9 = new Kn();
class v9 extends l3 {
  interpolate_(e, t, i, r) {
    const s = super.interpolate_(e, t, i, r);
    return (g9.fromArray(s).normalize().toArray(s), s);
  }
}
const Ps = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123,
  },
  uh = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array,
  },
  rT = { 9728: dn, 9729: rn, 9984: eh, 9985: Fg, 9986: Bc, 9987: hs },
  sT = { 33071: jn, 33648: Hc, 10497: Yo },
  oT = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
  b_ = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex",
  },
  xo = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences",
  },
  y9 = { CUBICSPLINE: void 0, LINEAR: ol, STEP: Wc },
  Sy = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
function x9(n) {
  return (
    n.DefaultMaterial === void 0 &&
      (n.DefaultMaterial = new cu({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: fs,
      })),
    n.DefaultMaterial
  );
}
function nf(n, e, t) {
  for (const i in t.extensions)
    n[i] === void 0 &&
      ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
      (e.userData.gltfExtensions[i] = t.extensions[i]));
}
function Ra(n, e) {
  e.extras !== void 0 &&
    (typeof e.extras == "object"
      ? Object.assign(n.userData, e.extras)
      : console.warn(
          "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras
        ));
}
function _9(n, e, t) {
  let i = !1,
    r = !1,
    s = !1;
  for (let u = 0, h = e.length; u < h; u++) {
    const d = e[u];
    if (
      (d.POSITION !== void 0 && (i = !0),
      d.NORMAL !== void 0 && (r = !0),
      d.COLOR_0 !== void 0 && (s = !0),
      i && r && s)
    )
      break;
  }
  if (!i && !r && !s) return Promise.resolve(n);
  const o = [],
    a = [],
    l = [];
  for (let u = 0, h = e.length; u < h; u++) {
    const d = e[u];
    if (i) {
      const p =
        d.POSITION !== void 0
          ? t.getDependency("accessor", d.POSITION)
          : n.attributes.position;
      o.push(p);
    }
    if (r) {
      const p =
        d.NORMAL !== void 0
          ? t.getDependency("accessor", d.NORMAL)
          : n.attributes.normal;
      a.push(p);
    }
    if (s) {
      const p =
        d.COLOR_0 !== void 0
          ? t.getDependency("accessor", d.COLOR_0)
          : n.attributes.color;
      l.push(p);
    }
  }
  return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(
    function (u) {
      const h = u[0],
        d = u[1],
        p = u[2];
      return (
        i && (n.morphAttributes.position = h),
        r && (n.morphAttributes.normal = d),
        s && (n.morphAttributes.color = p),
        (n.morphTargetsRelative = !0),
        n
      );
    }
  );
}
function A9(n, e) {
  if ((n.updateMorphTargets(), e.weights !== void 0))
    for (let t = 0, i = e.weights.length; t < i; t++)
      n.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (n.morphTargetInfluences.length === t.length) {
      n.morphTargetDictionary = {};
      for (let i = 0, r = t.length; i < r; i++)
        n.morphTargetDictionary[t[i]] = i;
    } else
      console.warn(
        "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
      );
  }
}
function M9(n) {
  const e = n.extensions && n.extensions[Et.KHR_DRACO_MESH_COMPRESSION];
  let t;
  return (
    e
      ? (t = "draco:" + e.bufferView + ":" + e.indices + ":" + aT(e.attributes))
      : (t = n.indices + ":" + aT(n.attributes) + ":" + n.mode),
    t
  );
}
function aT(n) {
  let e = "";
  const t = Object.keys(n).sort();
  for (let i = 0, r = t.length; i < r; i++) e += t[i] + ":" + n[t[i]] + ";";
  return e;
}
function P_(n) {
  switch (n) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error(
        "THREE.GLTFLoader: Unsupported normalized accessor component type."
      );
  }
}
function S9(n) {
  return n.search(/\.jpe?g($|\?)/i) > 0 || n.search(/^data\:image\/jpeg/) === 0
    ? "image/jpeg"
    : n.search(/\.webp($|\?)/i) > 0 || n.search(/^data\:image\/webp/) === 0
      ? "image/webp"
      : "image/png";
}
class w9 {
  constructor(e = {}, t = {}) {
    var i, r;
    ((this.json = e),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = t),
      (this.cache = new ZV()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.meshCache = { refs: {}, uses: {} }),
      (this.cameraCache = { refs: {}, uses: {} }),
      (this.lightCache = { refs: {}, uses: {} }),
      (this.sourceCache = {}),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {}));
    const s =
        typeof navigator < "u" &&
        /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0,
      o =
        typeof navigator < "u" &&
        ((i = navigator.userAgent) === null || i === void 0
          ? void 0
          : i.indexOf("Firefox")) > -1,
      a =
        typeof navigator < "u" && o
          ? (r = navigator.userAgent) === null || r === void 0
            ? void 0
            : r.match(/Firefox\/([0-9]+)\./)[1]
          : -1;
    (typeof createImageBitmap > "u" || s || (o && a < 98)
      ? (this.textureLoader = new Gh(this.options.manager))
      : (this.textureLoader = new LR(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new Qi(this.options.manager)),
      this.fileLoader.setResponseType("arraybuffer"),
      this.options.crossOrigin === "use-credentials" &&
        this.fileLoader.setWithCredentials(!0));
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const i = this,
      r = this.json,
      s = this.extensions;
    (this.cache.removeAll(),
      this._invokeAll(function (o) {
        return o._markDefs && o._markDefs();
      }),
      Promise.all(
        this._invokeAll(function (o) {
          return o.beforeRoot && o.beforeRoot();
        })
      )
        .then(function () {
          return Promise.all([
            i.getDependencies("scene"),
            i.getDependencies("animation"),
            i.getDependencies("camera"),
          ]);
        })
        .then(function (o) {
          const a = {
            scene: o[0][r.scene || 0],
            scenes: o[0],
            animations: o[1],
            cameras: o[2],
            asset: r.asset,
            parser: i,
            userData: {},
          };
          (nf(s, a, r),
            Ra(a, r),
            Promise.all(
              i._invokeAll(function (l) {
                return l.afterRoot && l.afterRoot(a);
              })
            ).then(function () {
              e(a);
            }));
        })
        .catch(t));
  }
  _markDefs() {
    const e = this.json.nodes || [],
      t = this.json.skins || [],
      i = this.json.meshes || [];
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r].joints;
      for (let a = 0, l = o.length; a < l; a++) e[o[a]].isBone = !0;
    }
    for (let r = 0, s = e.length; r < s; r++) {
      const o = e[r];
      (o.mesh !== void 0 &&
        (this._addNodeRef(this.meshCache, o.mesh),
        o.skin !== void 0 && (i[o.mesh].isSkinnedMesh = !0)),
        o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera));
    }
  }
  _addNodeRef(e, t) {
    t !== void 0 &&
      (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  _getNodeRef(e, t, i) {
    if (e.refs[t] <= 1) return i;
    const r = i.clone(),
      s = (o, a) => {
        const l = this.associations.get(o);
        l != null && this.associations.set(a, l);
        for (const [u, h] of o.children.entries()) s(h, a.children[u]);
      };
    return (s(i, r), (r.name += "_instance_" + e.uses[t]++), r);
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let i = 0; i < t.length; i++) {
      const r = e(t[i]);
      if (r) return r;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const i = [];
    for (let r = 0; r < t.length; r++) {
      const s = e(t[r]);
      s && i.push(s);
    }
    return i;
  }
  getDependency(e, t) {
    const i = e + ":" + t;
    let r = this.cache.get(i);
    if (!r) {
      switch (e) {
        case "scene":
          r = this.loadScene(t);
          break;
        case "node":
          r = this.loadNode(t);
          break;
        case "mesh":
          r = this._invokeOne(function (s) {
            return s.loadMesh && s.loadMesh(t);
          });
          break;
        case "accessor":
          r = this.loadAccessor(t);
          break;
        case "bufferView":
          r = this._invokeOne(function (s) {
            return s.loadBufferView && s.loadBufferView(t);
          });
          break;
        case "buffer":
          r = this.loadBuffer(t);
          break;
        case "material":
          r = this._invokeOne(function (s) {
            return s.loadMaterial && s.loadMaterial(t);
          });
          break;
        case "texture":
          r = this._invokeOne(function (s) {
            return s.loadTexture && s.loadTexture(t);
          });
          break;
        case "skin":
          r = this.loadSkin(t);
          break;
        case "animation":
          r = this._invokeOne(function (s) {
            return s.loadAnimation && s.loadAnimation(t);
          });
          break;
        case "camera":
          r = this.loadCamera(t);
          break;
        default:
          throw new Error("Unknown type: " + e);
      }
      this.cache.add(i, r);
    }
    return r;
  }
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const i = this,
        r = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      ((t = Promise.all(
        r.map(function (s, o) {
          return i.getDependency(e, o);
        })
      )),
        this.cache.add(e, t));
    }
    return t;
  }
  loadBuffer(e) {
    const t = this.json.buffers[e],
      i = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error(
        "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
      );
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[Et.KHR_BINARY_GLTF].body);
    const r = this.options;
    return new Promise(function (s, o) {
      i.load(cs.resolveURL(t.uri, r.path), s, void 0, function () {
        o(
          new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')
        );
      });
    });
  }
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function (i) {
      const r = t.byteLength || 0,
        s = t.byteOffset || 0;
      return i.slice(s, s + r);
    });
  }
  loadAccessor(e) {
    const t = this,
      i = this.json,
      r = this.json.accessors[e];
    if (r.bufferView === void 0 && r.sparse === void 0)
      return Promise.resolve(null);
    const s = [];
    return (
      r.bufferView !== void 0
        ? s.push(this.getDependency("bufferView", r.bufferView))
        : s.push(null),
      r.sparse !== void 0 &&
        (s.push(this.getDependency("bufferView", r.sparse.indices.bufferView)),
        s.push(this.getDependency("bufferView", r.sparse.values.bufferView))),
      Promise.all(s).then(function (o) {
        const a = o[0],
          l = oT[r.type],
          u = uh[r.componentType],
          h = u.BYTES_PER_ELEMENT,
          d = h * l,
          p = r.byteOffset || 0,
          g =
            r.bufferView !== void 0
              ? i.bufferViews[r.bufferView].byteStride
              : void 0,
          y = r.normalized === !0;
        let A, _;
        if (g && g !== d) {
          const m = Math.floor(p / g),
            x =
              "InterleavedBuffer:" +
              r.bufferView +
              ":" +
              r.componentType +
              ":" +
              m +
              ":" +
              r.count;
          let S = t.cache.get(x);
          (S ||
            ((A = new u(a, m * g, (r.count * g) / h)),
            (S = new Ch(A, g / h)),
            t.cache.add(x, S)),
            (_ = new Qo(S, l, (p % g) / h, y)));
        } else
          (a === null
            ? (A = new u(r.count * l))
            : (A = new u(a, p, r.count * l)),
            (_ = new Dt(A, l, y)));
        if (r.sparse !== void 0) {
          const m = oT.SCALAR,
            x = uh[r.sparse.indices.componentType],
            S = r.sparse.indices.byteOffset || 0,
            w = r.sparse.values.byteOffset || 0,
            C = new x(o[1], S, r.sparse.count * m),
            P = new u(o[2], w, r.sparse.count * l);
          a !== null && (_ = new Dt(_.array.slice(), _.itemSize, _.normalized));
          for (let R = 0, B = C.length; R < B; R++) {
            const b = C[R];
            if (
              (_.setX(b, P[R * l]),
              l >= 2 && _.setY(b, P[R * l + 1]),
              l >= 3 && _.setZ(b, P[R * l + 2]),
              l >= 4 && _.setW(b, P[R * l + 3]),
              l >= 5)
            )
              throw new Error(
                "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
              );
          }
        }
        return _;
      })
    );
  }
  loadTexture(e) {
    const t = this.json,
      i = this.options,
      s = t.textures[e].source,
      o = t.images[s];
    let a = this.textureLoader;
    if (o.uri) {
      const l = i.manager.getHandler(o.uri);
      l !== null && (a = l);
    }
    return this.loadTextureImage(e, s, a);
  }
  loadTextureImage(e, t, i) {
    const r = this,
      s = this.json,
      o = s.textures[e],
      a = s.images[t],
      l = (a.uri || a.bufferView) + ":" + o.sampler;
    if (this.textureCache[l]) return this.textureCache[l];
    const u = this.loadImageSource(t, i)
      .then(function (h) {
        ((h.flipY = !1), o.name && (h.name = o.name));
        const p = (s.samplers || {})[o.sampler] || {};
        return (
          (h.magFilter = rT[p.magFilter] || rn),
          (h.minFilter = rT[p.minFilter] || hs),
          (h.wrapS = sT[p.wrapS] || Yo),
          (h.wrapT = sT[p.wrapT] || Yo),
          r.associations.set(h, { textures: e }),
          h
        );
      })
      .catch(function () {
        return null;
      });
    return ((this.textureCache[l] = u), u);
  }
  loadImageSource(e, t) {
    const i = this,
      r = this.json,
      s = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((d) => d.clone());
    const o = r.images[e],
      a = self.URL || self.webkitURL;
    let l = o.uri || "",
      u = !1;
    if (o.bufferView !== void 0)
      l = i.getDependency("bufferView", o.bufferView).then(function (d) {
        u = !0;
        const p = new Blob([d], { type: o.mimeType });
        return ((l = a.createObjectURL(p)), l);
      });
    else if (o.uri === void 0)
      throw new Error(
        "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
      );
    const h = Promise.resolve(l)
      .then(function (d) {
        return new Promise(function (p, g) {
          let y = p;
          (t.isImageBitmapLoader === !0 &&
            (y = function (A) {
              const _ = new en(A);
              ((_.needsUpdate = !0), p(_));
            }),
            t.load(cs.resolveURL(d, s.path), y, void 0, g));
        });
      })
      .then(function (d) {
        return (
          u === !0 && a.revokeObjectURL(l),
          (d.userData.mimeType = o.mimeType || S9(o.uri)),
          d
        );
      })
      .catch(function (d) {
        throw (console.error("THREE.GLTFLoader: Couldn't load texture", l), d);
      });
    return ((this.sourceCache[e] = h), h);
  }
  assignTexture(e, t, i, r) {
    const s = this;
    return this.getDependency("texture", i.index).then(function (o) {
      if (
        (i.texCoord !== void 0 &&
          i.texCoord != 0 &&
          !(t === "aoMap" && i.texCoord == 1) &&
          console.warn(
            "THREE.GLTFLoader: Custom UV set " +
              i.texCoord +
              " for texture " +
              t +
              " not yet supported."
          ),
        s.extensions[Et.KHR_TEXTURE_TRANSFORM])
      ) {
        const a =
          i.extensions !== void 0
            ? i.extensions[Et.KHR_TEXTURE_TRANSFORM]
            : void 0;
        if (a) {
          const l = s.associations.get(o);
          ((o = s.extensions[Et.KHR_TEXTURE_TRANSFORM].extendTexture(o, a)),
            s.associations.set(o, l));
        }
      }
      return (r !== void 0 && (o.encoding = r), (e[t] = o), o);
    });
  }
  assignFinalMaterial(e) {
    const t = e.geometry;
    let i = e.material;
    const r = t.attributes.tangent === void 0,
      s = t.attributes.color !== void 0,
      o = t.attributes.normal === void 0;
    if (e.isPoints) {
      const a = "PointsMaterial:" + i.uuid;
      let l = this.cache.get(a);
      (l ||
        ((l = new bh()),
        En.prototype.copy.call(l, i),
        l.color.copy(i.color),
        (l.map = i.map),
        (l.sizeAttenuation = !1),
        this.cache.add(a, l)),
        (i = l));
    } else if (e.isLine) {
      const a = "LineBasicMaterial:" + i.uuid;
      let l = this.cache.get(a);
      (l ||
        ((l = new li()),
        En.prototype.copy.call(l, i),
        l.color.copy(i.color),
        this.cache.add(a, l)),
        (i = l));
    }
    if (r || s || o) {
      let a = "ClonedMaterial:" + i.uuid + ":";
      (i.isGLTFSpecularGlossinessMaterial && (a += "specular-glossiness:"),
        r && (a += "derivative-tangents:"),
        s && (a += "vertex-colors:"),
        o && (a += "flat-shading:"));
      let l = this.cache.get(a);
      (l ||
        ((l = i.clone()),
        s && (l.vertexColors = !0),
        o && (l.flatShading = !0),
        r &&
          (l.normalScale && (l.normalScale.y *= -1),
          l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)),
        this.cache.add(a, l),
        this.associations.set(l, this.associations.get(i))),
        (i = l));
    }
    (i.aoMap &&
      t.attributes.uv2 === void 0 &&
      t.attributes.uv !== void 0 &&
      t.setAttribute("uv2", t.attributes.uv),
      (e.material = i));
  }
  getMaterialType() {
    return cu;
  }
  loadMaterial(e) {
    const t = this,
      i = this.json,
      r = this.extensions,
      s = i.materials[e];
    let o;
    const a = {},
      l = s.extensions || {},
      u = [];
    if (l[Et.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
      const d = r[Et.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
      ((o = d.getMaterialType()), u.push(d.extendParams(a, s, t)));
    } else if (l[Et.KHR_MATERIALS_UNLIT]) {
      const d = r[Et.KHR_MATERIALS_UNLIT];
      ((o = d.getMaterialType()), u.push(d.extendParams(a, s, t)));
    } else {
      const d = s.pbrMetallicRoughness || {};
      if (
        ((a.color = new Ie(1, 1, 1)),
        (a.opacity = 1),
        Array.isArray(d.baseColorFactor))
      ) {
        const p = d.baseColorFactor;
        (a.color.fromArray(p), (a.opacity = p[3]));
      }
      (d.baseColorTexture !== void 0 &&
        u.push(t.assignTexture(a, "map", d.baseColorTexture, Tt)),
        (a.metalness = d.metallicFactor !== void 0 ? d.metallicFactor : 1),
        (a.roughness = d.roughnessFactor !== void 0 ? d.roughnessFactor : 1),
        d.metallicRoughnessTexture !== void 0 &&
          (u.push(
            t.assignTexture(a, "metalnessMap", d.metallicRoughnessTexture)
          ),
          u.push(
            t.assignTexture(a, "roughnessMap", d.metallicRoughnessTexture)
          )),
        (o = this._invokeOne(function (p) {
          return p.getMaterialType && p.getMaterialType(e);
        })),
        u.push(
          Promise.all(
            this._invokeAll(function (p) {
              return p.extendMaterialParams && p.extendMaterialParams(e, a);
            })
          )
        ));
    }
    s.doubleSided === !0 && (a.side = mr);
    const h = s.alphaMode || Sy.OPAQUE;
    if (
      (h === Sy.BLEND
        ? ((a.transparent = !0), (a.depthWrite = !1))
        : ((a.transparent = !1),
          h === Sy.MASK &&
            (a.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : 0.5)),
      s.normalTexture !== void 0 &&
        o !== Ji &&
        (u.push(t.assignTexture(a, "normalMap", s.normalTexture)),
        (a.normalScale = new ve(1, 1)),
        s.normalTexture.scale !== void 0))
    ) {
      const d = s.normalTexture.scale;
      a.normalScale.set(d, d);
    }
    return (
      s.occlusionTexture !== void 0 &&
        o !== Ji &&
        (u.push(t.assignTexture(a, "aoMap", s.occlusionTexture)),
        s.occlusionTexture.strength !== void 0 &&
          (a.aoMapIntensity = s.occlusionTexture.strength)),
      s.emissiveFactor !== void 0 &&
        o !== Ji &&
        (a.emissive = new Ie().fromArray(s.emissiveFactor)),
      s.emissiveTexture !== void 0 &&
        o !== Ji &&
        u.push(t.assignTexture(a, "emissiveMap", s.emissiveTexture, Tt)),
      Promise.all(u).then(function () {
        let d;
        return (
          o === T_
            ? (d =
                r[Et.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a))
            : (d = new o(a)),
          s.name && (d.name = s.name),
          Ra(d, s),
          t.associations.set(d, { materials: e }),
          s.extensions && nf(r, d, s),
          d
        );
      })
    );
  }
  createUniqueName(e) {
    const t = bt.sanitizeNodeName(e || "");
    let i = t;
    for (let r = 1; this.nodeNamesUsed[i]; ++r) i = t + "_" + r;
    return ((this.nodeNamesUsed[i] = !0), i);
  }
  loadGeometries(e) {
    const t = this,
      i = this.extensions,
      r = this.primitiveCache;
    function s(a) {
      return i[Et.KHR_DRACO_MESH_COMPRESSION]
        .decodePrimitive(a, t)
        .then(function (l) {
          return lT(l, a, t);
        });
    }
    const o = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const u = e[a],
        h = M9(u),
        d = r[h];
      if (d) o.push(d.promise);
      else {
        let p;
        (u.extensions && u.extensions[Et.KHR_DRACO_MESH_COMPRESSION]
          ? (p = s(u))
          : (p = lT(new ft(), u, t)),
          (r[h] = { primitive: u, promise: p }),
          o.push(p));
      }
    }
    return Promise.all(o);
  }
  loadMesh(e) {
    const t = this,
      i = this.json,
      r = this.extensions,
      s = i.meshes[e],
      o = s.primitives,
      a = [];
    for (let l = 0, u = o.length; l < u; l++) {
      const h =
        o[l].material === void 0
          ? x9(this.cache)
          : this.getDependency("material", o[l].material);
      a.push(h);
    }
    return (
      a.push(t.loadGeometries(o)),
      Promise.all(a).then(function (l) {
        const u = l.slice(0, l.length - 1),
          h = l[l.length - 1],
          d = [];
        for (let g = 0, y = h.length; g < y; g++) {
          const A = h[g],
            _ = o[g];
          let m;
          const x = u[g];
          if (
            _.mode === Ps.TRIANGLES ||
            _.mode === Ps.TRIANGLE_STRIP ||
            _.mode === Ps.TRIANGLE_FAN ||
            _.mode === void 0
          )
            ((m = s.isSkinnedMesh === !0 ? new uA(A, x) : new Bn(A, x)),
              m.isSkinnedMesh === !0 &&
                !m.geometry.attributes.skinWeight.normalized &&
                m.normalizeSkinWeights(),
              _.mode === Ps.TRIANGLE_STRIP
                ? (m.geometry = cT(m.geometry, DB))
                : _.mode === Ps.TRIANGLE_FAN &&
                  (m.geometry = cT(m.geometry, Y1)));
          else if (_.mode === Ps.LINES) m = new jr(A, x);
          else if (_.mode === Ps.LINE_STRIP) m = new Zs(A, x);
          else if (_.mode === Ps.LINE_LOOP) m = new fA(A, x);
          else if (_.mode === Ps.POINTS) m = new hA(A, x);
          else
            throw new Error(
              "THREE.GLTFLoader: Primitive mode unsupported: " + _.mode
            );
          (Object.keys(m.geometry.morphAttributes).length > 0 && A9(m, s),
            (m.name = t.createUniqueName(s.name || "mesh_" + e)),
            Ra(m, s),
            _.extensions && nf(r, m, _),
            t.assignFinalMaterial(m),
            d.push(m));
        }
        for (let g = 0, y = d.length; g < y; g++)
          t.associations.set(d[g], { meshes: e, primitives: g });
        if (d.length === 1) return d[0];
        const p = new Us();
        t.associations.set(p, { meshes: e });
        for (let g = 0, y = d.length; g < y; g++) p.add(d[g]);
        return p;
      })
    );
  }
  loadCamera(e) {
    let t;
    const i = this.json.cameras[e],
      r = i[i.type];
    if (!r) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return (
      i.type === "perspective"
        ? (t = new Vt(
            q1.radToDeg(r.yfov),
            r.aspectRatio || 1,
            r.znear || 1,
            r.zfar || 2e6
          ))
        : i.type === "orthographic" &&
          (t = new zr(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)),
      i.name && (t.name = this.createUniqueName(i.name)),
      Ra(t, i),
      Promise.resolve(t)
    );
  }
  loadSkin(e) {
    const t = this.json.skins[e],
      i = { joints: t.joints };
    return t.inverseBindMatrices === void 0
      ? Promise.resolve(i)
      : this.getDependency("accessor", t.inverseBindMatrices).then(
          function (r) {
            return ((i.inverseBindMatrices = r), i);
          }
        );
  }
  loadAnimation(e) {
    const i = this.json.animations[e],
      r = [],
      s = [],
      o = [],
      a = [],
      l = [];
    for (let u = 0, h = i.channels.length; u < h; u++) {
      const d = i.channels[u],
        p = i.samplers[d.sampler],
        g = d.target,
        y = g.node,
        A = i.parameters !== void 0 ? i.parameters[p.input] : p.input,
        _ = i.parameters !== void 0 ? i.parameters[p.output] : p.output;
      (r.push(this.getDependency("node", y)),
        s.push(this.getDependency("accessor", A)),
        o.push(this.getDependency("accessor", _)),
        a.push(p),
        l.push(g));
    }
    return Promise.all([
      Promise.all(r),
      Promise.all(s),
      Promise.all(o),
      Promise.all(a),
      Promise.all(l),
    ]).then(function (u) {
      const h = u[0],
        d = u[1],
        p = u[2],
        g = u[3],
        y = u[4],
        A = [];
      for (let m = 0, x = h.length; m < x; m++) {
        const S = h[m],
          w = d[m],
          C = p[m],
          P = g[m],
          R = y[m];
        if (S === void 0) continue;
        S.updateMatrix();
        let B;
        switch (xo[R.path]) {
          case xo.weights:
            B = Yc;
            break;
          case xo.rotation:
            B = Zo;
            break;
          case xo.position:
          case xo.scale:
          default:
            B = Qc;
            break;
        }
        const b = S.name ? S.name : S.uuid,
          L = P.interpolation !== void 0 ? y9[P.interpolation] : ol,
          U = [];
        xo[R.path] === xo.weights
          ? S.traverse(function (V) {
              V.morphTargetInfluences && U.push(V.name ? V.name : V.uuid);
            })
          : U.push(b);
        let J = C.array;
        if (C.normalized) {
          const V = P_(J.constructor),
            j = new Float32Array(J.length);
          for (let X = 0, oe = J.length; X < oe; X++) j[X] = J[X] * V;
          J = j;
        }
        for (let V = 0, j = U.length; V < j; V++) {
          const X = new B(U[V] + "." + xo[R.path], w.array, J, L);
          (P.interpolation === "CUBICSPLINE" &&
            ((X.createInterpolant = function (ae) {
              const I = this instanceof Zo ? v9 : l3;
              return new I(
                this.times,
                this.values,
                this.getValueSize() / 3,
                ae
              );
            }),
            (X.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
              !0)),
            A.push(X));
        }
      }
      const _ = i.name ? i.name : "animation_" + e;
      return new Zc(_, void 0, A);
    });
  }
  createNodeMesh(e) {
    const t = this.json,
      i = this,
      r = t.nodes[e];
    return r.mesh === void 0
      ? null
      : i.getDependency("mesh", r.mesh).then(function (s) {
          const o = i._getNodeRef(i.meshCache, r.mesh, s);
          return (
            r.weights !== void 0 &&
              o.traverse(function (a) {
                if (a.isMesh)
                  for (let l = 0, u = r.weights.length; l < u; l++)
                    a.morphTargetInfluences[l] = r.weights[l];
              }),
            o
          );
        });
  }
  loadNode(e) {
    const t = this.json,
      i = this.extensions,
      r = this,
      s = t.nodes[e],
      o = s.name ? r.createUniqueName(s.name) : "";
    return (function () {
      const a = [],
        l = r._invokeOne(function (u) {
          return u.createNodeMesh && u.createNodeMesh(e);
        });
      return (
        l && a.push(l),
        s.camera !== void 0 &&
          a.push(
            r.getDependency("camera", s.camera).then(function (u) {
              return r._getNodeRef(r.cameraCache, s.camera, u);
            })
          ),
        r
          ._invokeAll(function (u) {
            return u.createNodeAttachment && u.createNodeAttachment(e);
          })
          .forEach(function (u) {
            a.push(u);
          }),
        Promise.all(a)
      );
    })().then(function (a) {
      let l;
      if (
        (s.isBone === !0
          ? (l = new Hg())
          : a.length > 1
            ? (l = new Us())
            : a.length === 1
              ? (l = a[0])
              : (l = new Pt()),
        l !== a[0])
      )
        for (let u = 0, h = a.length; u < h; u++) l.add(a[u]);
      if (
        (s.name && ((l.userData.name = s.name), (l.name = o)),
        Ra(l, s),
        s.extensions && nf(i, l, s),
        s.matrix !== void 0)
      ) {
        const u = new ot();
        (u.fromArray(s.matrix), l.applyMatrix4(u));
      } else
        (s.translation !== void 0 && l.position.fromArray(s.translation),
          s.rotation !== void 0 && l.quaternion.fromArray(s.rotation),
          s.scale !== void 0 && l.scale.fromArray(s.scale));
      return (
        r.associations.has(l) || r.associations.set(l, {}),
        (r.associations.get(l).nodes = e),
        l
      );
    });
  }
  loadScene(e) {
    const t = this.json,
      i = this.extensions,
      r = this.json.scenes[e],
      s = this,
      o = new Us();
    (r.name && (o.name = s.createUniqueName(r.name)),
      Ra(o, r),
      r.extensions && nf(i, o, r));
    const a = r.nodes || [],
      l = [];
    for (let u = 0, h = a.length; u < h; u++) l.push(c3(a[u], o, t, s));
    return Promise.all(l).then(function () {
      const u = (h) => {
        const d = new Map();
        for (const [p, g] of s.associations)
          (p instanceof En || p instanceof en) && d.set(p, g);
        return (
          h.traverse((p) => {
            const g = s.associations.get(p);
            g != null && d.set(p, g);
          }),
          d
        );
      };
      return ((s.associations = u(o)), o);
    });
  }
}
function c3(n, e, t, i) {
  const r = t.nodes[n];
  return i
    .getDependency("node", n)
    .then(function (s) {
      if (r.skin === void 0) return s;
      let o;
      return i
        .getDependency("skin", r.skin)
        .then(function (a) {
          o = a;
          const l = [];
          for (let u = 0, h = o.joints.length; u < h; u++)
            l.push(i.getDependency("node", o.joints[u]));
          return Promise.all(l);
        })
        .then(function (a) {
          return (
            s.traverse(function (l) {
              if (!l.isMesh) return;
              const u = [],
                h = [];
              for (let d = 0, p = a.length; d < p; d++) {
                const g = a[d];
                if (g) {
                  u.push(g);
                  const y = new ot();
                  (o.inverseBindMatrices !== void 0 &&
                    y.fromArray(o.inverseBindMatrices.array, d * 16),
                    h.push(y));
                } else
                  console.warn(
                    'THREE.GLTFLoader: Joint "%s" could not be found.',
                    o.joints[d]
                  );
              }
              l.bind(new Th(u, h), l.matrixWorld);
            }),
            s
          );
        });
    })
    .then(function (s) {
      e.add(s);
      const o = [];
      if (r.children) {
        const a = r.children;
        for (let l = 0, u = a.length; l < u; l++) {
          const h = a[l];
          o.push(c3(h, s, t, i));
        }
      }
      return Promise.all(o);
    });
}
function E9(n, e, t) {
  const i = e.attributes,
    r = new Vr();
  if (i.POSITION !== void 0) {
    const a = t.json.accessors[i.POSITION],
      l = a.min,
      u = a.max;
    if (l !== void 0 && u !== void 0) {
      if (
        (r.set(new F(l[0], l[1], l[2]), new F(u[0], u[1], u[2])), a.normalized)
      ) {
        const h = P_(uh[a.componentType]);
        (r.min.multiplyScalar(h), r.max.multiplyScalar(h));
      }
    } else {
      console.warn(
        "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
      );
      return;
    }
  } else return;
  const s = e.targets;
  if (s !== void 0) {
    const a = new F(),
      l = new F();
    for (let u = 0, h = s.length; u < h; u++) {
      const d = s[u];
      if (d.POSITION !== void 0) {
        const p = t.json.accessors[d.POSITION],
          g = p.min,
          y = p.max;
        if (g !== void 0 && y !== void 0) {
          if (
            (l.setX(Math.max(Math.abs(g[0]), Math.abs(y[0]))),
            l.setY(Math.max(Math.abs(g[1]), Math.abs(y[1]))),
            l.setZ(Math.max(Math.abs(g[2]), Math.abs(y[2]))),
            p.normalized)
          ) {
            const A = P_(uh[p.componentType]);
            l.multiplyScalar(A);
          }
          a.max(l);
        } else
          console.warn(
            "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
          );
      }
    }
    r.expandByVector(a);
  }
  n.boundingBox = r;
  const o = new Wr();
  (r.getCenter(o.center),
    (o.radius = r.min.distanceTo(r.max) / 2),
    (n.boundingSphere = o));
}
function lT(n, e, t) {
  const i = e.attributes,
    r = [];
  function s(o, a) {
    return t.getDependency("accessor", o).then(function (l) {
      n.setAttribute(a, l);
    });
  }
  for (const o in i) {
    const a = b_[o] || o.toLowerCase();
    a in n.attributes || r.push(s(i[o], a));
  }
  if (e.indices !== void 0 && !n.index) {
    const o = t.getDependency("accessor", e.indices).then(function (a) {
      n.setIndex(a);
    });
    r.push(o);
  }
  return (
    Ra(n, e),
    E9(n, e, t),
    Promise.all(r).then(function () {
      return e.targets !== void 0 ? _9(n, e.targets, t) : n;
    })
  );
}
function cT(n, e) {
  let t = n.getIndex();
  if (t === null) {
    const o = [],
      a = n.getAttribute("position");
    if (a !== void 0) {
      for (let l = 0; l < a.count; l++) o.push(l);
      (n.setIndex(o), (t = n.getIndex()));
    } else
      return (
        console.error(
          "THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
        ),
        n
      );
  }
  const i = t.count - 2,
    r = [];
  if (e === Y1)
    for (let o = 1; o <= i; o++)
      (r.push(t.getX(0)), r.push(t.getX(o)), r.push(t.getX(o + 1)));
  else
    for (let o = 0; o < i; o++)
      o % 2 === 0
        ? (r.push(t.getX(o)), r.push(t.getX(o + 1)), r.push(t.getX(o + 2)))
        : (r.push(t.getX(o + 2)), r.push(t.getX(o + 1)), r.push(t.getX(o)));
  r.length / 3 !== i &&
    console.error(
      "THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
    );
  const s = n.clone();
  return (s.setIndex(r), s);
}
class C9 extends ft {
  constructor(e, t, i, r) {
    super();
    const s = [],
      o = [],
      a = [],
      l = new F(),
      u = new ot();
    (u.makeRotationFromEuler(i), u.setPosition(t));
    const h = new ot();
    (h.copy(u).invert(),
      d(),
      this.setAttribute("position", new Ve(s, 3)),
      this.setAttribute("normal", new Ve(o, 3)),
      this.setAttribute("uv", new Ve(a, 2)));
    function d() {
      let A,
        _ = [];
      const m = new F(),
        x = new F();
      if (e.geometry.isGeometry === !0) {
        console.error(
          "THREE.DecalGeometry no longer supports THREE.Geometry. Use BufferGeometry instead."
        );
        return;
      }
      const S = e.geometry,
        w = S.attributes.position,
        C = S.attributes.normal;
      if (S.index !== null) {
        const P = S.index;
        for (A = 0; A < P.count; A++)
          (m.fromBufferAttribute(w, P.getX(A)),
            x.fromBufferAttribute(C, P.getX(A)),
            p(_, m, x));
      } else
        for (A = 0; A < w.count; A++)
          (m.fromBufferAttribute(w, A),
            x.fromBufferAttribute(C, A),
            p(_, m, x));
      for (
        _ = g(_, l.set(1, 0, 0)),
          _ = g(_, l.set(-1, 0, 0)),
          _ = g(_, l.set(0, 1, 0)),
          _ = g(_, l.set(0, -1, 0)),
          _ = g(_, l.set(0, 0, 1)),
          _ = g(_, l.set(0, 0, -1)),
          A = 0;
        A < _.length;
        A++
      ) {
        const P = _[A];
        (a.push(0.5 + P.position.x / r.x, 0.5 + P.position.y / r.y),
          P.position.applyMatrix4(u),
          s.push(P.position.x, P.position.y, P.position.z),
          o.push(P.normal.x, P.normal.y, P.normal.z));
      }
    }
    function p(A, _, m) {
      (_.applyMatrix4(e.matrixWorld),
        _.applyMatrix4(h),
        m.transformDirection(e.matrixWorld),
        A.push(new uT(_.clone(), m.clone())));
    }
    function g(A, _) {
      const m = [],
        x = 0.5 * Math.abs(r.dot(_));
      for (let S = 0; S < A.length; S += 3) {
        let w,
          C,
          P,
          R = 0,
          B,
          b,
          L,
          U;
        const J = A[S + 0].position.dot(_) - x,
          V = A[S + 1].position.dot(_) - x,
          j = A[S + 2].position.dot(_) - x;
        switch (
          ((w = J > 0),
          (C = V > 0),
          (P = j > 0),
          (R = (w ? 1 : 0) + (C ? 1 : 0) + (P ? 1 : 0)),
          R)
        ) {
          case 0: {
            (m.push(A[S]), m.push(A[S + 1]), m.push(A[S + 2]));
            break;
          }
          case 1: {
            if (
              (w &&
                ((B = A[S + 1]),
                (b = A[S + 2]),
                (L = y(A[S], B, _, x)),
                (U = y(A[S], b, _, x))),
              C)
            ) {
              ((B = A[S]),
                (b = A[S + 2]),
                (L = y(A[S + 1], B, _, x)),
                (U = y(A[S + 1], b, _, x)),
                m.push(L),
                m.push(b.clone()),
                m.push(B.clone()),
                m.push(b.clone()),
                m.push(L.clone()),
                m.push(U));
              break;
            }
            (P &&
              ((B = A[S]),
              (b = A[S + 1]),
              (L = y(A[S + 2], B, _, x)),
              (U = y(A[S + 2], b, _, x))),
              m.push(B.clone()),
              m.push(b.clone()),
              m.push(L),
              m.push(U),
              m.push(L.clone()),
              m.push(b.clone()));
            break;
          }
          case 2: {
            (w ||
              ((B = A[S].clone()),
              (b = y(B, A[S + 1], _, x)),
              (L = y(B, A[S + 2], _, x)),
              m.push(B),
              m.push(b),
              m.push(L)),
              C ||
                ((B = A[S + 1].clone()),
                (b = y(B, A[S + 2], _, x)),
                (L = y(B, A[S], _, x)),
                m.push(B),
                m.push(b),
                m.push(L)),
              P ||
                ((B = A[S + 2].clone()),
                (b = y(B, A[S], _, x)),
                (L = y(B, A[S + 1], _, x)),
                m.push(B),
                m.push(b),
                m.push(L)));
            break;
          }
        }
      }
      return m;
    }
    function y(A, _, m, x) {
      const S = A.position.dot(m) - x,
        w = _.position.dot(m) - x,
        C = S / (S - w);
      return new uT(
        new F(
          A.position.x + C * (_.position.x - A.position.x),
          A.position.y + C * (_.position.y - A.position.y),
          A.position.z + C * (_.position.z - A.position.z)
        ),
        new F(
          A.normal.x + C * (_.normal.x - A.normal.x),
          A.normal.y + C * (_.normal.y - A.normal.y),
          A.normal.z + C * (_.normal.z - A.normal.z)
        )
      );
    }
  }
}
class uT {
  constructor(e, t) {
    ((this.position = e), (this.normal = t));
  }
  clone() {
    return new this.constructor(this.position.clone(), this.normal.clone());
  }
}
const wy = new WeakMap();
class T9 extends _i {
  constructor(e) {
    (super(e),
      (this.decoderPath = ""),
      (this.decoderConfig = {}),
      (this.decoderBinary = null),
      (this.decoderPending = null),
      (this.workerLimit = 4),
      (this.workerPool = []),
      (this.workerNextTaskID = 1),
      (this.workerSourceURL = ""),
      (this.defaultAttributeIDs = {
        position: "POSITION",
        normal: "NORMAL",
        color: "COLOR",
        uv: "TEX_COORD",
      }),
      (this.defaultAttributeTypes = {
        position: "Float32Array",
        normal: "Float32Array",
        color: "Float32Array",
        uv: "Float32Array",
      }));
  }
  setDecoderPath(e) {
    return ((this.decoderPath = e), this);
  }
  setDecoderConfig(e) {
    return ((this.decoderConfig = e), this);
  }
  setWorkerLimit(e) {
    return ((this.workerLimit = e), this);
  }
  load(e, t, i, r) {
    const s = new Qi(this.manager);
    (s.setPath(this.path),
      s.setResponseType("arraybuffer"),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials),
      s.load(
        e,
        (o) => {
          const a = {
            attributeIDs: this.defaultAttributeIDs,
            attributeTypes: this.defaultAttributeTypes,
            useUniqueIDs: !1,
          };
          this.decodeGeometry(o, a).then(t).catch(r);
        },
        i,
        r
      ));
  }
  decodeDracoFile(e, t, i, r) {
    const s = {
      attributeIDs: i || this.defaultAttributeIDs,
      attributeTypes: r || this.defaultAttributeTypes,
      useUniqueIDs: !!i,
    };
    this.decodeGeometry(e, s).then(t);
  }
  decodeGeometry(e, t) {
    for (const l in t.attributeTypes) {
      const u = t.attributeTypes[l];
      u.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[l] = u.name);
    }
    const i = JSON.stringify(t);
    if (wy.has(e)) {
      const l = wy.get(e);
      if (l.key === i) return l.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let r;
    const s = this.workerNextTaskID++,
      o = e.byteLength,
      a = this._getWorker(s, o)
        .then(
          (l) => (
            (r = l),
            new Promise((u, h) => {
              ((r._callbacks[s] = { resolve: u, reject: h }),
                r.postMessage(
                  { type: "decode", id: s, taskConfig: t, buffer: e },
                  [e]
                ));
            })
          )
        )
        .then((l) => this._createGeometry(l.geometry));
    return (
      a
        .catch(() => !0)
        .then(() => {
          r && s && this._releaseTask(r, s);
        }),
      wy.set(e, { key: i, promise: a }),
      a
    );
  }
  _createGeometry(e) {
    const t = new ft();
    e.index && t.setIndex(new Dt(e.index.array, 1));
    for (let i = 0; i < e.attributes.length; i++) {
      const r = e.attributes[i],
        s = r.name,
        o = r.array,
        a = r.itemSize;
      t.setAttribute(s, new Dt(o, a));
    }
    return t;
  }
  _loadLibrary(e, t) {
    const i = new Qi(this.manager);
    return (
      i.setPath(this.decoderPath),
      i.setResponseType(t),
      i.setWithCredentials(this.withCredentials),
      new Promise((r, s) => {
        i.load(e, r, void 0, s);
      })
    );
  }
  preload() {
    return (this._initDecoder(), this);
  }
  _initDecoder() {
    if (this.decoderPending) return this.decoderPending;
    const e =
        typeof WebAssembly != "object" || this.decoderConfig.type === "js",
      t = [];
    return (
      e
        ? t.push(this._loadLibrary("draco_decoder.js", "text"))
        : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
          t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
      (this.decoderPending = Promise.all(t).then((i) => {
        const r = i[0];
        e || (this.decoderConfig.wasmBinary = i[1]);
        const s = b9.toString(),
          o = [
            "/* draco decoder */",
            r,
            "",
            "/* worker */",
            s.substring(s.indexOf("{") + 1, s.lastIndexOf("}")),
          ].join(`
`);
        this.workerSourceURL = URL.createObjectURL(new Blob([o]));
      })),
      this.decoderPending
    );
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const r = new Worker(this.workerSourceURL);
        ((r._callbacks = {}),
          (r._taskCosts = {}),
          (r._taskLoad = 0),
          r.postMessage({ type: "init", decoderConfig: this.decoderConfig }),
          (r.onmessage = function (s) {
            const o = s.data;
            switch (o.type) {
              case "decode":
                r._callbacks[o.id].resolve(o);
                break;
              case "error":
                r._callbacks[o.id].reject(o);
                break;
              default:
                console.error(
                  'THREE.DRACOLoader: Unexpected message, "' + o.type + '"'
                );
            }
          }),
          this.workerPool.push(r));
      } else
        this.workerPool.sort(function (r, s) {
          return r._taskLoad > s._taskLoad ? -1 : 1;
        });
      const i = this.workerPool[this.workerPool.length - 1];
      return ((i._taskCosts[e] = t), (i._taskLoad += t), i);
    });
  }
  _releaseTask(e, t) {
    ((e._taskLoad -= e._taskCosts[t]),
      delete e._callbacks[t],
      delete e._taskCosts[t]);
  }
  debug() {
    console.log(
      "Task load: ",
      this.workerPool.map((e) => e._taskLoad)
    );
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return ((this.workerPool.length = 0), this);
  }
}
function b9() {
  let n, e;
  onmessage = function (o) {
    const a = o.data;
    switch (a.type) {
      case "init":
        ((n = a.decoderConfig),
          (e = new Promise(function (h) {
            ((n.onModuleLoaded = function (d) {
              h({ draco: d });
            }),
              DracoDecoderModule(n));
          })));
        break;
      case "decode":
        const l = a.buffer,
          u = a.taskConfig;
        e.then((h) => {
          const d = h.draco,
            p = new d.Decoder(),
            g = new d.DecoderBuffer();
          g.Init(new Int8Array(l), l.byteLength);
          try {
            const y = t(d, p, g, u),
              A = y.attributes.map((_) => _.array.buffer);
            (y.index && A.push(y.index.array.buffer),
              self.postMessage({ type: "decode", id: a.id, geometry: y }, A));
          } catch (y) {
            (console.error(y),
              self.postMessage({ type: "error", id: a.id, error: y.message }));
          } finally {
            (d.destroy(g), d.destroy(p));
          }
        });
        break;
    }
  };
  function t(o, a, l, u) {
    const h = u.attributeIDs,
      d = u.attributeTypes;
    let p, g;
    const y = a.GetEncodedGeometryType(l);
    if (y === o.TRIANGULAR_MESH)
      ((p = new o.Mesh()), (g = a.DecodeBufferToMesh(l, p)));
    else if (y === o.POINT_CLOUD)
      ((p = new o.PointCloud()), (g = a.DecodeBufferToPointCloud(l, p)));
    else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!g.ok() || p.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + g.error_msg());
    const A = { index: null, attributes: [] };
    for (const _ in h) {
      const m = self[d[_]];
      let x, S;
      if (u.useUniqueIDs) ((S = h[_]), (x = a.GetAttributeByUniqueId(p, S)));
      else {
        if (((S = a.GetAttributeId(p, o[h[_]])), S === -1)) continue;
        x = a.GetAttribute(p, S);
      }
      A.attributes.push(r(o, a, p, _, m, x));
    }
    return (y === o.TRIANGULAR_MESH && (A.index = i(o, a, p)), o.destroy(p), A);
  }
  function i(o, a, l) {
    const h = l.num_faces() * 3,
      d = h * 4,
      p = o._malloc(d);
    a.GetTrianglesUInt32Array(l, d, p);
    const g = new Uint32Array(o.HEAPF32.buffer, p, h).slice();
    return (o._free(p), { array: g, itemSize: 1 });
  }
  function r(o, a, l, u, h, d) {
    const p = d.num_components(),
      y = l.num_points() * p,
      A = y * h.BYTES_PER_ELEMENT,
      _ = s(o, h),
      m = o._malloc(A);
    a.GetAttributeDataArrayForAllPoints(l, d, _, A, m);
    const x = new h(o.HEAPF32.buffer, m, y).slice();
    return (o._free(m), { name: u, array: x, itemSize: p });
  }
  function s(o, a) {
    switch (a) {
      case Float32Array:
        return o.DT_FLOAT32;
      case Int8Array:
        return o.DT_INT8;
      case Int16Array:
        return o.DT_INT16;
      case Int32Array:
        return o.DT_INT32;
      case Uint8Array:
        return o.DT_UINT8;
      case Uint16Array:
        return o.DT_UINT16;
      case Uint32Array:
        return o.DT_UINT32;
    }
  }
}
let Qp;
const Ey = () => {
    if (Qp) return Qp;
    const n =
        "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB",
      e =
        "B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB",
      t = new Uint8Array([
        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1,
        0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0,
        11, 7, 0, 65, 0, 253, 15, 26, 11,
      ]),
      i = new Uint8Array([
        32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16,
        128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136,
        107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131,
        44, 45, 74, 156, 154, 70, 167,
      ]);
    if (typeof WebAssembly != "object") return { supported: !1 };
    let r = n;
    WebAssembly.validate(t) && (r = e);
    let s;
    const o = WebAssembly.instantiate(a(r), {}).then((d) => {
      ((s = d.instance), s.exports.__wasm_call_ctors());
    });
    function a(d) {
      const p = new Uint8Array(d.length);
      for (let y = 0; y < d.length; ++y) {
        const A = d.charCodeAt(y);
        p[y] =
          A > 96 ? A - 71 : A > 64 ? A - 65 : A > 47 ? A + 4 : A > 46 ? 63 : 62;
      }
      let g = 0;
      for (let y = 0; y < d.length; ++y)
        p[g++] = p[y] < 60 ? i[p[y]] : (p[y] - 60) * 64 + p[++y];
      return p.buffer.slice(0, g);
    }
    function l(d, p, g, y, A, _) {
      const m = s.exports.sbrk,
        x = (g + 3) & -4,
        S = m(x * y),
        w = m(A.length),
        C = new Uint8Array(s.exports.memory.buffer);
      C.set(A, w);
      const P = d(S, g, y, w, A.length);
      if (
        (P === 0 && _ && _(S, x, y),
        p.set(C.subarray(S, S + g * y)),
        m(S - m(0)),
        P !== 0)
      )
        throw new Error(`Malformed buffer data: ${P}`);
    }
    const u = {
        0: "",
        1: "meshopt_decodeFilterOct",
        2: "meshopt_decodeFilterQuat",
        3: "meshopt_decodeFilterExp",
        NONE: "",
        OCTAHEDRAL: "meshopt_decodeFilterOct",
        QUATERNION: "meshopt_decodeFilterQuat",
        EXPONENTIAL: "meshopt_decodeFilterExp",
      },
      h = {
        0: "meshopt_decodeVertexBuffer",
        1: "meshopt_decodeIndexBuffer",
        2: "meshopt_decodeIndexSequence",
        ATTRIBUTES: "meshopt_decodeVertexBuffer",
        TRIANGLES: "meshopt_decodeIndexBuffer",
        INDICES: "meshopt_decodeIndexSequence",
      };
    return (
      (Qp = {
        ready: o,
        supported: !0,
        decodeVertexBuffer(d, p, g, y, A) {
          l(s.exports.meshopt_decodeVertexBuffer, d, p, g, y, s.exports[u[A]]);
        },
        decodeIndexBuffer(d, p, g, y) {
          l(s.exports.meshopt_decodeIndexBuffer, d, p, g, y);
        },
        decodeIndexSequence(d, p, g, y) {
          l(s.exports.meshopt_decodeIndexSequence, d, p, g, y);
        },
        decodeGltfBuffer(d, p, g, y, A, _) {
          l(s.exports[h[A]], d, p, g, y, s.exports[u[_]]);
        },
      }),
      Qp
    );
  },
  fT = (n) => n === Object(n) && !Array.isArray(n) && typeof n != "function";
function zA(n, e) {
  const t = Vi((r) => r.gl),
    i = ra(Gh, fT(n) ? Object.values(n) : n);
  if (
    (H.useLayoutEffect(() => {
      e == null || e(i);
    }, [e]),
    H.useEffect(() => {
      (Array.isArray(i) ? i : [i]).forEach(t.initTexture);
    }, [t, i]),
    fT(n))
  ) {
    const r = Object.keys(n),
      s = {};
    return (r.forEach((o) => Object.assign(s, { [o]: i[r.indexOf(o)] })), s);
  } else return i;
}
zA.preload = (n) => ra.preload(Gh, n);
zA.clear = (n) => ra.clear(Gh, n);
function P9(n) {
  return Array.isArray(n);
}
function Cy(n = [0, 0, 0]) {
  return P9(n)
    ? n
    : n instanceof F || n instanceof hl
      ? [n.x, n.y, n.z]
      : [n, n, n];
}
const B9 = H.forwardRef(function (
  { debug: e, mesh: t, children: i, position: r, rotation: s, scale: o, ...a },
  l
) {
  const u = H.useRef(null);
  H.useImperativeHandle(l, () => u.current);
  const h = H.useRef(null);
  return (
    H.useLayoutEffect(() => {
      const d = (t == null ? void 0 : t.current) || u.current.parent,
        p = u.current;
      if (!(d instanceof Bn))
        throw new Error(
          'Decal must have a Mesh as parent or specify its "mesh" prop'
        );
      const g = {
        position: new F(),
        rotation: new hl(),
        scale: new F(1, 1, 1),
      };
      if (d) {
        Fs(g, { position: r, scale: o });
        const y = d.matrixWorld.clone();
        if ((d.matrixWorld.identity(), !s || typeof s == "number")) {
          const A = new Pt();
          (A.position.copy(g.position),
            A.lookAt(d.position),
            typeof s == "number" && A.rotateZ(s),
            Fs(g, { rotation: A.rotation }));
        } else Fs(g, { rotation: s });
        return (
          (p.geometry = new C9(d, g.position, g.rotation, g.scale)),
          h.current && Fs(h.current, g),
          (d.matrixWorld = y),
          () => {
            p.geometry.dispose();
          }
        );
      }
    }, [t, ...Cy(r), ...Cy(o), ...Cy(s)]),
    H.createElement(
      "mesh",
      { ref: u },
      i ||
        H.createElement(
          "meshStandardMaterial",
          _r(
            { transparent: !0, polygonOffset: !0, polygonOffsetFactor: -10 },
            a
          )
        ),
      e &&
        H.createElement(
          "mesh",
          { ref: h },
          H.createElement("boxGeometry", null),
          H.createElement("meshNormalMaterial", { wireframe: !0 }),
          H.createElement("axesHelper", null)
        )
    )
  );
});
let Zp = null;
function u3(n, e, t) {
  return (i) => {
    (t && t(i),
      n &&
        (Zp || (Zp = new T9()),
        Zp.setDecoderPath(
          typeof n == "string"
            ? n
            : "https://www.gstatic.com/draco/versioned/decoders/1.5.5/"
        ),
        i.setDRACOLoader(Zp)),
      e && i.setMeshoptDecoder(typeof Ey == "function" ? Ey() : Ey));
  };
}
function GA(n, e = !0, t = !0, i) {
  return ra(UA, n, u3(e, t, i));
}
GA.preload = (n, e = !0, t = !0, i) => ra.preload(UA, n, u3(e, t, i));
GA.clear = (n) => ra.clear(UA, n);
const f3 = H.forwardRef(
  (
    {
      makeDefault: n,
      camera: e,
      regress: t,
      domElement: i,
      enableDamping: r = !0,
      onChange: s,
      onStart: o,
      onEnd: a,
      ...l
    },
    u
  ) => {
    const h = Vi((C) => C.invalidate),
      d = Vi((C) => C.camera),
      p = Vi((C) => C.gl),
      g = Vi((C) => C.events),
      y = Vi((C) => C.setEvents),
      A = Vi((C) => C.set),
      _ = Vi((C) => C.get),
      m = Vi((C) => C.performance),
      x = e || d,
      S = i || g.connected || p.domElement,
      w = H.useMemo(() => new QV(x), [x]);
    return (
      fu(() => {
        w.enabled && w.update();
      }, -1),
      H.useEffect(() => (w.connect(S), () => void w.dispose()), [S, t, w, h]),
      H.useEffect(() => {
        const C = (B) => {
            (h(), t && m.regress(), s && s(B));
          },
          P = (B) => {
            o && o(B);
          },
          R = (B) => {
            a && a(B);
          };
        return (
          w.addEventListener("change", C),
          w.addEventListener("start", P),
          w.addEventListener("end", R),
          () => {
            (w.removeEventListener("start", P),
              w.removeEventListener("end", R),
              w.removeEventListener("change", C));
          }
        );
      }, [s, o, a, w, h, y]),
      H.useEffect(() => {
        if (n) {
          const C = _().controls;
          return (A({ controls: w }), () => A({ controls: C }));
        }
      }, [n, w]),
      H.createElement(
        "primitive",
        _r({ ref: u, object: w, enableDamping: r }, l)
      )
    );
  }
);
class R9 extends bh {
  constructor(e) {
    (super(e),
      (this.onBeforeCompile = (t, i) => {
        const { isWebGL2: r } = i.capabilities;
        t.fragmentShader = t.fragmentShader.replace(
          "#include <output_fragment>",
          `
        ${
          r
            ? "#include <output_fragment>"
            : `#extension GL_OES_standard_derivatives : enable
#include <output_fragment>`
        }
      vec2 cxy = 2.0 * gl_PointCoord - 1.0;
      float r = dot(cxy, cxy);
      float delta = fwidth(r);     
      float mask = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);
      gl_FragColor = vec4(gl_FragColor.rgb, mask * gl_FragColor.a );
      #include <tonemapping_fragment>
      #include <encodings_fragment>
      `
        );
      }));
  }
}
const L9 = H.forwardRef((n, e) => {
    const [t] = H.useState(() => new R9(null));
    return H.createElement(
      "primitive",
      _r({}, n, { object: t, ref: e, attach: "material" })
    );
  }),
  I9 = H.forwardRef(
    (
      {
        children: n,
        enabled: e = !0,
        speed: t = 1,
        rotationIntensity: i = 1,
        floatIntensity: r = 1,
        floatingRange: s = [-0.1, 0.1],
        ...o
      },
      a
    ) => {
      const l = H.useRef(null),
        u = H.useRef(Math.random() * 1e4);
      return (
        fu((h) => {
          var d, p;
          if (!e || t === 0) return;
          const g = u.current + h.clock.getElapsedTime();
          ((l.current.rotation.x = (Math.cos((g / 4) * t) / 8) * i),
            (l.current.rotation.y = (Math.sin((g / 4) * t) / 8) * i),
            (l.current.rotation.z = (Math.sin((g / 4) * t) / 20) * i));
          let y = Math.sin((g / 4) * t) / 10;
          ((y = q1.mapLinear(
            y,
            -0.1,
            0.1,
            (d = s == null ? void 0 : s[0]) !== null && d !== void 0 ? d : -0.1,
            (p = s == null ? void 0 : s[1]) !== null && p !== void 0 ? p : 0.1
          )),
            (l.current.position.y = y * r),
            l.current.updateMatrix());
        }),
        H.createElement(
          "group",
          o,
          H.createElement("group", { ref: OA([l, a]), matrixAutoUpdate: !1 }, n)
        )
      );
    }
  );
let wa, rf;
const D9 = H.createContext(null),
  hT = new ot(),
  dT = new F(),
  F9 = H.forwardRef(({ children: n, range: e, limit: t = 1e3, ...i }, r) => {
    const s = H.useRef(null),
      [o, a] = H.useState([]),
      [[l, u, h]] = H.useState(() => [
        new Float32Array(t * 3),
        Float32Array.from({ length: t * 3 }, () => 1),
        Float32Array.from({ length: t }, () => 1),
      ]);
    (H.useEffect(() => {
      s.current.geometry.attributes.position.needsUpdate = !0;
    }),
      fu(() => {
        for (
          s.current.updateMatrix(),
            s.current.updateMatrixWorld(),
            hT.copy(s.current.matrixWorld).invert(),
            s.current.geometry.drawRange.count = Math.min(
              t,
              e !== void 0 ? e : t,
              o.length
            ),
            wa = 0;
          wa < o.length;
          wa++
        )
          ((rf = o[wa].current),
            rf.getWorldPosition(dT).applyMatrix4(hT),
            dT.toArray(l, wa * 3),
            (s.current.geometry.attributes.position.needsUpdate = !0),
            (rf.matrixWorldNeedsUpdate = !0),
            rf.color.toArray(u, wa * 3),
            (s.current.geometry.attributes.color.needsUpdate = !0),
            h.set([rf.size], wa),
            (s.current.geometry.attributes.size.needsUpdate = !0));
      }));
    const d = H.useMemo(
      () => ({
        getParent: () => s,
        subscribe: (p) => (
          a((g) => [...g, p]),
          () => a((g) => g.filter((y) => y.current !== p.current))
        ),
      }),
      []
    );
    return H.createElement(
      "points",
      _r(
        {
          userData: { instances: o },
          matrixAutoUpdate: !1,
          ref: OA([r, s]),
          raycast: () => null,
        },
        i
      ),
      H.createElement(
        "bufferGeometry",
        null,
        H.createElement("bufferAttribute", {
          attach: "attributes-position",
          count: l.length / 3,
          array: l,
          itemSize: 3,
          usage: Qa,
        }),
        H.createElement("bufferAttribute", {
          attach: "attributes-color",
          count: u.length / 3,
          array: u,
          itemSize: 3,
          usage: Qa,
        }),
        H.createElement("bufferAttribute", {
          attach: "attributes-size",
          count: h.length,
          array: h,
          itemSize: 1,
          usage: Qa,
        })
      ),
      H.createElement(D9.Provider, { value: d }, n)
    );
  }),
  N9 = H.forwardRef(
    (
      { children: n, positions: e, colors: t, sizes: i, stride: r = 3, ...s },
      o
    ) => {
      const a = H.useRef(null);
      return (
        fu(() => {
          const l = a.current.geometry.attributes;
          ((l.position.needsUpdate = !0),
            t && (l.color.needsUpdate = !0),
            i && (l.size.needsUpdate = !0));
        }),
        H.createElement(
          "points",
          _r({ ref: OA([o, a]) }, s),
          H.createElement(
            "bufferGeometry",
            null,
            H.createElement("bufferAttribute", {
              attach: "attributes-position",
              count: e.length / r,
              array: e,
              itemSize: r,
              usage: Qa,
            }),
            t &&
              H.createElement("bufferAttribute", {
                attach: "attributes-color",
                count: t.length / r,
                array: t,
                itemSize: 3,
                usage: Qa,
              }),
            i &&
              H.createElement("bufferAttribute", {
                attach: "attributes-size",
                count: i.length / r,
                array: i,
                itemSize: 1,
                usage: Qa,
              })
          ),
          n
        )
      );
    }
  ),
  k9 = H.forwardRef((n, e) =>
    n.positions instanceof Float32Array
      ? H.createElement(N9, _r({}, n, { ref: e }))
      : H.createElement(F9, _r({}, n, { ref: e }))
  );
var tg = {},
  O9 = {
    get exports() {
      return tg;
    },
    set exports(n) {
      tg = n;
    },
  },
  U9 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",
  z9 = U9,
  G9 = z9;
function h3() {}
function d3() {}
d3.resetWarningCache = h3;
var H9 = function () {
  function n(i, r, s, o, a, l) {
    if (l !== G9) {
      var u = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      throw ((u.name = "Invariant Violation"), u);
    }
  }
  n.isRequired = n;
  function e() {
    return n;
  }
  var t = {
    array: n,
    bigint: n,
    bool: n,
    func: n,
    number: n,
    object: n,
    string: n,
    symbol: n,
    any: n,
    arrayOf: e,
    element: n,
    elementType: n,
    instanceOf: e,
    node: n,
    objectOf: e,
    oneOf: e,
    oneOfType: e,
    shape: e,
    exact: e,
    checkPropTypes: d3,
    resetWarningCache: h3,
  };
  return ((t.PropTypes = t), t);
};
O9.exports = H9();
function HA({ all: n, scene: e, camera: t }) {
  const i = Vi(({ gl: o }) => o),
    r = Vi(({ camera: o }) => o),
    s = Vi(({ scene: o }) => o);
  return (
    H.useLayoutEffect(() => {
      const o = [];
      (n &&
        (e || s).traverse((u) => {
          u.visible === !1 && (o.push(u), (u.visible = !0));
        }),
        i.compile(e || s, t || r));
      const a = new rA(128);
      (new iA(0.01, 1e5, a).update(i, e || s),
        a.dispose(),
        o.forEach((u) => (u.visible = !1)));
    }, []),
    null
  );
}
const p3 = () => {
    const { progress: n } = zV();
    return rt(UV, {
      as: "div",
      center: !0,
      style: {
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        flexDirection: "column",
      },
      children: [
        ce("span", { className: "canvas-loader" }),
        rt("p", {
          style: {
            fontSize: 14,
            color: "#F1F1F1",
            fontWeight: 800,
            marginTop: 40,
          },
          children: [n.toFixed(2), "%"],
        }),
      ],
    });
  },
  V9 = () => {
    const n = GA("./assets/scene.gltf");
    return ce("primitive", {
      object: n.scene,
      scale: 2.5,
      "position-y": 0,
      "rotation-y": 0,
    });
  },
  W9 = () =>
    ce(NA, {
      shadows: !0,
      frameloop: "demand",
      dpr: [1, 2],
      gl: { preserveDrawingBuffer: !0 },
      camera: { fov: 45, near: 0.1, far: 200, position: [-4, 3, 6] },
      children: rt(H.Suspense, {
        fallback: ce(p3, {}),
        children: [
          ce(f3, {
            autoRotate: !0,
            enableZoom: !1,
            maxPolarAngle: Math.PI / 2,
            minPolarAngle: Math.PI / 2,
          }),
          ce(V9, {}),
          ce(HA, { all: !0 }),
        ],
      }),
    }),
  j9 = (n) => {
    const [e] = zA([n.imgUrl]);
    return rt(I9, {
      speed: 1.75,
      rotationIntensity: 1,
      floatIntensity: 2,
      children: [
        ce("ambientLight", { intensity: 0.25 }),
        ce("directionalLight", { position: [0, 0, 0.05] }),
        rt("mesh", {
          castShadow: !0,
          receiveShadow: !0,
          scale: 2.75,
          children: [
            ce("icosahedronGeometry", { args: [1, 1] }),
            ce("meshStandardMaterial", {
              color: "#fff8eb",
              polygonOffset: !0,
              polygonOffsetFactor: -5,
              flatShading: !0,
            }),
            ce(B9, {
              position: [0, 0, 1],
              rotation: [2 * Math.PI, 0, 6.25],
              scale: 1,
              map: e,
              flatShading: !0,
            }),
          ],
        }),
      ],
    });
  },
  J9 = ({ icon: n }) =>
    rt(NA, {
      frameloop: "demand",
      dpr: [1, 2],
      gl: { preserveDrawingBuffer: !0 },
      children: [
        rt(H.Suspense, {
          fallback: ce(p3, {}),
          children: [ce(f3, { enableZoom: !1 }), ce(j9, { imgUrl: n })],
        }),
        ce(HA, { all: !0 }),
      ],
    }),
  X9 = (n) => {
    const e = H.useRef(),
      [t] = H.useState(() => XV(new Float32Array(5e3), { radius: 1.2 }));
    return (
      fu((i, r) => {
        ((e.current.rotation.x -= r / 10), (e.current.rotation.y -= r / 15));
      }),
      ce("group", {
        rotation: [0, 0, Math.PI / 4],
        children: ce(k9, {
          ref: e,
          positions: t,
          stride: 3,
          frustumCulled: !0,
          ...n,
          children: ce(L9, {
            transparent: !0,
            color: "#f272c8",
            size: 0.002,
            sizeAttenuation: !0,
            depthWrite: !1,
          }),
        }),
      })
    );
  },
  K9 = () =>
    ce("div", {
      className: "w-full h-auto absolute inset-0 z-[-1]",
      children: rt(NA, {
        camera: { position: [0, 0, 1] },
        children: [
          ce(H.Suspense, { fallback: null, children: ce(X9, {}) }),
          ce(HA, { all: !0 }),
        ],
      }),
    }),
  m3 = H.createContext({
    transformPagePoint: (n) => n,
    isStatic: !1,
    reducedMotion: "never",
  }),
  Kg = H.createContext({}),
  VA = H.createContext(null),
  Yg = typeof document < "u",
  pT = Yg ? H.useLayoutEffect : H.useEffect,
  g3 = H.createContext({ strict: !1 });
function Y9(n, e, t, i) {
  const { visualElement: r } = H.useContext(Kg),
    s = H.useContext(g3),
    o = H.useContext(VA),
    a = H.useContext(m3).reducedMotion,
    l = H.useRef();
  ((i = i || s.renderer),
    !l.current &&
      i &&
      (l.current = i(n, {
        visualState: e,
        parent: r,
        props: t,
        presenceContext: o,
        blockInitialAnimation: o ? o.initial === !1 : !1,
        reducedMotionConfig: a,
      })));
  const u = l.current;
  return (
    H.useInsertionEffect(() => {
      u && u.update(t, o);
    }),
    pT(() => {
      u && u.render();
    }),
    H.useEffect(() => {
      u && u.updateFeatures();
    }),
    (window.HandoffAppearAnimations ? pT : H.useEffect)(() => {
      u && u.animationState && u.animationState.animateChanges();
    }),
    u
  );
}
function Ac(n) {
  return (
    typeof n == "object" && Object.prototype.hasOwnProperty.call(n, "current")
  );
}
function Q9(n, e, t) {
  return H.useCallback(
    (i) => {
      (i && n.mount && n.mount(i),
        e && (i ? e.mount(i) : e.unmount()),
        t && (typeof t == "function" ? t(i) : Ac(t) && (t.current = i)));
    },
    [e]
  );
}
function fh(n) {
  return typeof n == "string" || Array.isArray(n);
}
function Qg(n) {
  return typeof n == "object" && typeof n.start == "function";
}
const WA = [
    "animate",
    "whileInView",
    "whileFocus",
    "whileHover",
    "whileTap",
    "whileDrag",
    "exit",
  ],
  jA = ["initial", ...WA];
function Zg(n) {
  return Qg(n.animate) || jA.some((e) => fh(n[e]));
}
function v3(n) {
  return !!(Zg(n) || n.variants);
}
function Z9(n, e) {
  if (Zg(n)) {
    const { initial: t, animate: i } = n;
    return {
      initial: t === !1 || fh(t) ? t : void 0,
      animate: fh(i) ? i : void 0,
    };
  }
  return n.inherit !== !1 ? e : {};
}
function q9(n) {
  const { initial: e, animate: t } = Z9(n, H.useContext(Kg));
  return H.useMemo(() => ({ initial: e, animate: t }), [mT(e), mT(t)]);
}
function mT(n) {
  return Array.isArray(n) ? n.join(" ") : n;
}
const gT = {
    animation: [
      "animate",
      "variants",
      "whileHover",
      "whileTap",
      "exit",
      "whileInView",
      "whileFocus",
      "whileDrag",
    ],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"],
  },
  hh = {};
for (const n in gT) hh[n] = { isEnabled: (e) => gT[n].some((t) => !!e[t]) };
function $9(n) {
  for (const e in n) hh[e] = { ...hh[e], ...n[e] };
}
function y3(n) {
  const e = H.useRef(null);
  return (e.current === null && (e.current = n()), e.current);
}
const Tf = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 };
let e8 = 1;
function t8() {
  return y3(() => {
    if (Tf.hasEverUpdated) return e8++;
  });
}
const x3 = H.createContext({}),
  _3 = H.createContext({}),
  n8 = Symbol.for("motionComponentSymbol");
function i8({
  preloadedFeatures: n,
  createVisualElement: e,
  useRender: t,
  useVisualState: i,
  Component: r,
}) {
  n && $9(n);
  function s(a, l) {
    let u;
    const h = { ...H.useContext(m3), ...a, layoutId: r8(a) },
      { isStatic: d } = h,
      p = q9(a),
      g = d ? void 0 : t8(),
      y = i(a, d);
    if (!d && Yg) {
      p.visualElement = Y9(r, y, h, e);
      const A = H.useContext(_3),
        _ = H.useContext(g3).strict;
      p.visualElement && (u = p.visualElement.loadFeatures(h, _, n, g, A));
    }
    return H.createElement(
      Kg.Provider,
      { value: p },
      u && p.visualElement
        ? H.createElement(u, { visualElement: p.visualElement, ...h })
        : null,
      t(r, a, g, Q9(y, p.visualElement, l), y, d, p.visualElement)
    );
  }
  const o = H.forwardRef(s);
  return ((o[n8] = r), o);
}
function r8({ layoutId: n }) {
  const e = H.useContext(x3).id;
  return e && n !== void 0 ? e + "-" + n : n;
}
function s8(n) {
  function e(i, r = {}) {
    return i8(n(i, r));
  }
  if (typeof Proxy > "u") return e;
  const t = new Map();
  return new Proxy(e, {
    get: (i, r) => (t.has(r) || t.set(r, e(r)), t.get(r)),
  });
}
const o8 = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view",
];
function JA(n) {
  return typeof n != "string" || n.includes("-")
    ? !1
    : !!(o8.indexOf(n) > -1 || /[A-Z]/.test(n));
}
const ng = {};
function a8(n) {
  Object.assign(ng, n);
}
const Wh = [
    "transformPerspective",
    "x",
    "y",
    "z",
    "translateX",
    "translateY",
    "translateZ",
    "scale",
    "scaleX",
    "scaleY",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "skew",
    "skewX",
    "skewY",
  ],
  vl = new Set(Wh);
function A3(n, { layout: e, layoutId: t }) {
  return (
    vl.has(n) ||
    n.startsWith("origin") ||
    ((e || t !== void 0) && (!!ng[n] || n === "opacity"))
  );
}
const Di = (n) => !!(n && n.getVelocity),
  l8 = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective",
  },
  c8 = Wh.length;
function u8(
  n,
  { enableHardwareAcceleration: e = !0, allowTransformNone: t = !0 },
  i,
  r
) {
  let s = "";
  for (let o = 0; o < c8; o++) {
    const a = Wh[o];
    if (n[a] !== void 0) {
      const l = l8[a] || a;
      s += `${l}(${n[a]}) `;
    }
  }
  return (
    e && !n.z && (s += "translateZ(0)"),
    (s = s.trim()),
    r ? (s = r(n, i ? "" : s)) : t && i && (s = "none"),
    s
  );
}
const M3 = (n) => (e) => typeof e == "string" && e.startsWith(n),
  S3 = M3("--"),
  B_ = M3("var(--"),
  f8 =
    /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g,
  h8 = (n, e) => (e && typeof n == "number" ? e.transform(n) : n),
  cl = (n, e, t) => Math.min(Math.max(t, n), e),
  yl = {
    test: (n) => typeof n == "number",
    parse: parseFloat,
    transform: (n) => n,
  },
  bf = { ...yl, transform: (n) => cl(0, 1, n) },
  qp = { ...yl, default: 1 },
  Pf = (n) => Math.round(n * 1e5) / 1e5,
  qg = /(-)?([\d]*\.?[\d])+/g,
  w3 =
    /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi,
  d8 =
    /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function jh(n) {
  return typeof n == "string";
}
const Jh = (n) => ({
    test: (e) => jh(e) && e.endsWith(n) && e.split(" ").length === 1,
    parse: parseFloat,
    transform: (e) => `${e}${n}`,
  }),
  Mo = Jh("deg"),
  us = Jh("%"),
  it = Jh("px"),
  p8 = Jh("vh"),
  m8 = Jh("vw"),
  vT = {
    ...us,
    parse: (n) => us.parse(n) / 100,
    transform: (n) => us.transform(n * 100),
  },
  yT = { ...yl, transform: Math.round },
  E3 = {
    borderWidth: it,
    borderTopWidth: it,
    borderRightWidth: it,
    borderBottomWidth: it,
    borderLeftWidth: it,
    borderRadius: it,
    radius: it,
    borderTopLeftRadius: it,
    borderTopRightRadius: it,
    borderBottomRightRadius: it,
    borderBottomLeftRadius: it,
    width: it,
    maxWidth: it,
    height: it,
    maxHeight: it,
    size: it,
    top: it,
    right: it,
    bottom: it,
    left: it,
    padding: it,
    paddingTop: it,
    paddingRight: it,
    paddingBottom: it,
    paddingLeft: it,
    margin: it,
    marginTop: it,
    marginRight: it,
    marginBottom: it,
    marginLeft: it,
    rotate: Mo,
    rotateX: Mo,
    rotateY: Mo,
    rotateZ: Mo,
    scale: qp,
    scaleX: qp,
    scaleY: qp,
    scaleZ: qp,
    skew: Mo,
    skewX: Mo,
    skewY: Mo,
    distance: it,
    translateX: it,
    translateY: it,
    translateZ: it,
    x: it,
    y: it,
    z: it,
    perspective: it,
    transformPerspective: it,
    opacity: bf,
    originX: vT,
    originY: vT,
    originZ: it,
    zIndex: yT,
    fillOpacity: bf,
    strokeOpacity: bf,
    numOctaves: yT,
  };
function XA(n, e, t, i) {
  const { style: r, vars: s, transform: o, transformOrigin: a } = n;
  let l = !1,
    u = !1,
    h = !0;
  for (const d in e) {
    const p = e[d];
    if (S3(d)) {
      s[d] = p;
      continue;
    }
    const g = E3[d],
      y = h8(p, g);
    if (vl.has(d)) {
      if (((l = !0), (o[d] = y), !h)) continue;
      p !== (g.default || 0) && (h = !1);
    } else d.startsWith("origin") ? ((u = !0), (a[d] = y)) : (r[d] = y);
  }
  if (
    (e.transform ||
      (l || i
        ? (r.transform = u8(n.transform, t, h, i))
        : r.transform && (r.transform = "none")),
    u)
  ) {
    const { originX: d = "50%", originY: p = "50%", originZ: g = 0 } = a;
    r.transformOrigin = `${d} ${p} ${g}`;
  }
}
const KA = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} });
function C3(n, e, t) {
  for (const i in e) !Di(e[i]) && !A3(i, t) && (n[i] = e[i]);
}
function g8({ transformTemplate: n }, e, t) {
  return H.useMemo(() => {
    const i = KA();
    return (
      XA(i, e, { enableHardwareAcceleration: !t }, n),
      Object.assign({}, i.vars, i.style)
    );
  }, [e]);
}
function v8(n, e, t) {
  const i = n.style || {},
    r = {};
  return (
    C3(r, i, n),
    Object.assign(r, g8(n, e, t)),
    n.transformValues ? n.transformValues(r) : r
  );
}
function y8(n, e, t) {
  const i = {},
    r = v8(n, e, t);
  return (
    n.drag &&
      n.dragListener !== !1 &&
      ((i.draggable = !1),
      (r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none"),
      (r.touchAction =
        n.drag === !0 ? "none" : `pan-${n.drag === "x" ? "y" : "x"}`)),
    n.tabIndex === void 0 &&
      (n.onTap || n.onTapStart || n.whileTap) &&
      (i.tabIndex = 0),
    (i.style = r),
    i
  );
}
const x8 = new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "onLayoutAnimationStart",
  "onLayoutAnimationComplete",
  "onLayoutMeasure",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "ignoreStrict",
  "viewport",
]);
function ig(n) {
  return (
    n.startsWith("while") ||
    (n.startsWith("drag") && n !== "draggable") ||
    n.startsWith("layout") ||
    n.startsWith("onTap") ||
    n.startsWith("onPan") ||
    x8.has(n)
  );
}
let T3 = (n) => !ig(n);
function _8(n) {
  n && (T3 = (e) => (e.startsWith("on") ? !ig(e) : n(e)));
}
try {
  _8(require("@emotion/is-prop-valid").default);
} catch {}
function A8(n, e, t) {
  const i = {};
  for (const r in n)
    (r === "values" && typeof n.values == "object") ||
      ((T3(r) ||
        (t === !0 && ig(r)) ||
        (!e && !ig(r)) ||
        (n.draggable && r.startsWith("onDrag"))) &&
        (i[r] = n[r]));
  return i;
}
function xT(n, e, t) {
  return typeof n == "string" ? n : it.transform(e + t * n);
}
function M8(n, e, t) {
  const i = xT(e, n.x, n.width),
    r = xT(t, n.y, n.height);
  return `${i} ${r}`;
}
const S8 = { offset: "stroke-dashoffset", array: "stroke-dasharray" },
  w8 = { offset: "strokeDashoffset", array: "strokeDasharray" };
function E8(n, e, t = 1, i = 0, r = !0) {
  n.pathLength = 1;
  const s = r ? S8 : w8;
  n[s.offset] = it.transform(-i);
  const o = it.transform(e),
    a = it.transform(t);
  n[s.array] = `${o} ${a}`;
}
function YA(
  n,
  {
    attrX: e,
    attrY: t,
    attrScale: i,
    originX: r,
    originY: s,
    pathLength: o,
    pathSpacing: a = 1,
    pathOffset: l = 0,
    ...u
  },
  h,
  d,
  p
) {
  if ((XA(n, u, h, p), d)) {
    n.style.viewBox && (n.attrs.viewBox = n.style.viewBox);
    return;
  }
  ((n.attrs = n.style), (n.style = {}));
  const { attrs: g, style: y, dimensions: A } = n;
  (g.transform && (A && (y.transform = g.transform), delete g.transform),
    A &&
      (r !== void 0 || s !== void 0 || y.transform) &&
      (y.transformOrigin = M8(
        A,
        r !== void 0 ? r : 0.5,
        s !== void 0 ? s : 0.5
      )),
    e !== void 0 && (g.x = e),
    t !== void 0 && (g.y = t),
    i !== void 0 && (g.scale = i),
    o !== void 0 && E8(g, o, a, l, !1));
}
const b3 = () => ({ ...KA(), attrs: {} }),
  QA = (n) => typeof n == "string" && n.toLowerCase() === "svg";
function C8(n, e, t, i) {
  const r = H.useMemo(() => {
    const s = b3();
    return (
      YA(s, e, { enableHardwareAcceleration: !1 }, QA(i), n.transformTemplate),
      { ...s.attrs, style: { ...s.style } }
    );
  }, [e]);
  if (n.style) {
    const s = {};
    (C3(s, n.style, n), (r.style = { ...s, ...r.style }));
  }
  return r;
}
function T8(n = !1) {
  return (t, i, r, s, { latestValues: o }, a) => {
    const u = (JA(t) ? C8 : y8)(i, o, a, t),
      d = { ...A8(i, typeof t == "string", n), ...u, ref: s },
      { children: p } = i,
      g = H.useMemo(() => (Di(p) ? p.get() : p), [p]);
    return (
      r && (d["data-projection-id"] = r),
      H.createElement(t, { ...d, children: g })
    );
  };
}
const ZA = (n) => n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
function P3(n, { style: e, vars: t }, i, r) {
  Object.assign(n.style, e, r && r.getProjectionStyles(i));
  for (const s in t) n.style.setProperty(s, t[s]);
}
const B3 = new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust",
]);
function R3(n, e, t, i) {
  P3(n, e, void 0, i);
  for (const r in e.attrs) n.setAttribute(B3.has(r) ? r : ZA(r), e.attrs[r]);
}
function qA(n, e) {
  const { style: t } = n,
    i = {};
  for (const r in t)
    (Di(t[r]) || (e.style && Di(e.style[r])) || A3(r, n)) && (i[r] = t[r]);
  return i;
}
function L3(n, e) {
  const t = qA(n, e);
  for (const i in n)
    if (Di(n[i]) || Di(e[i])) {
      const r =
        Wh.indexOf(i) !== -1
          ? "attr" + i.charAt(0).toUpperCase() + i.substring(1)
          : i;
      t[r] = n[i];
    }
  return t;
}
function $A(n, e, t, i = {}, r = {}) {
  return (
    typeof e == "function" && (e = e(t !== void 0 ? t : n.custom, i, r)),
    typeof e == "string" && (e = n.variants && n.variants[e]),
    typeof e == "function" && (e = e(t !== void 0 ? t : n.custom, i, r)),
    e
  );
}
const rg = (n) => Array.isArray(n),
  b8 = (n) => !!(n && typeof n == "object" && n.mix && n.toValue),
  P8 = (n) => (rg(n) ? n[n.length - 1] || 0 : n);
function Sm(n) {
  const e = Di(n) ? n.get() : n;
  return b8(e) ? e.toValue() : e;
}
function B8(
  { scrapeMotionValuesFromProps: n, createRenderState: e, onMount: t },
  i,
  r,
  s
) {
  const o = { latestValues: R8(i, r, s, n), renderState: e() };
  return (t && (o.mount = (a) => t(i, a, o)), o);
}
const I3 = (n) => (e, t) => {
  const i = H.useContext(Kg),
    r = H.useContext(VA),
    s = () => B8(n, e, i, r);
  return t ? s() : y3(s);
};
function R8(n, e, t, i) {
  const r = {},
    s = i(n, {});
  for (const p in s) r[p] = Sm(s[p]);
  let { initial: o, animate: a } = n;
  const l = Zg(n),
    u = v3(n);
  e &&
    u &&
    !l &&
    n.inherit !== !1 &&
    (o === void 0 && (o = e.initial), a === void 0 && (a = e.animate));
  let h = t ? t.initial === !1 : !1;
  h = h || o === !1;
  const d = h ? a : o;
  return (
    d &&
      typeof d != "boolean" &&
      !Qg(d) &&
      (Array.isArray(d) ? d : [d]).forEach((g) => {
        const y = $A(n, g);
        if (!y) return;
        const { transitionEnd: A, transition: _, ...m } = y;
        for (const x in m) {
          let S = m[x];
          if (Array.isArray(S)) {
            const w = h ? S.length - 1 : 0;
            S = S[w];
          }
          S !== null && (r[x] = S);
        }
        for (const x in A) r[x] = A[x];
      }),
    r
  );
}
const L8 = {
    useVisualState: I3({
      scrapeMotionValuesFromProps: L3,
      createRenderState: b3,
      onMount: (n, e, { renderState: t, latestValues: i }) => {
        try {
          t.dimensions =
            typeof e.getBBox == "function"
              ? e.getBBox()
              : e.getBoundingClientRect();
        } catch {
          t.dimensions = { x: 0, y: 0, width: 0, height: 0 };
        }
        (YA(
          t,
          i,
          { enableHardwareAcceleration: !1 },
          QA(e.tagName),
          n.transformTemplate
        ),
          R3(e, t));
      },
    }),
  },
  I8 = {
    useVisualState: I3({
      scrapeMotionValuesFromProps: qA,
      createRenderState: KA,
    }),
  };
function D8(n, { forwardMotionProps: e = !1 }, t, i) {
  return {
    ...(JA(n) ? L8 : I8),
    preloadedFeatures: t,
    useRender: T8(e),
    createVisualElement: i,
    Component: n,
  };
}
function zs(n, e, t, i = { passive: !0 }) {
  return (n.addEventListener(e, t, i), () => n.removeEventListener(e, t));
}
const D3 = (n) =>
  n.pointerType === "mouse"
    ? typeof n.button != "number" || n.button <= 0
    : n.isPrimary !== !1;
function $g(n, e = "page") {
  return { point: { x: n[e + "X"], y: n[e + "Y"] } };
}
const F8 = (n) => (e) => D3(e) && n(e, $g(e));
function Vs(n, e, t, i) {
  return zs(n, e, F8(t), i);
}
const N8 = (n, e) => (t) => e(n(t)),
  Vo = (...n) => n.reduce(N8);
function F3(n) {
  let e = null;
  return () => {
    const t = () => {
      e = null;
    };
    return e === null ? ((e = n), t) : !1;
  };
}
const _T = F3("dragHorizontal"),
  AT = F3("dragVertical");
function N3(n) {
  let e = !1;
  if (n === "y") e = AT();
  else if (n === "x") e = _T();
  else {
    const t = _T(),
      i = AT();
    t && i
      ? (e = () => {
          (t(), i());
        })
      : (t && t(), i && i());
  }
  return e;
}
function k3() {
  const n = N3(!0);
  return n ? (n(), !1) : !0;
}
class sa {
  constructor(e) {
    ((this.isMounted = !1), (this.node = e));
  }
  update() {}
}
function k8(n) {
  let e = [],
    t = [],
    i = 0,
    r = !1,
    s = !1;
  const o = new WeakSet(),
    a = {
      schedule: (l, u = !1, h = !1) => {
        const d = h && r,
          p = d ? e : t;
        return (
          u && o.add(l),
          p.indexOf(l) === -1 && (p.push(l), d && r && (i = e.length)),
          l
        );
      },
      cancel: (l) => {
        const u = t.indexOf(l);
        (u !== -1 && t.splice(u, 1), o.delete(l));
      },
      process: (l) => {
        if (r) {
          s = !0;
          return;
        }
        if (((r = !0), ([e, t] = [t, e]), (t.length = 0), (i = e.length), i))
          for (let u = 0; u < i; u++) {
            const h = e[u];
            (h(l), o.has(h) && (a.schedule(h), n()));
          }
        ((r = !1), s && ((s = !1), a.process(l)));
      },
    };
  return a;
}
const Un = { delta: 0, timestamp: 0, isProcessing: !1 },
  O8 = 40;
let R_ = !0,
  dh = !1;
const e0 = ["read", "update", "preRender", "render", "postRender"],
  Dc = e0.reduce((n, e) => ((n[e] = k8(() => (dh = !0))), n), {}),
  U8 = (n) => Dc[n].process(Un),
  O3 = (n) => {
    ((dh = !1),
      (Un.delta = R_ ? 1e3 / 60 : Math.max(Math.min(n - Un.timestamp, O8), 1)),
      (Un.timestamp = n),
      (Un.isProcessing = !0),
      e0.forEach(U8),
      (Un.isProcessing = !1),
      dh && ((R_ = !1), requestAnimationFrame(O3)));
  },
  z8 = () => {
    ((dh = !0), (R_ = !0), Un.isProcessing || requestAnimationFrame(O3));
  },
  an = e0.reduce((n, e) => {
    const t = Dc[e];
    return (
      (n[e] = (i, r = !1, s = !1) => (dh || z8(), t.schedule(i, r, s))),
      n
    );
  }, {});
function qs(n) {
  e0.forEach((e) => Dc[e].cancel(n));
}
function MT(n, e) {
  const t = "pointer" + (e ? "enter" : "leave"),
    i = "onHover" + (e ? "Start" : "End"),
    r = (s, o) => {
      if (s.type === "touch" || k3()) return;
      const a = n.getProps();
      (n.animationState &&
        a.whileHover &&
        n.animationState.setActive("whileHover", e),
        a[i] && an.update(() => a[i](s, o)));
    };
  return Vs(n.current, t, r, { passive: !n.getProps()[i] });
}
class G8 extends sa {
  mount() {
    this.unmount = Vo(MT(this.node, !0), MT(this.node, !1));
  }
  unmount() {}
}
class H8 extends sa {
  constructor() {
    (super(...arguments), (this.isActive = !1));
  }
  onFocus() {
    let e = !1;
    try {
      e = this.node.current.matches(":focus-visible");
    } catch {
      e = !0;
    }
    !e ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !0),
      (this.isActive = !0));
  }
  onBlur() {
    !this.isActive ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !1),
      (this.isActive = !1));
  }
  mount() {
    this.unmount = Vo(
      zs(this.node.current, "focus", () => this.onFocus()),
      zs(this.node.current, "blur", () => this.onBlur())
    );
  }
  unmount() {}
}
const U3 = (n, e) => (e ? (n === e ? !0 : U3(n, e.parentElement)) : !1),
  bn = (n) => n;
function Ty(n, e) {
  if (!e) return;
  const t = new PointerEvent("pointer" + n);
  e(t, $g(t));
}
class V8 extends sa {
  constructor() {
    (super(...arguments),
      (this.removeStartListeners = bn),
      (this.removeEndListeners = bn),
      (this.removeAccessibleListeners = bn),
      (this.startPointerPress = (e, t) => {
        if ((this.removeEndListeners(), this.isPressing)) return;
        const i = this.node.getProps(),
          s = Vs(
            window,
            "pointerup",
            (a, l) => {
              if (!this.checkPressEnd()) return;
              const { onTap: u, onTapCancel: h } = this.node.getProps();
              an.update(() => {
                U3(this.node.current, a.target) ? u && u(a, l) : h && h(a, l);
              });
            },
            { passive: !(i.onTap || i.onPointerUp) }
          ),
          o = Vs(window, "pointercancel", (a, l) => this.cancelPress(a, l), {
            passive: !(i.onTapCancel || i.onPointerCancel),
          });
        ((this.removeEndListeners = Vo(s, o)), this.startPress(e, t));
      }),
      (this.startAccessiblePress = () => {
        const e = (s) => {
            if (s.key !== "Enter" || this.isPressing) return;
            const o = (a) => {
              a.key !== "Enter" ||
                !this.checkPressEnd() ||
                Ty("up", (l, u) => {
                  const { onTap: h } = this.node.getProps();
                  h && an.update(() => h(l, u));
                });
            };
            (this.removeEndListeners(),
              (this.removeEndListeners = zs(this.node.current, "keyup", o)),
              Ty("down", (a, l) => {
                this.startPress(a, l);
              }));
          },
          t = zs(this.node.current, "keydown", e),
          i = () => {
            this.isPressing && Ty("cancel", (s, o) => this.cancelPress(s, o));
          },
          r = zs(this.node.current, "blur", i);
        this.removeAccessibleListeners = Vo(t, r);
      }));
  }
  startPress(e, t) {
    this.isPressing = !0;
    const { onTapStart: i, whileTap: r } = this.node.getProps();
    (r &&
      this.node.animationState &&
      this.node.animationState.setActive("whileTap", !0),
      i && an.update(() => i(e, t)));
  }
  checkPressEnd() {
    return (
      this.removeEndListeners(),
      (this.isPressing = !1),
      this.node.getProps().whileTap &&
        this.node.animationState &&
        this.node.animationState.setActive("whileTap", !1),
      !k3()
    );
  }
  cancelPress(e, t) {
    if (!this.checkPressEnd()) return;
    const { onTapCancel: i } = this.node.getProps();
    i && an.update(() => i(e, t));
  }
  mount() {
    const e = this.node.getProps(),
      t = Vs(this.node.current, "pointerdown", this.startPointerPress, {
        passive: !(e.onTapStart || e.onPointerStart),
      }),
      i = zs(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = Vo(t, i);
  }
  unmount() {
    (this.removeStartListeners(),
      this.removeEndListeners(),
      this.removeAccessibleListeners());
  }
}
const L_ = new WeakMap(),
  by = new WeakMap(),
  W8 = (n) => {
    const e = L_.get(n.target);
    e && e(n);
  },
  j8 = (n) => {
    n.forEach(W8);
  };
function J8({ root: n, ...e }) {
  const t = n || document;
  by.has(t) || by.set(t, {});
  const i = by.get(t),
    r = JSON.stringify(e);
  return (
    i[r] || (i[r] = new IntersectionObserver(j8, { root: n, ...e })),
    i[r]
  );
}
function X8(n, e, t) {
  const i = J8(e);
  return (
    L_.set(n, t),
    i.observe(n),
    () => {
      (L_.delete(n), i.unobserve(n));
    }
  );
}
const K8 = { some: 0, all: 1 };
class Y8 extends sa {
  constructor() {
    (super(...arguments), (this.hasEnteredView = !1), (this.isInView = !1));
  }
  startObserver() {
    this.unmount();
    const { viewport: e = {} } = this.node.getProps(),
      { root: t, margin: i, amount: r = "some", once: s } = e,
      o = {
        root: t ? t.current : void 0,
        rootMargin: i,
        threshold: typeof r == "number" ? r : K8[r],
      },
      a = (l) => {
        const { isIntersecting: u } = l;
        if (
          this.isInView === u ||
          ((this.isInView = u), s && !u && this.hasEnteredView)
        )
          return;
        (u && (this.hasEnteredView = !0),
          this.node.animationState &&
            this.node.animationState.setActive("whileInView", u));
        const { onViewportEnter: h, onViewportLeave: d } = this.node.getProps(),
          p = u ? h : d;
        p && p(l);
      };
    return X8(this.node.current, o, a);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u") return;
    const { props: e, prevProps: t } = this.node;
    ["amount", "margin", "root"].some(Q8(e, t)) && this.startObserver();
  }
  unmount() {}
}
function Q8({ viewport: n = {} }, { viewport: e = {} } = {}) {
  return (t) => n[t] !== e[t];
}
const Z8 = {
  inView: { Feature: Y8 },
  tap: { Feature: V8 },
  focus: { Feature: H8 },
  hover: { Feature: G8 },
};
function z3(n, e) {
  if (!Array.isArray(e)) return !1;
  const t = e.length;
  if (t !== n.length) return !1;
  for (let i = 0; i < t; i++) if (e[i] !== n[i]) return !1;
  return !0;
}
function q8(n) {
  const e = {};
  return (n.values.forEach((t, i) => (e[i] = t.get())), e);
}
function $8(n) {
  const e = {};
  return (n.values.forEach((t, i) => (e[i] = t.getVelocity())), e);
}
function t0(n, e, t) {
  const i = n.getProps();
  return $A(i, e, t !== void 0 ? t : i.custom, q8(n), $8(n));
}
const e6 = "framerAppearId",
  t6 = "data-" + ZA(e6);
let n6 = bn,
  eM = bn;
const Wo = (n) => n * 1e3,
  Ws = (n) => n / 1e3,
  i6 = { current: !1 },
  G3 = (n) => Array.isArray(n) && typeof n[0] == "number";
function H3(n) {
  return !!(
    !n ||
    (typeof n == "string" && V3[n]) ||
    G3(n) ||
    (Array.isArray(n) && n.every(H3))
  );
}
const df = ([n, e, t, i]) => `cubic-bezier(${n}, ${e}, ${t}, ${i})`,
  V3 = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: df([0, 0.65, 0.55, 1]),
    circOut: df([0.55, 0, 1, 0.45]),
    backIn: df([0.31, 0.01, 0.66, -0.59]),
    backOut: df([0.33, 1.53, 0.69, 0.99]),
  };
function W3(n) {
  if (n) return G3(n) ? df(n) : Array.isArray(n) ? n.map(W3) : V3[n];
}
function r6(
  n,
  e,
  t,
  {
    delay: i = 0,
    duration: r,
    repeat: s = 0,
    repeatType: o = "loop",
    ease: a,
    times: l,
  } = {}
) {
  const u = { [e]: t };
  l && (u.offset = l);
  const h = W3(a);
  return (
    Array.isArray(h) && (u.easing = h),
    n.animate(u, {
      delay: i,
      duration: r,
      easing: Array.isArray(h) ? "linear" : h,
      fill: "both",
      iterations: s + 1,
      direction: o === "reverse" ? "alternate" : "normal",
    })
  );
}
const ST = {
    waapi: () => Object.hasOwnProperty.call(Element.prototype, "animate"),
  },
  Py = {},
  j3 = {};
for (const n in ST)
  j3[n] = () => (Py[n] === void 0 && (Py[n] = ST[n]()), Py[n]);
function s6(n, { repeat: e, repeatType: t = "loop" }) {
  const i = e && t !== "loop" && e % 2 === 1 ? 0 : n.length - 1;
  return n[i];
}
const J3 = (n, e, t) =>
    (((1 - 3 * t + 3 * e) * n + (3 * t - 6 * e)) * n + 3 * e) * n,
  o6 = 1e-7,
  a6 = 12;
function l6(n, e, t, i, r) {
  let s,
    o,
    a = 0;
  do ((o = e + (t - e) / 2), (s = J3(o, i, r) - n), s > 0 ? (t = o) : (e = o));
  while (Math.abs(s) > o6 && ++a < a6);
  return o;
}
function Xh(n, e, t, i) {
  if (n === e && t === i) return bn;
  const r = (s) => l6(s, 0, 1, n, t);
  return (s) => (s === 0 || s === 1 ? s : J3(r(s), e, i));
}
const c6 = Xh(0.42, 0, 1, 1),
  u6 = Xh(0, 0, 0.58, 1),
  X3 = Xh(0.42, 0, 0.58, 1),
  f6 = (n) => Array.isArray(n) && typeof n[0] != "number",
  K3 = (n) => (e) => (e <= 0.5 ? n(2 * e) / 2 : (2 - n(2 * (1 - e))) / 2),
  Y3 = (n) => (e) => 1 - n(1 - e),
  Q3 = (n) => 1 - Math.sin(Math.acos(n)),
  tM = Y3(Q3),
  h6 = K3(tM),
  Z3 = Xh(0.33, 1.53, 0.69, 0.99),
  nM = Y3(Z3),
  d6 = K3(nM),
  p6 = (n) =>
    (n *= 2) < 1 ? 0.5 * nM(n) : 0.5 * (2 - Math.pow(2, -10 * (n - 1))),
  m6 = {
    linear: bn,
    easeIn: c6,
    easeInOut: X3,
    easeOut: u6,
    circIn: Q3,
    circInOut: h6,
    circOut: tM,
    backIn: nM,
    backInOut: d6,
    backOut: Z3,
    anticipate: p6,
  },
  wT = (n) => {
    if (Array.isArray(n)) {
      eM(n.length === 4);
      const [e, t, i, r] = n;
      return Xh(e, t, i, r);
    } else if (typeof n == "string") return m6[n];
    return n;
  },
  iM = (n, e) => (t) =>
    !!(
      (jh(t) && d8.test(t) && t.startsWith(n)) ||
      (e && Object.prototype.hasOwnProperty.call(t, e))
    ),
  q3 = (n, e, t) => (i) => {
    if (!jh(i)) return i;
    const [r, s, o, a] = i.match(qg);
    return {
      [n]: parseFloat(r),
      [e]: parseFloat(s),
      [t]: parseFloat(o),
      alpha: a !== void 0 ? parseFloat(a) : 1,
    };
  },
  g6 = (n) => cl(0, 255, n),
  By = { ...yl, transform: (n) => Math.round(g6(n)) },
  ja = {
    test: iM("rgb", "red"),
    parse: q3("red", "green", "blue"),
    transform: ({ red: n, green: e, blue: t, alpha: i = 1 }) =>
      "rgba(" +
      By.transform(n) +
      ", " +
      By.transform(e) +
      ", " +
      By.transform(t) +
      ", " +
      Pf(bf.transform(i)) +
      ")",
  };
function v6(n) {
  let e = "",
    t = "",
    i = "",
    r = "";
  return (
    n.length > 5
      ? ((e = n.substring(1, 3)),
        (t = n.substring(3, 5)),
        (i = n.substring(5, 7)),
        (r = n.substring(7, 9)))
      : ((e = n.substring(1, 2)),
        (t = n.substring(2, 3)),
        (i = n.substring(3, 4)),
        (r = n.substring(4, 5)),
        (e += e),
        (t += t),
        (i += i),
        (r += r)),
    {
      red: parseInt(e, 16),
      green: parseInt(t, 16),
      blue: parseInt(i, 16),
      alpha: r ? parseInt(r, 16) / 255 : 1,
    }
  );
}
const I_ = { test: iM("#"), parse: v6, transform: ja.transform },
  Mc = {
    test: iM("hsl", "hue"),
    parse: q3("hue", "saturation", "lightness"),
    transform: ({ hue: n, saturation: e, lightness: t, alpha: i = 1 }) =>
      "hsla(" +
      Math.round(n) +
      ", " +
      us.transform(Pf(e)) +
      ", " +
      us.transform(Pf(t)) +
      ", " +
      Pf(bf.transform(i)) +
      ")",
  },
  pi = {
    test: (n) => ja.test(n) || I_.test(n) || Mc.test(n),
    parse: (n) =>
      ja.test(n) ? ja.parse(n) : Mc.test(n) ? Mc.parse(n) : I_.parse(n),
    transform: (n) =>
      jh(n) ? n : n.hasOwnProperty("red") ? ja.transform(n) : Mc.transform(n),
  },
  on = (n, e, t) => -t * n + t * e + n;
function Ry(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
        ? e
        : t < 2 / 3
          ? n + (e - n) * (2 / 3 - t) * 6
          : n
  );
}
function y6({ hue: n, saturation: e, lightness: t, alpha: i }) {
  ((n /= 360), (e /= 100), (t /= 100));
  let r = 0,
    s = 0,
    o = 0;
  if (!e) r = s = o = t;
  else {
    const a = t < 0.5 ? t * (1 + e) : t + e - t * e,
      l = 2 * t - a;
    ((r = Ry(l, a, n + 1 / 3)), (s = Ry(l, a, n)), (o = Ry(l, a, n - 1 / 3)));
  }
  return {
    red: Math.round(r * 255),
    green: Math.round(s * 255),
    blue: Math.round(o * 255),
    alpha: i,
  };
}
const Ly = (n, e, t) => {
    const i = n * n;
    return Math.sqrt(Math.max(0, t * (e * e - i) + i));
  },
  x6 = [I_, ja, Mc],
  _6 = (n) => x6.find((e) => e.test(n));
function ET(n) {
  const e = _6(n);
  let t = e.parse(n);
  return (e === Mc && (t = y6(t)), t);
}
const $3 = (n, e) => {
  const t = ET(n),
    i = ET(e),
    r = { ...t };
  return (s) => (
    (r.red = Ly(t.red, i.red, s)),
    (r.green = Ly(t.green, i.green, s)),
    (r.blue = Ly(t.blue, i.blue, s)),
    (r.alpha = on(t.alpha, i.alpha, s)),
    ja.transform(r)
  );
};
function A6(n) {
  var e, t;
  return (
    isNaN(n) &&
    jh(n) &&
    (((e = n.match(qg)) === null || e === void 0 ? void 0 : e.length) || 0) +
      (((t = n.match(w3)) === null || t === void 0 ? void 0 : t.length) || 0) >
      0
  );
}
const eL = { regex: f8, countKey: "Vars", token: "${v}", parse: bn },
  tL = { regex: w3, countKey: "Colors", token: "${c}", parse: pi.parse },
  nL = { regex: qg, countKey: "Numbers", token: "${n}", parse: yl.parse };
function Iy(n, { regex: e, countKey: t, token: i, parse: r }) {
  const s = n.tokenised.match(e);
  s &&
    ((n["num" + t] = s.length),
    (n.tokenised = n.tokenised.replace(e, i)),
    n.values.push(...s.map(r)));
}
function sg(n) {
  const e = n.toString(),
    t = {
      value: e,
      tokenised: e,
      values: [],
      numVars: 0,
      numColors: 0,
      numNumbers: 0,
    };
  return (t.value.includes("var(--") && Iy(t, eL), Iy(t, tL), Iy(t, nL), t);
}
function iL(n) {
  return sg(n).values;
}
function rL(n) {
  const { values: e, numColors: t, numVars: i, tokenised: r } = sg(n),
    s = e.length;
  return (o) => {
    let a = r;
    for (let l = 0; l < s; l++)
      l < i
        ? (a = a.replace(eL.token, o[l]))
        : l < i + t
          ? (a = a.replace(tL.token, pi.transform(o[l])))
          : (a = a.replace(nL.token, Pf(o[l])));
    return a;
  };
}
const M6 = (n) => (typeof n == "number" ? 0 : n);
function S6(n) {
  const e = iL(n);
  return rL(n)(e.map(M6));
}
const qo = {
    test: A6,
    parse: iL,
    createTransformer: rL,
    getAnimatableNone: S6,
  },
  sL = (n, e) => (t) => `${t > 0 ? e : n}`;
function oL(n, e) {
  return typeof n == "number"
    ? (t) => on(n, e, t)
    : pi.test(n)
      ? $3(n, e)
      : n.startsWith("var(")
        ? sL(n, e)
        : lL(n, e);
}
const aL = (n, e) => {
    const t = [...n],
      i = t.length,
      r = n.map((s, o) => oL(s, e[o]));
    return (s) => {
      for (let o = 0; o < i; o++) t[o] = r[o](s);
      return t;
    };
  },
  w6 = (n, e) => {
    const t = { ...n, ...e },
      i = {};
    for (const r in t)
      n[r] !== void 0 && e[r] !== void 0 && (i[r] = oL(n[r], e[r]));
    return (r) => {
      for (const s in i) t[s] = i[s](r);
      return t;
    };
  },
  lL = (n, e) => {
    const t = qo.createTransformer(e),
      i = sg(n),
      r = sg(e);
    return i.numVars === r.numVars &&
      i.numColors === r.numColors &&
      i.numNumbers >= r.numNumbers
      ? Vo(aL(i.values, r.values), t)
      : sL(n, e);
  },
  ph = (n, e, t) => {
    const i = e - n;
    return i === 0 ? 1 : (t - n) / i;
  },
  CT = (n, e) => (t) => on(n, e, t);
function E6(n) {
  return typeof n == "number"
    ? CT
    : typeof n == "string"
      ? pi.test(n)
        ? $3
        : lL
      : Array.isArray(n)
        ? aL
        : typeof n == "object"
          ? w6
          : CT;
}
function C6(n, e, t) {
  const i = [],
    r = t || E6(n[0]),
    s = n.length - 1;
  for (let o = 0; o < s; o++) {
    let a = r(n[o], n[o + 1]);
    if (e) {
      const l = Array.isArray(e) ? e[o] || bn : e;
      a = Vo(l, a);
    }
    i.push(a);
  }
  return i;
}
function cL(n, e, { clamp: t = !0, ease: i, mixer: r } = {}) {
  const s = n.length;
  if ((eM(s === e.length), s === 1)) return () => e[0];
  n[0] > n[s - 1] && ((n = [...n].reverse()), (e = [...e].reverse()));
  const o = C6(e, i, r),
    a = o.length,
    l = (u) => {
      let h = 0;
      if (a > 1) for (; h < n.length - 2 && !(u < n[h + 1]); h++);
      const d = ph(n[h], n[h + 1], u);
      return o[h](d);
    };
  return t ? (u) => l(cl(n[0], n[s - 1], u)) : l;
}
function T6(n, e) {
  const t = n[n.length - 1];
  for (let i = 1; i <= e; i++) {
    const r = ph(0, e, i);
    n.push(on(t, 1, r));
  }
}
function b6(n) {
  const e = [0];
  return (T6(e, n.length - 1), e);
}
function P6(n, e) {
  return n.map((t) => t * e);
}
function B6(n, e) {
  return n.map(() => e || X3).splice(0, n.length - 1);
}
function og({
  duration: n = 300,
  keyframes: e,
  times: t,
  ease: i = "easeInOut",
}) {
  const r = f6(i) ? i.map(wT) : wT(i),
    s = { done: !1, value: e[0] },
    o = P6(t && t.length === e.length ? t : b6(e), n),
    a = cL(o, e, { ease: Array.isArray(r) ? r : B6(e, r) });
  return {
    calculatedDuration: n,
    next: (l) => ((s.value = a(l)), (s.done = l >= n), s),
  };
}
function uL(n, e) {
  return e ? n * (1e3 / e) : 0;
}
const R6 = 5;
function fL(n, e, t) {
  const i = Math.max(e - R6, 0);
  return uL(t - n(i), e - i);
}
const Dy = 0.001,
  L6 = 0.01,
  TT = 10,
  I6 = 0.05,
  D6 = 1;
function F6({
  duration: n = 800,
  bounce: e = 0.25,
  velocity: t = 0,
  mass: i = 1,
}) {
  let r, s;
  n6(n <= Wo(TT));
  let o = 1 - e;
  ((o = cl(I6, D6, o)),
    (n = cl(L6, TT, Ws(n))),
    o < 1
      ? ((r = (u) => {
          const h = u * o,
            d = h * n,
            p = h - t,
            g = D_(u, o),
            y = Math.exp(-d);
          return Dy - (p / g) * y;
        }),
        (s = (u) => {
          const d = u * o * n,
            p = d * t + t,
            g = Math.pow(o, 2) * Math.pow(u, 2) * n,
            y = Math.exp(-d),
            A = D_(Math.pow(u, 2), o);
          return ((-r(u) + Dy > 0 ? -1 : 1) * ((p - g) * y)) / A;
        }))
      : ((r = (u) => {
          const h = Math.exp(-u * n),
            d = (u - t) * n + 1;
          return -Dy + h * d;
        }),
        (s = (u) => {
          const h = Math.exp(-u * n),
            d = (t - u) * (n * n);
          return h * d;
        })));
  const a = 5 / n,
    l = k6(r, s, a);
  if (((n = Wo(n)), isNaN(l)))
    return { stiffness: 100, damping: 10, duration: n };
  {
    const u = Math.pow(l, 2) * i;
    return { stiffness: u, damping: o * 2 * Math.sqrt(i * u), duration: n };
  }
}
const N6 = 12;
function k6(n, e, t) {
  let i = t;
  for (let r = 1; r < N6; r++) i = i - n(i) / e(i);
  return i;
}
function D_(n, e) {
  return n * Math.sqrt(1 - e * e);
}
const O6 = ["duration", "bounce"],
  U6 = ["stiffness", "damping", "mass"];
function bT(n, e) {
  return e.some((t) => n[t] !== void 0);
}
function z6(n) {
  let e = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: !1,
    ...n,
  };
  if (!bT(n, U6) && bT(n, O6)) {
    const t = F6(n);
    ((e = { ...e, ...t, velocity: 0, mass: 1 }),
      (e.isResolvedFromDuration = !0));
  }
  return e;
}
function hL({ keyframes: n, restDelta: e, restSpeed: t, ...i }) {
  const r = n[0],
    s = n[n.length - 1],
    o = { done: !1, value: r },
    {
      stiffness: a,
      damping: l,
      mass: u,
      velocity: h,
      duration: d,
      isResolvedFromDuration: p,
    } = z6(i),
    g = h ? -Ws(h) : 0,
    y = l / (2 * Math.sqrt(a * u)),
    A = s - r,
    _ = Ws(Math.sqrt(a / u)),
    m = Math.abs(A) < 5;
  (t || (t = m ? 0.01 : 2), e || (e = m ? 0.005 : 0.5));
  let x;
  if (y < 1) {
    const S = D_(_, y);
    x = (w) => {
      const C = Math.exp(-y * _ * w);
      return (
        s - C * (((g + y * _ * A) / S) * Math.sin(S * w) + A * Math.cos(S * w))
      );
    };
  } else if (y === 1) x = (S) => s - Math.exp(-_ * S) * (A + (g + _ * A) * S);
  else {
    const S = _ * Math.sqrt(y * y - 1);
    x = (w) => {
      const C = Math.exp(-y * _ * w),
        P = Math.min(S * w, 300);
      return (
        s - (C * ((g + y * _ * A) * Math.sinh(P) + S * A * Math.cosh(P))) / S
      );
    };
  }
  return {
    calculatedDuration: (p && d) || null,
    next: (S) => {
      const w = x(S);
      if (p) o.done = S >= d;
      else {
        let C = g;
        S !== 0 && (y < 1 ? (C = fL(x, S, w)) : (C = 0));
        const P = Math.abs(C) <= t,
          R = Math.abs(s - w) <= e;
        o.done = P && R;
      }
      return ((o.value = o.done ? s : w), o);
    },
  };
}
function PT({
  keyframes: n,
  velocity: e = 0,
  power: t = 0.8,
  timeConstant: i = 325,
  bounceDamping: r = 10,
  bounceStiffness: s = 500,
  modifyTarget: o,
  min: a,
  max: l,
  restDelta: u = 0.5,
  restSpeed: h,
}) {
  const d = n[0],
    p = { done: !1, value: d },
    g = (B) => (a !== void 0 && B < a) || (l !== void 0 && B > l),
    y = (B) =>
      a === void 0
        ? l
        : l === void 0 || Math.abs(a - B) < Math.abs(l - B)
          ? a
          : l;
  let A = t * e;
  const _ = d + A,
    m = o === void 0 ? _ : o(_);
  m !== _ && (A = m - d);
  const x = (B) => -A * Math.exp(-B / i),
    S = (B) => m + x(B),
    w = (B) => {
      const b = x(B),
        L = S(B);
      ((p.done = Math.abs(b) <= u), (p.value = p.done ? m : L));
    };
  let C, P;
  const R = (B) => {
    g(p.value) &&
      ((C = B),
      (P = hL({
        keyframes: [p.value, y(p.value)],
        velocity: fL(S, B, p.value),
        damping: r,
        stiffness: s,
        restDelta: u,
        restSpeed: h,
      })));
  };
  return (
    R(0),
    {
      calculatedDuration: null,
      next: (B) => {
        let b = !1;
        return (
          !P && C === void 0 && ((b = !0), w(B), R(B)),
          C !== void 0 && B > C ? P.next(B - C) : (!b && w(B), p)
        );
      },
    }
  );
}
const G6 = (n) => {
    const e = ({ timestamp: t }) => n(t);
    return {
      start: () => an.update(e, !0),
      stop: () => qs(e),
      now: () => (Un.isProcessing ? Un.timestamp : performance.now()),
    };
  },
  BT = 2e4;
function RT(n) {
  let e = 0;
  const t = 50;
  let i = n.next(e);
  for (; !i.done && e < BT; ) ((e += t), (i = n.next(e)));
  return e >= BT ? 1 / 0 : e;
}
const H6 = { decay: PT, inertia: PT, tween: og, keyframes: og, spring: hL };
function ag({
  autoplay: n = !0,
  delay: e = 0,
  driver: t = G6,
  keyframes: i,
  type: r = "keyframes",
  repeat: s = 0,
  repeatDelay: o = 0,
  repeatType: a = "loop",
  onPlay: l,
  onStop: u,
  onComplete: h,
  onUpdate: d,
  ...p
}) {
  let g = 1,
    y = !1,
    A,
    _;
  const m = () => {
    (A && A(),
      (_ = new Promise((q) => {
        A = q;
      })));
  };
  m();
  let x;
  const S = H6[r] || og;
  let w;
  S !== og &&
    typeof i[0] != "number" &&
    ((w = cL([0, 100], i, { clamp: !1 })), (i = [0, 100]));
  const C = S({ ...p, keyframes: i });
  let P;
  a === "mirror" &&
    (P = S({
      ...p,
      keyframes: [...i].reverse(),
      velocity: -(p.velocity || 0),
    }));
  let R = "idle",
    B = null,
    b = null,
    L = null;
  C.calculatedDuration === null && s && (C.calculatedDuration = RT(C));
  const { calculatedDuration: U } = C;
  let J = 1 / 0,
    V = 1 / 0;
  U !== null && ((J = U + o), (V = J * (s + 1) - o));
  let j = 0;
  const X = (q) => {
      if (b === null) return;
      (g > 0 && (b = Math.min(b, q)), B !== null ? (j = B) : (j = (q - b) * g));
      const Q = j - e,
        ee = Q < 0;
      ((j = Math.max(Q, 0)), R === "finished" && B === null && (j = V));
      let ne = j,
        Ee = C;
      if (s) {
        const Xe = j / J;
        let xe = Math.floor(Xe),
          Se = Xe % 1;
        (!Se && Xe >= 1 && (Se = 1),
          Se === 1 && xe--,
          (xe = Math.min(xe, s + 1)));
        const ge = !!(xe % 2);
        ge &&
          (a === "reverse"
            ? ((Se = 1 - Se), o && (Se -= o / J))
            : a === "mirror" && (Ee = P));
        let se = cl(0, 1, Se);
        (j > V && (se = a === "reverse" && ge ? 1 : 0), (ne = se * J));
      }
      const Ae = ee ? { done: !1, value: i[0] } : Ee.next(ne);
      w && (Ae.value = w(Ae.value));
      let { done: $ } = Ae;
      !ee && U !== null && ($ = j >= V);
      const Je =
        B === null &&
        (R === "finished" || (R === "running" && $) || (g < 0 && j <= 0));
      return (d && d(Ae.value), Je && I(), Ae);
    },
    oe = () => {
      (x && x.stop(), (x = void 0));
    },
    ae = () => {
      ((R = "idle"), oe(), m(), (b = L = null));
    },
    I = () => {
      ((R = "finished"), h && h(), oe(), m());
    },
    G = () => {
      if (y) return;
      x || (x = t(X));
      const q = x.now();
      (l && l(),
        B !== null ? (b = q - B) : (!b || R === "finished") && (b = q),
        (L = b),
        (B = null),
        (R = "running"),
        x.start());
    };
  n && G();
  const z = {
    then(q, Q) {
      return _.then(q, Q);
    },
    get time() {
      return Ws(j);
    },
    set time(q) {
      ((q = Wo(q)),
        (j = q),
        B !== null || !x || g === 0 ? (B = q) : (b = x.now() - q / g));
    },
    get duration() {
      const q = C.calculatedDuration === null ? RT(C) : C.calculatedDuration;
      return Ws(q);
    },
    get speed() {
      return g;
    },
    set speed(q) {
      q === g || !x || ((g = q), (z.time = Ws(j)));
    },
    get state() {
      return R;
    },
    play: G,
    pause: () => {
      ((R = "paused"), (B = j));
    },
    stop: () => {
      ((y = !0), R !== "idle" && ((R = "idle"), u && u(), ae()));
    },
    cancel: () => {
      (L !== null && X(L), ae());
    },
    complete: () => {
      R = "finished";
    },
    sample: (q) => ((b = 0), X(q)),
  };
  return z;
}
const V6 = new Set([
    "opacity",
    "clipPath",
    "filter",
    "transform",
    "backgroundColor",
  ]),
  $p = 10,
  W6 = 2e4,
  j6 = (n, e) => e.type === "spring" || n === "backgroundColor" || !H3(e.ease);
function J6(n, e, { onUpdate: t, onComplete: i, ...r }) {
  if (
    !(
      j3.waapi() &&
      V6.has(e) &&
      !r.repeatDelay &&
      r.repeatType !== "mirror" &&
      r.damping !== 0 &&
      r.type !== "inertia"
    )
  )
    return !1;
  let o = !1,
    a,
    l;
  const u = () => {
    l = new Promise((m) => {
      a = m;
    });
  };
  u();
  let { keyframes: h, duration: d = 300, ease: p, times: g } = r;
  if (j6(e, r)) {
    const m = ag({ ...r, repeat: 0, delay: 0 });
    let x = { done: !1, value: h[0] };
    const S = [];
    let w = 0;
    for (; !x.done && w < W6; ) ((x = m.sample(w)), S.push(x.value), (w += $p));
    ((g = void 0), (h = S), (d = w - $p), (p = "linear"));
  }
  const y = r6(n.owner.current, e, h, { ...r, duration: d, ease: p, times: g }),
    A = () => y.cancel(),
    _ = () => {
      (an.update(A), a(), u());
    };
  return (
    (y.onfinish = () => {
      (n.set(s6(h, r)), i && i(), _());
    }),
    {
      then(m, x) {
        return l.then(m, x);
      },
      get time() {
        return Ws(y.currentTime || 0);
      },
      set time(m) {
        y.currentTime = Wo(m);
      },
      get speed() {
        return y.playbackRate;
      },
      set speed(m) {
        y.playbackRate = m;
      },
      get duration() {
        return Ws(d);
      },
      play: () => {
        o || (y.play(), qs(A));
      },
      pause: () => y.pause(),
      stop: () => {
        if (((o = !0), y.playState === "idle")) return;
        const { currentTime: m } = y;
        if (m) {
          const x = ag({ ...r, autoplay: !1 });
          n.setWithVelocity(x.sample(m - $p).value, x.sample(m).value, $p);
        }
        _();
      },
      complete: () => y.finish(),
      cancel: _,
    }
  );
}
function X6({ keyframes: n, delay: e, onUpdate: t, onComplete: i }) {
  const r = () => (
    t && t(n[n.length - 1]),
    i && i(),
    {
      time: 0,
      speed: 1,
      duration: 0,
      play: bn,
      pause: bn,
      stop: bn,
      then: (s) => (s(), Promise.resolve()),
      cancel: bn,
      complete: bn,
    }
  );
  return e
    ? ag({ keyframes: [0, 1], duration: 0, delay: e, onComplete: r })
    : r();
}
const K6 = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 },
  Y6 = (n) => ({
    type: "spring",
    stiffness: 550,
    damping: n === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10,
  }),
  Q6 = { type: "keyframes", duration: 0.8 },
  Z6 = { type: "keyframes", ease: [0.25, 0.1, 0.35, 1], duration: 0.3 },
  q6 = (n, { keyframes: e }) =>
    e.length > 2
      ? Q6
      : vl.has(n)
        ? n.startsWith("scale")
          ? Y6(e[1])
          : K6
        : Z6,
  F_ = (n, e) =>
    n === "zIndex"
      ? !1
      : !!(
          typeof e == "number" ||
          Array.isArray(e) ||
          (typeof e == "string" && qo.test(e) && !e.startsWith("url("))
        ),
  $6 = new Set(["brightness", "contrast", "saturate", "opacity"]);
function eW(n) {
  const [e, t] = n.slice(0, -1).split("(");
  if (e === "drop-shadow") return n;
  const [i] = t.match(qg) || [];
  if (!i) return n;
  const r = t.replace(i, "");
  let s = $6.has(e) ? 1 : 0;
  return (i !== t && (s *= 100), e + "(" + s + r + ")");
}
const tW = /([a-z-]*)\(.*?\)/g,
  N_ = {
    ...qo,
    getAnimatableNone: (n) => {
      const e = n.match(tW);
      return e ? e.map(eW).join(" ") : n;
    },
  },
  nW = {
    ...E3,
    color: pi,
    backgroundColor: pi,
    outlineColor: pi,
    fill: pi,
    stroke: pi,
    borderColor: pi,
    borderTopColor: pi,
    borderRightColor: pi,
    borderBottomColor: pi,
    borderLeftColor: pi,
    filter: N_,
    WebkitFilter: N_,
  },
  rM = (n) => nW[n];
function sM(n, e) {
  let t = rM(n);
  return (
    t !== N_ && (t = qo),
    t.getAnimatableNone ? t.getAnimatableNone(e) : void 0
  );
}
function iW({
  when: n,
  delay: e,
  delayChildren: t,
  staggerChildren: i,
  staggerDirection: r,
  repeat: s,
  repeatType: o,
  repeatDelay: a,
  from: l,
  elapsed: u,
  ...h
}) {
  return !!Object.keys(h).length;
}
function LT(n) {
  return (
    n === 0 ||
    (typeof n == "string" && parseFloat(n) === 0 && n.indexOf(" ") === -1)
  );
}
function IT(n) {
  return typeof n == "number" ? 0 : sM("", n);
}
function dL(n, e) {
  return n[e] || n.default || n;
}
function rW(n, [...e]) {
  for (let t = 0; t < e.length; t++)
    e[t] === null && (e[t] = t === 0 ? n : e[t - 1]);
  return e;
}
function sW(n, e, t, i) {
  const r = F_(e, t);
  let s = i.from !== void 0 ? i.from : n.get();
  return (
    s === "none" && r && typeof t == "string"
      ? (s = sM(e, t))
      : LT(s) && typeof t == "string"
        ? (s = IT(t))
        : !Array.isArray(t) && LT(t) && typeof s == "string" && (t = IT(s)),
    Array.isArray(t) ? rW(s, t) : [s, t]
  );
}
const oM =
  (n, e, t, i = {}) =>
  (r) => {
    const s = dL(i, n) || {},
      o = s.delay || i.delay || 0;
    let { elapsed: a = 0 } = i;
    a = a - Wo(o);
    const l = sW(e, n, t, s),
      u = l[0],
      h = l[l.length - 1],
      d = F_(n, u),
      p = F_(n, h);
    let g = {
      keyframes: l,
      velocity: e.getVelocity(),
      ease: "easeOut",
      ...s,
      delay: -a,
      onUpdate: (y) => {
        (e.set(y), s.onUpdate && s.onUpdate(y));
      },
      onComplete: () => {
        (r(), s.onComplete && s.onComplete());
      },
    };
    if (
      (iW(s) || (g = { ...g, ...q6(n, g) }),
      g.duration && (g.duration = Wo(g.duration)),
      g.repeatDelay && (g.repeatDelay = Wo(g.repeatDelay)),
      !d || !p || i6.current || s.type === !1)
    )
      return X6(g);
    if (
      e.owner &&
      e.owner.current instanceof HTMLElement &&
      !e.owner.getProps().onUpdate
    ) {
      const y = J6(e, n, g);
      if (y) return y;
    }
    return ag(g);
  };
function lg(n) {
  return !!(Di(n) && n.add);
}
const oW = (n) => /^\-?\d*\.?\d+$/.test(n),
  aW = (n) => /^0[^.\s]+$/.test(n);
function aM(n, e) {
  n.indexOf(e) === -1 && n.push(e);
}
function lM(n, e) {
  const t = n.indexOf(e);
  t > -1 && n.splice(t, 1);
}
class cM {
  constructor() {
    this.subscriptions = [];
  }
  add(e) {
    return (aM(this.subscriptions, e), () => lM(this.subscriptions, e));
  }
  notify(e, t, i) {
    const r = this.subscriptions.length;
    if (r)
      if (r === 1) this.subscriptions[0](e, t, i);
      else
        for (let s = 0; s < r; s++) {
          const o = this.subscriptions[s];
          o && o(e, t, i);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const lW = (n) => !isNaN(parseFloat(n));
class cW {
  constructor(e, t = {}) {
    ((this.version = "10.12.4"),
      (this.timeDelta = 0),
      (this.lastUpdated = 0),
      (this.canTrackVelocity = !1),
      (this.events = {}),
      (this.updateAndNotify = (i, r = !0) => {
        ((this.prev = this.current), (this.current = i));
        const { delta: s, timestamp: o } = Un;
        (this.lastUpdated !== o &&
          ((this.timeDelta = s),
          (this.lastUpdated = o),
          an.postRender(this.scheduleVelocityCheck)),
          this.prev !== this.current &&
            this.events.change &&
            this.events.change.notify(this.current),
          this.events.velocityChange &&
            this.events.velocityChange.notify(this.getVelocity()),
          r &&
            this.events.renderRequest &&
            this.events.renderRequest.notify(this.current));
      }),
      (this.scheduleVelocityCheck = () => an.postRender(this.velocityCheck)),
      (this.velocityCheck = ({ timestamp: i }) => {
        i !== this.lastUpdated &&
          ((this.prev = this.current),
          this.events.velocityChange &&
            this.events.velocityChange.notify(this.getVelocity()));
      }),
      (this.hasAnimated = !1),
      (this.prev = this.current = e),
      (this.canTrackVelocity = lW(this.current)),
      (this.owner = t.owner));
  }
  onChange(e) {
    return this.on("change", e);
  }
  on(e, t) {
    this.events[e] || (this.events[e] = new cM());
    const i = this.events[e].add(t);
    return e === "change"
      ? () => {
          (i(),
            an.read(() => {
              this.events.change.getSize() || this.stop();
            }));
        }
      : i;
  }
  clearListeners() {
    for (const e in this.events) this.events[e].clear();
  }
  attach(e, t) {
    ((this.passiveEffect = e), (this.stopPassiveEffect = t));
  }
  set(e, t = !0) {
    !t || !this.passiveEffect
      ? this.updateAndNotify(e, t)
      : this.passiveEffect(e, this.updateAndNotify);
  }
  setWithVelocity(e, t, i) {
    (this.set(t), (this.prev = e), (this.timeDelta = i));
  }
  jump(e) {
    (this.updateAndNotify(e),
      (this.prev = e),
      this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect());
  }
  get() {
    return this.current;
  }
  getPrevious() {
    return this.prev;
  }
  getVelocity() {
    return this.canTrackVelocity
      ? uL(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta)
      : 0;
  }
  start(e) {
    return (
      this.stop(),
      new Promise((t) => {
        ((this.hasAnimated = !0),
          (this.animation = e(t)),
          this.events.animationStart && this.events.animationStart.notify());
      }).then(() => {
        (this.events.animationComplete &&
          this.events.animationComplete.notify(),
          this.clearAnimation());
      })
    );
  }
  stop() {
    (this.animation &&
      (this.animation.stop(),
      this.events.animationCancel && this.events.animationCancel.notify()),
      this.clearAnimation());
  }
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  destroy() {
    (this.clearListeners(),
      this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect());
  }
}
function $c(n, e) {
  return new cW(n, e);
}
const pL = (n) => (e) => e.test(n),
  uW = { test: (n) => n === "auto", parse: (n) => n },
  mL = [yl, it, us, Mo, m8, p8, uW],
  sf = (n) => mL.find(pL(n)),
  fW = [...mL, pi, qo],
  hW = (n) => fW.find(pL(n));
function dW(n, e, t) {
  n.hasValue(e) ? n.getValue(e).set(t) : n.addValue(e, $c(t));
}
function pW(n, e) {
  const t = t0(n, e);
  let {
    transitionEnd: i = {},
    transition: r = {},
    ...s
  } = t ? n.makeTargetAnimatable(t, !1) : {};
  s = { ...s, ...i };
  for (const o in s) {
    const a = P8(s[o]);
    dW(n, o, a);
  }
}
function mW(n, e, t) {
  var i, r;
  const s = Object.keys(e).filter((a) => !n.hasValue(a)),
    o = s.length;
  if (o)
    for (let a = 0; a < o; a++) {
      const l = s[a],
        u = e[l];
      let h = null;
      (Array.isArray(u) && (h = u[0]),
        h === null &&
          (h =
            (r = (i = t[l]) !== null && i !== void 0 ? i : n.readValue(l)) !==
              null && r !== void 0
              ? r
              : e[l]),
        h != null &&
          (typeof h == "string" && (oW(h) || aW(h))
            ? (h = parseFloat(h))
            : !hW(h) && qo.test(u) && (h = sM(l, u)),
          n.addValue(l, $c(h, { owner: n })),
          t[l] === void 0 && (t[l] = h),
          h !== null && n.setBaseTarget(l, h)));
    }
}
function gW(n, e) {
  return e ? (e[n] || e.default || e).from : void 0;
}
function vW(n, e, t) {
  const i = {};
  for (const r in n) {
    const s = gW(r, e);
    if (s !== void 0) i[r] = s;
    else {
      const o = t.getValue(r);
      o && (i[r] = o.get());
    }
  }
  return i;
}
function yW({ protectedKeys: n, needsAnimating: e }, t) {
  const i = n.hasOwnProperty(t) && e[t] !== !0;
  return ((e[t] = !1), i);
}
function gL(n, e, { delay: t = 0, transitionOverride: i, type: r } = {}) {
  let {
    transition: s = n.getDefaultTransition(),
    transitionEnd: o,
    ...a
  } = n.makeTargetAnimatable(e);
  const l = n.getValue("willChange");
  i && (s = i);
  const u = [],
    h = r && n.animationState && n.animationState.getState()[r];
  for (const d in a) {
    const p = n.getValue(d),
      g = a[d];
    if (!p || g === void 0 || (h && yW(h, d))) continue;
    const y = { delay: t, elapsed: 0, ...s };
    if (window.HandoffAppearAnimations && !p.hasAnimated) {
      const _ = n.getProps()[t6];
      _ && (y.elapsed = window.HandoffAppearAnimations(_, d, p, an));
    }
    p.start(oM(d, p, g, n.shouldReduceMotion && vl.has(d) ? { type: !1 } : y));
    const A = p.animation;
    (lg(l) && (l.add(d), A.then(() => l.remove(d))), u.push(A));
  }
  return (
    o &&
      Promise.all(u).then(() => {
        o && pW(n, o);
      }),
    u
  );
}
function k_(n, e, t = {}) {
  const i = t0(n, e, t.custom);
  let { transition: r = n.getDefaultTransition() || {} } = i || {};
  t.transitionOverride && (r = t.transitionOverride);
  const s = i ? () => Promise.all(gL(n, i, t)) : () => Promise.resolve(),
    o =
      n.variantChildren && n.variantChildren.size
        ? (l = 0) => {
            const {
              delayChildren: u = 0,
              staggerChildren: h,
              staggerDirection: d,
            } = r;
            return xW(n, e, u + l, h, d, t);
          }
        : () => Promise.resolve(),
    { when: a } = r;
  if (a) {
    const [l, u] = a === "beforeChildren" ? [s, o] : [o, s];
    return l().then(() => u());
  } else return Promise.all([s(), o(t.delay)]);
}
function xW(n, e, t = 0, i = 0, r = 1, s) {
  const o = [],
    a = (n.variantChildren.size - 1) * i,
    l = r === 1 ? (u = 0) => u * i : (u = 0) => a - u * i;
  return (
    Array.from(n.variantChildren)
      .sort(_W)
      .forEach((u, h) => {
        (u.notify("AnimationStart", e),
          o.push(
            k_(u, e, { ...s, delay: t + l(h) }).then(() =>
              u.notify("AnimationComplete", e)
            )
          ));
      }),
    Promise.all(o)
  );
}
function _W(n, e) {
  return n.sortNodePosition(e);
}
function AW(n, e, t = {}) {
  n.notify("AnimationStart", e);
  let i;
  if (Array.isArray(e)) {
    const r = e.map((s) => k_(n, s, t));
    i = Promise.all(r);
  } else if (typeof e == "string") i = k_(n, e, t);
  else {
    const r = typeof e == "function" ? t0(n, e, t.custom) : e;
    i = Promise.all(gL(n, r, t));
  }
  return i.then(() => n.notify("AnimationComplete", e));
}
const MW = [...WA].reverse(),
  SW = WA.length;
function wW(n) {
  return (e) =>
    Promise.all(e.map(({ animation: t, options: i }) => AW(n, t, i)));
}
function EW(n) {
  let e = wW(n);
  const t = TW();
  let i = !0;
  const r = (l, u) => {
    const h = t0(n, u);
    if (h) {
      const { transition: d, transitionEnd: p, ...g } = h;
      l = { ...l, ...g, ...p };
    }
    return l;
  };
  function s(l) {
    e = l(n);
  }
  function o(l, u) {
    const h = n.getProps(),
      d = n.getVariantContext(!0) || {},
      p = [],
      g = new Set();
    let y = {},
      A = 1 / 0;
    for (let m = 0; m < SW; m++) {
      const x = MW[m],
        S = t[x],
        w = h[x] !== void 0 ? h[x] : d[x],
        C = fh(w),
        P = x === u ? S.isActive : null;
      P === !1 && (A = m);
      let R = w === d[x] && w !== h[x] && C;
      if (
        (R && i && n.manuallyAnimateOnMount && (R = !1),
        (S.protectedKeys = { ...y }),
        (!S.isActive && P === null) ||
          (!w && !S.prevProp) ||
          Qg(w) ||
          typeof w == "boolean")
      )
        continue;
      const B = CW(S.prevProp, w);
      let b = B || (x === u && S.isActive && !R && C) || (m > A && C);
      const L = Array.isArray(w) ? w : [w];
      let U = L.reduce(r, {});
      P === !1 && (U = {});
      const { prevResolvedValues: J = {} } = S,
        V = { ...J, ...U },
        j = (X) => {
          ((b = !0), g.delete(X), (S.needsAnimating[X] = !0));
        };
      for (const X in V) {
        const oe = U[X],
          ae = J[X];
        y.hasOwnProperty(X) ||
          (oe !== ae
            ? rg(oe) && rg(ae)
              ? !z3(oe, ae) || B
                ? j(X)
                : (S.protectedKeys[X] = !0)
              : oe !== void 0
                ? j(X)
                : g.add(X)
            : oe !== void 0 && g.has(X)
              ? j(X)
              : (S.protectedKeys[X] = !0));
      }
      ((S.prevProp = w),
        (S.prevResolvedValues = U),
        S.isActive && (y = { ...y, ...U }),
        i && n.blockInitialAnimation && (b = !1),
        b &&
          !R &&
          p.push(
            ...L.map((X) => ({ animation: X, options: { type: x, ...l } }))
          ));
    }
    if (g.size) {
      const m = {};
      (g.forEach((x) => {
        const S = n.getBaseTarget(x);
        S !== void 0 && (m[x] = S);
      }),
        p.push({ animation: m }));
    }
    let _ = !!p.length;
    return (
      i && h.initial === !1 && !n.manuallyAnimateOnMount && (_ = !1),
      (i = !1),
      _ ? e(p) : Promise.resolve()
    );
  }
  function a(l, u, h) {
    var d;
    if (t[l].isActive === u) return Promise.resolve();
    ((d = n.variantChildren) === null ||
      d === void 0 ||
      d.forEach((g) => {
        var y;
        return (y = g.animationState) === null || y === void 0
          ? void 0
          : y.setActive(l, u);
      }),
      (t[l].isActive = u));
    const p = o(h, l);
    for (const g in t) t[g].protectedKeys = {};
    return p;
  }
  return {
    animateChanges: o,
    setActive: a,
    setAnimateFunction: s,
    getState: () => t,
  };
}
function CW(n, e) {
  return typeof e == "string" ? e !== n : Array.isArray(e) ? !z3(e, n) : !1;
}
function Ea(n = !1) {
  return {
    isActive: n,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {},
  };
}
function TW() {
  return {
    animate: Ea(!0),
    whileInView: Ea(),
    whileHover: Ea(),
    whileTap: Ea(),
    whileDrag: Ea(),
    whileFocus: Ea(),
    exit: Ea(),
  };
}
class bW extends sa {
  constructor(e) {
    (super(e), e.animationState || (e.animationState = EW(e)));
  }
  updateAnimationControlsSubscription() {
    const { animate: e } = this.node.getProps();
    (this.unmount(), Qg(e) && (this.unmount = e.subscribe(this.node)));
  }
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: e } = this.node.getProps(),
      { animate: t } = this.node.prevProps || {};
    e !== t && this.updateAnimationControlsSubscription();
  }
  unmount() {}
}
let PW = 0;
class BW extends sa {
  constructor() {
    (super(...arguments), (this.id = PW++));
  }
  update() {
    if (!this.node.presenceContext) return;
    const {
        isPresent: e,
        onExitComplete: t,
        custom: i,
      } = this.node.presenceContext,
      { isPresent: r } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || e === r) return;
    const s = this.node.animationState.setActive("exit", !e, {
      custom: i ?? this.node.getProps().custom,
    });
    t && !e && s.then(() => t(this.id));
  }
  mount() {
    const { register: e } = this.node.presenceContext || {};
    e && (this.unmount = e(this.id));
  }
  unmount() {}
}
const RW = { animation: { Feature: bW }, exit: { Feature: BW } },
  DT = (n, e) => Math.abs(n - e);
function LW(n, e) {
  const t = DT(n.x, e.x),
    i = DT(n.y, e.y);
  return Math.sqrt(t ** 2 + i ** 2);
}
class vL {
  constructor(e, t, { transformPagePoint: i } = {}) {
    if (
      ((this.startEvent = null),
      (this.lastMoveEvent = null),
      (this.lastMoveEventInfo = null),
      (this.handlers = {}),
      (this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
        const u = Ny(this.lastMoveEventInfo, this.history),
          h = this.startEvent !== null,
          d = LW(u.offset, { x: 0, y: 0 }) >= 3;
        if (!h && !d) return;
        const { point: p } = u,
          { timestamp: g } = Un;
        this.history.push({ ...p, timestamp: g });
        const { onStart: y, onMove: A } = this.handlers;
        (h ||
          (y && y(this.lastMoveEvent, u),
          (this.startEvent = this.lastMoveEvent)),
          A && A(this.lastMoveEvent, u));
      }),
      (this.handlePointerMove = (u, h) => {
        ((this.lastMoveEvent = u),
          (this.lastMoveEventInfo = Fy(h, this.transformPagePoint)),
          an.update(this.updatePoint, !0));
      }),
      (this.handlePointerUp = (u, h) => {
        if ((this.end(), !(this.lastMoveEvent && this.lastMoveEventInfo)))
          return;
        const { onEnd: d, onSessionEnd: p } = this.handlers,
          g = Ny(
            u.type === "pointercancel"
              ? this.lastMoveEventInfo
              : Fy(h, this.transformPagePoint),
            this.history
          );
        (this.startEvent && d && d(u, g), p && p(u, g));
      }),
      !D3(e))
    )
      return;
    ((this.handlers = t), (this.transformPagePoint = i));
    const r = $g(e),
      s = Fy(r, this.transformPagePoint),
      { point: o } = s,
      { timestamp: a } = Un;
    this.history = [{ ...o, timestamp: a }];
    const { onSessionStart: l } = t;
    (l && l(e, Ny(s, this.history)),
      (this.removeListeners = Vo(
        Vs(window, "pointermove", this.handlePointerMove),
        Vs(window, "pointerup", this.handlePointerUp),
        Vs(window, "pointercancel", this.handlePointerUp)
      )));
  }
  updateHandlers(e) {
    this.handlers = e;
  }
  end() {
    (this.removeListeners && this.removeListeners(), qs(this.updatePoint));
  }
}
function Fy(n, e) {
  return e ? { point: e(n.point) } : n;
}
function FT(n, e) {
  return { x: n.x - e.x, y: n.y - e.y };
}
function Ny({ point: n }, e) {
  return {
    point: n,
    delta: FT(n, yL(e)),
    offset: FT(n, IW(e)),
    velocity: DW(e, 0.1),
  };
}
function IW(n) {
  return n[0];
}
function yL(n) {
  return n[n.length - 1];
}
function DW(n, e) {
  if (n.length < 2) return { x: 0, y: 0 };
  let t = n.length - 1,
    i = null;
  const r = yL(n);
  for (; t >= 0 && ((i = n[t]), !(r.timestamp - i.timestamp > Wo(e))); ) t--;
  if (!i) return { x: 0, y: 0 };
  const s = Ws(r.timestamp - i.timestamp);
  if (s === 0) return { x: 0, y: 0 };
  const o = { x: (r.x - i.x) / s, y: (r.y - i.y) / s };
  return (o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o);
}
function Zi(n) {
  return n.max - n.min;
}
function O_(n, e = 0, t = 0.01) {
  return Math.abs(n - e) <= t;
}
function NT(n, e, t, i = 0.5) {
  ((n.origin = i),
    (n.originPoint = on(e.min, e.max, n.origin)),
    (n.scale = Zi(t) / Zi(e)),
    (O_(n.scale, 1, 1e-4) || isNaN(n.scale)) && (n.scale = 1),
    (n.translate = on(t.min, t.max, n.origin) - n.originPoint),
    (O_(n.translate) || isNaN(n.translate)) && (n.translate = 0));
}
function Bf(n, e, t, i) {
  (NT(n.x, e.x, t.x, i ? i.originX : void 0),
    NT(n.y, e.y, t.y, i ? i.originY : void 0));
}
function kT(n, e, t) {
  ((n.min = t.min + e.min), (n.max = n.min + Zi(e)));
}
function FW(n, e, t) {
  (kT(n.x, e.x, t.x), kT(n.y, e.y, t.y));
}
function OT(n, e, t) {
  ((n.min = e.min - t.min), (n.max = n.min + Zi(e)));
}
function Rf(n, e, t) {
  (OT(n.x, e.x, t.x), OT(n.y, e.y, t.y));
}
function NW(n, { min: e, max: t }, i) {
  return (
    e !== void 0 && n < e
      ? (n = i ? on(e, n, i.min) : Math.max(n, e))
      : t !== void 0 && n > t && (n = i ? on(t, n, i.max) : Math.min(n, t)),
    n
  );
}
function UT(n, e, t) {
  return {
    min: e !== void 0 ? n.min + e : void 0,
    max: t !== void 0 ? n.max + t - (n.max - n.min) : void 0,
  };
}
function kW(n, { top: e, left: t, bottom: i, right: r }) {
  return { x: UT(n.x, t, r), y: UT(n.y, e, i) };
}
function zT(n, e) {
  let t = e.min - n.min,
    i = e.max - n.max;
  return (
    e.max - e.min < n.max - n.min && ([t, i] = [i, t]),
    { min: t, max: i }
  );
}
function OW(n, e) {
  return { x: zT(n.x, e.x), y: zT(n.y, e.y) };
}
function UW(n, e) {
  let t = 0.5;
  const i = Zi(n),
    r = Zi(e);
  return (
    r > i
      ? (t = ph(e.min, e.max - i, n.min))
      : i > r && (t = ph(n.min, n.max - r, e.min)),
    cl(0, 1, t)
  );
}
function zW(n, e) {
  const t = {};
  return (
    e.min !== void 0 && (t.min = e.min - n.min),
    e.max !== void 0 && (t.max = e.max - n.min),
    t
  );
}
const U_ = 0.35;
function GW(n = U_) {
  return (
    n === !1 ? (n = 0) : n === !0 && (n = U_),
    { x: GT(n, "left", "right"), y: GT(n, "top", "bottom") }
  );
}
function GT(n, e, t) {
  return { min: HT(n, e), max: HT(n, t) };
}
function HT(n, e) {
  return typeof n == "number" ? n : n[e] || 0;
}
const VT = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }),
  Lf = () => ({ x: VT(), y: VT() }),
  WT = () => ({ min: 0, max: 0 }),
  Sn = () => ({ x: WT(), y: WT() });
function rs(n) {
  return [n("x"), n("y")];
}
function xL({ top: n, left: e, right: t, bottom: i }) {
  return { x: { min: e, max: t }, y: { min: n, max: i } };
}
function HW({ x: n, y: e }) {
  return { top: e.min, right: n.max, bottom: e.max, left: n.min };
}
function VW(n, e) {
  if (!e) return n;
  const t = e({ x: n.left, y: n.top }),
    i = e({ x: n.right, y: n.bottom });
  return { top: t.y, left: t.x, bottom: i.y, right: i.x };
}
function ky(n) {
  return n === void 0 || n === 1;
}
function z_({ scale: n, scaleX: e, scaleY: t }) {
  return !ky(n) || !ky(e) || !ky(t);
}
function La(n) {
  return z_(n) || _L(n) || n.z || n.rotate || n.rotateX || n.rotateY;
}
function _L(n) {
  return jT(n.x) || jT(n.y);
}
function jT(n) {
  return n && n !== "0%";
}
function cg(n, e, t) {
  const i = n - t,
    r = e * i;
  return t + r;
}
function JT(n, e, t, i, r) {
  return (r !== void 0 && (n = cg(n, r, i)), cg(n, t, i) + e);
}
function G_(n, e = 0, t = 1, i, r) {
  ((n.min = JT(n.min, e, t, i, r)), (n.max = JT(n.max, e, t, i, r)));
}
function AL(n, { x: e, y: t }) {
  (G_(n.x, e.translate, e.scale, e.originPoint),
    G_(n.y, t.translate, t.scale, t.originPoint));
}
function WW(n, e, t, i = !1) {
  const r = t.length;
  if (!r) return;
  e.x = e.y = 1;
  let s, o;
  for (let a = 0; a < r; a++) {
    ((s = t[a]), (o = s.projectionDelta));
    const l = s.instance;
    (l && l.style && l.style.display === "contents") ||
      (i &&
        s.options.layoutScroll &&
        s.scroll &&
        s !== s.root &&
        Sc(n, { x: -s.scroll.offset.x, y: -s.scroll.offset.y }),
      o && ((e.x *= o.x.scale), (e.y *= o.y.scale), AL(n, o)),
      i && La(s.latestValues) && Sc(n, s.latestValues));
  }
  ((e.x = XT(e.x)), (e.y = XT(e.y)));
}
function XT(n) {
  return Number.isInteger(n) || n > 1.0000000000001 || n < 0.999999999999
    ? n
    : 1;
}
function Co(n, e) {
  ((n.min = n.min + e), (n.max = n.max + e));
}
function KT(n, e, [t, i, r]) {
  const s = e[r] !== void 0 ? e[r] : 0.5,
    o = on(n.min, n.max, s);
  G_(n, e[t], e[i], o, e.scale);
}
const jW = ["x", "scaleX", "originX"],
  JW = ["y", "scaleY", "originY"];
function Sc(n, e) {
  (KT(n.x, e, jW), KT(n.y, e, JW));
}
function ML(n, e) {
  return xL(VW(n.getBoundingClientRect(), e));
}
function XW(n, e, t) {
  const i = ML(n, t),
    { scroll: r } = e;
  return (r && (Co(i.x, r.offset.x), Co(i.y, r.offset.y)), i);
}
const KW = new WeakMap();
class YW {
  constructor(e) {
    ((this.openGlobalLock = null),
      (this.isDragging = !1),
      (this.currentDirection = null),
      (this.originPoint = { x: 0, y: 0 }),
      (this.constraints = !1),
      (this.hasMutatedConstraints = !1),
      (this.elastic = Sn()),
      (this.visualElement = e));
  }
  start(e, { snapToCursor: t = !1 } = {}) {
    const { presenceContext: i } = this.visualElement;
    if (i && i.isPresent === !1) return;
    const r = (l) => {
        (this.stopAnimation(), t && this.snapToCursor($g(l, "page").point));
      },
      s = (l, u) => {
        const { drag: h, dragPropagation: d, onDragStart: p } = this.getProps();
        if (
          h &&
          !d &&
          (this.openGlobalLock && this.openGlobalLock(),
          (this.openGlobalLock = N3(h)),
          !this.openGlobalLock)
        )
          return;
        ((this.isDragging = !0),
          (this.currentDirection = null),
          this.resolveConstraints(),
          this.visualElement.projection &&
            ((this.visualElement.projection.isAnimationBlocked = !0),
            (this.visualElement.projection.target = void 0)),
          rs((y) => {
            let A = this.getAxisMotionValue(y).get() || 0;
            if (us.test(A)) {
              const { projection: _ } = this.visualElement;
              if (_ && _.layout) {
                const m = _.layout.layoutBox[y];
                m && (A = Zi(m) * (parseFloat(A) / 100));
              }
            }
            this.originPoint[y] = A;
          }),
          p && an.update(() => p(l, u), !1, !0));
        const { animationState: g } = this.visualElement;
        g && g.setActive("whileDrag", !0);
      },
      o = (l, u) => {
        const {
          dragPropagation: h,
          dragDirectionLock: d,
          onDirectionLock: p,
          onDrag: g,
        } = this.getProps();
        if (!h && !this.openGlobalLock) return;
        const { offset: y } = u;
        if (d && this.currentDirection === null) {
          ((this.currentDirection = QW(y)),
            this.currentDirection !== null && p && p(this.currentDirection));
          return;
        }
        (this.updateAxis("x", u.point, y),
          this.updateAxis("y", u.point, y),
          this.visualElement.render(),
          g && g(l, u));
      },
      a = (l, u) => this.stop(l, u);
    this.panSession = new vL(
      e,
      { onSessionStart: r, onStart: s, onMove: o, onSessionEnd: a },
      { transformPagePoint: this.visualElement.getTransformPagePoint() }
    );
  }
  stop(e, t) {
    const i = this.isDragging;
    if ((this.cancel(), !i)) return;
    const { velocity: r } = t;
    this.startAnimation(r);
    const { onDragEnd: s } = this.getProps();
    s && an.update(() => s(e, t));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: e, animationState: t } = this.visualElement;
    (e && (e.isAnimationBlocked = !1),
      this.panSession && this.panSession.end(),
      (this.panSession = void 0));
    const { dragPropagation: i } = this.getProps();
    (!i &&
      this.openGlobalLock &&
      (this.openGlobalLock(), (this.openGlobalLock = null)),
      t && t.setActive("whileDrag", !1));
  }
  updateAxis(e, t, i) {
    const { drag: r } = this.getProps();
    if (!i || !em(e, r, this.currentDirection)) return;
    const s = this.getAxisMotionValue(e);
    let o = this.originPoint[e] + i[e];
    (this.constraints &&
      this.constraints[e] &&
      (o = NW(o, this.constraints[e], this.elastic[e])),
      s.set(o));
  }
  resolveConstraints() {
    const { dragConstraints: e, dragElastic: t } = this.getProps(),
      { layout: i } = this.visualElement.projection || {},
      r = this.constraints;
    (e && Ac(e)
      ? this.constraints || (this.constraints = this.resolveRefConstraints())
      : e && i
        ? (this.constraints = kW(i.layoutBox, e))
        : (this.constraints = !1),
      (this.elastic = GW(t)),
      r !== this.constraints &&
        i &&
        this.constraints &&
        !this.hasMutatedConstraints &&
        rs((s) => {
          this.getAxisMotionValue(s) &&
            (this.constraints[s] = zW(i.layoutBox[s], this.constraints[s]));
        }));
  }
  resolveRefConstraints() {
    const { dragConstraints: e, onMeasureDragConstraints: t } = this.getProps();
    if (!e || !Ac(e)) return !1;
    const i = e.current,
      { projection: r } = this.visualElement;
    if (!r || !r.layout) return !1;
    const s = XW(i, r.root, this.visualElement.getTransformPagePoint());
    let o = OW(r.layout.layoutBox, s);
    if (t) {
      const a = t(HW(o));
      ((this.hasMutatedConstraints = !!a), a && (o = xL(a)));
    }
    return o;
  }
  startAnimation(e) {
    const {
        drag: t,
        dragMomentum: i,
        dragElastic: r,
        dragTransition: s,
        dragSnapToOrigin: o,
        onDragTransitionEnd: a,
      } = this.getProps(),
      l = this.constraints || {},
      u = rs((h) => {
        if (!em(h, t, this.currentDirection)) return;
        let d = (l && l[h]) || {};
        o && (d = { min: 0, max: 0 });
        const p = r ? 200 : 1e6,
          g = r ? 40 : 1e7,
          y = {
            type: "inertia",
            velocity: i ? e[h] : 0,
            bounceStiffness: p,
            bounceDamping: g,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10,
            ...s,
            ...d,
          };
        return this.startAxisValueAnimation(h, y);
      });
    return Promise.all(u).then(a);
  }
  startAxisValueAnimation(e, t) {
    const i = this.getAxisMotionValue(e);
    return i.start(oM(e, i, 0, t));
  }
  stopAnimation() {
    rs((e) => this.getAxisMotionValue(e).stop());
  }
  getAxisMotionValue(e) {
    const t = "_drag" + e.toUpperCase(),
      i = this.visualElement.getProps(),
      r = i[t];
    return (
      r ||
      this.visualElement.getValue(e, (i.initial ? i.initial[e] : void 0) || 0)
    );
  }
  snapToCursor(e) {
    rs((t) => {
      const { drag: i } = this.getProps();
      if (!em(t, i, this.currentDirection)) return;
      const { projection: r } = this.visualElement,
        s = this.getAxisMotionValue(t);
      if (r && r.layout) {
        const { min: o, max: a } = r.layout.layoutBox[t];
        s.set(e[t] - on(o, a, 0.5));
      }
    });
  }
  scalePositionWithinConstraints() {
    if (!this.visualElement.current) return;
    const { drag: e, dragConstraints: t } = this.getProps(),
      { projection: i } = this.visualElement;
    if (!Ac(t) || !i || !this.constraints) return;
    this.stopAnimation();
    const r = { x: 0, y: 0 };
    rs((o) => {
      const a = this.getAxisMotionValue(o);
      if (a) {
        const l = a.get();
        r[o] = UW({ min: l, max: l }, this.constraints[o]);
      }
    });
    const { transformTemplate: s } = this.visualElement.getProps();
    ((this.visualElement.current.style.transform = s ? s({}, "") : "none"),
      i.root && i.root.updateScroll(),
      i.updateLayout(),
      this.resolveConstraints(),
      rs((o) => {
        if (!em(o, e, null)) return;
        const a = this.getAxisMotionValue(o),
          { min: l, max: u } = this.constraints[o];
        a.set(on(l, u, r[o]));
      }));
  }
  addListeners() {
    if (!this.visualElement.current) return;
    KW.set(this.visualElement, this);
    const e = this.visualElement.current,
      t = Vs(e, "pointerdown", (l) => {
        const { drag: u, dragListener: h = !0 } = this.getProps();
        u && h && this.start(l);
      }),
      i = () => {
        const { dragConstraints: l } = this.getProps();
        Ac(l) && (this.constraints = this.resolveRefConstraints());
      },
      { projection: r } = this.visualElement,
      s = r.addEventListener("measure", i);
    (r && !r.layout && (r.root && r.root.updateScroll(), r.updateLayout()),
      i());
    const o = zs(window, "resize", () => this.scalePositionWithinConstraints()),
      a = r.addEventListener(
        "didUpdate",
        ({ delta: l, hasLayoutChanged: u }) => {
          this.isDragging &&
            u &&
            (rs((h) => {
              const d = this.getAxisMotionValue(h);
              d &&
                ((this.originPoint[h] += l[h].translate),
                d.set(d.get() + l[h].translate));
            }),
            this.visualElement.render());
        }
      );
    return () => {
      (o(), t(), s(), a && a());
    };
  }
  getProps() {
    const e = this.visualElement.getProps(),
      {
        drag: t = !1,
        dragDirectionLock: i = !1,
        dragPropagation: r = !1,
        dragConstraints: s = !1,
        dragElastic: o = U_,
        dragMomentum: a = !0,
      } = e;
    return {
      ...e,
      drag: t,
      dragDirectionLock: i,
      dragPropagation: r,
      dragConstraints: s,
      dragElastic: o,
      dragMomentum: a,
    };
  }
}
function em(n, e, t) {
  return (e === !0 || e === n) && (t === null || t === n);
}
function QW(n, e = 10) {
  let t = null;
  return (Math.abs(n.y) > e ? (t = "y") : Math.abs(n.x) > e && (t = "x"), t);
}
class ZW extends sa {
  constructor(e) {
    (super(e),
      (this.removeGroupControls = bn),
      (this.removeListeners = bn),
      (this.controls = new YW(e)));
  }
  mount() {
    const { dragControls: e } = this.node.getProps();
    (e && (this.removeGroupControls = e.subscribe(this.controls)),
      (this.removeListeners = this.controls.addListeners() || bn));
  }
  unmount() {
    (this.removeGroupControls(), this.removeListeners());
  }
}
const YT = (n) => (e, t) => {
  n && an.update(() => n(e, t));
};
class qW extends sa {
  constructor() {
    (super(...arguments), (this.removePointerDownListener = bn));
  }
  onPointerDown(e) {
    this.session = new vL(e, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
    });
  }
  createPanHandlers() {
    const {
      onPanSessionStart: e,
      onPanStart: t,
      onPan: i,
      onPanEnd: r,
    } = this.node.getProps();
    return {
      onSessionStart: YT(e),
      onStart: YT(t),
      onMove: i,
      onEnd: (s, o) => {
        (delete this.session, r && an.update(() => r(s, o)));
      },
    };
  }
  mount() {
    this.removePointerDownListener = Vs(this.node.current, "pointerdown", (e) =>
      this.onPointerDown(e)
    );
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    (this.removePointerDownListener(), this.session && this.session.end());
  }
}
function $W() {
  const n = H.useContext(VA);
  if (n === null) return [!0, null];
  const { isPresent: e, onExitComplete: t, register: i } = n,
    r = H.useId();
  return (H.useEffect(() => i(r), []), !e && t ? [!1, () => t && t(r)] : [!0]);
}
function QT(n, e) {
  return e.max === e.min ? 0 : (n / (e.max - e.min)) * 100;
}
const of = {
    correct: (n, e) => {
      if (!e.target) return n;
      if (typeof n == "string")
        if (it.test(n)) n = parseFloat(n);
        else return n;
      const t = QT(n, e.target.x),
        i = QT(n, e.target.y);
      return `${t}% ${i}%`;
    },
  },
  e7 = {
    correct: (n, { treeScale: e, projectionDelta: t }) => {
      const i = n,
        r = qo.parse(n);
      if (r.length > 5) return i;
      const s = qo.createTransformer(n),
        o = typeof r[0] != "number" ? 1 : 0,
        a = t.x.scale * e.x,
        l = t.y.scale * e.y;
      ((r[0 + o] /= a), (r[1 + o] /= l));
      const u = on(a, l, 0.5);
      return (
        typeof r[2 + o] == "number" && (r[2 + o] /= u),
        typeof r[3 + o] == "number" && (r[3 + o] /= u),
        s(r)
      );
    },
  };
class t7 extends vh.Component {
  componentDidMount() {
    const {
        visualElement: e,
        layoutGroup: t,
        switchLayoutGroup: i,
        layoutId: r,
      } = this.props,
      { projection: s } = e;
    (a8(n7),
      s &&
        (t.group && t.group.add(s),
        i && i.register && r && i.register(s),
        s.root.didUpdate(),
        s.addEventListener("animationComplete", () => {
          this.safeToRemove();
        }),
        s.setOptions({
          ...s.options,
          onExitComplete: () => this.safeToRemove(),
        })),
      (Tf.hasEverUpdated = !0));
  }
  getSnapshotBeforeUpdate(e) {
    const {
        layoutDependency: t,
        visualElement: i,
        drag: r,
        isPresent: s,
      } = this.props,
      o = i.projection;
    return (
      o &&
        ((o.isPresent = s),
        r || e.layoutDependency !== t || t === void 0
          ? o.willUpdate()
          : this.safeToRemove(),
        e.isPresent !== s &&
          (s
            ? o.promote()
            : o.relegate() ||
              an.postRender(() => {
                const a = o.getStack();
                (!a || !a.members.length) && this.safeToRemove();
              }))),
      null
    );
  }
  componentDidUpdate() {
    const { projection: e } = this.props.visualElement;
    e &&
      (e.root.didUpdate(),
      !e.currentAnimation && e.isLead() && this.safeToRemove());
  }
  componentWillUnmount() {
    const {
        visualElement: e,
        layoutGroup: t,
        switchLayoutGroup: i,
      } = this.props,
      { projection: r } = e;
    r &&
      (r.scheduleCheckAfterUnmount(),
      t && t.group && t.group.remove(r),
      i && i.deregister && i.deregister(r));
  }
  safeToRemove() {
    const { safeToRemove: e } = this.props;
    e && e();
  }
  render() {
    return null;
  }
}
function SL(n) {
  const [e, t] = $W(),
    i = H.useContext(x3);
  return vh.createElement(t7, {
    ...n,
    layoutGroup: i,
    switchLayoutGroup: H.useContext(_3),
    isPresent: e,
    safeToRemove: t,
  });
}
const n7 = {
    borderRadius: {
      ...of,
      applyTo: [
        "borderTopLeftRadius",
        "borderTopRightRadius",
        "borderBottomLeftRadius",
        "borderBottomRightRadius",
      ],
    },
    borderTopLeftRadius: of,
    borderTopRightRadius: of,
    borderBottomLeftRadius: of,
    borderBottomRightRadius: of,
    boxShadow: e7,
  },
  wL = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
  i7 = wL.length,
  ZT = (n) => (typeof n == "string" ? parseFloat(n) : n),
  qT = (n) => typeof n == "number" || it.test(n);
function r7(n, e, t, i, r, s) {
  r
    ? ((n.opacity = on(0, t.opacity !== void 0 ? t.opacity : 1, s7(i))),
      (n.opacityExit = on(e.opacity !== void 0 ? e.opacity : 1, 0, o7(i))))
    : s &&
      (n.opacity = on(
        e.opacity !== void 0 ? e.opacity : 1,
        t.opacity !== void 0 ? t.opacity : 1,
        i
      ));
  for (let o = 0; o < i7; o++) {
    const a = `border${wL[o]}Radius`;
    let l = $T(e, a),
      u = $T(t, a);
    if (l === void 0 && u === void 0) continue;
    (l || (l = 0),
      u || (u = 0),
      l === 0 || u === 0 || qT(l) === qT(u)
        ? ((n[a] = Math.max(on(ZT(l), ZT(u), i), 0)),
          (us.test(u) || us.test(l)) && (n[a] += "%"))
        : (n[a] = u));
  }
  (e.rotate || t.rotate) && (n.rotate = on(e.rotate || 0, t.rotate || 0, i));
}
function $T(n, e) {
  return n[e] !== void 0 ? n[e] : n.borderRadius;
}
const s7 = EL(0, 0.5, tM),
  o7 = EL(0.5, 0.95, bn);
function EL(n, e, t) {
  return (i) => (i < n ? 0 : i > e ? 1 : t(ph(n, e, i)));
}
function eb(n, e) {
  ((n.min = e.min), (n.max = e.max));
}
function fr(n, e) {
  (eb(n.x, e.x), eb(n.y, e.y));
}
function tb(n, e, t, i, r) {
  return (
    (n -= e),
    (n = cg(n, 1 / t, i)),
    r !== void 0 && (n = cg(n, 1 / r, i)),
    n
  );
}
function a7(n, e = 0, t = 1, i = 0.5, r, s = n, o = n) {
  if (
    (us.test(e) &&
      ((e = parseFloat(e)), (e = on(o.min, o.max, e / 100) - o.min)),
    typeof e != "number")
  )
    return;
  let a = on(s.min, s.max, i);
  (n === s && (a -= e),
    (n.min = tb(n.min, e, t, a, r)),
    (n.max = tb(n.max, e, t, a, r)));
}
function nb(n, e, [t, i, r], s, o) {
  a7(n, e[t], e[i], e[r], e.scale, s, o);
}
const l7 = ["x", "scaleX", "originX"],
  c7 = ["y", "scaleY", "originY"];
function ib(n, e, t, i) {
  (nb(n.x, e, l7, t ? t.x : void 0, i ? i.x : void 0),
    nb(n.y, e, c7, t ? t.y : void 0, i ? i.y : void 0));
}
function rb(n) {
  return n.translate === 0 && n.scale === 1;
}
function CL(n) {
  return rb(n.x) && rb(n.y);
}
function H_(n, e) {
  return (
    n.x.min === e.x.min &&
    n.x.max === e.x.max &&
    n.y.min === e.y.min &&
    n.y.max === e.y.max
  );
}
function sb(n) {
  return Zi(n.x) / Zi(n.y);
}
class u7 {
  constructor() {
    this.members = [];
  }
  add(e) {
    (aM(this.members, e), e.scheduleRender());
  }
  remove(e) {
    if (
      (lM(this.members, e),
      e === this.prevLead && (this.prevLead = void 0),
      e === this.lead)
    ) {
      const t = this.members[this.members.length - 1];
      t && this.promote(t);
    }
  }
  relegate(e) {
    const t = this.members.findIndex((r) => e === r);
    if (t === 0) return !1;
    let i;
    for (let r = t; r >= 0; r--) {
      const s = this.members[r];
      if (s.isPresent !== !1) {
        i = s;
        break;
      }
    }
    return i ? (this.promote(i), !0) : !1;
  }
  promote(e, t) {
    const i = this.lead;
    if (e !== i && ((this.prevLead = i), (this.lead = e), e.show(), i)) {
      (i.instance && i.scheduleRender(),
        e.scheduleRender(),
        (e.resumeFrom = i),
        t && (e.resumeFrom.preserveOpacity = !0),
        i.snapshot &&
          ((e.snapshot = i.snapshot),
          (e.snapshot.latestValues = i.animationValues || i.latestValues)),
        e.root && e.root.isUpdating && (e.isLayoutDirty = !0));
      const { crossfade: r } = e.options;
      r === !1 && i.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e) => {
      const { options: t, resumingFrom: i } = e;
      (t.onExitComplete && t.onExitComplete(),
        i && i.options.onExitComplete && i.options.onExitComplete());
    });
  }
  scheduleRender() {
    this.members.forEach((e) => {
      e.instance && e.scheduleRender(!1);
    });
  }
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function ob(n, e, t) {
  let i = "";
  const r = n.x.translate / e.x,
    s = n.y.translate / e.y;
  if (
    ((r || s) && (i = `translate3d(${r}px, ${s}px, 0) `),
    (e.x !== 1 || e.y !== 1) && (i += `scale(${1 / e.x}, ${1 / e.y}) `),
    t)
  ) {
    const { rotate: l, rotateX: u, rotateY: h } = t;
    (l && (i += `rotate(${l}deg) `),
      u && (i += `rotateX(${u}deg) `),
      h && (i += `rotateY(${h}deg) `));
  }
  const o = n.x.scale * e.x,
    a = n.y.scale * e.y;
  return ((o !== 1 || a !== 1) && (i += `scale(${o}, ${a})`), i || "none");
}
const f7 = (n, e) => n.depth - e.depth;
class h7 {
  constructor() {
    ((this.children = []), (this.isDirty = !1));
  }
  add(e) {
    (aM(this.children, e), (this.isDirty = !0));
  }
  remove(e) {
    (lM(this.children, e), (this.isDirty = !0));
  }
  forEach(e) {
    (this.isDirty && this.children.sort(f7),
      (this.isDirty = !1),
      this.children.forEach(e));
  }
}
function d7(n, e) {
  const t = performance.now(),
    i = ({ timestamp: r }) => {
      const s = r - t;
      s >= e && (qs(i), n(s - e));
    };
  return (an.read(i, !0), () => qs(i));
}
function p7(n) {
  window.MotionDebug && window.MotionDebug.record(n);
}
function m7(n) {
  return n instanceof SVGElement && n.tagName !== "svg";
}
function g7(n, e, t) {
  const i = Di(n) ? n : $c(n);
  return (i.start(oM("", i, e, t)), i.animation);
}
const ab = ["", "X", "Y", "Z"],
  lb = 1e3;
let v7 = 0;
const Ia = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0,
};
function TL({
  attachResizeListener: n,
  defaultParent: e,
  measureScroll: t,
  checkIsScrollRoot: i,
  resetTransform: r,
}) {
  return class {
    constructor(o, a = {}, l = e == null ? void 0 : e()) {
      ((this.id = v7++),
        (this.animationId = 0),
        (this.children = new Set()),
        (this.options = {}),
        (this.isTreeAnimating = !1),
        (this.isAnimationBlocked = !1),
        (this.isLayoutDirty = !1),
        (this.isProjectionDirty = !1),
        (this.isSharedProjectionDirty = !1),
        (this.isTransformDirty = !1),
        (this.updateManuallyBlocked = !1),
        (this.updateBlockedByResize = !1),
        (this.isUpdating = !1),
        (this.isSVG = !1),
        (this.needsReset = !1),
        (this.shouldResetTransform = !1),
        (this.treeScale = { x: 1, y: 1 }),
        (this.eventHandlers = new Map()),
        (this.potentialNodes = new Map()),
        (this.checkUpdateFailed = () => {
          this.isUpdating && ((this.isUpdating = !1), this.clearAllSnapshots());
        }),
        (this.updateProjection = () => {
          ((Ia.totalNodes =
            Ia.resolvedTargetDeltas =
            Ia.recalculatedProjection =
              0),
            this.nodes.forEach(_7),
            this.nodes.forEach(w7),
            this.nodes.forEach(E7),
            this.nodes.forEach(A7),
            p7(Ia));
        }),
        (this.hasProjected = !1),
        (this.isVisible = !0),
        (this.animationProgress = 0),
        (this.sharedNodes = new Map()),
        (this.elementId = o),
        (this.latestValues = a),
        (this.root = l ? l.root || l : this),
        (this.path = l ? [...l.path, l] : []),
        (this.parent = l),
        (this.depth = l ? l.depth + 1 : 0),
        o && this.root.registerPotentialNode(o, this));
      for (let u = 0; u < this.path.length; u++)
        this.path[u].shouldResetTransform = !0;
      this.root === this && (this.nodes = new h7());
    }
    addEventListener(o, a) {
      return (
        this.eventHandlers.has(o) || this.eventHandlers.set(o, new cM()),
        this.eventHandlers.get(o).add(a)
      );
    }
    notifyListeners(o, ...a) {
      const l = this.eventHandlers.get(o);
      l && l.notify(...a);
    }
    hasListeners(o) {
      return this.eventHandlers.has(o);
    }
    registerPotentialNode(o, a) {
      this.potentialNodes.set(o, a);
    }
    mount(o, a = !1) {
      if (this.instance) return;
      ((this.isSVG = m7(o)), (this.instance = o));
      const { layoutId: l, layout: u, visualElement: h } = this.options;
      if (
        (h && !h.current && h.mount(o),
        this.root.nodes.add(this),
        this.parent && this.parent.children.add(this),
        this.elementId && this.root.potentialNodes.delete(this.elementId),
        a && (u || l) && (this.isLayoutDirty = !0),
        n)
      ) {
        let d;
        const p = () => (this.root.updateBlockedByResize = !1);
        n(o, () => {
          ((this.root.updateBlockedByResize = !0),
            d && d(),
            (d = d7(p, 250)),
            Tf.hasAnimatedSinceResize &&
              ((Tf.hasAnimatedSinceResize = !1), this.nodes.forEach(ub)));
        });
      }
      (l && this.root.registerSharedNode(l, this),
        this.options.animate !== !1 &&
          h &&
          (l || u) &&
          this.addEventListener(
            "didUpdate",
            ({
              delta: d,
              hasLayoutChanged: p,
              hasRelativeTargetChanged: g,
              layout: y,
            }) => {
              if (this.isTreeAnimationBlocked()) {
                ((this.target = void 0), (this.relativeTarget = void 0));
                return;
              }
              const A =
                  this.options.transition || h.getDefaultTransition() || B7,
                { onLayoutAnimationStart: _, onLayoutAnimationComplete: m } =
                  h.getProps(),
                x = !this.targetLayout || !H_(this.targetLayout, y) || g,
                S = !p && g;
              if (
                this.options.layoutRoot ||
                (this.resumeFrom && this.resumeFrom.instance) ||
                S ||
                (p && (x || !this.currentAnimation))
              ) {
                (this.resumeFrom &&
                  ((this.resumingFrom = this.resumeFrom),
                  (this.resumingFrom.resumingFrom = void 0)),
                  this.setAnimationOrigin(d, S));
                const w = { ...dL(A, "layout"), onPlay: _, onComplete: m };
                ((h.shouldReduceMotion || this.options.layoutRoot) &&
                  ((w.delay = 0), (w.type = !1)),
                  this.startAnimation(w));
              } else
                (!p && this.animationProgress === 0 && ub(this),
                  this.isLead() &&
                    this.options.onExitComplete &&
                    this.options.onExitComplete());
              this.targetLayout = y;
            }
          ));
    }
    unmount() {
      (this.options.layoutId && this.willUpdate(),
        this.root.nodes.remove(this));
      const o = this.getStack();
      (o && o.remove(this),
        this.parent && this.parent.children.delete(this),
        (this.instance = void 0),
        qs(this.updateProjection));
    }
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return (
        this.isAnimationBlocked ||
        (this.parent && this.parent.isTreeAnimationBlocked()) ||
        !1
      );
    }
    startUpdate() {
      this.isUpdateBlocked() ||
        ((this.isUpdating = !0),
        this.nodes && this.nodes.forEach(C7),
        this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: o } = this.options;
      return o && o.getProps().transformTemplate;
    }
    willUpdate(o = !0) {
      if (this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (
        (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
      )
        return;
      this.isLayoutDirty = !0;
      for (let h = 0; h < this.path.length; h++) {
        const d = this.path[h];
        ((d.shouldResetTransform = !0),
          d.updateScroll("snapshot"),
          d.options.layoutRoot && d.willUpdate(!1));
      }
      const { layoutId: a, layout: l } = this.options;
      if (a === void 0 && !l) return;
      const u = this.getTransformTemplate();
      ((this.prevTransformTemplateValue = u
        ? u(this.latestValues, "")
        : void 0),
        this.updateSnapshot(),
        o && this.notifyListeners("willUpdate"));
    }
    didUpdate() {
      if (this.isUpdateBlocked()) {
        (this.unblockUpdate(),
          this.clearAllSnapshots(),
          this.nodes.forEach(cb));
        return;
      }
      this.isUpdating &&
        ((this.isUpdating = !1),
        this.potentialNodes.size &&
          (this.potentialNodes.forEach(R7), this.potentialNodes.clear()),
        this.nodes.forEach(S7),
        this.nodes.forEach(y7),
        this.nodes.forEach(x7),
        this.clearAllSnapshots(),
        Dc.update.process(Un),
        Dc.preRender.process(Un),
        Dc.render.process(Un));
    }
    clearAllSnapshots() {
      (this.nodes.forEach(M7), this.sharedNodes.forEach(T7));
    }
    scheduleUpdateProjection() {
      an.preRender(this.updateProjection, !1, !0);
    }
    scheduleCheckAfterUnmount() {
      an.postRender(() => {
        this.isLayoutDirty
          ? this.root.didUpdate()
          : this.root.checkUpdateFailed();
      });
    }
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      if (
        !this.instance ||
        (this.updateScroll(),
        !(this.options.alwaysMeasureLayout && this.isLead()) &&
          !this.isLayoutDirty)
      )
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let l = 0; l < this.path.length; l++) this.path[l].updateScroll();
      const o = this.layout;
      ((this.layout = this.measure(!1)),
        (this.layoutCorrected = Sn()),
        (this.isLayoutDirty = !1),
        (this.projectionDelta = void 0),
        this.notifyListeners("measure", this.layout.layoutBox));
      const { visualElement: a } = this.options;
      a &&
        a.notify(
          "LayoutMeasure",
          this.layout.layoutBox,
          o ? o.layoutBox : void 0
        );
    }
    updateScroll(o = "measure") {
      let a = !!(this.options.layoutScroll && this.instance);
      (this.scroll &&
        this.scroll.animationId === this.root.animationId &&
        this.scroll.phase === o &&
        (a = !1),
        a &&
          (this.scroll = {
            animationId: this.root.animationId,
            phase: o,
            isRoot: i(this.instance),
            offset: t(this.instance),
          }));
    }
    resetTransform() {
      if (!r) return;
      const o = this.isLayoutDirty || this.shouldResetTransform,
        a = this.projectionDelta && !CL(this.projectionDelta),
        l = this.getTransformTemplate(),
        u = l ? l(this.latestValues, "") : void 0,
        h = u !== this.prevTransformTemplateValue;
      o &&
        (a || La(this.latestValues) || h) &&
        (r(this.instance, u),
        (this.shouldResetTransform = !1),
        this.scheduleRender());
    }
    measure(o = !0) {
      const a = this.measurePageBox();
      let l = this.removeElementScroll(a);
      return (
        o && (l = this.removeTransform(l)),
        L7(l),
        {
          animationId: this.root.animationId,
          measuredBox: a,
          layoutBox: l,
          latestValues: {},
          source: this.id,
        }
      );
    }
    measurePageBox() {
      const { visualElement: o } = this.options;
      if (!o) return Sn();
      const a = o.measureViewportBox(),
        { scroll: l } = this.root;
      return (l && (Co(a.x, l.offset.x), Co(a.y, l.offset.y)), a);
    }
    removeElementScroll(o) {
      const a = Sn();
      fr(a, o);
      for (let l = 0; l < this.path.length; l++) {
        const u = this.path[l],
          { scroll: h, options: d } = u;
        if (u !== this.root && h && d.layoutScroll) {
          if (h.isRoot) {
            fr(a, o);
            const { scroll: p } = this.root;
            p && (Co(a.x, -p.offset.x), Co(a.y, -p.offset.y));
          }
          (Co(a.x, h.offset.x), Co(a.y, h.offset.y));
        }
      }
      return a;
    }
    applyTransform(o, a = !1) {
      const l = Sn();
      fr(l, o);
      for (let u = 0; u < this.path.length; u++) {
        const h = this.path[u];
        (!a &&
          h.options.layoutScroll &&
          h.scroll &&
          h !== h.root &&
          Sc(l, { x: -h.scroll.offset.x, y: -h.scroll.offset.y }),
          La(h.latestValues) && Sc(l, h.latestValues));
      }
      return (La(this.latestValues) && Sc(l, this.latestValues), l);
    }
    removeTransform(o) {
      const a = Sn();
      fr(a, o);
      for (let l = 0; l < this.path.length; l++) {
        const u = this.path[l];
        if (!u.instance || !La(u.latestValues)) continue;
        z_(u.latestValues) && u.updateSnapshot();
        const h = Sn(),
          d = u.measurePageBox();
        (fr(h, d),
          ib(a, u.latestValues, u.snapshot ? u.snapshot.layoutBox : void 0, h));
      }
      return (La(this.latestValues) && ib(a, this.latestValues), a);
    }
    setTargetDelta(o) {
      ((this.targetDelta = o),
        this.root.scheduleUpdateProjection(),
        (this.isProjectionDirty = !0));
    }
    setOptions(o) {
      this.options = {
        ...this.options,
        ...o,
        crossfade: o.crossfade !== void 0 ? o.crossfade : !0,
      };
    }
    clearMeasurements() {
      ((this.scroll = void 0),
        (this.layout = void 0),
        (this.snapshot = void 0),
        (this.prevTransformTemplateValue = void 0),
        (this.targetDelta = void 0),
        (this.target = void 0),
        (this.isLayoutDirty = !1));
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent &&
        this.relativeParent.resolvedRelativeTargetAt !== Un.timestamp &&
        this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(o = !1) {
      var a;
      const l = this.getLead();
      (this.isProjectionDirty || (this.isProjectionDirty = l.isProjectionDirty),
        this.isTransformDirty || (this.isTransformDirty = l.isTransformDirty),
        this.isSharedProjectionDirty ||
          (this.isSharedProjectionDirty = l.isSharedProjectionDirty));
      const u = !!this.resumingFrom || this !== l;
      if (
        !(
          o ||
          (u && this.isSharedProjectionDirty) ||
          this.isProjectionDirty ||
          (!((a = this.parent) === null || a === void 0) &&
            a.isProjectionDirty) ||
          this.attemptToResolveRelativeTarget
        )
      )
        return;
      const { layout: d, layoutId: p } = this.options;
      if (!(!this.layout || !(d || p))) {
        if (
          ((this.resolvedRelativeTargetAt = Un.timestamp),
          !this.targetDelta && !this.relativeTarget)
        ) {
          const g = this.getClosestProjectingParent();
          g && g.layout
            ? ((this.relativeParent = g),
              this.forceRelativeParentToResolveTarget(),
              (this.relativeTarget = Sn()),
              (this.relativeTargetOrigin = Sn()),
              Rf(
                this.relativeTargetOrigin,
                this.layout.layoutBox,
                g.layout.layoutBox
              ),
              fr(this.relativeTarget, this.relativeTargetOrigin))
            : (this.relativeParent = this.relativeTarget = void 0);
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (
            (this.target ||
              ((this.target = Sn()), (this.targetWithTransforms = Sn())),
            this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.relativeParent &&
            this.relativeParent.target
              ? (this.forceRelativeParentToResolveTarget(),
                FW(
                  this.target,
                  this.relativeTarget,
                  this.relativeParent.target
                ))
              : this.targetDelta
                ? (this.resumingFrom
                    ? (this.target = this.applyTransform(this.layout.layoutBox))
                    : fr(this.target, this.layout.layoutBox),
                  AL(this.target, this.targetDelta))
                : fr(this.target, this.layout.layoutBox),
            this.attemptToResolveRelativeTarget)
          ) {
            this.attemptToResolveRelativeTarget = !1;
            const g = this.getClosestProjectingParent();
            g &&
            !!g.resumingFrom == !!this.resumingFrom &&
            !g.options.layoutScroll &&
            g.target
              ? ((this.relativeParent = g),
                this.forceRelativeParentToResolveTarget(),
                (this.relativeTarget = Sn()),
                (this.relativeTargetOrigin = Sn()),
                Rf(this.relativeTargetOrigin, this.target, g.target),
                fr(this.relativeTarget, this.relativeTargetOrigin))
              : (this.relativeParent = this.relativeTarget = void 0);
          }
          Ia.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (
        !(
          !this.parent ||
          z_(this.parent.latestValues) ||
          _L(this.parent.latestValues)
        )
      )
        return this.parent.isProjecting()
          ? this.parent
          : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!(
        (this.relativeTarget || this.targetDelta || this.options.layoutRoot) &&
        this.layout
      );
    }
    calcProjection() {
      var o;
      const a = this.getLead(),
        l = !!this.resumingFrom || this !== a;
      let u = !0;
      if (
        ((this.isProjectionDirty ||
          (!((o = this.parent) === null || o === void 0) &&
            o.isProjectionDirty)) &&
          (u = !1),
        l &&
          (this.isSharedProjectionDirty || this.isTransformDirty) &&
          (u = !1),
        this.resolvedRelativeTargetAt === Un.timestamp && (u = !1),
        u)
      )
        return;
      const { layout: h, layoutId: d } = this.options;
      if (
        ((this.isTreeAnimating = !!(
          (this.parent && this.parent.isTreeAnimating) ||
          this.currentAnimation ||
          this.pendingAnimation
        )),
        this.isTreeAnimating ||
          (this.targetDelta = this.relativeTarget = void 0),
        !this.layout || !(h || d))
      )
        return;
      (fr(this.layoutCorrected, this.layout.layoutBox),
        WW(this.layoutCorrected, this.treeScale, this.path, l));
      const { target: p } = a;
      if (!p) return;
      this.projectionDelta ||
        ((this.projectionDelta = Lf()),
        (this.projectionDeltaWithTransform = Lf()));
      const g = this.treeScale.x,
        y = this.treeScale.y,
        A = this.projectionTransform;
      (Bf(this.projectionDelta, this.layoutCorrected, p, this.latestValues),
        (this.projectionTransform = ob(this.projectionDelta, this.treeScale)),
        (this.projectionTransform !== A ||
          this.treeScale.x !== g ||
          this.treeScale.y !== y) &&
          ((this.hasProjected = !0),
          this.scheduleRender(),
          this.notifyListeners("projectionUpdate", p)),
        Ia.recalculatedProjection++);
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(o = !0) {
      if ((this.options.scheduleRender && this.options.scheduleRender(), o)) {
        const a = this.getStack();
        a && a.scheduleRender();
      }
      this.resumingFrom &&
        !this.resumingFrom.instance &&
        (this.resumingFrom = void 0);
    }
    setAnimationOrigin(o, a = !1) {
      const l = this.snapshot,
        u = l ? l.latestValues : {},
        h = { ...this.latestValues },
        d = Lf();
      ((!this.relativeParent || !this.relativeParent.options.layoutRoot) &&
        (this.relativeTarget = this.relativeTargetOrigin = void 0),
        (this.attemptToResolveRelativeTarget = !a));
      const p = Sn(),
        g = l ? l.source : void 0,
        y = this.layout ? this.layout.source : void 0,
        A = g !== y,
        _ = this.getStack(),
        m = !_ || _.members.length <= 1,
        x = !!(A && !m && this.options.crossfade === !0 && !this.path.some(P7));
      this.animationProgress = 0;
      let S;
      ((this.mixTargetDelta = (w) => {
        const C = w / 1e3;
        (fb(d.x, o.x, C),
          fb(d.y, o.y, C),
          this.setTargetDelta(d),
          this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.layout &&
            this.relativeParent &&
            this.relativeParent.layout &&
            (Rf(p, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
            b7(this.relativeTarget, this.relativeTargetOrigin, p, C),
            S && H_(this.relativeTarget, S) && (this.isProjectionDirty = !1),
            S || (S = Sn()),
            fr(S, this.relativeTarget)),
          A &&
            ((this.animationValues = h), r7(h, u, this.latestValues, C, x, m)),
          this.root.scheduleUpdateProjection(),
          this.scheduleRender(),
          (this.animationProgress = C));
      }),
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0));
    }
    startAnimation(o) {
      (this.notifyListeners("animationStart"),
        this.currentAnimation && this.currentAnimation.stop(),
        this.resumingFrom &&
          this.resumingFrom.currentAnimation &&
          this.resumingFrom.currentAnimation.stop(),
        this.pendingAnimation &&
          (qs(this.pendingAnimation), (this.pendingAnimation = void 0)),
        (this.pendingAnimation = an.update(() => {
          ((Tf.hasAnimatedSinceResize = !0),
            (this.currentAnimation = g7(0, lb, {
              ...o,
              onUpdate: (a) => {
                (this.mixTargetDelta(a), o.onUpdate && o.onUpdate(a));
              },
              onComplete: () => {
                (o.onComplete && o.onComplete(), this.completeAnimation());
              },
            })),
            this.resumingFrom &&
              (this.resumingFrom.currentAnimation = this.currentAnimation),
            (this.pendingAnimation = void 0));
        })));
    }
    completeAnimation() {
      this.resumingFrom &&
        ((this.resumingFrom.currentAnimation = void 0),
        (this.resumingFrom.preserveOpacity = void 0));
      const o = this.getStack();
      (o && o.exitAnimationComplete(),
        (this.resumingFrom =
          this.currentAnimation =
          this.animationValues =
            void 0),
        this.notifyListeners("animationComplete"));
    }
    finishAnimation() {
      (this.currentAnimation &&
        (this.mixTargetDelta && this.mixTargetDelta(lb),
        this.currentAnimation.stop()),
        this.completeAnimation());
    }
    applyTransformsToTarget() {
      const o = this.getLead();
      let {
        targetWithTransforms: a,
        target: l,
        layout: u,
        latestValues: h,
      } = o;
      if (!(!a || !l || !u)) {
        if (
          this !== o &&
          this.layout &&
          u &&
          bL(this.options.animationType, this.layout.layoutBox, u.layoutBox)
        ) {
          l = this.target || Sn();
          const d = Zi(this.layout.layoutBox.x);
          ((l.x.min = o.target.x.min), (l.x.max = l.x.min + d));
          const p = Zi(this.layout.layoutBox.y);
          ((l.y.min = o.target.y.min), (l.y.max = l.y.min + p));
        }
        (fr(a, l),
          Sc(a, h),
          Bf(this.projectionDeltaWithTransform, this.layoutCorrected, a, h));
      }
    }
    registerSharedNode(o, a) {
      (this.sharedNodes.has(o) || this.sharedNodes.set(o, new u7()),
        this.sharedNodes.get(o).add(a));
      const u = a.options.initialPromotionConfig;
      a.promote({
        transition: u ? u.transition : void 0,
        preserveFollowOpacity:
          u && u.shouldPreserveFollowOpacity
            ? u.shouldPreserveFollowOpacity(a)
            : void 0,
      });
    }
    isLead() {
      const o = this.getStack();
      return o ? o.lead === this : !0;
    }
    getLead() {
      var o;
      const { layoutId: a } = this.options;
      return a
        ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.lead) ||
            this
        : this;
    }
    getPrevLead() {
      var o;
      const { layoutId: a } = this.options;
      return a
        ? (o = this.getStack()) === null || o === void 0
          ? void 0
          : o.prevLead
        : void 0;
    }
    getStack() {
      const { layoutId: o } = this.options;
      if (o) return this.root.sharedNodes.get(o);
    }
    promote({ needsReset: o, transition: a, preserveFollowOpacity: l } = {}) {
      const u = this.getStack();
      (u && u.promote(this, l),
        o && ((this.projectionDelta = void 0), (this.needsReset = !0)),
        a && this.setOptions({ transition: a }));
    }
    relegate() {
      const o = this.getStack();
      return o ? o.relegate(this) : !1;
    }
    resetRotation() {
      const { visualElement: o } = this.options;
      if (!o) return;
      let a = !1;
      const { latestValues: l } = o;
      if (((l.rotate || l.rotateX || l.rotateY || l.rotateZ) && (a = !0), !a))
        return;
      const u = {};
      for (let h = 0; h < ab.length; h++) {
        const d = "rotate" + ab[h];
        l[d] && ((u[d] = l[d]), o.setStaticValue(d, 0));
      }
      o.render();
      for (const h in u) o.setStaticValue(h, u[h]);
      o.scheduleRender();
    }
    getProjectionStyles(o = {}) {
      var a, l;
      const u = {};
      if (!this.instance || this.isSVG) return u;
      if (this.isVisible) u.visibility = "";
      else return { visibility: "hidden" };
      const h = this.getTransformTemplate();
      if (this.needsReset)
        return (
          (this.needsReset = !1),
          (u.opacity = ""),
          (u.pointerEvents = Sm(o.pointerEvents) || ""),
          (u.transform = h ? h(this.latestValues, "") : "none"),
          u
        );
      const d = this.getLead();
      if (!this.projectionDelta || !this.layout || !d.target) {
        const A = {};
        return (
          this.options.layoutId &&
            ((A.opacity =
              this.latestValues.opacity !== void 0
                ? this.latestValues.opacity
                : 1),
            (A.pointerEvents = Sm(o.pointerEvents) || "")),
          this.hasProjected &&
            !La(this.latestValues) &&
            ((A.transform = h ? h({}, "") : "none"), (this.hasProjected = !1)),
          A
        );
      }
      const p = d.animationValues || d.latestValues;
      (this.applyTransformsToTarget(),
        (u.transform = ob(
          this.projectionDeltaWithTransform,
          this.treeScale,
          p
        )),
        h && (u.transform = h(p, u.transform)));
      const { x: g, y } = this.projectionDelta;
      ((u.transformOrigin = `${g.origin * 100}% ${y.origin * 100}% 0`),
        d.animationValues
          ? (u.opacity =
              d === this
                ? (l =
                    (a = p.opacity) !== null && a !== void 0
                      ? a
                      : this.latestValues.opacity) !== null && l !== void 0
                  ? l
                  : 1
                : this.preserveOpacity
                  ? this.latestValues.opacity
                  : p.opacityExit)
          : (u.opacity =
              d === this
                ? p.opacity !== void 0
                  ? p.opacity
                  : ""
                : p.opacityExit !== void 0
                  ? p.opacityExit
                  : 0));
      for (const A in ng) {
        if (p[A] === void 0) continue;
        const { correct: _, applyTo: m } = ng[A],
          x = u.transform === "none" ? p[A] : _(p[A], d);
        if (m) {
          const S = m.length;
          for (let w = 0; w < S; w++) u[m[w]] = x;
        } else u[A] = x;
      }
      return (
        this.options.layoutId &&
          (u.pointerEvents = d === this ? Sm(o.pointerEvents) || "" : "none"),
        u
      );
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    resetTree() {
      (this.root.nodes.forEach((o) => {
        var a;
        return (a = o.currentAnimation) === null || a === void 0
          ? void 0
          : a.stop();
      }),
        this.root.nodes.forEach(cb),
        this.root.sharedNodes.clear());
    }
  };
}
function y7(n) {
  n.updateLayout();
}
function x7(n) {
  var e;
  const t =
    ((e = n.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) ||
    n.snapshot;
  if (n.isLead() && n.layout && t && n.hasListeners("didUpdate")) {
    const { layoutBox: i, measuredBox: r } = n.layout,
      { animationType: s } = n.options,
      o = t.source !== n.layout.source;
    s === "size"
      ? rs((d) => {
          const p = o ? t.measuredBox[d] : t.layoutBox[d],
            g = Zi(p);
          ((p.min = i[d].min), (p.max = p.min + g));
        })
      : bL(s, t.layoutBox, i) &&
        rs((d) => {
          const p = o ? t.measuredBox[d] : t.layoutBox[d],
            g = Zi(i[d]);
          ((p.max = p.min + g),
            n.relativeTarget &&
              !n.currentAnimation &&
              ((n.isProjectionDirty = !0),
              (n.relativeTarget[d].max = n.relativeTarget[d].min + g)));
        });
    const a = Lf();
    Bf(a, i, t.layoutBox);
    const l = Lf();
    o ? Bf(l, n.applyTransform(r, !0), t.measuredBox) : Bf(l, i, t.layoutBox);
    const u = !CL(a);
    let h = !1;
    if (!n.resumeFrom) {
      const d = n.getClosestProjectingParent();
      if (d && !d.resumeFrom) {
        const { snapshot: p, layout: g } = d;
        if (p && g) {
          const y = Sn();
          Rf(y, t.layoutBox, p.layoutBox);
          const A = Sn();
          (Rf(A, i, g.layoutBox),
            H_(y, A) || (h = !0),
            d.options.layoutRoot &&
              ((n.relativeTarget = A),
              (n.relativeTargetOrigin = y),
              (n.relativeParent = d)));
        }
      }
    }
    n.notifyListeners("didUpdate", {
      layout: i,
      snapshot: t,
      delta: l,
      layoutDelta: a,
      hasLayoutChanged: u,
      hasRelativeTargetChanged: h,
    });
  } else if (n.isLead()) {
    const { onExitComplete: i } = n.options;
    i && i();
  }
  n.options.transition = void 0;
}
function _7(n) {
  (Ia.totalNodes++,
    n.parent &&
      (n.isProjecting() || (n.isProjectionDirty = n.parent.isProjectionDirty),
      n.isSharedProjectionDirty ||
        (n.isSharedProjectionDirty = !!(
          n.isProjectionDirty ||
          n.parent.isProjectionDirty ||
          n.parent.isSharedProjectionDirty
        )),
      n.isTransformDirty || (n.isTransformDirty = n.parent.isTransformDirty)));
}
function A7(n) {
  n.isProjectionDirty = n.isSharedProjectionDirty = n.isTransformDirty = !1;
}
function M7(n) {
  n.clearSnapshot();
}
function cb(n) {
  n.clearMeasurements();
}
function S7(n) {
  const { visualElement: e } = n.options;
  (e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"),
    n.resetTransform());
}
function ub(n) {
  (n.finishAnimation(), (n.targetDelta = n.relativeTarget = n.target = void 0));
}
function w7(n) {
  n.resolveTargetDelta();
}
function E7(n) {
  n.calcProjection();
}
function C7(n) {
  n.resetRotation();
}
function T7(n) {
  n.removeLeadSnapshot();
}
function fb(n, e, t) {
  ((n.translate = on(e.translate, 0, t)),
    (n.scale = on(e.scale, 1, t)),
    (n.origin = e.origin),
    (n.originPoint = e.originPoint));
}
function hb(n, e, t, i) {
  ((n.min = on(e.min, t.min, i)), (n.max = on(e.max, t.max, i)));
}
function b7(n, e, t, i) {
  (hb(n.x, e.x, t.x, i), hb(n.y, e.y, t.y, i));
}
function P7(n) {
  return n.animationValues && n.animationValues.opacityExit !== void 0;
}
const B7 = { duration: 0.45, ease: [0.4, 0, 0.1, 1] };
function R7(n, e) {
  let t = n.root;
  for (let s = n.path.length - 1; s >= 0; s--)
    if (n.path[s].instance) {
      t = n.path[s];
      break;
    }
  const r = (t && t !== n.root ? t.instance : document).querySelector(
    `[data-projection-id="${e}"]`
  );
  r && n.mount(r, !0);
}
function db(n) {
  ((n.min = Math.round(n.min)), (n.max = Math.round(n.max)));
}
function L7(n) {
  (db(n.x), db(n.y));
}
function bL(n, e, t) {
  return (
    n === "position" || (n === "preserve-aspect" && !O_(sb(e), sb(t), 0.2))
  );
}
const I7 = TL({
    attachResizeListener: (n, e) => zs(n, "resize", e),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop,
    }),
    checkIsScrollRoot: () => !0,
  }),
  Oy = { current: void 0 },
  PL = TL({
    measureScroll: (n) => ({ x: n.scrollLeft, y: n.scrollTop }),
    defaultParent: () => {
      if (!Oy.current) {
        const n = new I7(0, {});
        (n.mount(window), n.setOptions({ layoutScroll: !0 }), (Oy.current = n));
      }
      return Oy.current;
    },
    resetTransform: (n, e) => {
      n.style.transform = e !== void 0 ? e : "none";
    },
    checkIsScrollRoot: (n) => window.getComputedStyle(n).position === "fixed",
  }),
  D7 = {
    pan: { Feature: qW },
    drag: { Feature: ZW, ProjectionNode: PL, MeasureLayout: SL },
  },
  F7 = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function N7(n) {
  const e = F7.exec(n);
  if (!e) return [,];
  const [, t, i] = e;
  return [t, i];
}
function V_(n, e, t = 1) {
  const [i, r] = N7(n);
  if (!i) return;
  const s = window.getComputedStyle(e).getPropertyValue(i);
  return s ? s.trim() : B_(r) ? V_(r, e, t + 1) : r;
}
function k7(n, { ...e }, t) {
  const i = n.current;
  if (!(i instanceof Element)) return { target: e, transitionEnd: t };
  (t && (t = { ...t }),
    n.values.forEach((r) => {
      const s = r.get();
      if (!B_(s)) return;
      const o = V_(s, i);
      o && r.set(o);
    }));
  for (const r in e) {
    const s = e[r];
    if (!B_(s)) continue;
    const o = V_(s, i);
    o && ((e[r] = o), t || (t = {}), t[r] === void 0 && (t[r] = s));
  }
  return { target: e, transitionEnd: t };
}
const O7 = new Set([
    "width",
    "height",
    "top",
    "left",
    "right",
    "bottom",
    "x",
    "y",
  ]),
  BL = (n) => O7.has(n),
  U7 = (n) => Object.keys(n).some(BL),
  pb = (n) => n === yl || n === it,
  mb = (n, e) => parseFloat(n.split(", ")[e]),
  gb =
    (n, e) =>
    (t, { transform: i }) => {
      if (i === "none" || !i) return 0;
      const r = i.match(/^matrix3d\((.+)\)$/);
      if (r) return mb(r[1], e);
      {
        const s = i.match(/^matrix\((.+)\)$/);
        return s ? mb(s[1], n) : 0;
      }
    },
  z7 = new Set(["x", "y", "z"]),
  G7 = Wh.filter((n) => !z7.has(n));
function H7(n) {
  const e = [];
  return (
    G7.forEach((t) => {
      const i = n.getValue(t);
      i !== void 0 &&
        (e.push([t, i.get()]), i.set(t.startsWith("scale") ? 1 : 0));
    }),
    e.length && n.render(),
    e
  );
}
const vb = {
    width: ({ x: n }, { paddingLeft: e = "0", paddingRight: t = "0" }) =>
      n.max - n.min - parseFloat(e) - parseFloat(t),
    height: ({ y: n }, { paddingTop: e = "0", paddingBottom: t = "0" }) =>
      n.max - n.min - parseFloat(e) - parseFloat(t),
    top: (n, { top: e }) => parseFloat(e),
    left: (n, { left: e }) => parseFloat(e),
    bottom: ({ y: n }, { top: e }) => parseFloat(e) + (n.max - n.min),
    right: ({ x: n }, { left: e }) => parseFloat(e) + (n.max - n.min),
    x: gb(4, 13),
    y: gb(5, 14),
  },
  V7 = (n, e, t) => {
    const i = e.measureViewportBox(),
      r = e.current,
      s = getComputedStyle(r),
      { display: o } = s,
      a = {};
    (o === "none" && e.setStaticValue("display", n.display || "block"),
      t.forEach((u) => {
        a[u] = vb[u](i, s);
      }),
      e.render());
    const l = e.measureViewportBox();
    return (
      t.forEach((u) => {
        const h = e.getValue(u);
        (h && h.jump(a[u]), (n[u] = vb[u](l, s)));
      }),
      n
    );
  },
  W7 = (n, e, t = {}, i = {}) => {
    ((e = { ...e }), (i = { ...i }));
    const r = Object.keys(e).filter(BL);
    let s = [],
      o = !1;
    const a = [];
    if (
      (r.forEach((l) => {
        const u = n.getValue(l);
        if (!n.hasValue(l)) return;
        let h = t[l],
          d = sf(h);
        const p = e[l];
        let g;
        if (rg(p)) {
          const y = p.length,
            A = p[0] === null ? 1 : 0;
          ((h = p[A]), (d = sf(h)));
          for (let _ = A; _ < y && p[_] !== null; _++)
            g ? eM(sf(p[_]) === g) : (g = sf(p[_]));
        } else g = sf(p);
        if (d !== g)
          if (pb(d) && pb(g)) {
            const y = u.get();
            (typeof y == "string" && u.set(parseFloat(y)),
              typeof p == "string"
                ? (e[l] = parseFloat(p))
                : Array.isArray(p) && g === it && (e[l] = p.map(parseFloat)));
          } else
            d != null &&
            d.transform &&
            g != null &&
            g.transform &&
            (h === 0 || p === 0)
              ? h === 0
                ? u.set(g.transform(h))
                : (e[l] = d.transform(p))
              : (o || ((s = H7(n)), (o = !0)),
                a.push(l),
                (i[l] = i[l] !== void 0 ? i[l] : e[l]),
                u.jump(p));
      }),
      a.length)
    ) {
      const l = a.indexOf("height") >= 0 ? window.pageYOffset : null,
        u = V7(e, n, a);
      return (
        s.length &&
          s.forEach(([h, d]) => {
            n.getValue(h).set(d);
          }),
        n.render(),
        Yg && l !== null && window.scrollTo({ top: l }),
        { target: u, transitionEnd: i }
      );
    } else return { target: e, transitionEnd: i };
  };
function j7(n, e, t, i) {
  return U7(e) ? W7(n, e, t, i) : { target: e, transitionEnd: i };
}
const J7 = (n, e, t, i) => {
    const r = k7(n, e, i);
    return ((e = r.target), (i = r.transitionEnd), j7(n, e, t, i));
  },
  W_ = { current: null },
  RL = { current: !1 };
function X7() {
  if (((RL.current = !0), !!Yg))
    if (window.matchMedia) {
      const n = window.matchMedia("(prefers-reduced-motion)"),
        e = () => (W_.current = n.matches);
      (n.addListener(e), e());
    } else W_.current = !1;
}
function K7(n, e, t) {
  const { willChange: i } = e;
  for (const r in e) {
    const s = e[r],
      o = t[r];
    if (Di(s)) (n.addValue(r, s), lg(i) && i.add(r));
    else if (Di(o)) (n.addValue(r, $c(s, { owner: n })), lg(i) && i.remove(r));
    else if (o !== s)
      if (n.hasValue(r)) {
        const a = n.getValue(r);
        !a.hasAnimated && a.set(s);
      } else {
        const a = n.getStaticValue(r);
        n.addValue(r, $c(a !== void 0 ? a : s, { owner: n }));
      }
  }
  for (const r in t) e[r] === void 0 && n.removeValue(r);
  return e;
}
const yb = new WeakMap(),
  LL = Object.keys(hh),
  Y7 = LL.length,
  xb = [
    "AnimationStart",
    "AnimationComplete",
    "Update",
    "BeforeLayoutMeasure",
    "LayoutMeasure",
    "LayoutAnimationStart",
    "LayoutAnimationComplete",
  ],
  Q7 = jA.length;
class Z7 {
  constructor(
    {
      parent: e,
      props: t,
      presenceContext: i,
      reducedMotionConfig: r,
      visualState: s,
    },
    o = {}
  ) {
    ((this.current = null),
      (this.children = new Set()),
      (this.isVariantNode = !1),
      (this.isControllingVariants = !1),
      (this.shouldReduceMotion = null),
      (this.values = new Map()),
      (this.features = {}),
      (this.valueSubscriptions = new Map()),
      (this.prevMotionValues = {}),
      (this.events = {}),
      (this.propEventSubscriptions = {}),
      (this.notifyUpdate = () => this.notify("Update", this.latestValues)),
      (this.render = () => {
        this.current &&
          (this.triggerBuild(),
          this.renderInstance(
            this.current,
            this.renderState,
            this.props.style,
            this.projection
          ));
      }),
      (this.scheduleRender = () => an.render(this.render, !1, !0)));
    const { latestValues: a, renderState: l } = s;
    ((this.latestValues = a),
      (this.baseTarget = { ...a }),
      (this.initialValues = t.initial ? { ...a } : {}),
      (this.renderState = l),
      (this.parent = e),
      (this.props = t),
      (this.presenceContext = i),
      (this.depth = e ? e.depth + 1 : 0),
      (this.reducedMotionConfig = r),
      (this.options = o),
      (this.isControllingVariants = Zg(t)),
      (this.isVariantNode = v3(t)),
      this.isVariantNode && (this.variantChildren = new Set()),
      (this.manuallyAnimateOnMount = !!(e && e.current)));
    const { willChange: u, ...h } = this.scrapeMotionValuesFromProps(t, {});
    for (const d in h) {
      const p = h[d];
      a[d] !== void 0 && Di(p) && (p.set(a[d], !1), lg(u) && u.add(d));
    }
  }
  scrapeMotionValuesFromProps(e, t) {
    return {};
  }
  mount(e) {
    ((this.current = e),
      yb.set(e, this),
      this.projection && this.projection.mount(e),
      this.parent &&
        this.isVariantNode &&
        !this.isControllingVariants &&
        (this.removeFromVariantTree = this.parent.addVariantChild(this)),
      this.values.forEach((t, i) => this.bindToMotionValue(i, t)),
      RL.current || X7(),
      (this.shouldReduceMotion =
        this.reducedMotionConfig === "never"
          ? !1
          : this.reducedMotionConfig === "always"
            ? !0
            : W_.current),
      this.parent && this.parent.children.add(this),
      this.update(this.props, this.presenceContext));
  }
  unmount() {
    (yb.delete(this.current),
      this.projection && this.projection.unmount(),
      qs(this.notifyUpdate),
      qs(this.render),
      this.valueSubscriptions.forEach((e) => e()),
      this.removeFromVariantTree && this.removeFromVariantTree(),
      this.parent && this.parent.children.delete(this));
    for (const e in this.events) this.events[e].clear();
    for (const e in this.features) this.features[e].unmount();
    this.current = null;
  }
  bindToMotionValue(e, t) {
    const i = vl.has(e),
      r = t.on("change", (o) => {
        ((this.latestValues[e] = o),
          this.props.onUpdate && an.update(this.notifyUpdate, !1, !0),
          i && this.projection && (this.projection.isTransformDirty = !0));
      }),
      s = t.on("renderRequest", this.scheduleRender);
    this.valueSubscriptions.set(e, () => {
      (r(), s());
    });
  }
  sortNodePosition(e) {
    return !this.current ||
      !this.sortInstanceNodePosition ||
      this.type !== e.type
      ? 0
      : this.sortInstanceNodePosition(this.current, e.current);
  }
  loadFeatures({ children: e, ...t }, i, r, s, o) {
    let a, l;
    for (let u = 0; u < Y7; u++) {
      const h = LL[u],
        {
          isEnabled: d,
          Feature: p,
          ProjectionNode: g,
          MeasureLayout: y,
        } = hh[h];
      (g && (a = g),
        d(t) &&
          (!this.features[h] && p && (this.features[h] = new p(this)),
          y && (l = y)));
    }
    if (!this.projection && a) {
      this.projection = new a(
        s,
        this.latestValues,
        this.parent && this.parent.projection
      );
      const {
        layoutId: u,
        layout: h,
        drag: d,
        dragConstraints: p,
        layoutScroll: g,
        layoutRoot: y,
      } = t;
      this.projection.setOptions({
        layoutId: u,
        layout: h,
        alwaysMeasureLayout: !!d || (p && Ac(p)),
        visualElement: this,
        scheduleRender: () => this.scheduleRender(),
        animationType: typeof h == "string" ? h : "both",
        initialPromotionConfig: o,
        layoutScroll: g,
        layoutRoot: y,
      });
    }
    return l;
  }
  updateFeatures() {
    for (const e in this.features) {
      const t = this.features[e];
      t.isMounted
        ? t.update(this.props, this.prevProps)
        : (t.mount(), (t.isMounted = !0));
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.options, this.props);
  }
  measureViewportBox() {
    return this.current
      ? this.measureInstanceViewportBox(this.current, this.props)
      : Sn();
  }
  getStaticValue(e) {
    return this.latestValues[e];
  }
  setStaticValue(e, t) {
    this.latestValues[e] = t;
  }
  makeTargetAnimatable(e, t = !0) {
    return this.makeTargetAnimatableFromInstance(e, this.props, t);
  }
  update(e, t) {
    ((e.transformTemplate || this.props.transformTemplate) &&
      this.scheduleRender(),
      (this.prevProps = this.props),
      (this.props = e),
      (this.prevPresenceContext = this.presenceContext),
      (this.presenceContext = t));
    for (let i = 0; i < xb.length; i++) {
      const r = xb[i];
      this.propEventSubscriptions[r] &&
        (this.propEventSubscriptions[r](),
        delete this.propEventSubscriptions[r]);
      const s = e["on" + r];
      s && (this.propEventSubscriptions[r] = this.on(r, s));
    }
    ((this.prevMotionValues = K7(
      this,
      this.scrapeMotionValuesFromProps(e, this.prevProps),
      this.prevMotionValues
    )),
      this.handleChildMotionValue && this.handleChildMotionValue());
  }
  getProps() {
    return this.props;
  }
  getVariant(e) {
    return this.props.variants ? this.props.variants[e] : void 0;
  }
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode
      ? this
      : this.parent
        ? this.parent.getClosestVariantNode()
        : void 0;
  }
  getVariantContext(e = !1) {
    if (e) return this.parent ? this.parent.getVariantContext() : void 0;
    if (!this.isControllingVariants) {
      const i = this.parent ? this.parent.getVariantContext() || {} : {};
      return (
        this.props.initial !== void 0 && (i.initial = this.props.initial),
        i
      );
    }
    const t = {};
    for (let i = 0; i < Q7; i++) {
      const r = jA[i],
        s = this.props[r];
      (fh(s) || s === !1) && (t[r] = s);
    }
    return t;
  }
  addVariantChild(e) {
    const t = this.getClosestVariantNode();
    if (t)
      return (
        t.variantChildren && t.variantChildren.add(e),
        () => t.variantChildren.delete(e)
      );
  }
  addValue(e, t) {
    (t !== this.values.get(e) &&
      (this.removeValue(e), this.bindToMotionValue(e, t)),
      this.values.set(e, t),
      (this.latestValues[e] = t.get()));
  }
  removeValue(e) {
    this.values.delete(e);
    const t = this.valueSubscriptions.get(e);
    (t && (t(), this.valueSubscriptions.delete(e)),
      delete this.latestValues[e],
      this.removeValueFromRenderState(e, this.renderState));
  }
  hasValue(e) {
    return this.values.has(e);
  }
  getValue(e, t) {
    if (this.props.values && this.props.values[e]) return this.props.values[e];
    let i = this.values.get(e);
    return (
      i === void 0 &&
        t !== void 0 &&
        ((i = $c(t, { owner: this })), this.addValue(e, i)),
      i
    );
  }
  readValue(e) {
    return this.latestValues[e] !== void 0 || !this.current
      ? this.latestValues[e]
      : this.readValueFromInstance(this.current, e, this.options);
  }
  setBaseTarget(e, t) {
    this.baseTarget[e] = t;
  }
  getBaseTarget(e) {
    var t;
    const { initial: i } = this.props,
      r =
        typeof i == "string" || typeof i == "object"
          ? (t = $A(this.props, i)) === null || t === void 0
            ? void 0
            : t[e]
          : void 0;
    if (i && r !== void 0) return r;
    const s = this.getBaseTargetFromProps(this.props, e);
    return s !== void 0 && !Di(s)
      ? s
      : this.initialValues[e] !== void 0 && r === void 0
        ? void 0
        : this.baseTarget[e];
  }
  on(e, t) {
    return (
      this.events[e] || (this.events[e] = new cM()),
      this.events[e].add(t)
    );
  }
  notify(e, ...t) {
    this.events[e] && this.events[e].notify(...t);
  }
}
class IL extends Z7 {
  sortInstanceNodePosition(e, t) {
    return e.compareDocumentPosition(t) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(e, t) {
    return e.style ? e.style[t] : void 0;
  }
  removeValueFromRenderState(e, { vars: t, style: i }) {
    (delete t[e], delete i[e]);
  }
  makeTargetAnimatableFromInstance(
    { transition: e, transitionEnd: t, ...i },
    { transformValues: r },
    s
  ) {
    let o = vW(i, e || {}, this);
    if ((r && (t && (t = r(t)), i && (i = r(i)), o && (o = r(o))), s)) {
      mW(this, i, o);
      const a = J7(this, i, o, t);
      ((t = a.transitionEnd), (i = a.target));
    }
    return { transition: e, transitionEnd: t, ...i };
  }
}
function q7(n) {
  return window.getComputedStyle(n);
}
class $7 extends IL {
  readValueFromInstance(e, t) {
    if (vl.has(t)) {
      const i = rM(t);
      return (i && i.default) || 0;
    } else {
      const i = q7(e),
        r = (S3(t) ? i.getPropertyValue(t) : i[t]) || 0;
      return typeof r == "string" ? r.trim() : r;
    }
  }
  measureInstanceViewportBox(e, { transformPagePoint: t }) {
    return ML(e, t);
  }
  build(e, t, i, r) {
    XA(e, t, i, r.transformTemplate);
  }
  scrapeMotionValuesFromProps(e, t) {
    return qA(e, t);
  }
  handleChildMotionValue() {
    this.childSubscription &&
      (this.childSubscription(), delete this.childSubscription);
    const { children: e } = this.props;
    Di(e) &&
      (this.childSubscription = e.on("change", (t) => {
        this.current && (this.current.textContent = `${t}`);
      }));
  }
  renderInstance(e, t, i, r) {
    P3(e, t, i, r);
  }
}
class ej extends IL {
  constructor() {
    (super(...arguments), (this.isSVGTag = !1));
  }
  getBaseTargetFromProps(e, t) {
    return e[t];
  }
  readValueFromInstance(e, t) {
    if (vl.has(t)) {
      const i = rM(t);
      return (i && i.default) || 0;
    }
    return ((t = B3.has(t) ? t : ZA(t)), e.getAttribute(t));
  }
  measureInstanceViewportBox() {
    return Sn();
  }
  scrapeMotionValuesFromProps(e, t) {
    return L3(e, t);
  }
  build(e, t, i, r) {
    YA(e, t, i, this.isSVGTag, r.transformTemplate);
  }
  renderInstance(e, t, i, r) {
    R3(e, t, i, r);
  }
  mount(e) {
    ((this.isSVGTag = QA(e.tagName)), super.mount(e));
  }
}
const tj = (n, e) =>
    JA(n)
      ? new ej(e, { enableHardwareAcceleration: !1 })
      : new $7(e, { enableHardwareAcceleration: !0 }),
  nj = { layout: { ProjectionNode: PL, MeasureLayout: SL } },
  ij = { ...RW, ...Z8, ...D7, ...nj },
  ai = s8((n, e) => D8(n, e, ij, tj)),
  Jn = {
    paddingX: "sm:px-16 px-6",
    paddingY: "sm:py-16 py-6",
    padding: "sm:px-16 px-6 sm:py-16 py-10",
    heroHeadText:
      "font-black text-white lg:text-[80px] sm:text-[60px] xs:text-[50px] text-[40px] lg:leading-[98px] mt-2",
    heroSubText:
      "text-[#dfd9ff] font-medium lg:text-[30px] sm:text-[26px] xs:text-[20px] text-[16px] lg:leading-[40px]",
    sectionHeadText:
      "text-white font-black md:text-[60px] sm:text-[50px] xs:text-[40px] text-[30px]",
    sectionSubText:
      "sm:text-[18px] text-[14px] text-secondary uppercase tracking-wider",
  };
function rj(n, e, t, i) {
  return new (t || (t = Promise))(function (r, s) {
    function o(u) {
      try {
        l(i.next(u));
      } catch (h) {
        s(h);
      }
    }
    function a(u) {
      try {
        l(i.throw(u));
      } catch (h) {
        s(h);
      }
    }
    function l(u) {
      var h;
      u.done
        ? r(u.value)
        : ((h = u.value),
          h instanceof t
            ? h
            : new t(function (d) {
                d(h);
              })).then(o, a);
    }
    l((i = i.apply(n, e || [])).next());
  });
}
const _b = (n, e, t, i) => {
    n.style.transition = `${e} ${t}ms ${i}`;
  },
  Ls = (n, e, t) => Math.min(Math.max(n, e), t);
class sj {
  constructor(e, t) {
    ((this.glareAngle = 0),
      (this.glareOpacity = 0),
      (this.calculateGlareSize = (o) => {
        const { width: a, height: l } = o,
          u = Math.sqrt(Math.pow(a, 2) + Math.pow(l, 2));
        return { width: u, height: u };
      }),
      (this.setSize = (o) => {
        const a = this.calculateGlareSize(o);
        ((this.glareEl.style.width = `${a.width}px`),
          (this.glareEl.style.height = `${a.height}px`));
      }),
      (this.update = (o, a, l, u) => {
        (this.updateAngle(o, a.glareReverse), this.updateOpacity(o, a, l, u));
      }),
      (this.updateAngle = (o, a) => {
        const { xPercentage: l, yPercentage: u } = o,
          h = 180 / Math.PI,
          d = l ? Math.atan2(u, -l) * h : 0;
        this.glareAngle = d - (a ? 180 : 0);
      }),
      (this.updateOpacity = (o, a, l, u) => {
        const { xPercentage: h, yPercentage: d } = o,
          { glarePosition: p, glareReverse: g, glareMaxOpacity: y } = a,
          A = l ? -1 : 1,
          _ = u ? -1 : 1,
          m = g ? -1 : 1;
        let x = 0;
        switch (p) {
          case "top":
            x = -h * A * m;
            break;
          case "right":
            x = d * _ * m;
            break;
          case "bottom":
          case void 0:
            x = h * A * m;
            break;
          case "left":
            x = -d * _ * m;
            break;
          case "all":
            x = Math.hypot(h, d);
        }
        const S = Ls(x, 0, 100);
        this.glareOpacity = (S * y) / 100;
      }),
      (this.render = (o) => {
        const { glareColor: a } = o;
        ((this.glareEl.style.transform = `rotate(${this.glareAngle}deg) translate(-50%, -50%)`),
          (this.glareEl.style.opacity = this.glareOpacity.toString()),
          (this.glareEl.style.background = `linear-gradient(0deg, rgba(255,255,255,0) 0%, ${a} 100%)`));
      }),
      (this.glareWrapperEl = document.createElement("div")),
      (this.glareEl = document.createElement("div")),
      this.glareWrapperEl.appendChild(this.glareEl),
      (this.glareWrapperEl.className = "glare-wrapper"),
      (this.glareEl.className = "glare"));
    const i = {
        position: "absolute",
        top: "0",
        left: "0",
        width: "100%",
        height: "100%",
        overflow: "hidden",
        borderRadius: t,
        WebkitMaskImage: "-webkit-radial-gradient(white, black)",
        pointerEvents: "none",
      },
      r = this.calculateGlareSize(e),
      s = {
        position: "absolute",
        top: "50%",
        left: "50%",
        transformOrigin: "0% 0%",
        pointerEvents: "none",
        width: `${r.width}px`,
        height: `${r.height}px`,
      };
    (Object.assign(this.glareWrapperEl.style, i),
      Object.assign(this.glareEl.style, s));
  }
}
class oj {
  constructor() {
    ((this.glareAngle = 0),
      (this.glareOpacity = 0),
      (this.tiltAngleX = 0),
      (this.tiltAngleY = 0),
      (this.tiltAngleXPercentage = 0),
      (this.tiltAngleYPercentage = 0),
      (this.update = (e, t) => {
        (this.updateTilt(e, t),
          this.updateTiltManualInput(e, t),
          this.updateTiltReverse(t),
          this.updateTiltLimits(t));
      }),
      (this.updateTilt = (e, t) => {
        const { xPercentage: i, yPercentage: r } = e,
          { tiltMaxAngleX: s, tiltMaxAngleY: o } = t;
        ((this.tiltAngleX = (i * s) / 100),
          (this.tiltAngleY = ((r * o) / 100) * -1));
      }),
      (this.updateTiltManualInput = (e, t) => {
        const {
          tiltAngleXManual: i,
          tiltAngleYManual: r,
          tiltMaxAngleX: s,
          tiltMaxAngleY: o,
        } = t;
        (i !== null || r !== null) &&
          ((this.tiltAngleX = i !== null ? i : 0),
          (this.tiltAngleY = r !== null ? r : 0),
          (e.xPercentage = (100 * this.tiltAngleX) / s),
          (e.yPercentage = (100 * this.tiltAngleY) / o));
      }),
      (this.updateTiltReverse = (e) => {
        const t = e.tiltReverse ? -1 : 1;
        ((this.tiltAngleX = t * this.tiltAngleX),
          (this.tiltAngleY = t * this.tiltAngleY));
      }),
      (this.updateTiltLimits = (e) => {
        const { tiltAxis: t } = e;
        ((this.tiltAngleX = Ls(this.tiltAngleX, -90, 90)),
          (this.tiltAngleY = Ls(this.tiltAngleY, -90, 90)),
          t &&
            ((this.tiltAngleX = t === "x" ? this.tiltAngleX : 0),
            (this.tiltAngleY = t === "y" ? this.tiltAngleY : 0)));
      }),
      (this.updateTiltAnglesPercentage = (e) => {
        const { tiltMaxAngleX: t, tiltMaxAngleY: i } = e;
        ((this.tiltAngleXPercentage = (this.tiltAngleX / t) * 100),
          (this.tiltAngleYPercentage = (this.tiltAngleY / i) * 100));
      }),
      (this.render = (e) => {
        e.style.transform += `rotateX(${this.tiltAngleX}deg) rotateY(${this.tiltAngleY}deg) `;
      }));
  }
}
const aj = Object.assign(
  Object.assign(
    {
      scale: 1,
      perspective: 1e3,
      flipVertically: !1,
      flipHorizontally: !1,
      reset: !0,
      transitionEasing: "cubic-bezier(.03,.98,.52,.99)",
      transitionSpeed: 400,
      trackOnWindow: !1,
      gyroscope: !1,
    },
    {
      tiltEnable: !0,
      tiltReverse: !1,
      tiltAngleXInitial: 0,
      tiltAngleYInitial: 0,
      tiltMaxAngleX: 20,
      tiltMaxAngleY: 20,
      tiltAxis: void 0,
      tiltAngleXManual: null,
      tiltAngleYManual: null,
    }
  ),
  {
    glareEnable: !1,
    glareMaxOpacity: 0.7,
    glareColor: "#ffffff",
    glarePosition: "bottom",
    glareReverse: !1,
    glareBorderRadius: "0",
  }
);
class hu extends H.PureComponent {
  constructor() {
    (super(...arguments),
      (this.wrapperEl = {
        node: null,
        size: { width: 0, height: 0, left: 0, top: 0 },
        clientPosition: { x: null, y: null, xPercentage: 0, yPercentage: 0 },
        updateAnimationId: null,
        scale: 1,
      }),
      (this.tilt = null),
      (this.glare = null),
      (this.addDeviceOrientationEventListener = () =>
        rj(this, void 0, void 0, function* () {
          if (!window.DeviceOrientationEvent) return;
          const e = DeviceOrientationEvent.requestPermission;
          typeof e == "function"
            ? (yield e()) === "granted" &&
              window.addEventListener("deviceorientation", this.onMove)
            : window.addEventListener("deviceorientation", this.onMove);
        })),
      (this.setSize = () => {
        (this.setWrapperElSize(),
          this.glare && this.glare.setSize(this.wrapperEl.size));
      }),
      (this.mainLoop = (e) => {
        (this.wrapperEl.updateAnimationId !== null &&
          cancelAnimationFrame(this.wrapperEl.updateAnimationId),
          this.processInput(e),
          this.update(e.type),
          (this.wrapperEl.updateAnimationId = requestAnimationFrame(
            this.renderFrame
          )));
      }),
      (this.onEnter = (e) => {
        const { onEnter: t } = this.props;
        (this.setSize(),
          (this.wrapperEl.node.style.willChange = "transform"),
          this.setTransitions(),
          t && t(e.type));
      }),
      (this.onMove = (e) => {
        (this.mainLoop(e), this.emitOnMove(e));
      }),
      (this.onLeave = (e) => {
        const { onLeave: t } = this.props;
        if ((this.setTransitions(), t && t(e.type), this.props.reset)) {
          const i = new CustomEvent("autoreset");
          this.onMove(i);
        }
      }),
      (this.processInput = (e) => {
        const { scale: t } = this.props;
        switch (e.type) {
          case "mousemove":
            ((this.wrapperEl.clientPosition.x = e.pageX),
              (this.wrapperEl.clientPosition.y = e.pageY),
              (this.wrapperEl.scale = t));
            break;
          case "touchmove":
            ((this.wrapperEl.clientPosition.x = e.touches[0].pageX),
              (this.wrapperEl.clientPosition.y = e.touches[0].pageY),
              (this.wrapperEl.scale = t));
            break;
          case "deviceorientation":
            (this.processInputDeviceOrientation(e), (this.wrapperEl.scale = t));
            break;
          case "autoreset":
            const {
                tiltAngleXInitial: i,
                tiltAngleYInitial: r,
                tiltMaxAngleX: s,
                tiltMaxAngleY: o,
              } = this.props,
              a = (r / o) * 100;
            ((this.wrapperEl.clientPosition.xPercentage = Ls(
              (i / s) * 100,
              -100,
              100
            )),
              (this.wrapperEl.clientPosition.yPercentage = Ls(a, -100, 100)),
              (this.wrapperEl.scale = 1));
        }
      }),
      (this.processInputDeviceOrientation = (e) => {
        if (!e.gamma || !e.beta || !this.props.gyroscope) return;
        const { tiltMaxAngleX: t, tiltMaxAngleY: i } = this.props,
          r = e.gamma;
        ((this.wrapperEl.clientPosition.xPercentage = (e.beta / t) * 100),
          (this.wrapperEl.clientPosition.yPercentage = (r / i) * 100),
          (this.wrapperEl.clientPosition.xPercentage = Ls(
            this.wrapperEl.clientPosition.xPercentage,
            -100,
            100
          )),
          (this.wrapperEl.clientPosition.yPercentage = Ls(
            this.wrapperEl.clientPosition.yPercentage,
            -100,
            100
          )));
      }),
      (this.update = (e) => {
        const {
          tiltEnable: t,
          flipVertically: i,
          flipHorizontally: r,
        } = this.props;
        (e !== "autoreset" &&
          e !== "deviceorientation" &&
          e !== "propChange" &&
          this.updateClientInput(),
          t && this.tilt.update(this.wrapperEl.clientPosition, this.props),
          this.updateFlip(),
          this.tilt.updateTiltAnglesPercentage(this.props),
          this.glare &&
            this.glare.update(this.wrapperEl.clientPosition, this.props, i, r));
      }),
      (this.updateClientInput = () => {
        const { trackOnWindow: e } = this.props;
        let t, i;
        if (e) {
          const { x: r, y: s } = this.wrapperEl.clientPosition;
          ((t = (s / window.innerHeight) * 200 - 100),
            (i = (r / window.innerWidth) * 200 - 100));
        } else {
          const {
            size: { width: r, height: s, left: o, top: a },
            clientPosition: { x: l, y: u },
          } = this.wrapperEl;
          ((t = ((u - a) / s) * 200 - 100), (i = ((l - o) / r) * 200 - 100));
        }
        ((this.wrapperEl.clientPosition.xPercentage = Ls(t, -100, 100)),
          (this.wrapperEl.clientPosition.yPercentage = Ls(i, -100, 100)));
      }),
      (this.updateFlip = () => {
        const { flipVertically: e, flipHorizontally: t } = this.props;
        (e && ((this.tilt.tiltAngleX += 180), (this.tilt.tiltAngleY *= -1)),
          t && (this.tilt.tiltAngleY += 180));
      }),
      (this.renderFrame = () => {
        (this.resetWrapperElTransform(),
          this.renderPerspective(),
          this.tilt.render(this.wrapperEl.node),
          this.renderScale(),
          this.glare && this.glare.render(this.props));
      }));
  }
  componentDidMount() {
    if (
      ((this.tilt = new oj()),
      this.initGlare(),
      this.addEventListeners(),
      typeof CustomEvent > "u")
    )
      return;
    const e = new CustomEvent("autoreset");
    this.mainLoop(e);
    const t = new CustomEvent("initial");
    this.emitOnMove(t);
  }
  componentWillUnmount() {
    (this.wrapperEl.updateAnimationId !== null &&
      cancelAnimationFrame(this.wrapperEl.updateAnimationId),
      this.removeEventListeners());
  }
  componentDidUpdate() {
    const e = new CustomEvent("propChange");
    (this.mainLoop(e), this.emitOnMove(e));
  }
  addEventListeners() {
    const { trackOnWindow: e, gyroscope: t } = this.props;
    (window.addEventListener("resize", this.setSize),
      e &&
        (window.addEventListener("mouseenter", this.onEnter),
        window.addEventListener("mousemove", this.onMove),
        window.addEventListener("mouseout", this.onLeave),
        window.addEventListener("touchstart", this.onEnter),
        window.addEventListener("touchmove", this.onMove),
        window.addEventListener("touchend", this.onLeave)),
      t && this.addDeviceOrientationEventListener());
  }
  removeEventListeners() {
    const { trackOnWindow: e, gyroscope: t } = this.props;
    (window.removeEventListener("resize", this.setSize),
      e &&
        (window.removeEventListener("mouseenter", this.onEnter),
        window.removeEventListener("mousemove", this.onMove),
        window.removeEventListener("mouseout", this.onLeave),
        window.removeEventListener("touchstart", this.onEnter),
        window.removeEventListener("touchmove", this.onMove),
        window.removeEventListener("touchend", this.onLeave)),
      t &&
        window.DeviceOrientationEvent &&
        window.removeEventListener("deviceorientation", this.onMove));
  }
  setWrapperElSize() {
    const e = this.wrapperEl.node.getBoundingClientRect();
    ((this.wrapperEl.size.width = this.wrapperEl.node.offsetWidth),
      (this.wrapperEl.size.height = this.wrapperEl.node.offsetHeight),
      (this.wrapperEl.size.left = e.left + window.scrollX),
      (this.wrapperEl.size.top = e.top + window.scrollY));
  }
  initGlare() {
    const { glareEnable: e, glareBorderRadius: t } = this.props;
    e &&
      ((this.glare = new sj(this.wrapperEl.size, t)),
      this.wrapperEl.node.appendChild(this.glare.glareWrapperEl));
  }
  emitOnMove(e) {
    const { onMove: t } = this.props;
    if (!t) return;
    let i = 0,
      r = 0;
    (this.glare && ((i = this.glare.glareAngle), (r = this.glare.glareOpacity)),
      t({
        tiltAngleX: this.tilt.tiltAngleX,
        tiltAngleY: this.tilt.tiltAngleY,
        tiltAngleXPercentage: this.tilt.tiltAngleXPercentage,
        tiltAngleYPercentage: this.tilt.tiltAngleYPercentage,
        glareAngle: i,
        glareOpacity: r,
        eventType: e.type,
      }));
  }
  resetWrapperElTransform() {
    this.wrapperEl.node.style.transform = "";
  }
  renderPerspective() {
    const { perspective: e } = this.props;
    this.wrapperEl.node.style.transform += `perspective(${e}px) `;
  }
  renderScale() {
    const { scale: e } = this.wrapperEl;
    this.wrapperEl.node.style.transform += `scale3d(${e},${e},${e})`;
  }
  setTransitions() {
    const { transitionSpeed: e, transitionEasing: t } = this.props;
    (_b(this.wrapperEl.node, "all", e, t),
      this.glare && _b(this.glare.glareEl, "opacity", e, t));
  }
  render() {
    const { children: e, className: t, style: i } = this.props;
    return vh.createElement(
      "div",
      {
        ref: (r) => (this.wrapperEl.node = r),
        onMouseEnter: this.onEnter,
        onMouseMove: this.onMove,
        onMouseLeave: this.onLeave,
        onTouchStart: this.onEnter,
        onTouchMove: this.onMove,
        onTouchEnd: this.onLeave,
        className: t,
        style: i,
      },
      e
    );
  }
}
hu.defaultProps = aj;
const lj = "/assets/profile-795f52a5.jpeg",
  n0 = (n) => ({
    hidden: { y: -50, opacity: 0 },
    show: {
      y: 0,
      opacity: 1,
      transition: { type: "spring", duration: 1.25, delay: n },
    },
  }),
  xl = (n, e, t, i) => ({
    hidden: {
      x: n === "left" ? 100 : n === "right" ? -100 : 0,
      y: n === "up" ? 100 : n === "down" ? -100 : 0,
      opacity: 0,
    },
    show: {
      x: 0,
      y: 0,
      opacity: 1,
      transition: { type: e, delay: t, duration: i, ease: "easeOut" },
    },
  }),
  Ab = (n, e, t, i) => ({
    hidden: {
      x: n === "left" ? "-100%" : n === "right" ? "100%" : 0,
      y: n === "up" || n === "down" ? "100%" : 0,
    },
    show: {
      x: 0,
      y: 0,
      transition: { type: e, delay: t, duration: i, ease: "easeOut" },
    },
  }),
  cj = (n, e) => ({
    hidden: {},
    show: { transition: { staggerChildren: n, delayChildren: e || 0 } },
  }),
  uj = () =>
    rt("section", {
      className: "relative w-full h-screen mx-auto bg-opacity-40",
      children: [
        rt("div", {
          className: `absolute inset-0 top-[120px]  max-w-7xl mx-auto ${Jn.paddingX} flex flex-row items-start gap-5`,
          children: [
            ce("div", {
              className: "flex flex-col justify-center items-center mt-5",
            }),
            rt("div", {
              className: "flex items-center",
              children: [
                ce(hu, {
                  className: "xs:w-[250px] w-full align:left",
                  children: ce(ai.div, {
                    children: ce("img", {
                      src: lj,
                      alt: "web-development",
                      className:
                        "w-100 h-100 object-contain w-full green-black-gradient p-[5px] rounded-[20px] shadow-card",
                    }),
                  }),
                }),
                rt("div", {
                  className: "align:left",
                  style: { marginLeft: "25px" },
                  children: [
                    rt("h1", {
                      className: `${Jn.heroHeadText} text-white`,
                      children: [
                        "Hi, I'm ",
                        ce("span", {
                          className: "text-[#60A7B4]",
                          children: "Richa",
                        }),
                      ],
                    }),
                    rt("p", {
                      className: `${Jn.heroSubText} mt-2 text-white-100`,
                      children: [
                        "Passionate front-end, web, and app developer",
                        ce("br", { className: "sm:block hidden" }),
                        "committed to crafting engaging and impactful",
                        ce("br", { className: "sm:block hidden" }),
                        "digital solutions.",
                      ],
                    }),
                  ],
                }),
              ],
            }),
          ],
        }),
        ce("div", {
          className:
            "absolute xs:bottom-10 bottom-32 w-full flex justify-center items-center",
          children: ce("a", {
            href: "#about",
            children: ce("div", {
              className:
                "w-[35px] h-[64px] rounded-3xl border-4 border-secondary flex justify-center items-start p-2",
              children: ce(ai.div, {
                animate: { y: [0, 24, 0] },
                transition: {
                  duration: 1.5,
                  repeat: 1 / 0,
                  repeatType: "loop",
                },
                className: "w-3 h-3 rounded-full bg-secondary mb-1",
              }),
            }),
          }),
        }),
      ],
    }),
  fj = "/assets/logo-23a4bb24.svg",
  hj = "/assets/art-1a890986.png",
  dj = "/assets/blogger-c4ff6891.png",
  pj = "/assets/mobile-0d672194.png",
  mj = "/assets/web-1e474f26.png",
  DL = "/assets/github-3b4e1609.png",
  gj = "/assets/menu-b5599218.svg",
  vj = "/assets/close-54702a70.svg",
  yj = "/assets/cert1-ede27d7a.jpeg",
  xj = "/assets/cert2-03a22b5c.jpeg",
  _j = "/assets/cert3-777e52f3.jpeg",
  Aj = "/assets/cert4-cd1e078b.jpeg",
  Mj = "/assets/clubApp-4ba903a0.jpg",
  Sj = "/assets/css-79a7f026.png",
  wj =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPAAAADwCAYAAAA+VemSAAAACXBIWXMAAAsTAAALEwEAmpwYAAANG0lEQVR4nO2dX6xcRR2AD9QYgpYElEDv3fltqdUSHtSISNWIiIE09vbuzMKa+GBq4p/4hoIGEx/qSxOiL1T62Adj4kN90gegSXnQxAdCIiYkloQKSKKQpo3c7szeikrXzPZCW3r39uzdc2bOzPm+5Jc0t7t7dn4z386cc+bMFAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQFs415cdVqtHrJZjzqgTToudhFEn/N/8//nXxP6eAHAJIy13Oi3HnZFxqdBy3L+HJAJEZLy/e5016og1cr60vGvh3+Pf6z+DSgQIzGhZLVgjz80q7hUia/XC6mCHUIEAgfDCWS2vzCvvJRK/zrkxQILyIjFA4vIiMUDi8iIxQOLyIjFA4vIiMUDi8iIxQOLyIjFA4vIiMUDi8iIxQOLyIjFA4vIiMUDi8iIxQOLyIjFA4vIiMbSe1OVFYmgtuciLxNBKnJE/xJaucomNeu1cr7s9dm4Baie3HpieGFoHEgMkDhIDJA4SAyQOEgMkDhIDNASn5YDV8vis70NigMg4LT++eFsFibnFBMngjPzoynujSIzE0Hhsv/vo9AkOSIzE0Fj8vrtXn6WExEgMjcMa9cPyUw2RGImhMVijfjD7fGEkRmKIjtXq4c1P+kdiJIZojLR8z+9wP9+TO0iMxBAcp+W788qLxDyKCBFwRr5TlbxIjMQQENeTb1st71QpLxIjMSQ2bJ4qsVE/m/V7+SVs/FI2l/8YqDeslmecVof9ebYPp9Uhq9VTTqtTdZahwlywPA80v+etSmJn5EVn5Aln5DPjorhm2mvHB4prR8uLd1stB61Wb8YWFYmhVlxPfSuUvPNcnd4M46Vt1zsjjzmj3oot6/RcqNfP9WVHiHxAZjit9oeWN7TEntGgs2i1PB9bViSGynB9+WYseecZTs/ZGx+NLesGueCcGMphtfq6NfLfRjTcgD3xeFBssUY9HbvM03PBcBqugjUyaIq8MSRe2Ss3Oi0vxy4zEsPMDI081DR5Y0g87KkvxS4vEkOyw+ZpMdTdfqhqndxHbkCZp/6gcU4MKfS8lzTYf9t9t90SqtZGpnNX7DIjMVwV36tZrf7T/MYqvwtdnc7IycbnRXNhq7WMTNekIK+PkVbfD50fp9UvY5e73I+b4hZT2xhp1bNavR278ZUWeHnx7tA5clqWYpcbieEKRj21LyV5fQwHt94cuipX9nV2xi43EsNlONPZY7U6F7uxzRrjwR0fDF2Vp5d3bY1d7pkl1pwTZ4vrd7/mr+bGbmSbEnhp2/Wh8+VnZsUu96YkNpwTZ4fT6oEUe953Y7W3oELn7MyenTfELvemJdb0xNmQurwTgXX386Hz5h/ji13uuSQ29MTJY42632pZjd2Y5m6MWj0S42Jf7HIjcYuxPflqDvJeEFh+Hzx/Wv0idrmRuKXYfvcr1sgoduOpTmD1dsiplH5ZnhRmYrmy+WM4nQ621703J3nfC61+GvJ2W/TyInH7GPbli06Ljd1Y6gl11hnZFiKPq4MdYrW8Er/M1Ybl6nRzmTzHmq28a6HVb0Llc70la3MIy3C6eZztyRecUcPYjSNIA9Tq4VB5pSeG2mmTvBcElv9Z3flGqKZFTwy1MTLd3WvnhtHFCiqx3yVCq59stIh7lSAxVI7fhcAZ+VdsmaKGlj8Ol+WOEM2L4TRUvORLc3cUCH6PWKtfj3Tnc3U3MXpimJvRg+qzyLu+zGVz6Iz81hn1Vy/krPlHYtg0rtf9tDNyJnav19Qoncc59x5iOA0zg7zVC4zEst4pCRuqVY0z2z9Fz1uPwEgsSFwn9sHFTzojp2MPT3MWGIkFietg2O/e3vSNqHMRGIkFiZE3bYGRWJC4Cs4ub99ltXojdo/WRoGRWJAYedMWGIkFiTfV8+qFT1gj/4zdk6UaVQqMxILEM8nbX/w48jZLYCQWJEbedHvgeR+CX2/apb+2Mdl/WKvDfuNyH06rQ1arp5xWp2KPYlyN+cgSvweP1fKP2JWSQ5TNechG69/jjLzojDzhnyDb6BHI8YHiWr+Rm9VysOm3Dy0SF8Vqf3s3x2VbchQ49DRDv52MM/JYkx9csW2edom86Qkco9GOBp1Fq+X52LK6huSjEZzbJ7f5gsdOfm5RNv+pDR/XeuOjsfPrGpKPqIyW1QLD5rQFjiLxl4sPOC3HY8vqNsiHb9tFzoz3d6+zRp6Lnexco2w9pDp8XNkrNzotL8fOs5uejz/H2Ao2GNaoI7GTnHOUrYdKG23gntjvvBE7z27jfBwpcn0g32p5J3aCc47SdVF1ow3cE0/uIzcg3269XBg5P9JyZ5EbTT5/ySVK10Utx+/sKYIuahg/31NDy/EiJ1LfLDqVKFsfNRz7ZKg1qt/FGvVq7HxvFFndWrL97qOxE9qGKFsfVR/XGvXzelvQOmXQ6lDsfDdtU/basFqOxU5oG6JsfVR93FFP7au3Ba1TBi1LsfO9Ufg2X+SC0+ql2AltQ5SujwyGi34OvWtAzqeGVi8VudCmzcdiRvn6qPa4p5d3bS0C44/pGpDz6aGGRS4gcN4CjwfFliIw/pguuqRtEZghdN4C33/Lh4rAJNADnyhygYtYeQvMObDkfRHLX1KP/4uYf5StjxqOvbfeFpTiVWiVz22ktVUZoic19yhbH5UfW6tD9bag9cqgnoyd79ZM5PAwlTJfgf2sqCIwjZ6JpTObSunxE7z9RO/oyc04ytZFHcf285OLQDR5LrTN9WEGD48T5iuwf0KoCESzn0ZSeT5O6OGB/nwFXut97qt/w7vOPbEldW19oN/Dkjr5CuyfSloZdG6qq+34z3ZG/hZbVNfWJXXeZXWwQ6yWV2InPbcom/96v4d61q9fVcfMK2vU07Fz7NaJdq5Muc6q/UQOAk/iaJVDySavSmnbtCLl+6EnrrYxlc17oIb9F7/2d87rQts29rzvB4nzFHgSWqzf++jMnp03zNou/PzqJu/MYJH3IgynMxX4YmN/0+93NDLd3X7/ow33RjLd3U3fG8m2edg8DSTOV+DLQqtTk4tRl+9OeHjtb43fndAi73QYTrdA4ITDMmy+OkiMwLFFdcg7H0hMDxxbWEfPi8ShG1rZjMcWIqWwDJvpiRE4vogOeePAcJoeGHkTB4kZQtPzJg4Scw7MsDlxkJiLWJzzJg4ScxWaC1aJw7TL99/qkHesVk+VzZ9/LZuty8X8MT0yPEh8YQE1a+RXK1p9bNb8+ff497Z9oUGLvPFos8RWq7/bXvfeeXPoP8N/VuzyIG9LaeM58eQB90H31qpyOFza9lGn1Z/alUPFw/hNoU09sV/p4tTg5g9XnUP/mf6zW5LD13iet2G0QWL/kPtqb0HVlUP/2U1+kB55Myf34fTQyEN159AaGWQrr2bY3Hiy7YkD7reT4z5WlmFzOuTYE1uj7g+VP6fVA1nlTtPzJkdmPfHJcVFcEyp3/lj+mFnIa7hglSwZ9cRPhM6d3/M3eXk1PW/y5CDxsCcPhs6bv2AWu9zIC1kMp4f97u2hq9IfM3a5NxuWYXN+pNwTn9ULHwmdr8nsrBTl1QybsyXVnriO3f6uhj9mcvIaLlhlT4o9sd8nKHSeTi/v2pqUvJqetzWk1hPH2AFvZV9nZzLyGnre1pGYxHtD58dpWWpAuZEXMhhOa3UodD06o56MXu6rhGXYDClI7B+4D11T1qhXY5cbeSGb4fTIdO4KVZ3+WI2Wl3NeSK0ntlqeCVVrVsux5uaBq82QqsRG7qu78ob9zj2xy4m8kKXE/rzUz5Cqq3pXBp2bmvoUEj0vZCGxM+rZOmZmjQfFFmvU0/HLh7yQ/4Wto+OlbddXVdH+s/xnNqBcVwQXrCDLntivILna396dt3pHg87iZJnaJpaRC1aQs8ROi7VaHj+zZ+cNs5bLz692Rh5zRr0VvRzICy0eTk+Wm7VaDo5Md/f4QHHttHL4//Ov8a9t8vKxDJuhdRK/F1qdmlyM0uqw7519TP594W+non8/5IVYNHo4nUFwzgu1g8TIC4mDxPS8kDhIzLAZEgeJOeeFxEFiLlhB4iAxV5shcZCYW0WQOEjMfV5IHCRmkgYkDhIzwwoSB4mZHgmJ03aJmdsMydNWiZEXsqFtEiMvZEdbJEZeyJbcJUZeyJ5cJUZeaA25SYy80DpykRh5obWkLjHyQutJVWLkBUhUYuQFSFRi5AVIVGLkBUhUYuQFSFRi5AVIVGLkBUhUYuQFSFRi5AVIVGLkBUhUYuQFSFRi5AVIVGLkBUhUYuQFCMxoWS1YI89VIO8L/geBCgQIzHh/9zpr1BFr5PzM4ho579/rP4OKA4jISMudTsvx0gJrOe7fQ6UBNIhzfdlhtXrEajnmjDrhtNhJGHXC/83/n39N7O8JAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFCE4v/t8177cNMPugAAAABJRU5ErkJggg==",
  Ej = "/assets/html-92b76a73.png",
  Cj =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPAAAADwCAYAAAA+VemSAAAACXBIWXMAAAsTAAALEwEAmpwYAAAOgElEQVR4nO2dCdCVZRXHz8Pnwi4groElmijuK6m4YCqJpZmJqJla40qGWjgYZZQL5p4GJZlboKKTGzoouWSAiQsuqONY42Q1LVrZYlpZnebcy51B6uO7977LeZ/7/H4z/wGGmfve5zznf577vu+ziAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtIW+JIqIQafkgKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyB/Sp+yKQJHwmlft+3l4kumiN62dmixx8WdJ9dg246LOjggUH79A4aQv3v79sg6Oab1P//pAlBL50iev9s0b8tq3bBkdTwDnjsisHA7zwj+v1viB62f9C+vbN9395rBx03JuhV00TfXFrF/kgM74DHriob+A8/EZ16YtChg7N9x+40oF/QyccGfXVhlfojMbwDHruqaOB3l4teMkV00IBijLuq1loz6PRJov94rgr9kRjeAY9dVTPwy/eJ7rZtOcZdVVtvHvSp2737IzG8DRC7qmTghdeWN+p2p769g94zEwNj4AqYMyYDz7tcdI0uX/PKCtn3mP01r/5IDG8DxK4qGPjumdUxr6yQvY6aezEGxsAVMGmVDWz3vAP7+xtWunnltGRu2f2RGN4GiF2eBranvttu4W9UWY3WHxL0tYcwMAaugFmrZuDzJ2e/fhkaN6a82WaSGt4GiF1eBv79Y6L9+/qbs1ndcCEGxsAVMGxVDDztZH9TtqIh64Ra0Sm+PxLD2wCxy8PANtNqw6H+pmxWgwcGvWZ6Wf2RGN4GiF0eBr732/nd+24/MugVU0WfuUP09cX11Ub259J5oldPE917l/oroXY//9hDgr6xpMz+SAxvA8QuDwNPOjq7cfv1qd+X/ufFnq9nr4J22LK1z990WKgtPyy/PxLD2wCxy8PANuc46/vZR29qfR3xxPE9f3ZXV9Azjwv61tNe/ZEY3gaIXWUb+O/PSs0kWa553ufba+u/losefuDqf44/eZt3fySGtwFiV9kGfnF+tmvarht/far99trIOmqz//3MGWeK/vP5KvRHYngHPHaVbeAHr8t2zQP2yD6pwh54NeZejx0d9JUFVeqPxPAOeOwq28C2cCHL9T57eD6zor46SfTa85p7CKal9kdieAc8dpVt4NuvzHZN28ius/sjMbwDHrvKNnDWd8AH7omBOwpvA8Susg38yA2S+f2v7VLZuf2RGN4Bj11lG9geGGW95qxzO7k/EsM74LGrbAPb6NmrV7Zrrjso6E/v79T+SAzvgMeusg1s2nJEtmuaRgwPtd08Oq8/EsM74LHLw8C2QCDrdU22Fc+NM6r3Kkgz9UdieAc8dnkY+KaL8t2Jw1YcPXZzp/RHYngHPHZ5GNiOTFlzjfwM3JAdZLZgduz9kRjeAY9dHgY2fXI1iwqyasetgt5yaTXmNmvL/ZEY3gGPXV4GtuWARRm4ITti1FYu/XZRTP2RGN4Bj11eBjbZrKqiTWxae62gnz406LN3xtAfieEd8NjlaeDn75LayYBlmHjl1UwPfLe6T64lNbwDHrs8DWz6+uk+e0NvNzLozZeI/vsF/z54b38khnfAY5e3gc1AB+9TvoEbsu19bruiSv2RGN4Bj13eBja9uVRqI6KXiUWCfvhD/mcDY+AKGCI2VcHApt8tzr7ZXVZ1dQX94gm+q50kNbwNELuqYmDTHx+X2mQMTxOLBN1qRNAnnDa3k9TwNkDsqpKBGycW2iiYdcVSVq3RFfSCM8p/Wi2p4W2A2FU1Azf0w+9JbSKG92h81MGhthUuBsbA7maNycAmO0zshMP8R+OD9irvvlhSw9sAsavKBl55G9j9Rvua+JCxobYxPAbGwO6mjc3ADc2fJbrLNn4mPuv44tsqqeFtgNgVk4EbWjRH9KP7Zjt1sB2FEGq7ahbbH4nhbYDYFaOBG3ruzvo9sh12VpaJN14/29EuPfdHYngbIHbFbOCVZ3JdeY7o+zcux8TnnlZcmyU1vJMndnWCgRt6d7norZeJ7jSqWAMP7B/0z08U1R+J4Z00sauTDLyyFl4rtfnNRZn4m18qqj8SwztRYlenGrghO+93/93zN/Do7Yppt6SGd4LErk43cEN3Xi26wbr5GbhXr6C/frSI/kgM78SIXakY2GR7Y+21c34mnnd5Ef2RGN5JEbtSMrDpradF99gxHwN/4YT82y6p4Z0QMcvm96ZmYNNrD0ntlMOsbT94HwyMgR0T+fXF1TSwLWIouu02LTJr27f5IAbGwE0m3M8flNrWqLboPa8kthP+sibxkQeFXN/jXnhGfXRcOq9YAy+Zm73t6w3BwBi4h0Sz0wVmnCnat3c9aU6ekF/S3Ped7El83Mfz+T7L737vQoVRmxW7DtemQ2Zte78+GBgD93CavW3vsuqE+rtn5pPENtplTeJTJ4bMo+75k6W2+fqqn33OScXeX2e9D+7qwsAYuJvXHXYEZ3erbQYPDPri/OwJvOdO2e8Dp3wm28buq5v2aNva2ESMIsxra3vt87O0vX9fDIyBV9kjeda5UjNoT8lj281kOaX+hXvy2VDdFhG0c1tgG7o3cyrDpsOCvrEkfwO/ujB7+zdaDwNj4BUJZXsS79riYvWhg4P+6Mb2Rp8xOYy+pjuuau3adj6RnR7YyjXGjs7/fvjqadkNvN1IDJy8gf+0VPRzx9Tvp9qd0jfp6FA7c7eZxH17mdQ2asvDvCZbk9vsqDt9UvvnAo/fO799qexzNt8ke9uPGIeBkzbw3ItFNxyaj5HsKfVJE0LtyfJfnnzvdWxr1JfvE71iqtR+kuZlXrumPYTqqZ3LfiC6fQ4nL9i+WLYBfNa4n35MddcFS2p4m7Bd/eyB7A9RVie7jx4xPOjwDetGK+Ia9hCsmbbuvkN+17T7zgWz24u5/QyffGx+3+XB6/LPC0kNbyNmkY2YRRm4DH3l1OYMvHiO5L5/1d671I8JbWanSNss/pZLpfZuOa/r9+1dzHtqSQ1vE2aRLUfLY06ul1o5DGzi+OJ+adi9qE12ue4CqW06d89M0RtnSO1khUP3C7ruoPyvO3E864GTN7Al9mVn+5yPm1X287yVY0dsAYFtReP9vfPSw9cXU9QlNbxH0awyE4wb45+QrcoKT6tttZ+x3t87D+00qrXihYE72MCm3/xYdP0h/onZrGwktddf7bT1xCP8v38VH17pCklqeJsvz3nPZe5vnEUXndV+O+09dB6vlLw0oeD1z5Ia3sbLU3d9q9hXS3nIJkBkffpqvzi2+IB/W1rVsA3yXc6JgTvMwCZ7elr2kSHNymZR5bVO95cP5zuppGj171vOod+SGt6GK0L2sKdPQZMvsuiqafkvKLCn2d7tkh5kSx3vb3PyCAZO0MAmq/Z2Do938jY07eRi7v1spZFNyvBun3SjQQPaWzCCgRMegRv61SP5rNnNIvs5bxMiimynzaf+8intL+goStuPDPrSveX2uaSGt8nKWCN8zfTm1gjnLZvBZBuil9XWx28t/lyjZrTWmkGnnljslj4YOBEDr7xLx6c+Vl8+WMaoa69L7Jplt9PmNl9/gc+9ca9eQT9xQNBXFvj1s6SGt7HKlu2kYdvt/L89pLLKfsIeMra1Oc5FydYP28O8Mu6P1xkQ9JQjQ23JpXe7JTW8A+4l2zvZTsjbd7f63lFZRh3bCcS2uPnFw/7t6u5p9SVT6mbOa7KLvdO1bXptR5F3ctooIA9JangHvAqyA65tIf9XJ4kefmDQnbcOtamZNrJYstpobffQm2xUX8NrezmbYefPqm/u7v39W5GZbdGc+t5hpx1VPx1hhy1DbWMEa2OjmA3oV//3ZsNDbfsgWz1kC/Bvv7K+Ftu7HdqNJDW8A46IgWJgDEwhoBAoIzBJQCGIOwckNbwDjoiBYmAMTCGgECgjMElAIYg7ByQ1vAOOiIFiYAxMIaAQKCMwSUAhiDsHJDW8A46IgWJgDEwhoBAoIzBJQCGIOwckNbwDjoiBYmAMTCGgECgjMElAIYg7ByQ1vAOOiIFiYAxMIaAQKCMwSUAhiDsHJDW8A46IgWJgDEwhoBBoiiMwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEg+/BceiofdqS/+vQAAAABJRU5ErkJggg==",
  Tj = "/assets/linux-e95eb46e.png",
  bj = "/assets/reactjs-966214a8.png",
  Pj = "/assets/aws-422538a0.png",
  Bj = "/assets/python-b64ed3d8.png",
  Rj = "/assets/swift-c0e53850.png",
  Lj = "/assets/xcode-d87f44d8.svg",
  Ij =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFjUlEQVR4nO1YXWwUVRQ+trRR1AcRNaG0kBgfJD74ID+K+PNgTBoTurOsoEYNIPCkpupOS8VWFAtoYoyFtraljY3aitCiQPkprbsr6U6RmGjAF2mBpTsz95ZSMBC73V2OubdQOrNTdv5aeOhJTjLZ+/N9373n3nPuAkzZlN0GttOXCd2+J0HyloAk7IawcBIk4QKEhWHuI98neBvv41kEWJZxq2kDHFuaC5KwBSShDyQvWvKw9xxI3s0geWZPPvGQ7wGQvN9AWIhZJp4iRIhBWKiC46/MnBzy3cKrIAkDjomn7sh5CC9bMXHEj6/NAkmodZ24lLIj1RzLXfIvTQdJaJtw8tKo7+eYLq78ZJLHa94OJ3zZzgXYDJuFLy7VuM1wqnJGvmvZa3ZX0BUBEhex3B757oL7ISz033IBkjBg74pl97wFoNxNHlyQryVt5KxP7mceqyK2WyTvmW01SZkhf93n51vckbAQg+O+PAsCWHngLGTSuY1w2myOPCuyRuqU20yA0MeLxrQ2UlU6PrRzSj2Y1e7lPqe0wJ1D3eVbYCJ8WLnrTMC8tQW6GPbivDUFzgWEheL0AsLeFqcC8jbqBEhezPvY44IA708mBLCHh8MdWDNBOyAJf5kIIXulcuoZKMDsdi/3uaXa1XcQQv1mdsDWI2USrlEEyTuUXoDsj4EsolWfVfeWafI5latSxt8lb8AQTY56B40Z4ZgRIA7YEXCf/AluqG9OS76ouhFnyJ+mjM9RtmoE7KGXjHBMhFDUf8KOAFGVOPDG+l3jkt9Q/QPv41ellPHPKo0aAdtITypO1G/iEMtii1XyjyhfYYDGR8GNRFwnz5z1ZWNgzBxM1FgB76ghIwEmrtGov8SqgK/JPxrw74iKuZU3zkRu5Wr8lsqaPttJD94hF/Hx9yhleIBe0bQvUuqMBBSlF6CKi6yQf0639SPgO3jbvcG3ubPvJ5QaTZ9fSRJf7jvI21ar7SnxnykXG+AVzzdXzMlixAz5bLkEd9LzGvDPyd/j9mdtPIRIEhvPJLCuN4aPK9XYQYY1cyxX9xqM9581/2+e7N9sRsDr6gENcCcdxjzli3H7s7Z9yjA2nI5jTU8cG3oTeIgMaeZopv2YJZcYCSgH03ZOnJ0uH8xUNuEh+l/6g6fz8kiEk288ncBOVRt6QZrAp5UGo3FDECnMAUsWFatuRqSE/K5NPGQYH1TK0wrIU77E1r4EBomWfIgmcaV6aJxx/gqwbJHCGTxxGEz4qFKBAZpIIbCfXMb3SRcuVuvxIaWcnxHm7Hux2oAfqGFsI5dTxoVoEitI7+itpCN/HqLv2fzftE9coZ+QgbAkY0TCru/pS2DNmSuYYXTzKH4fOLKov3rshC+oNxKSU+8kSWw6O3Kga3vi6JPb9Pf+NnBs6MsEWWxlE94pf4i7yQUNiS3kJL6pHsRf6L+mif9ML+Eb6kHcHhnk5Hf0xrFNTuIuMsAxrpHfB1g2DVyxaNl0iIr7V6mHUyrGHHkrB8xS1uNCpQ7fVX/jIbaHXsQjNMa9lV7EbeQUv6XmK7U4TV7PxzwWrcbvzw5rbqOV6mGEqLiXY7ppTYODc4+QWHysgHVqp+mMPZ6vUzv1ixJvIRcfBrctRJLN+nR/t1zqWMB0+SO+Q5p8QJJNrpIPEnwqSBJXx4KsVts7eIJxKABkcWiN2t6hPydBis+4Qh4RM0IkcUwDQBJ/sN95dhwpO0zVTjqP8PIgUphzUwynFuiPP6/d3sTVAMUlWpVlGaCICyBaVMxrdvbw4C87Vo7wkoS98v681lbEq0pdYRaguES/ywzbuQAaz9euTLIZJshCJPmjRgCN57sqIEiTR4724yyYIDvaj7MYhqsCQgouDNLEqQCJCzBJFiBxgWEy7MnCnDKwaf8D/XwNTR5ovP0AAAAASUVORK5CYII=",
  Dj = "/assets/kotlin-b009094b.svg",
  Fj = "/assets/java-322a9f14.png",
  Nj = "/assets/wordcount-19d1ba23.jpg",
  kj = "/assets/samsung-5ec0ce30.png",
  Oj = "/assets/dandc-5a155e66.jpg",
  Uj = "/assets/instagram-0a016134.png",
  zj = "/assets/linkedin-66de55a9.png",
  Gj = "/assets/twitter-f97c69c2.png",
  Mb = [
    { id: "about", title: "About" },
    { id: "work", title: "Work" },
    { id: "contact", title: "Contact" },
  ],
  Hj = [
    {
      title: "App Developer",
      icon: pj,
      link: "https://github.com/richk21/Chat-App-Kotlin-Firebase",
    },
    {
      title: "Web Developer",
      icon: mj,
      link: "https://github.com/richk21/Word-Count",
    },
    { title: "Blogger", icon: dj, link: "https://algonoob.devdojo.com/" },
    {
      title: "Artist",
      icon: hj,
      link: "https://www.instagram.com/richa_art21/",
    },
  ],
  Vj = [
    { name: "Java", icon: Fj },
    { name: "Kotlin", icon: Dj },
    { name: "Android Studio", icon: Ij },
    { name: "XCode", icon: Lj },
    { name: "Swift", icon: Rj },
    { name: "Python", icon: Bj },
    { name: "HTML", icon: Ej },
    { name: "CSS", icon: Sj },
    { name: "JavaScript", icon: Cj },
    { name: "React JS", icon: bj },
    { name: "AWS EC2", icon: Pj },
    { name: "git", icon: wj },
    { name: "Linux", icon: Tj },
  ],
  Wj = [
    {
      title: "App Developer Intern",
      company_name: "Duke and Clyde Corp.",
      icon: Oj,
      iconBg: "#E6DEDD",
      date: "June 2022 - Oct 2023",
      points: [
        "Worked with a team to design, develop and launch fintech mobile applications.",
        "Used the latest tools and technologies to create user-friendly and intuitive interfaces.",
        "Contributed to a cutting-edge fintech platform, gaining exposure to agile development methodologies.",
      ],
    },
    {
      title: "R&D Intern",
      company_name: "Samsung PRISM",
      icon: kj,
      iconBg: "#E6DEDD",
      date: "April 2023 - Present",
      points: [
        "Participated in brainstorming sessions, fostering a supportive research environment.",
        "Worked on cutting-edge projects with an experienced team and mentors.",
      ],
    },
  ],
  jj = [
    {
      name: "Club Portfolio",
      description: "University club portfolio app made in Swift, XCode.",
      tags: [
        { name: "Swift", color: "blue-text-gradient" },
        { name: "Xcode", color: "green-text-gradient" },
        { name: "VIT", color: "pink-text-gradient" },
      ],
      image: Mj,
      source_code_link: "https://github.com/richk21/IQuestIOS_App",
    },
    {
      name: "Word Count",
      description:
        "Web application that counts the number of words that you've entered. The display is designed in retro style.",
      tags: [
        { name: "CSS", color: "blue-text-gradient" },
        { name: "HTML", color: "green-text-gradient" },
        { name: "JavaScript", color: "pink-text-gradient" },
      ],
      image: Nj,
      source_code_link: "https://github.com/richk21/Word-Count",
    },
  ],
  Jj = [
    {
      index: 1,
      name: "instagram",
      logo: Uj,
      url: "https://www.instagram.com/richa_art21/",
    },
    {
      index: 2,
      name: "twitter",
      logo: Gj,
      url: "https://twitter.com/richa25424629",
    },
    {
      index: 3,
      name: "linkedin",
      logo: zj,
      url: "https://www.linkedin.com/in/richa-kiran-9557b8219/",
    },
  ],
  Xj = [
    {
      name: "Block.one: Getting Started with Smart Contracts",
      company: "Google Cloud",
      description:
        "Learnt how to build, deploy and call actions on a smart contract.",
      tags: [
        { name: "GoogleCloud", color: "blue-text-gradient" },
        { name: "SmartContracts", color: "green-text-gradient" },
        { name: "Blockchain", color: "pink-text-gradient" },
      ],
      image: yj,
      source_code_link:
        "https://www.coursera.org/account/accomplishments/verify/G7DL3Z5B7QRL",
    },
    {
      name: "Introduction to Docker",
      company: "Google Cloud",
      description:
        "Learnt how to create, run and debug containers and pushing and pulling of images to and from Google Container Repository.",
      tags: [
        { name: "GoogleCloud", color: "blue-text-gradient" },
        { name: "Docker", color: "green-text-gradient" },
        { name: "WebDevelopment", color: "pink-text-gradient" },
      ],
      image: xj,
      source_code_link:
        "https://www.coursera.org/account/accomplishments/verify/NX35K6SVW8KN",
    },
    {
      name: "Block.one: Getting Started with The EOSIO Blockchain",
      company: "Google Cloud",
      description:
        "Learnt about Compute Engine Virtual machine ane EOSIO platform, creation of a wallet and running a single node blockchain.",
      tags: [
        { name: "GoogleCloud", color: "blue-text-gradient" },
        { name: "EOSIO", color: "green-text-gradient" },
        { name: "Blockchain", color: "pink-text-gradient" },
      ],
      image: _j,
      source_code_link:
        "https://www.coursera.org/account/accomplishments/verify/DSNZGL7RHU5S",
    },
    {
      name: "Create a Virtual Private Cloud (VPC) Using AWS",
      company: "Coursera Project Network",
      description:
        "Learnt how to create and run two Virtual Machines in a Virtual Private Cloud in AWS.",
      tags: [
        { name: "Coursera", color: "blue-text-gradient" },
        { name: "VPC", color: "green-text-gradient" },
        { name: "AWS", color: "pink-text-gradient" },
      ],
      image: Aj,
      source_code_link:
        "https://www.coursera.org/account/accomplishments/verify/JMU45GFBASD5",
    },
  ],
  Kj = () => {
    const [n, e] = H.useState(""),
      [t, i] = H.useState(!1),
      [r, s] = H.useState(!1);
    return (
      H.useEffect(() => {
        const o = () => {
          window.scrollY > 100 ? s(!0) : s(!1);
        };
        return (
          window.addEventListener("scroll", o),
          () => window.removeEventListener("scroll", o)
        );
      }, []),
      ce("nav", {
        className: `${Jn.paddingX} w-full flex items-center py-5 fixed top-0 z-20 ${r ? "bg-primary" : "bg-transparent"}`,
        children: rt("div", {
          className:
            "w-full flex justify-between items-center max-w-7xl mx-auto",
          children: [
            rt(FN, {
              to: "/",
              className: "flex items-center gap-2",
              onClick: () => {
                (e(""), window.scrollTo(0, 0));
              },
              children: [
                ce("img", {
                  src: fj,
                  alt: "logo",
                  className: "w-9 h-9 object-contain",
                }),
                rt("p", {
                  className:
                    "text-white text-[18px] font-bold cursor-pointer flex ",
                  children: [
                    "Richa Kiran ",
                    ce("span", { className: "sm:block hidden" }),
                  ],
                }),
              ],
            }),
            ce("ul", {
              className: "list-none hidden sm:flex flex-row gap-10",
              children: Mb.map((o) =>
                ce(
                  "li",
                  {
                    className: `${n === o.title ? "text-white" : "text-secondary"} hover:text-white text-[18px] font-medium cursor-pointer`,
                    onClick: () => e(o.title),
                    children: ce("a", { href: `#${o.id}`, children: o.title }),
                  },
                  o.id
                )
              ),
            }),
            rt("div", {
              className: "sm:hidden flex flex-1 justify-end items-center",
              children: [
                ce("img", {
                  src: t ? vj : gj,
                  alt: "menu",
                  className: "w-[28px] h-[28px] object-contain",
                  onClick: () => i(!t),
                }),
                ce("div", {
                  className: `${t ? "flex" : "hidden"} p-6 black-gradient absolute top-20 right-0 mx-4 my-2 min-w-[140px] z-10 rounded-xl`,
                  children: ce("ul", {
                    className:
                      "list-none flex justify-end items-start flex-1 flex-col gap-4",
                    children: Mb.map((o) =>
                      ce(
                        "li",
                        {
                          className: `font-poppins font-medium cursor-pointer text-[16px] ${n === o.title ? "text-white" : "text-secondary"}`,
                          onClick: () => {
                            (i(!t), e(o.title));
                          },
                          children: ce("a", {
                            href: `#${o.id}`,
                            children: o.title,
                          }),
                        },
                        o.id
                      )
                    ),
                  }),
                }),
              ],
            }),
          ],
        }),
      })
    );
  },
  du = (n, e) =>
    function () {
      return rt(ai.section, {
        variants: cj(),
        initial: "hidden",
        whileInView: "show",
        viewport: { once: !0, amount: 0.25 },
        className: `${Jn.padding} max-w-7xl mx-auto relative z-0`,
        children: [
          ce("span", { className: "hash-span", id: e, children: "" }),
          ce(n, {}),
        ],
      });
    },
  Yj = ({ index: n, title: e, icon: t, link: i }) =>
    ce(hu, {
      className: "xs:w-[250px] w-full",
      children: ce(ai.div, {
        variants: xl("right", "spring", n * 0.5, 0.75),
        className:
          "w-full pink-green-gradient p-[1px] rounded-[20px] shadow-card",
        children: ce("a", {
          href: i,
          children: rt("div", {
            options: { max: 45, scale: 1, speed: 450 },
            className:
              "bg-tertiary rounded-[20px] py-5 px-12 min-h-[280px] flex justify-evenly items-center flex-col",
            children: [
              ce("img", {
                src: t,
                alt: "web-development",
                className: "w-16 h-16 object-contain",
              }),
              ce("h3", {
                className: "text-white text-[20px] font-bold text-center",
                children: e,
              }),
            ],
          }),
        }),
      }),
    }),
  Qj = () =>
    rt(dg, {
      children: [
        rt(ai.div, {
          variants: n0(),
          children: [
            ce("p", { className: Jn.sectionSubText, children: "Introduction" }),
            ce("h2", { className: Jn.sectionHeadText, children: "Overview." }),
          ],
        }),
        ce(ai.p, {
          variants: xl("", "", 0.1, 1),
          className: "mt-4 text-secondary text-[17px] max-w-3xl leading-[30px]",
          children:
            "As a front-end apps and web developer and computer science student, I see code as a canvas for creativity. I believe in the power of simple, elegant design to transform the way we interact with technology. With every project, I strive to build immersive experiences that leave a lasting impression on users and push the boundaries of what's possible.",
        }),
        ce("div", {
          className: "mt-20 flex flex-wrap gap-10",
          children: Hj.map((n, e) => ce(Yj, { index: e, ...n }, n.title)),
        }),
      ],
    }),
  Zj = du(Qj, "about"),
  qj = () =>
    ce("div", {
      className: "flex flex-row flex-wrap justify-center gap-10",
      children: Vj.map((n) =>
        ce(
          "div",
          { className: "w-28 h-28", children: ce(J9, { icon: n.icon }) },
          n.name
        )
      ),
    }),
  $j = du(qj, "");
var i0 = {},
  ug = {},
  eJ = {
    get exports() {
      return ug;
    },
    set exports(n) {
      ug = n;
    },
  };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/ (function (n) {
  (function () {
    var e = {}.hasOwnProperty;
    function t() {
      for (var i = [], r = 0; r < arguments.length; r++) {
        var s = arguments[r];
        if (s) {
          var o = typeof s;
          if (o === "string" || o === "number") i.push(s);
          else if (Array.isArray(s)) {
            if (s.length) {
              var a = t.apply(null, s);
              a && i.push(a);
            }
          } else if (o === "object") {
            if (
              s.toString !== Object.prototype.toString &&
              !s.toString.toString().includes("[native code]")
            ) {
              i.push(s.toString());
              continue;
            }
            for (var l in s) e.call(s, l) && s[l] && i.push(l);
          }
        }
      }
      return i.join(" ");
    }
    n.exports ? ((t.default = t), (n.exports = t)) : (window.classNames = t);
  })();
})(eJ);
i0.__esModule = !0;
i0.default = void 0;
var tJ = uM(H),
  _o = uM(tg),
  nJ = uM(ug);
function uM(n) {
  return n && n.__esModule ? n : { default: n };
}
const FL = ({
  animate: n = !0,
  className: e = "",
  layout: t = "2-columns",
  lineColor: i = "#FFF",
  children: r,
}) => (
  typeof window == "object" &&
    document.documentElement.style.setProperty("--line-color", i),
  tJ.default.createElement(
    "div",
    {
      className: (0, nJ.default)(e, "vertical-timeline", {
        "vertical-timeline--animate": n,
        "vertical-timeline--two-columns": t === "2-columns",
        "vertical-timeline--one-column-left":
          t === "1-column" || t === "1-column-left",
        "vertical-timeline--one-column-right": t === "1-column-right",
      }),
    },
    r
  )
);
FL.propTypes = {
  children: _o.default.oneOfType([
    _o.default.arrayOf(_o.default.node),
    _o.default.node,
  ]).isRequired,
  className: _o.default.string,
  animate: _o.default.bool,
  layout: _o.default.oneOf([
    "1-column-left",
    "1-column",
    "2-columns",
    "1-column-right",
  ]),
  lineColor: _o.default.string,
};
var iJ = FL;
i0.default = iJ;
var r0 = {};
function j_() {
  return (
    (j_ =
      Object.assign ||
      function (n) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e];
          for (var i in t)
            Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
        }
        return n;
      }),
    j_.apply(this, arguments)
  );
}
function rJ(n, e) {
  ((n.prototype = Object.create(e.prototype)),
    (n.prototype.constructor = n),
    J_(n, e));
}
function J_(n, e) {
  return (
    (J_ =
      Object.setPrototypeOf ||
      function (i, r) {
        return ((i.__proto__ = r), i);
      }),
    J_(n, e)
  );
}
function sJ(n, e) {
  if (n == null) return {};
  var t = {},
    i = Object.keys(n),
    r,
    s;
  for (s = 0; s < i.length; s++)
    ((r = i[s]), !(e.indexOf(r) >= 0) && (t[r] = n[r]));
  return t;
}
var X_ = new Map(),
  tm = new WeakMap(),
  Sb = 0,
  NL = void 0;
function oJ(n) {
  NL = n;
}
function aJ(n) {
  return n
    ? (tm.has(n) || ((Sb += 1), tm.set(n, Sb.toString())), tm.get(n))
    : "0";
}
function lJ(n) {
  return Object.keys(n)
    .sort()
    .filter(function (e) {
      return n[e] !== void 0;
    })
    .map(function (e) {
      return e + "_" + (e === "root" ? aJ(n.root) : n[e]);
    })
    .toString();
}
function cJ(n) {
  var e = lJ(n),
    t = X_.get(e);
  if (!t) {
    var i = new Map(),
      r,
      s = new IntersectionObserver(function (o) {
        o.forEach(function (a) {
          var l,
            u =
              a.isIntersecting &&
              r.some(function (h) {
                return a.intersectionRatio >= h;
              });
          (n.trackVisibility && typeof a.isVisible > "u" && (a.isVisible = u),
            (l = i.get(a.target)) == null ||
              l.forEach(function (h) {
                h(u, a);
              }));
        });
      }, n);
    ((r =
      s.thresholds ||
      (Array.isArray(n.threshold) ? n.threshold : [n.threshold || 0])),
      (t = { id: e, observer: s, elements: i }),
      X_.set(e, t));
  }
  return t;
}
function fM(n, e, t, i) {
  if (
    (t === void 0 && (t = {}),
    i === void 0 && (i = NL),
    typeof window.IntersectionObserver > "u" && i !== void 0)
  ) {
    var r = n.getBoundingClientRect();
    return (
      e(i, {
        isIntersecting: i,
        target: n,
        intersectionRatio: typeof t.threshold == "number" ? t.threshold : 0,
        time: 0,
        boundingClientRect: r,
        intersectionRect: r,
        rootBounds: r,
      }),
      function () {}
    );
  }
  var s = cJ(t),
    o = s.id,
    a = s.observer,
    l = s.elements,
    u = l.get(n) || [];
  return (
    l.has(n) || l.set(n, u),
    u.push(e),
    a.observe(n),
    function () {
      (u.splice(u.indexOf(e), 1),
        u.length === 0 && (l.delete(n), a.unobserve(n)),
        l.size === 0 && (a.disconnect(), X_.delete(o)));
    }
  );
}
var uJ = [
  "children",
  "as",
  "triggerOnce",
  "threshold",
  "root",
  "rootMargin",
  "onChange",
  "skip",
  "trackVisibility",
  "delay",
  "initialInView",
  "fallbackInView",
];
function wb(n) {
  return typeof n.children != "function";
}
var fg = (function (n) {
  rJ(e, n);
  function e(i) {
    var r;
    return (
      (r = n.call(this, i) || this),
      (r.node = null),
      (r._unobserveCb = null),
      (r.handleNode = function (s) {
        (r.node &&
          (r.unobserve(),
          !s &&
            !r.props.triggerOnce &&
            !r.props.skip &&
            r.setState({ inView: !!r.props.initialInView, entry: void 0 })),
          (r.node = s || null),
          r.observeNode());
      }),
      (r.handleChange = function (s, o) {
        (s && r.props.triggerOnce && r.unobserve(),
          wb(r.props) || r.setState({ inView: s, entry: o }),
          r.props.onChange && r.props.onChange(s, o));
      }),
      (r.state = { inView: !!i.initialInView, entry: void 0 }),
      r
    );
  }
  var t = e.prototype;
  return (
    (t.componentDidUpdate = function (r) {
      (r.rootMargin !== this.props.rootMargin ||
        r.root !== this.props.root ||
        r.threshold !== this.props.threshold ||
        r.skip !== this.props.skip ||
        r.trackVisibility !== this.props.trackVisibility ||
        r.delay !== this.props.delay) &&
        (this.unobserve(), this.observeNode());
    }),
    (t.componentWillUnmount = function () {
      (this.unobserve(), (this.node = null));
    }),
    (t.observeNode = function () {
      if (!(!this.node || this.props.skip)) {
        var r = this.props,
          s = r.threshold,
          o = r.root,
          a = r.rootMargin,
          l = r.trackVisibility,
          u = r.delay,
          h = r.fallbackInView;
        this._unobserveCb = fM(
          this.node,
          this.handleChange,
          {
            threshold: s,
            root: o,
            rootMargin: a,
            trackVisibility: l,
            delay: u,
          },
          h
        );
      }
    }),
    (t.unobserve = function () {
      this._unobserveCb && (this._unobserveCb(), (this._unobserveCb = null));
    }),
    (t.render = function () {
      if (!wb(this.props)) {
        var r = this.state,
          s = r.inView,
          o = r.entry;
        return this.props.children({
          inView: s,
          entry: o,
          ref: this.handleNode,
        });
      }
      var a = this.props,
        l = a.children,
        u = a.as,
        h = sJ(a, uJ);
      return H.createElement(u || "div", j_({ ref: this.handleNode }, h), l);
    }),
    e
  );
})(H.Component);
fg.displayName = "InView";
fg.defaultProps = { threshold: 0, triggerOnce: !1, initialInView: !1 };
function fJ(n) {
  var e = n === void 0 ? {} : n,
    t = e.threshold,
    i = e.delay,
    r = e.trackVisibility,
    s = e.rootMargin,
    o = e.root,
    a = e.triggerOnce,
    l = e.skip,
    u = e.initialInView,
    h = e.fallbackInView,
    d = H.useRef(),
    p = H.useState({ inView: !!u }),
    g = p[0],
    y = p[1],
    A = H.useCallback(
      function (m) {
        (d.current !== void 0 && (d.current(), (d.current = void 0)),
          !l &&
            m &&
            (d.current = fM(
              m,
              function (x, S) {
                (y({ inView: x, entry: S }),
                  S.isIntersecting &&
                    a &&
                    d.current &&
                    (d.current(), (d.current = void 0)));
              },
              {
                root: o,
                rootMargin: s,
                threshold: t,
                trackVisibility: r,
                delay: i,
              },
              h
            )));
      },
      [Array.isArray(t) ? t.toString() : t, o, s, a, l, r, h, i]
    );
  H.useEffect(function () {
    !d.current && g.entry && !a && !l && y({ inView: !!u });
  });
  var _ = [A, g.inView, g.entry];
  return ((_.ref = _[0]), (_.inView = _[1]), (_.entry = _[2]), _);
}
const hJ = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        InView: fg,
        default: fg,
        defaultFallbackInView: oJ,
        observe: fM,
        useInView: fJ,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  dJ = II(hJ);
r0.__esModule = !0;
r0.default = void 0;
var Ao = hM(H),
  qt = hM(tg),
  nm = hM(ug),
  pJ = dJ;
function hM(n) {
  return n && n.__esModule ? n : { default: n };
}
const kL = ({
  children: n = "",
  className: e = "",
  contentArrowStyle: t = null,
  contentStyle: i = null,
  date: r = "",
  dateClassName: s = "",
  icon: o = null,
  iconClassName: a = "",
  iconOnClick: l = null,
  onTimelineElementClick: u = null,
  iconStyle: h = null,
  id: d = "",
  position: p = "",
  style: g = null,
  textClassName: y = "",
  intersectionObserverProps: A = {
    rootMargin: "0px 0px -40px 0px",
    triggerOnce: !0,
  },
  visible: _ = !1,
}) =>
  Ao.default.createElement(pJ.InView, A, ({ inView: m, ref: x }) =>
    Ao.default.createElement(
      "div",
      {
        ref: x,
        id: d,
        className: (0, nm.default)(e, "vertical-timeline-element", {
          "vertical-timeline-element--left": p === "left",
          "vertical-timeline-element--right": p === "right",
          "vertical-timeline-element--no-children": n === "",
        }),
        style: g,
      },
      Ao.default.createElement(
        Ao.default.Fragment,
        null,
        Ao.default.createElement(
          "span",
          {
            style: h,
            onClick: l,
            className: (0, nm.default)(a, "vertical-timeline-element-icon", {
              "bounce-in": m || _,
              "is-hidden": !(m || _),
            }),
          },
          o
        ),
        Ao.default.createElement(
          "div",
          {
            style: i,
            onClick: u,
            className: (0, nm.default)(y, "vertical-timeline-element-content", {
              "bounce-in": m || _,
              "is-hidden": !(m || _),
            }),
          },
          Ao.default.createElement("div", {
            style: t,
            className: "vertical-timeline-element-content-arrow",
          }),
          n,
          Ao.default.createElement(
            "span",
            { className: (0, nm.default)(s, "vertical-timeline-element-date") },
            r
          )
        )
      )
    )
  );
kL.propTypes = {
  children: qt.default.oneOfType([
    qt.default.arrayOf(qt.default.node),
    qt.default.node,
  ]),
  className: qt.default.string,
  contentArrowStyle: qt.default.shape({}),
  contentStyle: qt.default.shape({}),
  date: qt.default.node,
  dateClassName: qt.default.string,
  icon: qt.default.element,
  iconClassName: qt.default.string,
  iconStyle: qt.default.shape({}),
  iconOnClick: qt.default.func,
  onTimelineElementClick: qt.default.func,
  id: qt.default.string,
  position: qt.default.string,
  style: qt.default.shape({}),
  textClassName: qt.default.string,
  visible: qt.default.bool,
  intersectionObserverProps: qt.default.shape({
    root: qt.default.object,
    rootMargin: qt.default.string,
    threshold: qt.default.number,
    triggerOnce: qt.default.bool,
  }),
};
var mJ = kL;
r0.default = mJ;
var OL = { VerticalTimeline: i0.default, VerticalTimelineElement: r0.default };
const gJ = ({ experience: n }) =>
    rt(OL.VerticalTimelineElement, {
      contentStyle: { background: "#224B52", color: "#fff" },
      contentArrowStyle: { borderRight: "7px solid  #232631" },
      date: n.date,
      iconStyle: { background: n.iconBg },
      icon: ce("div", {
        className: "flex justify-center items-center w-full h-full",
        children: ce("img", {
          src: n.icon,
          alt: n.company_name,
          className: "w-[60%] h-[60%] object-contain",
        }),
      }),
      children: [
        rt("div", {
          children: [
            ce("h3", {
              className: "text-white text-[24px] font-bold",
              children: n.title,
            }),
            ce("p", {
              className: "text-secondary text-[16px] font-semibold",
              style: { margin: 0 },
              children: n.company_name,
            }),
          ],
        }),
        ce("ul", {
          className: "mt-5 list-disc ml-5 space-y-2",
          children: n.points.map((e, t) =>
            ce(
              "li",
              {
                className: "text-white-100 text-[14px] pl-1 tracking-wider",
                children: e,
              },
              `experience-point-${t}`
            )
          ),
        }),
      ],
    }),
  vJ = () =>
    rt(dg, {
      children: [
        rt(ai.div, {
          variants: n0(),
          children: [
            ce("p", {
              className: `${Jn.sectionSubText} text-center`,
              children: "What I have done so far",
            }),
            ce("h2", {
              className: `${Jn.sectionHeadText} text-center`,
              children: "Work Experience.",
            }),
          ],
        }),
        ce("div", {
          className: "mt-20 flex flex-col",
          children: ce(OL.VerticalTimeline, {
            children: Wj.map((n, e) =>
              ce(gJ, { experience: n }, `experience-${e}`)
            ),
          }),
        }),
      ],
    }),
  yJ = du(vJ, "work"),
  xJ = ({
    index: n,
    name: e,
    description: t,
    tags: i,
    image: r,
    source_code_link: s,
  }) =>
    ce(ai.div, {
      variants: xl("up", "spring", n * 0.5, 0.75),
      children: rt(hu, {
        options: { max: 45, scale: 1, speed: 450 },
        className: "bg-tertiary p-5 rounded-2xl sm:w-[360px] w-full",
        children: [
          rt("div", {
            className: "relative w-full h-[230px]",
            children: [
              ce("img", {
                src: r,
                alt: "project_image",
                className: "w-full h-full object-cover rounded-2xl",
              }),
              ce("div", {
                className:
                  "absolute inset-0 flex justify-end m-3 card-img_hover",
                children: ce("div", {
                  onClick: () => window.open(s, "_blank"),
                  className:
                    "black-gradient w-10 h-10 rounded-full flex justify-center items-center cursor-pointer",
                  children: ce("img", {
                    src: DL,
                    alt: "source code",
                    className: "w-1/2 h-1/2 object-contain",
                  }),
                }),
              }),
            ],
          }),
          rt("div", {
            className: "mt-5",
            children: [
              ce("h3", {
                className: "text-white font-bold text-[24px]",
                children: e,
              }),
              ce("p", {
                className: "mt-2 text-secondary text-[14px]",
                children: t,
              }),
            ],
          }),
          ce("div", {
            className: "mt-4 flex flex-wrap gap-2",
            children: i.map((o) =>
              rt(
                "p",
                {
                  className: `text-[14px] ${o.color}`,
                  children: ["#", o.name],
                },
                `${e}-${o.name}`
              )
            ),
          }),
        ],
      }),
    }),
  _J = () =>
    rt(dg, {
      children: [
        rt(ai.div, {
          variants: n0(),
          children: [
            ce("p", {
              className: `${Jn.sectionSubText} `,
              children: "My work",
            }),
            ce("h2", {
              className: `${Jn.sectionHeadText}`,
              children: "Projects.",
            }),
          ],
        }),
        ce("div", {
          className: "w-full flex",
          children: ce(ai.p, {
            variants: xl("", "", 0.1, 1),
            className:
              "mt-3 text-secondary text-[17px] max-w-3xl leading-[30px]",
            children:
              "Following projects showcases my skills and experience through real-world examples of my work. Each project is briefly described with links to code repositories and live demos in it. It reflects my ability to solve complex problems, work with different technologies, and manage projects effectively.",
          }),
        }),
        ce("div", {
          className: "mt-20 flex flex-wrap gap-7",
          children: jj.map((n, e) =>
            ce(xJ, { index: e, ...n }, `project-${e}`)
          ),
        }),
      ],
    }),
  AJ = du(_J, ""),
  MJ = ({
    index: n,
    name: e,
    company: t,
    description: i,
    tags: r,
    image: s,
    source_code_link: o,
  }) =>
    ce(ai.div, {
      variants: xl("up", "spring", n * 0.5, 0.75),
      children: rt(hu, {
        options: { max: 45, scale: 1, speed: 450 },
        className: "bg-black-200 p-5 m-5 rounded-2xl sm:w-[360px] w-full",
        children: [
          rt("div", {
            className: "relative w-full h-[230px]",
            children: [
              ce("img", {
                src: s,
                alt: "project_image",
                className: "w-full h-full object-cover rounded-2xl",
              }),
              ce("div", {
                className:
                  "absolute inset-0 flex justify-end m-3 card-img_hover",
                children: ce("div", {
                  onClick: () => window.open(o, "_blank"),
                  className:
                    "black-gradient w-10 h-10 rounded-full flex justify-center items-center cursor-pointer",
                  children: ce("img", {
                    src: DL,
                    alt: "source code",
                    className: "w-1/2 h-1/2 object-contain",
                  }),
                }),
              }),
            ],
          }),
          rt("div", {
            className: "mt-5",
            children: [
              ce("h3", {
                className: "text-white font-bold text-[24px]",
                children: e,
              }),
              ce("h4", {
                className: "text-white font-bold text-[24px]",
                children: t,
              }),
              ce("p", {
                className: "mt-2 text-secondary text-[14px]",
                children: i,
              }),
            ],
          }),
          ce("div", {
            className: "mt-4 flex flex-wrap gap-2",
            children: r.map((a) =>
              rt(
                "p",
                {
                  className: `text-[14px] ${a.color}`,
                  children: ["#", a.name],
                },
                `${e}-${a.name}`
              )
            ),
          }),
        ],
      }),
    });
function SJ() {
  document
    .querySelector(".overflow-x-scroll")
    .scrollBy({ left: -500, behavior: "smooth" });
}
function wJ() {
  document
    .querySelector(".overflow-x-scroll")
    .scrollBy({ left: 500, behavior: "smooth" });
}
const EJ = () =>
    ce(dg, {
      children: rt("div", {
        className: "mt-12 bg-black-100 rounded-[20px]",
        children: [
          rt("div", {
            className: `bg-tertiary rounded-2xl ${Jn.padding} min-h-[300px]`,
            children: [
              rt(ai.div, {
                variants: n0(),
                children: [
                  ce("p", {
                    className: Jn.sectionSubText,
                    children: "My Knowledge",
                  }),
                  ce("h2", {
                    className: Jn.sectionHeadText,
                    children: "Certifications.",
                  }),
                ],
              }),
              ce("div", {
                className: "w-full flex",
                children: ce(ai.p, {
                  variants: xl("", "", 0.1, 1),
                  className:
                    "mt-3 mb-20 text-secondary text-[17px] max-w-3xl leading-[30px]",
                  children:
                    "As a computer science student, I have earned several industry-recognized certifications that demonstrate my proficiency in various programming languages and software development tools. These certifications have equipped me with valuable skills and expertise to excel in my career.",
                }),
              }),
            ],
          }),
          rt("div", {
            className: `-mt-20 pb-14 ${Jn.paddingX} overflow-x-scroll`,
            style: { width: "100%" },
            children: [
              ce("div", {
                className: "flex flex-nowrap gap-7",
                children: Xj.map((n, e) => ce(MJ, { index: e, ...n }, n.name)),
              }),
              ce("div", {
                className:
                  "absolute top-0 bottom-0 left-0 flex items-center justify-center opacity-0 hover:opacity-100 w-10",
                onClick: SJ,
                children: ce("div", {
                  className:
                    "hover:rounded-full hover:bg-gray-600 h-8 w-8 flex items-center justify-center transition-all duration-300 cursor-pointer z-10",
                  children: ce("i", {
                    className: "fas fa-chevron-left text-white",
                  }),
                }),
              }),
              ce("div", {
                className:
                  "absolute top-0 bottom-0 right-0 flex items-center justify-center opacity-0 hover:opacity-100 w-10",
                onClick: wJ,
                children: ce("div", {
                  className:
                    "hover:rounded-full hover:bg-gray-600 h-8 w-8 flex items-center justify-center transition-all duration-300 cursor-pointer z-10",
                  children: ce("i", {
                    className: "fas fa-chevron-right text-white",
                  }),
                }),
              }),
            ],
          }),
        ],
      }),
    }),
  CJ = du(EJ, ""),
  mh = { _origin: "https://api.emailjs.com" },
  TJ = (n, e = "https://api.emailjs.com") => {
    ((mh._userID = n), (mh._origin = e));
  },
  UL = (n, e, t) => {
    if (!n)
      throw "The public key is required. Visit https://dashboard.emailjs.com/admin/account";
    if (!e)
      throw "The service ID is required. Visit https://dashboard.emailjs.com/admin";
    if (!t)
      throw "The template ID is required. Visit https://dashboard.emailjs.com/admin/templates";
    return !0;
  };
class Eb {
  constructor(e) {
    ((this.status = e ? e.status : 0),
      (this.text = e ? e.responseText : "Network Error"));
  }
}
const zL = (n, e, t = {}) =>
    new Promise((i, r) => {
      const s = new XMLHttpRequest();
      (s.addEventListener("load", ({ target: o }) => {
        const a = new Eb(o);
        a.status === 200 || a.text === "OK" ? i(a) : r(a);
      }),
        s.addEventListener("error", ({ target: o }) => {
          r(new Eb(o));
        }),
        s.open("POST", mh._origin + n, !0),
        Object.keys(t).forEach((o) => {
          s.setRequestHeader(o, t[o]);
        }),
        s.send(e));
    }),
  bJ = (n, e, t, i) => {
    const r = i || mh._userID;
    return (
      UL(r, n, e),
      zL(
        "/api/v1.0/email/send",
        JSON.stringify({
          lib_version: "3.11.0",
          user_id: r,
          service_id: n,
          template_id: e,
          template_params: t,
        }),
        { "Content-type": "application/json" }
      )
    );
  },
  PJ = (n) => {
    let e;
    if (
      (typeof n == "string" ? (e = document.querySelector(n)) : (e = n),
      !e || e.nodeName !== "FORM")
    )
      throw "The 3rd parameter is expected to be the HTML form element or the style selector of form";
    return e;
  },
  BJ = (n, e, t, i) => {
    const r = i || mh._userID,
      s = PJ(t);
    UL(r, n, e);
    const o = new FormData(s);
    return (
      o.append("lib_version", "3.11.0"),
      o.append("service_id", n),
      o.append("template_id", e),
      o.append("user_id", r),
      zL("/api/v1.0/email/send-form", o)
    );
  },
  RJ = { init: TJ, send: bJ, sendForm: BJ },
  LJ = ({ index: n, name: e, logo: t, url: i }) =>
    ce(ai.div, {
      variants: xl("up", "spring", n * 0.5, 0.75),
      children: ce(hu, {
        options: { max: 45, scale: 1, speed: 450 },
        className: "bg-black-200 m-1 rounded-2xl sm:w-[40px] w-full",
        children: ce("div", {
          className: "relative w-full h-[40px]",
          children: ce("a", {
            href: i,
            children: ce("img", {
              src: t,
              alt: e,
              className: "w-full h-full object-cover rounded-2xl",
            }),
          }),
        }),
      }),
    }),
  IJ = () => {
    const n = H.useRef(),
      [e, t] = H.useState({ name: "", email: "", message: "" }),
      [i, r] = H.useState(!1),
      s = (a) => {
        const { target: l } = a,
          { name: u, value: h } = l;
        t({ ...e, [u]: h });
      },
      o = (a) => {
        (a.preventDefault(),
          r(!0),
          RJ.send(
            {}.VITE_APP_EMAILJS_SERVICE_ID,
            {}.VITE_APP_EMAILJS_TEMPLATE_ID,
            {
              from_name: e.name,
              to_name: "Richa Kiran",
              from_email: e.email,
              to_email: "richa21kiran@gmail.com",
              message: e.message,
            },
            {}.VITE_APP_EMAILJS_PUBLIC_KEY
          ).then(
            () => {
              (r(!1),
                alert("Thank you. I will get back to you as soon as possible."),
                t({ name: "", email: "", message: "" }));
            },
            (l) => {
              (r(!1),
                console.error(l),
                alert("Ahh, something went wrong. Please try again."));
            }
          ));
      };
    return rt("div", {
      className:
        "xl:mt-12 flex xl:flex-row flex-col-reverse gap-10 overflow-hidden",
      children: [
        rt(ai.div, {
          variants: Ab("left", "tween", 0.2, 1),
          className: "flex-[0.75] bg-black-100 p-8 rounded-2xl",
          children: [
            ce("p", { className: Jn.sectionSubText, children: "Get in touch" }),
            ce("h3", { className: Jn.sectionHeadText, children: "Contact." }),
            ce("div", {
              className: "flex gap-4 mt-4",
              children: Jj.map((a, l) => ce(LJ, { index: l, ...a }, a.name)),
            }),
            rt("form", {
              ref: n,
              onSubmit: o,
              className: "mt-12 flex flex-col gap-8",
              children: [
                rt("label", {
                  className: "flex flex-col",
                  children: [
                    ce("span", {
                      className: "text-white font-medium mb-4",
                      children: "Your Name",
                    }),
                    ce("input", {
                      type: "text",
                      name: "name",
                      value: e.name,
                      onChange: s,
                      placeholder: "What's your good name?",
                      className:
                        "bg-tertiary py-4 px-6 placeholder:text-secondary text-white rounded-lg outline-none border-none font-medium",
                    }),
                  ],
                }),
                rt("label", {
                  className: "flex flex-col",
                  children: [
                    ce("span", {
                      className: "text-white font-medium mb-4",
                      children: "Your email",
                    }),
                    ce("input", {
                      type: "email",
                      name: "email",
                      value: e.email,
                      onChange: s,
                      placeholder: "What's your web address?",
                      className:
                        "bg-tertiary py-4 px-6 placeholder:text-secondary text-white rounded-lg outline-none border-none font-medium",
                    }),
                  ],
                }),
                rt("label", {
                  className: "flex flex-col",
                  children: [
                    ce("span", {
                      className: "text-white font-medium mb-4",
                      children: "Your Message",
                    }),
                    ce("textarea", {
                      rows: 7,
                      name: "message",
                      value: e.message,
                      onChange: s,
                      placeholder: "What you want to say?",
                      className:
                        "bg-tertiary py-4 px-6 placeholder:text-secondary text-white rounded-lg outline-none border-none font-medium",
                    }),
                  ],
                }),
                ce("button", {
                  type: "submit",
                  className:
                    "bg-tertiary py-3 px-8 rounded-xl outline-none w-fit text-white font-bold shadow-md shadow-primary hover:bg-white hover:text-black-100",
                  children: i ? "Sending..." : "Send",
                }),
              ],
            }),
          ],
        }),
        ce(ai.div, {
          variants: Ab("right", "tween", 0.2, 1),
          className: "xl:flex-1 xl:h-auto md:h-[550px] h-[350px]",
          children: ce(W9, {}),
        }),
      ],
    });
  },
  DJ = du(IJ, "contact"),
  FJ = () =>
    ce(LN, {
      children: rt("div", {
        className: "relative z-0 bg-primary",
        children: [
          rt("div", {
            className:
              "bg-hero-pattern bg-cover bg-no-repeat bg-center bg-fit linear-gradient(to bottom, rgba(0,0,0,0), rgba(0,0,0,1))",
            children: [ce(Kj, {}), ce(uj, {})],
          }),
          ce(Zj, {}),
          ce(yJ, {}),
          ce($j, {}),
          ce(AJ, {}),
          ce(CJ, {}),
          rt("div", {
            className: "relative z-0",
            children: [ce(DJ, {}), ce(K9, {})],
          }),
        ],
      }),
    });
zy.createRoot(document.getElementById("root")).render(
  ce(vh.StrictMode, { children: ce(FJ, {}) })
);
